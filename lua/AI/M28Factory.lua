---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 22:33
---
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local NavUtils = import("/lua/sim/navutils.lua")

local reftBlueprintPriorityOverride = 'M28FactoryPreferredBlueprintByCategory' --[x] is the blueprint ref, if there's a priority override it returns a numerical value (higher number = higher priority)
local refiTimeSinceLastOrderCheck = 'M28FactoryTimeSinceLastCheck' --against factory, gametime in seconds when the factory was last identified as idle with no order
--NOTE: Also have a blueprint blacklist in the landsubteam data - see M28Team

--Factory types (used by subteams)
refiFactoryTypeLand = 1
refiFactoryTypeAir = 2
refiFactoryTypeNaval = 3
refiFactoryTypeOther = 4

function GetBlueprintsThatCanBuildOfCategory(aiBrain, iCategoryCondition, oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
    --returns nil if cant find any blueprints that can build
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBlueprintsThatCanBuildOfCategory'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tBlueprints = EntityCategoryGetUnitList(iCategoryCondition)
    local tAllBlueprints = __blueprints
    local tValidBlueprints = {}
    local iValidBlueprints = 0
    local tBestBlueprints = {}
    local iBestBlueprints = 0
    local iHighestTech = 1
    local iCurrentTech = 1
    --if bGetSlowest == nil then bGetSlowest = false end
    --if bGetFastest == nil then bGetFastest = false end
    local iCurSpeed, iCurMass
    local tiLowestSpeedByTech = {1000, 1000, 1000}
    local tiLowestMassByTech = {100000000, 100000000, 100000000}
    local tiHighestSpeedByTech = {0,0,0}
    local oCurBlueprint
    local iHighestPriority = 0
    local bCanBuildRequiredCategory
    local iCategoriesThatBlueprintCanBuild
    local tsBlueprintsMeetingDesiredCategoriesToBuild
    if iOptionalCategoryThatMustBeAbleToBuild then
        tsBlueprintsMeetingDesiredCategoriesToBuild = EntityCategoryGetUnitList(iOptionalCategoryThatMustBeAbleToBuild)
        if bDebugMessages == true then LOG(sFunctionRef..': tsBlueprintsMeetingDesiredCategoriesToBuild='..repru(tsBlueprintsMeetingDesiredCategoriesToBuild)) end
    end





    if bDebugMessages == true then LOG(sFunctionRef..': reftBlueprintPriorityOverride='..repru(aiBrain[reftBlueprintPriorityOverride])) end
    if not(oFactory.CanBuild) then
        if oFactory.UnitId then
            M28Utilities.ErrorHandler('Factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..' doesnt have .canbuild')
        else
            M28Utilities.ErrorHandler('Factory has no UnitId and doesnt have .CanBuild')
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return nil
    else
        for _, sBlueprint in tBlueprints do
            if bDebugMessages == true then LOG(sFunctionRef..': About to see if factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; can build blueprint '..sBlueprint..'; CanBuild='..tostring(oFactory:CanBuild(sBlueprint))) end
            if oFactory:CanBuild(sBlueprint) == true then
                --Check we can build the desired category
                if not(iOptionalCategoryThatMustBeAbleToBuild) then bCanBuildRequiredCategory = true
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Have said we need to build a particualr category, will see if sBLueprint='..sBlueprint..' can build this') end
                    bCanBuildRequiredCategory = false
                    iCategoriesThatBlueprintCanBuild = nil
                    if tAllBlueprints[sBlueprint].Economy.BuildableCategory and not(M28Utilities.IsTableEmpty(tsBlueprintsMeetingDesiredCategoriesToBuild)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': sBlueprint has a buildablecategory set, will convert it into a category and see if it matches any of the blueprints we want to be able to build') end
                        for categoryIndex, category in tAllBlueprints[sBlueprint].Economy.BuildableCategory do
                            if categoryIndex == 1 then
                                iCategoriesThatBlueprintCanBuild = ParseEntityCategory(category)
                            else
                                iCategoriesThatBlueprintCanBuild = iCategoriesThatBlueprintCanBuild + ParseEntityCategory(category)
                            end
                        end

                        for iAltBlueprint, sAltBlueprint in tsBlueprintsMeetingDesiredCategoriesToBuild do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if sAltBlueprint='..(sAltBlueprint or 'nil')..' has a category that matches with what sBLueprint can build') end
                            if EntityCategoryContains(iCategoriesThatBlueprintCanBuild, sAltBlueprint) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Can build the desired category') end
                                bCanBuildRequiredCategory = true
                                break
                            end
                        end
                    end
                end

                if bCanBuildRequiredCategory then
                    --if EntityCategoryContains(iCategoryCondition, sBlueprint) then --tBlueprints is already filtered to just those that meet the categories
                    iValidBlueprints = iValidBlueprints + 1
                    tValidBlueprints[iValidBlueprints] = sBlueprint
                    if bIgnoreTechDifferences then iCurrentTech = 1
                    else
                        if EntityCategoryContains(categories.TECH3 + categories.EXPERIMENTAL, sBlueprint) then iCurrentTech = 3
                        elseif EntityCategoryContains(categories.TECH2, sBlueprint) then iCurrentTech = 2
                        else iCurrentTech = 1
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': '..sBlueprint..': iCurrentTech='..iCurrentTech..'; iHighestTech='..iHighestTech) end
                    if iCurrentTech > iHighestTech then
                        iHighestTech = iCurrentTech
                        iHighestPriority = 0
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if sBlueprint has a priority specified if we arent looking for slowest or fastest. sBlueprint='..sBlueprint..'; bGetSlowest='..tostring(bGetSlowest)..'; bGetFastest='..tostring(bGetFastest)..'; bGetCheapest='..tostring((bGetCheapest or false))) end
                    if not(bGetSlowest) and not(bGetFastest) and not(bGetCheapest) and aiBrain[reftBlueprintPriorityOverride][sBlueprint] then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have a priority specified='..aiBrain[reftBlueprintPriorityOverride][sBlueprint]..'; iHighestPriority='..iHighestPriority) end
                        iHighestPriority = math.max(aiBrain[reftBlueprintPriorityOverride][sBlueprint], iHighestPriority)
                    end
                    if bGetSlowest == true or bGetFastest == true then
                        oCurBlueprint = tAllBlueprints[sBlueprint]
                        iCurSpeed = oCurBlueprint.Physics.MaxSpeed
                        if bDebugMessages == true then LOG(sFunctionRef..': '..sBlueprint..': iCurSpeed='..iCurSpeed) end
                        if bGetSlowest == true then
                            if iCurSpeed < tiLowestSpeedByTech[iCurrentTech] then tiLowestSpeedByTech[iCurrentTech] = iCurSpeed end
                        elseif bGetFastest == true then
                            if iCurSpeed > tiHighestSpeedByTech[iCurrentTech] then tiHighestSpeedByTech[iCurrentTech] = iCurSpeed end
                        end
                    elseif bGetCheapest then
                        oCurBlueprint = tAllBlueprints[sBlueprint]
                        iCurMass = oCurBlueprint.Economy.BuildCostMass
                        if iCurMass < tiLowestMassByTech[iCurrentTech] then tiLowestMassByTech[iCurrentTech] = iCurMass end
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to get cheapest; iCurMass='..iCurMass..'; iCurrentTech='..iCurrentTech..'; tiLowestMassByTech[iCurrentTech]='..tiLowestMassByTech[iCurrentTech]) end
                    end
                    --end
                end
            end
        end
        --Now get a list of blueprints that are this tech level and of the highest priority
        --if bDebugMessages == true then LOG(sFunctionRef..': iHighestTech='..iHighestTech..'; tiHighestSpeedByTech='..tiHighestSpeedByTech[iHighestTech]..'; bGetSlowest='..tostring(bGetSlowest)..'; bGetFastest='..tostring(bGetFastest)) end
        local bIsValid, iCurrentPriority
        local iMinTechToUse = iHighestTech
        local iFastestSpeed = tiHighestSpeedByTech[iHighestTech]
        if bGetFastest == true and iHighestTech >= 3 then
            --If cybran, want loyalist instead of bomb; if Aeon want blaze instead of harbinger or shield disrupter; If sera probably want hover tank instead of siege tank; if UEF want titan
            if tiHighestSpeedByTech[3] <= 3.5 and tiHighestSpeedByTech[2] - tiHighestSpeedByTech[3] >= 0.6 then
                iMinTechToUse = 2
                iFastestSpeed = math.max(tiHighestSpeedByTech[3], tiHighestSpeedByTech[2])
            end
        end

        for _, sBlueprint in tValidBlueprints do
            bIsValid = false
            if EntityCategoryContains(categories.TECH3 + categories.EXPERIMENTAL, sBlueprint) then iCurrentTech = 3
            elseif EntityCategoryContains(categories.TECH2, sBlueprint) then iCurrentTech = 2
            else iCurrentTech = 1
            end
            if bDebugMessages == true then LOG(sFunctionRef..': sBlueprint='..sBlueprint..': Considering whether we have high enough tech to consider') end
            if iCurrentTech >= iMinTechToUse then
                if not(bGetFastest) and not(bGetSlowest) and not(bGetCheapest) then iCurrentPriority = aiBrain[reftBlueprintPriorityOverride][sBlueprint] end
                if iCurrentPriority == nil then iCurrentPriority = 0 end
                if bDebugMessages == true then LOG(sFunctionRef..': sBlueprint='..sBlueprint..'; iCurrentTech='..iCurrentTech..'; considering priority, iCurrentPriority='..iCurrentPriority..'; iHighestPriority='..iHighestPriority) end
                if iCurrentPriority >= iHighestPriority then
                    bIsValid = true

                    if not(bGetSlowest) and not(bGetFastest) and not(bGetCheapest) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Not interested in if slowest or fastest or cheapest so marking BP as valid') end
                        bIsValid = true
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to get either the slowest, fastest or cheapest') end
                        bIsValid = false
                        if bGetSlowest or bGetFastest then
                            oCurBlueprint = tAllBlueprints[sBlueprint]
                            iCurSpeed = oCurBlueprint.Physics.MaxSpeed
                            if bDebugMessages == true then LOG(sFunctionRef..': sBlueprint='..sBlueprint..'; iCurSpeed='..iCurSpeed) end
                            if bGetSlowest == true then
                                if iCurSpeed <= tiLowestSpeedByTech[iHighestTech] then bIsValid = true end
                            elseif iCurSpeed >= iFastestSpeed then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have the highest speed for tech levels being considered') end
                                bIsValid = true
                            end
                        elseif bGetCheapest then
                            oCurBlueprint = tAllBlueprints[sBlueprint]
                            iCurMass = oCurBlueprint.Economy.BuildCostMass
                            if iCurMass <= tiLowestMassByTech[iCurrentTech] then bIsValid = true end
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to get cheapest; iCurMass='..iCurMass..'; iCurrentTech='..iCurrentTech..'; tiLowestMassByTech[iCurrentTech]='..tiLowestMassByTech[iCurrentTech]..'; bIsValid='..tostring(bIsValid)) end
                        else M28Utilities.ErrorHandler('Missing code')
                        end
                    end
                end
                if bIsValid == true then
                    iBestBlueprints = iBestBlueprints + 1
                    tBestBlueprints[iBestBlueprints] = sBlueprint
                    if bDebugMessages == true then LOG(sFunctionRef..': Have valid blueprint='..sBlueprint) end
                end
            end
        end

        local iBPToBuild = math.random(1, iBestBlueprints)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return tBestBlueprints[iBPToBuild]
    end


end

function AdjustBlueprintForOverrides(aiBrain, sBPIDToBuild, tLZTeamData, iFactoryTechLevel)
    --Blacklisted units
    if M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subrefBlueprintBlacklist][sBPIDToBuild] then
        sBPIDToBuild = nil
    else
        --Special case - Cybran and UEF - if building loyalists or titans, then check if want to switch to bricks/percies
        if sBPIDToBuild == 'url0303' then --Loyalist
            if M28Team.tTeamData[aiBrain.M28Team][M28Team.refbEnemyHasPerciesOrBricks] or M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat * categories.TECH3) >= 2 then
                aiBrain[reftBlueprintPriorityOverride]['url0303'] = nil --loyalist
                aiBrain[reftBlueprintPriorityOverride]['xrl0305'] = 1 --brick
                sBPIDToBuild = 'xrl0305'
            end
        elseif sBPIDToBuild == 'uel0303' then --Titan
            if M28Team.tTeamData[aiBrain.M28Team][M28Team.refbEnemyHasPerciesOrBricks] or M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat * categories.TECH3) >= 15 then
                aiBrain[reftBlueprintPriorityOverride]['url0303'] = nil --Titan
                aiBrain[reftBlueprintPriorityOverride]['xel0305'] = 1 --Percival
                sBPIDToBuild = 'xel0305'
            end
        end

        if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, sBPIDToBuild) then
            --Engineers - dont build if we have spare engineers at our current LZ
            local iMaxSpareWanted = 1
            if not(M28Conditions.TeamHasLowMass(aiBrain.M28Team)) then
                iMaxSpareWanted = math.max(2, 1 + math.floor(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamLowestMassPercentStored] * 10)) * M28Engineer.tiBPByTech[iFactoryTechLevel]
            end
            if tLZTeamData[M28Map.subrefLZSpareBPByTech][iFactoryTechLevel] > iMaxSpareWanted then
                sBPIDToBuild = nil
            end
        end
    end
    return sBPIDToBuild
end

function GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iTargetLandZone, bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths, bDontGetCombat)
    local sFunctionRef = 'GetLandZoneSupportCategoryWanted'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if iTargetLandZone == 31 or iTargetLandZone == 8 or iTargetLandZone == 13 then bDebugMessages = true end


    local iBaseCategoryWanted
    local bInSameIsland = false
    if NavUtils.GetLabel(M28Map.refPathingTypeLand, oFactory:GetPosition()) == NavUtils.GetLabel(M28Map.refPathingTypeLand, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZMidpoint]) then
        bInSameIsland = true
    end
    local tLZTargetTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][iTeam]
    if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateau '..iPlateau..'; iTargetLandZone='..iTargetLandZone..'; bInSameIsland='..tostring(bInSameIsland)..'; bDontConsiderBuildingMAA='..tostring(bDontConsiderBuildingMAA)..'; tLZTargetTeamData[M28Map.subrefbLZWantsIndirectSupport]='..tostring(tLZTargetTeamData[M28Map.subrefbLZWantsIndirectSupport])..'; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]..'; tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA]='..tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA]..'; tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted]='..tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted]..'; tLZTargetTeamData[M28Map.subrefbLZWantsSupport]='..tostring(tLZTargetTeamData[M28Map.subrefbLZWantsSupport])..'; LZ Air to ground enemy threat='..tLZTargetTeamData[M28Map.refiLZEnemyAirToGroundThreat]..'; tLZTargetTeamData[M28Map.refbLZWantsMobileShield]='..tostring(tLZTargetTeamData[M28Map.refbLZWantsMobileShield])..'; tLZTargetTeamData[M28Map.refbLZWantsMobileStealth]='..tostring(tLZTargetTeamData[M28Map.refbLZWantsMobileStealth])) end

    --Mobile shields as highest priority
    if bConsiderMobileShields and tLZTargetTeamData[M28Map.refbLZWantsMobileShield] then
        iBaseCategoryWanted = M28UnitInfo.refCategoryMobileLandShield
        if bInSameIsland then iBaseCategoryWanted = M28UnitInfo.refCategoryMobileLandShield
        else iBaseCategoryWanted = iBaseCategoryWanted * categories.AMPHIBIOUS + iBaseCategoryWanted * categories.HOVER
        end
        if bDebugMessages == true then LOG(sFunctionRef..': LZ wants mobile stealths so will build them; blueprint expect to build from this='..(GetBlueprintsThatCanBuildOfCategory(oFactory:GetAIBrain(), iBaseCategoryWanted, oFactory) or 'nil')) end
        --If dont have any blueprints to build then look to support indirect or DF instead
        local sBPIDToBuild = GetBlueprintsThatCanBuildOfCategory(oFactory:GetAIBrain(), iBaseCategoryWanted, oFactory)
        if sBPIDToBuild then
            sBPIDToBuild = AdjustBlueprintForOverrides(oFactory:GetAIBrain(), sBPIDToBuild, tLZTargetTeamData, M28UnitInfo.GetUnitTechLevel(oFactory))
        end
        if not(sBPIDToBuild) then iBaseCategoryWanted = nil end
    end
    if not(iBaseCategoryWanted) then
        --Mobile stealth
        if bConsiderMobileStealths and tLZTargetTeamData[M28Map.refbLZWantsMobileStealth] then
            iBaseCategoryWanted = M28UnitInfo.refCategoryMobileLandStealth
            if bInSameIsland then iBaseCategoryWanted = M28UnitInfo.refCategoryMobileLandStealth
            else iBaseCategoryWanted = iBaseCategoryWanted * categories.AMPHIBIOUS + iBaseCategoryWanted * categories.HOVER
            end
            if bDebugMessages == true then LOG(sFunctionRef..': LZ wants mobile shilelds so will build them; blueprint expect to build from this='..(GetBlueprintsThatCanBuildOfCategory(oFactory:GetAIBrain(), iBaseCategoryWanted, oFactory) or 'nil')) end
            --If dont have any blueprints to build then look to support indirect or DF instead
            local sBPIDToBuild = GetBlueprintsThatCanBuildOfCategory(oFactory:GetAIBrain(), iBaseCategoryWanted, oFactory)
            if sBPIDToBuild then
                sBPIDToBuild = AdjustBlueprintForOverrides(oFactory:GetAIBrain(), sBPIDToBuild, tLZTargetTeamData, M28UnitInfo.GetUnitTechLevel(oFactory))
            end
            if not(sBPIDToBuild) then iBaseCategoryWanted = nil end
        end
    end
    if not(iBaseCategoryWanted) then
        if not(bDontGetCombat) and tLZTargetTeamData[M28Map.subrefbLZWantsIndirectSupport] and tLZTargetTeamData[M28Map.subrefbLZWantsSupport] then
            --First consider if we need MAA more urgently than indirect
            local bWantMAANotIndirect = false
            if not(bDontConsiderBuildingMAA) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 500 and tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA] < tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted] then
                --We want more MAA for this LZ as well as wanting more indirect fire; prioritise MAA based on threat ratio and if enemy has a large air to ground force
                local iMAARatioWanted = 8
                if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 25000 then iMAARatioWanted = 4 end
                if tLZTargetTeamData[M28Map.refiLZEnemyAirToGroundThreat] >= 200 then iMAARatioWanted = iMAARatioWanted * 0.5 end
                if tLZTargetTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] < tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA] * iMAARatioWanted then
                    bWantMAANotIndirect = true
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': tLZTargetTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..tLZTargetTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]..'; bWantMAANotIndirect='..tostring(bWantMAANotIndirect)) end
            if bWantMAANotIndirect then
                if M28UnitInfo.GetUnitTechLevel(oFactory) == 3 and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA) >= 50 or (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] >= 2000 and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.TECH3 * M28UnitInfo.refCategoryBomber, M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround])) == false) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 0 and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA - categories.TECH3) >  oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) * 4 then iBaseCategoryWanted = M28UnitInfo.refCategoryMAA
                else
                    iBaseCategoryWanted = M28UnitInfo.refCategoryMAA - categories.TECH3
                end
                if not(bInSameIsland) then iBaseCategoryWanted = iBaseCategoryWanted * categories.AMPHIBIOUS + iBaseCategoryWanted * categories.HOVER end
                if bDebugMessages == true then LOG(sFunctionRef..': Will get MAA1') end
            else
                if bInSameIsland then
                    iBaseCategoryWanted = M28UnitInfo.refCategoryIndirect
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oFactory='..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; iTeam='..iTeam..'; iPlateau='..iPlateau..'; iTargetLandZone='..iTargetLandZone..'; We want indirect support for this LZ; Enemy structure threat by DF range='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZThreatEnemyStructureDFByRange])..'; Total indirect threat wanted for LZ='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZIndirectThreatWanted]) end
                else
                    --Only consider amphibious indirect (so most factions wont build anything)
                    iBaseCategoryWanted = M28UnitInfo.refCategoryIndirect * categories.AMPHIBIOUS + M28UnitInfo.refCategoryIndirect * categories.HOVER
                end
                --If enemy has a firebase in range then cancel request for indirect
                if not(tLZTargetTeamData[M28Map.subrefLZTCoreBase]) and M28Utilities.IsTableEmpty(tLZTargetTeamData[M28Map.subreftEnemyFirebasesInRange]) == false then
                    iBaseCategoryWanted = nil
                    if bDebugMessages == true then LOG(sFunctionRef..': Are in range of a firebase so wont get indirect afterall') end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Will get Indirect') end
                end
            end
        end
        if not(iBaseCategoryWanted) then
            --We dont want indirect fire units, do we want MAA units?
            if bDebugMessages == true then LOG(sFunctionRef..': Dont want indirect fire, do we want MAA? M28Map.subrefLZThreatAllyGroundAA='..tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA]..'; M28Map.subrefLZMAAThreatWanted='..tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted]..'; tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA]='..reprs(tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA])..'; tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted]='..tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted]) end
            if not(bDontConsiderBuildingMAA) and tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA] < tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted] and (M28UnitInfo.GetUnitTechLevel(oFactory) >= 2 or (M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoAllEnemyAir]) == false and (not(bDontConsiderBuildingMAA) or tLZTargetTeamData[M28Map.refiLZEnemyAirToGroundThreat] > 0))) then
                if M28UnitInfo.GetUnitTechLevel(oFactory) == 3 and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA) >= 50 or (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] >= 2000 and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.TECH3 * M28UnitInfo.refCategoryBomber, M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround])) == false) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 0 and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA - categories.TECH3) >  oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) * 4 then iBaseCategoryWanted = M28UnitInfo.refCategoryMAA
                else
                    iBaseCategoryWanted = M28UnitInfo.refCategoryMAA - categories.TECH3
                end
                if not(bInSameIsland) then iBaseCategoryWanted = iBaseCategoryWanted * categories.AMPHIBIOUS + iBaseCategoryWanted * categories.HOVER end
                if bDebugMessages == true then LOG(sFunctionRef..': Will build MAA2') end
            elseif not(bDontGetCombat) and tLZTargetTeamData[M28Map.subrefbLZWantsSupport] then
                --We want DF units (but not indirect fire units)
                if bInSameIsland then
                    local iFactoryTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory)
                    local iTechCategory = M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)

                    iBaseCategoryWanted = M28UnitInfo.refCategorySkirmisher * iTechCategory
                    if not(tLZTargetTeamData[M28Map.subrefLZTCoreBase]) and M28Utilities.IsTableEmpty(tLZTargetTeamData[M28Map.subreftEnemyFirebasesInRange]) == false then
                        iBaseCategoryWanted = M28UnitInfo.refCategoryDFTank
                        if bDebugMessages == true then LOG(sFunctionRef..': Are in range of a firebase so wont get indirect afterall') end
                    end
                    if not(GetBlueprintsThatCanBuildOfCategory(oFactory:GetAIBrain(), iBaseCategoryWanted, oFactory)) then
                        iBaseCategoryWanted = M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategorySkirmisher
                    else
                        --We can build skirmishers, but if we have built fewer than 15 T3 tanks, and enemy is using T2 and lower tech, consider building t3 tanks instead
                        if iFactoryTechLevel >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] <= 2 and M28Conditions.GetLifetimeBuildCount(oFactory:GetAIBrain(), M28UnitInfo.refCategoryDFTank * iTechCategory) <= 15 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy is still at T2 or lower and we havent built many T3 normal tanks so will build normal tanks first before trying to build skrimishers') end
                            iBaseCategoryWanted = M28UnitInfo.refCategoryDFTank
                        end
                    end

                else
                    iBaseCategoryWanted = M28UnitInfo.refCategoryAmphibiousCombat
                end
            elseif bDebugMessages == true then LOG(sFunctionRef..': Dont want any support category for this LZ')
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': is iBaseCategoryWanted nil='..tostring(iBaseCategoryWanted == nil)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBaseCategoryWanted
end

function GetBlueprintToBuildForLandFactory(aiBrain, oFactory)
    local sFunctionRef = 'GetBlueprintToBuildForLandFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iCategoryToBuild
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oFactory:GetPosition(), true, oFactory)
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
    local iFactoryTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory)
    local iTeam = aiBrain.M28Team
    local bHaveLowMass = M28Conditions.TeamHasLowMass(iTeam)
    local bHaveLowPower = M28Conditions.HaveLowPower(iTeam)
    local bCanPathToEnemyWithLand = false
    if tLZData[M28Map.subrefLZIslandRef] == NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZTeamData[M28Map.reftClosestEnemyBase]) then bCanPathToEnemyWithLand = true end
    if iLandZone == 31 or iLandZone == 13 or iLandZone == 8 then bDebugMessages = true end


    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, time='..GetGameTimeSeconds()..'; oFactory='..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; Checking if we have the highest tech land factory in the current land zone, iFactoryTechLevel='..iFactoryTechLevel..'; Highest friendly factory tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; Allied ground threat='..(M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] or 'nil')..'; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]='..(M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] or 'nil')..'; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat]='..(M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] or 'nil')..'; M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat]='..(M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] or 'nil')..'; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat]='..(M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat] or 'nil')..'; Is factory paused='..tostring(oFactory:IsPaused())..'; IsPaused value='..tostring(oFactory[M28UnitInfo.refbPaused])..'; Does LZ factory is in need BP='..tostring(tLZTeamData[M28Map.subrefLZTbWantBP])..'; Core LZ='..tostring(tLZTeamData[M28Map.subrefLZTCoreBase] or false)..'; Core expansion='..tostring(tLZTeamData[M28Map.subrefLZCoreExpansion] or false)) end

    local iLandFactoriesInLZ = 0
    local bHaveHighestLZTech = true
    --if iFactoryTechLevel < 3 and iFactoryTechLevel < M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] then
    local tLandFactoriesInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
    for iLZFactory, oLZFactory in  tLandFactoriesInLZ do
        if not(oLZFactory == oFactory) and M28UnitInfo.GetUnitTechLevel(oLZFactory) > iFactoryTechLevel then
            bHaveHighestLZTech = false
            break
        end
    end
    iLandFactoriesInLZ = table.getn(tLandFactoriesInLZ)
    --end

    local bDontConsiderBuildingMAA = false
    --Do we already ahve lots of MAA?
    if tLZTeamData[M28Map.refiLZEnemyAirToGroundThreat] == 0 then
        if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoMAATargetsByIsland][iPlateau] or -10) < 10 then
            if not(tLZTeamData[M28Map.subrefLZCoreExpansion]) then
                bDontConsiderBuildingMAA = true
            else
                local iMAAInLZ = 0
                local iEnemyAirToGround = 0
                for iEntry, iIslandLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandLandZones][tLZData[M28Map.subrefLZIslandRef]] do
                    iMAAInLZ = iMAAInLZ + tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZThreatAllyGroundAA]
                    iEnemyAirToGround = iEnemyAirToGround + tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.refiLZEnemyAirToGroundThreat]
                end
                if iMAAInLZ >= 300 and iMAAInLZ >= iEnemyAirToGround * 2 then
                    bDontConsiderBuildingMAA = true
                end
            end
        elseif (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] >= math.min(600 or M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] * 2)) and (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] >= M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] + (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] + M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] + M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat]) * 0.2) or (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] > math.max(4000, M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] <= 4000 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) >= 5) then
            --Do we have more than 1/8 of our DF and indirect force in AA? Or alternatively enemy has no air to ground and we have a lot of AA
            if M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] < M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] * 8 or (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] >= 4000 and M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] <= 4000 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) >= 3) then
                if not(tLZTeamData[M28Map.subrefLZCoreExpansion]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': We have lots of MAA; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat]='..M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat]..'; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat]='..M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat]..'; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat]='..M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat]..'; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat]='..M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat]..'; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]) end
                    bDontConsiderBuildingMAA = true
                else
                    local iMAAInLZ = 0
                    local iEnemyAirToGround = 0
                    for iEntry, iIslandLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauIslandLandZones][tLZData[M28Map.subrefLZIslandRef]] do
                        iMAAInLZ = iMAAInLZ + tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZThreatAllyGroundAA]
                        iEnemyAirToGround = iEnemyAirToGround + tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.refiLZEnemyAirToGroundThreat]
                    end
                    if iMAAInLZ >= 300 and iMAAInLZ >= iEnemyAirToGround * 2 then
                        bDontConsiderBuildingMAA = true
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': bDontConsiderBuildingMAA after considering global values='..tostring(bDontConsiderBuildingMAA)..'; GroundAA threat='..M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat]..'; Enemy air to ground threat='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]..'; Enemy AirAA threat='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat]..'; Enemy torp bomber threat='..M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat]..'; Air other threat='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat]..'; Current T3 MAA='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3)..'; Allied DF threat='..M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat]..'; Allied indirect='..M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat]) end
    if not(bDontConsiderBuildingMAA) then
        --If enemy has low air to ground threat relative to their combat threat then dont get more mAA if we already have half the factories building MAA
        if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] < math.max(200, M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] * 0.4) then
            local bCapMAABuiltAtOnce = true
            if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 0 then
                --Check we dont have air to ground enemy threat in a nearby LZ
                if tLZTeamData[M28Map.refiLZEnemyAirToGroundThreat] > 0 then bCapMAABuiltAtOnce = false
                elseif M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.refiLZEnemyAirToGroundThreat] > 0 then
                            bCapMAABuiltAtOnce = false
                            break
                        end
                    end
                end
            end
            if bCapMAABuiltAtOnce then
                if M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryMAA) >= math.max(1, math.floor(iLandFactoriesInLZ * 0.5)) then
                    bDontConsiderBuildingMAA = true
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bCapMAABuiltAtOnce='..tostring(bCapMAABuiltAtOnce)..'; Number of MAA already being built='..M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryMAA)..'; bDontConsiderBuildingMAA='..tostring(bDontConsiderBuildingMAA)) end
        end
    end

    --Mobile shields if we are at T2+ as part of the land zone reinforcement logic
    local bConsiderMobileShields = false
    if iFactoryTechLevel >= 2 and not(bHaveLowPower) and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoShieldTargetsByPlateau][iPlateau] or -100) >= 15 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 15 * iFactoryTechLevel and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 70 then
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 60 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= (1 + M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryMobileLandShield)) * 16 then
            local iCurMobileShields = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMobileLandShield)
            if iCurMobileShields <= 35 and iCurMobileShields * 250 <= math.max(2000, (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat])) then
                bConsiderMobileShields = true
            end
        end
    end

    --Mobile stealth if we are at T2+ as part of the land zone reinforcement logic
    local bConsiderMobileStealths = false
    if iFactoryTechLevel >= 2 and not(bHaveLowPower) and not(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbEnemyHasOmni]) and not(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbEnemyBuiltOmni]) and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiLastTimeNoStealthTargetsByPlateau][iPlateau] or -100) >= 15 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 15 * iFactoryTechLevel and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 70 then
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 60 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= (1 + M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryMobileLandStealth)) * 16 then
            local iCurMobileStealths = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMobileLandStealth)
            if iCurMobileStealths <= 16 and iCurMobileStealths * 600 <= math.max(1800, (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat]) * 0.3) then
                bConsiderMobileStealths = true
            end
        end
    end

    local bSaveMassDueToEnemyFirebaseOrOurExperimental
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamEngineersBuildingExperimentals]) == false and bHaveLowMass then
        bSaveMassDueToEnemyFirebaseOrOurExperimental = true
    else bSaveMassDueToEnemyFirebaseOrOurExperimental = M28Conditions.WantToEcoDueToEnemyFirebase(iTeam, tLZTeamData, iPlateau)
    end


    iCategoryToBuild = M28UnitInfo.refCategoryEngineer --Placeholder
    local sBPIDToBuild
    local iCurrentConditionToTry = 0

    --subfunctions to mean we can do away with the 'current condition == 1, == 2.....==999 type approach making it much easier to add to
    function ConsiderBuildingCategory(iCategoryToBuild)
        sBPIDToBuild = GetBlueprintsThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oFactory, nil, nil, nil, nil, false)
        if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..' Factory='..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; LZ='..iLandZone..'; iCurrentConditionToTry='..iCurrentConditionToTry..'; sBPIDToBuild before adjusting for override='..(sBPIDToBuild or 'nil')) end
        if sBPIDToBuild then
            sBPIDToBuild = AdjustBlueprintForOverrides(aiBrain, sBPIDToBuild, tLZTeamData, iFactoryTechLevel)
        end
        if sBPIDToBuild then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd) --Assumes we will end code if we get to this point
            return sBPIDToBuild
        end
    end

    function ConsiderUpgrading()
        sBPIDToBuild = M28UnitInfo.GetUnitUpgradeBlueprint(oFactory, true)
        return sBPIDToBuild
    end



    --MAIN BUILDER LOGIC:
    --Enemy early bomber defence (higher priority than tanks since we have our ACU to deal with tanks as a last resort)
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if not(bDontConsiderBuildingMAA) then
        local iNearbyMAAThreat = tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                iNearbyMAAThreat = iNearbyMAAThreat + tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]
            end
        end
        if iNearbyMAAThreat < 165 then
            --If enemy has any air units then want at least 110 MAA; if they have any air to ground want at least 165
            if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 0 or (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat] + M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] > 0 and iNearbyMAAThreat < 110) then
                if bDebugMessages == true then LOG(sFunctionRef..': Want to have a basic level of MAA unless we have lots already; MAA that we alreayd have='..oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA)) end
                if oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA) <= 5 then
                    --Only build if we ahve <2 under construction in this LZ
                    if M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryMAA) < 2 then
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryMAA - categories.TECH3) then return sBPIDToBuild end
                    end
                end
            end
        end
    end



    --Enemies nearby and have built fewer tanks of this tech level than engineers
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then LOG(sFunctionRef..': CHecking if nearby enemy threat and we are T2 plus, iFactoryTechLevel='..iFactoryTechLevel..'; Enemies in this or adjacent LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; bSaveMassDueToEnemyFirebaseOrOurExperimental='..tostring(bSaveMassDueToEnemyFirebaseOrOurExperimental)..'; bDontConsiderBuildingMAA='..tostring(bDontConsiderBuildingMAA)) end
    if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
        --Build tanks unless we have a LC of tanks of at least 5 and more than our LC of engineers
        local iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iLandZone, false, bConsiderMobileShields, bConsiderMobileStealths)
        if not(iCategoryToGet) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                if iFactoryTechLevel < 3 or not(bDontConsiderBuildingMAA) then
                    iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iAdjLZ, false, bConsiderMobileShields, bConsiderMobileStealths)
                elseif M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 1000 then
                    iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iAdjLZ, false, bConsiderMobileShields, bConsiderMobileStealths)
                else
                    iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iAdjLZ, bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths)
                end
                if iCategoryToGet then break end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for support category wanted for this or adjacent LZ. Is iCategoryToGet nil='..tostring(iCategoryToGet == nil)) end
        if iCategoryToGet then
            local iTankLC = M28Conditions.GetLifetimeBuildCount(aiBrain, iCategoryToGet * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))
            if bDebugMessages == true then LOG(sFunctionRef..': Lifetime build count for this tech level='..iTankLC..'; Engi LC for this tech='..M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))) end
            if iTankLC < 3 or bHaveLowMass or iTankLC < M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then
                if iFactoryTechLevel < 3 then
                    if ConsiderBuildingCategory(iCategoryToGet) then return sBPIDToBuild end
                else
                    --Enemies near to base/land factory, and we have a category to get; however want to still consider unit ratios but based on these LZs before going with the standard support category - i.e. consider indirect fire if have lots of DF and T3 land
                    local iDFTotalThreat = tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
                    local iIndirectTotalThreat = tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]
                    local iEnemyAirToGroundThreat = tLZTeamData[M28Map.refiLZEnemyAirToGroundThreat]
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                            iDFTotalThreat = iDFTotalThreat + M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZThreatAllyMobileDFTotal]
                            iIndirectTotalThreat = iIndirectTotalThreat + M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZThreatAllyMobileIndirectTotal]
                            iEnemyAirToGroundThreat = iEnemyAirToGroundThreat + M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.refiLZEnemyAirToGroundThreat]
                        end
                    end
                    if iDFTotalThreat >= 8000 and iDFTotalThreat > iIndirectTotalThreat * 8 and iEnemyAirToGroundThreat <= tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] and (EntityCategoryContains(categories.AEON, oFactory.UnitId)) or iDFTotalThreat > iIndirectTotalThreat * 10 then
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryT3MobileArtillery) then return sBPIDToBuild end
                    elseif ConsiderBuildingCategory(iCategoryToGet) then return sBPIDToBuild end
                end
            end
        end
    end

    --Initial engineers
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering high priority engineers, iFactoryTechLevel='..iFactoryTechLevel..'; Team highest factory tech level='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; Lifetime build count='..M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))..'; Current units='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))) end
    if iFactoryTechLevel >= M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] and tLZTeamData[M28Map.subrefLZTCoreBase] then
        if M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) <= 4 or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) <= 2 then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then return sBPIDToBuild end
        end
    end

    --Early game - more engineers if are on a large map where unlikely to have enemies nearby for a while
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if GetGameTimeSeconds() <= 480 and tLZTeamData[M28Map.subrefLZTCoreBase] and M28Utilities.GetDistanceBetweenPositions(tLZTeamData[M28Map.reftClosestEnemyBase], tLZData[M28Map.subrefLZMidpoint]) >= 450 then
        --Do we have adjacent LZ with unbuilt mexes, no enemies, needing engineers with no engineers currently assigned or traveling?
        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
            if not(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ]) then
                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZMexUnbuiltLocations]) == false and M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTEngineersTravelingHere]) == false and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTbWantBP] then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then return sBPIDToBuild end
                end
            end
        end
    end

    --Initiail combat
    if bDebugMessages == true then LOG(sFunctionRef..': Considering initial combat units, lifetime count='..M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat)) end
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bCanPathToEnemyWithLand and iFactoryTechLevel == 1 and bHaveHighestLZTech and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat) < 2 then
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryDFTank) then return sBPIDToBuild end
    end

    --Scouts if we want any
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want land scouts, does this LZ want scouts='..tostring(tLZTeamData[M28Map.refbWantLandScout])) end
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if tLZTeamData[M28Map.refbWantLandScout] then
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryLandScout) then return sBPIDToBuild end
    end

    --Initial T2+ tanks if have at least 5 engis of our current tech level and dont have many tanks (core base only)
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if iFactoryTechLevel >= 2 and bHaveHighestLZTech and tLZTeamData[M28Map.subrefLZTCoreBase] and math.min(8, aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))) > math.max(1, aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMobileLand * categories.DIRECTFIRE * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))) then
        if bCanPathToEnemyWithLand then
            if ConsiderBuildingCategory(M28UnitInfo.refCategorySkirmisher * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then return sBPIDToBuild
            elseif ConsiderBuildingCategory(M28UnitInfo.refCategoryLandCombat * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then return sBPIDToBuild end
        else
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryAmphibiousCombat) then return sBPIDToBuild end
        end
    end

    --Non-core land zones - consider building combat units ahead of engineers if need them for this LZ
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then LOG(sFunctionRef..': iCurrentConditionToTry='..iCurrentConditionToTry..'; Do we have a core base='..tostring(tLZTeamData[M28Map.subrefLZTCoreBase] or false)..'; will consider if we want non-core base units for this LZ if not a core base') end
    if not(tLZTeamData[M28Map.subrefLZTCoreBase]) then
        local iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iLandZone, bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths, bSaveMassDueToEnemyFirebaseOrOurExperimental)
        if iCategoryToGet then
            if ConsiderBuildingCategory(iCategoryToGet) then return sBPIDToBuild end
        end
    end

    --Engineers if we dont have low mass, and want more
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    local bNeedCurTech = true
    for iCurTech = 1, iFactoryTechLevel do
        if tLZTeamData[M28Map.subrefLZSpareBPByTech][iCurTech] > 0 then
            bNeedCurTech = false
            break
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': about to consider getting engineers, do we have low mass='..tostring(bHaveLowMass)..'; Highest team tech level='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; bHaveHighestLZTech='..tostring(bHaveHighestLZTech)..'; bNeedCurTech='..tostring(bNeedCurTech)) end
    if bNeedCurTech and not(bHaveLowMass) and (iFactoryTechLevel >= M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5) then
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then return sBPIDToBuild end
    end

    --Engineers if we have few engineers in the current land zone and want more
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bNeedCurTech and not(tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal] > 10) then
        local tLZEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        local iEngisInLZ = 0
        if M28Utilities.IsTableEmpty(tLZEngineers) == false then
            iEngisInLZ = table.getn(tLZEngineers)
        end
        local iEngisWanted = 3
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] > 3 then
            iEngisWanted = math.min(6, math.ceil(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]))
        end
        if not(tLZTeamData[M28Map.subrefLZTCoreBase]) then iEngisWanted = iEngisWanted * 0.5 end
        if iEngisInLZ < iEngisWanted then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then return sBPIDToBuild end
        end
    end




    --Other actions - dont do unless we have lots of mass if this is lower than our highest tech level
    if bHaveHighestLZTech then

        --Combat or MAA if this LZ needs more units
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        --if tLZTeamData[M28Map.subrefbLZWantsSupport] then
        if bDebugMessages == true then LOG(sFunctionRef..': Have highest LZ tech, iCurrentConditionToTry='..iCurrentConditionToTry..'; Will see if we want to get support for this LZ, bDontConsiderBuildingMAA='..tostring(bDontConsiderBuildingMAA)..'; bConsiderMobileShields='..tostring(bConsiderMobileShields)..'; bConsiderMobileStealths='..tostring(bConsiderMobileStealths)) end
        local iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iLandZone, bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths, bSaveMassDueToEnemyFirebaseOrOurExperimental)
        if iCategoryToGet then
            if ConsiderBuildingCategory(iCategoryToGet) then return sBPIDToBuild end
        end


        --Upgrade factory if this LZ is lagging behind tech wise
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if iFactoryTechLevel == 1 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 2 and (iLandFactoriesInLZ >= 4 or M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] == 3) then
            local bUpgradingLandFactory = false
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then
                for iUnit, oUnit in tLZTeamData[M28Map.subrefActiveUpgrades] do
                    if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have an active land factory upgrade='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit.UnitId)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Fraction complete='..oUnit:GetFractionComplete()..'; Work progress='..oUnit:GetWorkProgress()) end
                        bUpgradingLandFactory = true
                        break
                    end
                end
            end
            if not(bUpgradingLandFactory) then
                if ConsiderUpgrading() then return sBPIDToBuild end
            end
        end

        --Maintain basic level of unit threat ratios
        --DF tanks of the cur tech level or higher - get more if we have fewer of these than we have engineers of this tech level and we have less DF threat than the enemy overall
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bCanPathToEnemyWithLand and not(bSaveMassDueToEnemyFirebaseOrOurExperimental) and iFactoryTechLevel >= 2 and math.min(9, aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))) > aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryMobileLand * categories.DIRECTFIRE * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then
            if bDebugMessages == true then LOG(sFunctionRef..': Have fewer DF tanks than engineers so want to get more skirmishers or (if cant build any) DF tanks') end
            if ConsiderBuildingCategory(M28UnitInfo.refCategorySkirmisher * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then return sBPIDToBuild
            elseif ConsiderBuildingCategory(M28UnitInfo.refCategoryLandCombat * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then return sBPIDToBuild end
        end

        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then LOG(sFunctionRef..': Checking threat ratios for if we want more indirect, DF threat='..M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat]..'; Indirect='..M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat]) end
        if not(bSaveMassDueToEnemyFirebaseOrOurExperimental) then
            local iIndirectRatioWanted
            if iFactoryTechLevel == 1 then iIndirectRatioWanted = 8
            elseif iFactoryTechLevel == 2 then iIndirectRatioWanted = 12
            elseif iFactoryTechLevel == 3 then
                if aiBrain:GetCurrentUnits((M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategorySkirmisher) * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) >= 60 then
                    if EntityCategoryContains(categories.AEON, oFactory.UnitId) then iIndirectRatioWanted = 3.5
                    else iIndirectRatioWanted = 4
                    end
                else
                    if EntityCategoryContains(categories.AEON, oFactory.UnitId) then iIndirectRatioWanted = 7
                    else iIndirectRatioWanted = 10
                    end
                end
            end
            if bCanPathToEnemyWithLand and M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] > M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] * iIndirectRatioWanted and (not(bHaveLowMass) or (iFactoryTechLevel >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] > M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] * iIndirectRatioWanted * 2 and aiBrain:GetCurrentUnits((M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategorySkirmisher) * categories.TECH3) >= 50)) then
                if bDebugMessages == true then LOG(sFunctionRef..': Will try to build more indirect fire units if arent building any of this tech level or higher in this LZ') end
                if iFactoryTechLevel == 1 or M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryIndirect * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) == 0 then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryIndirect) then return sBPIDToBuild end
                end
            end
        end

        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bCanPathToEnemyWithLand and not(bHaveLowMass) and not(bDontConsiderBuildingMAA) then
            --Maintain MAA ratio vs overall combat threat - Only get MAA if we either have T2 land, or 50 gross mass, or enemy has air; max of 2 at a time
            if bDebugMessages == true then LOG(sFunctionRef..': Checking MAA ratio overall, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]..'; M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir]='..tostring(M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir])..'; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat]='..M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat]) end
            if iFactoryTechLevel >= 2 or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoAllEnemyAir]) == false or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 5 then
                local iThreatFactor = 20
                if M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir] and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 4000 then iThreatFactor = 8
                elseif not(M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbHaveAirControl]) and (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 2000 or M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir]) then iThreatFactor = 13
                end
                if M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] > M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] * iThreatFactor then
                    local iMAACat
                    if oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA) >= 50 or (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] >= 2000 and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.TECH3 * M28UnitInfo.refCategoryBomber, M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround])) == false) and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA - categories.TECH3) >  oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) * 4 then iMAACat = M28UnitInfo.refCategoryMAA
                    else
                        iMAACat = M28UnitInfo.refCategoryMAA - categories.TECH3
                    end
                    if M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, iMAACat) <= 1 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will get MAA3') end
                        if ConsiderBuildingCategory(iMAACat) then return sBPIDToBuild end
                    end
                end
            end
        end

        --Be building engineers in 1/4 of land facs if we have a shortfall for this land zone
        if iLandFactoriesInLZ > 1 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.01 or M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) and tLZTeamData[M28Map.subrefLZTbWantBP] then
            if M28Conditions.GetNumberOfUnitsMeetingCategoryUnderConstructionInLandZone(tLZTeamData, M28UnitInfo.refCategoryEngineer) < iLandFactoriesInLZ * 0.25 then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then return sBPIDToBuild end
            end
        end

        --Combat or MAA if we have a LZ within half of dist between us and nearest enemy that wants more units
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        local iEnemyPlateau, iEnemyLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.GetPrimaryEnemyBaseLocation(aiBrain))
        if iEnemyPlateau == iPlateau then
            local iDistToEnemyBaseToConsider
            --Is enemy in same island?
            local iIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLZData[M28Map.subrefLZMidpoint])

            if NavUtils.GetLabel(M28Map.refPathingTypeLand, M28Map.GetPrimaryEnemyBaseLocation(aiBrain)) == iIsland then
                if not(bHaveLowMass) then iDistToEnemyBaseToConsider = M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iEnemyLandZone) * 0.75
                else iDistToEnemyBaseToConsider = M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iEnemyLandZone) * 0.5
                end
            else
                --enemy base is a dif island to ours, so want to control all of our island (within reason)
                iDistToEnemyBaseToConsider = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefLZMidpoint], M28Map.GetPrimaryEnemyBaseLocation(aiBrain))
            end

            for iEntry, tLZPathing in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': About to check alternative LZ '..tLZPathing[M28Map.subrefLZNumber]..'; iDistToEnemyBaseToConsider='..iDistToEnemyBaseToConsider..'; tLZPathing[M28Map.subrefLZTravelDist]='..tLZPathing[M28Map.subrefLZTravelDist]) end
                if tLZPathing[M28Map.subrefLZTravelDist] <= iDistToEnemyBaseToConsider then
                    --if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tLZPathing[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefbLZWantsSupport] then
                    --How far away is it?
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to reinforce alternative LZ '..(tLZPathing[M28Map.subrefLZNumber] or 'nil')..'; Travel dist='..(tLZPathing[M28Map.subrefLZTravelDist] or 'nil')..'; iDistToEnemyBaseToConsider='..(iDistToEnemyBaseToConsider or 'nil')..'; Size of this alt LZ in segments='..(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tLZPathing[M28Map.subrefLZNumber]][M28Map.subrefLZTotalSegmentCount] or 'nil')) end
                    --if tLZPathing[M28Map.subrefLZTravelDist] <= iDistToEnemyBaseToConsider then
                    local iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, tLZPathing[M28Map.subrefLZNumber], bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths, bSaveMassDueToEnemyFirebaseOrOurExperimental)
                    if bDebugMessages == true then LOG(sFunctionRef..': DO we have no category (i.e. false means we want to build something) for this alternative LZ '..tLZPathing[M28Map.subrefLZNumber]..'='..tostring(iCategoryToGet==nil)..'; bDontConsiderBuildingMAA='..tostring(bDontConsiderBuildingMAA)) end
                    if iCategoryToGet then
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Will draw the LZ where we want more units in a rnadom colour')
                            M28Map.DrawSpecificLandZone(iPlateau, tLZPathing[M28Map.subrefLZNumber], math.random(1, 8))
                        end
                        if ConsiderBuildingCategory(iCategoryToGet) then return sBPIDToBuild end
                    end
                else
                    break
                end
            end
        end
        --Now consider islands
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherIslands]) == false then
            local iDistanceThreshold
            if bHaveLowMass then iDistanceThreshold = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefLZMidpoint], M28Map.GetPrimaryEnemyBaseLocation(aiBrain)) * 0.5
            else iDistanceThreshold = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefLZMidpoint], M28Map.GetPrimaryEnemyBaseLocation(aiBrain)) * 0.75
            end

            for iEntry, tPathingData in tLZData[M28Map.subrefLZPathingToOtherIslands] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering island '..tPathingData[M28Map.subrefIslandNumber]..'; travel dist='..tPathingData[M28Map.subrefIslandTravelDist]..'; Closest LZ ref='..(tPathingData[M28Map.subrefIslandClosestLZRef] or 'nil')..'; are enemies in this or adjacent LZ='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
                if tPathingData[M28Map.subrefIslandTravelDist] > iDistanceThreshold then break
                else
                    --Are there enemies in the target LZ?
                    if tPathingData[M28Map.subrefIslandClosestLZRef] and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathingData[M28Map.subrefIslandClosestLZRef]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                        if ConsiderBuildingCategory(M28UnitInfo.refCategoryAmphibiousCombat) then return sBPIDToBuild end
                    end
                end
            end
        end
    elseif not(bHaveHighestLZTech) then
        if bDebugMessages == true then LOG(sFunctionRef..': Consideringi f we want to upgrade factory, iFactoryTechLevel='..iFactoryTechLevel..'; Brain highest tech='..aiBrain[M28Economy.refiOurHighestLandFactoryTech]) end
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if iFactoryTechLevel < aiBrain[M28Economy.refiOurHighestLandFactoryTech] then
            --Do we want ot upgrade a support factory? Check first if are upgrading anything here
            local bUpgradingLandFactory = false

            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then
                for iUnit, oUnit in tLZTeamData[M28Map.subrefActiveUpgrades] do
                    if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have an active land factory upgrade='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit.UnitId)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Fraction complete='..oUnit:GetFractionComplete()..'; Work progress='..oUnit:GetWorkProgress()) end
                        bUpgradingLandFactory = true
                        break
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bUpgradingLandFactory='..tostring(bUpgradingLandFactory)..'; bHaveLowMass='..tostring(bHaveLowMass)..'; Lowest mass % stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]) end
            if not(bUpgradingLandFactory) or (not(bHaveLowMass) and aiBrain[M28Economy.refiOurHighestLandFactoryTech] == 3 and (iFactoryTechLevel == 1 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5)) then

                if not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.3 and M28Conditions.GetLifetimeBuildCount(aiBrain, categories.LAND * categories.MOBILE * M28UnitInfo.ConvertTechLevelToCategory(aiBrain[M28Economy.refiOurHighestLandFactoryTech])) >= 3 then
                    if ConsiderUpgrading() then return sBPIDToBuild end
                elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.02 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.15 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0) and M28Conditions.GetLifetimeBuildCount(aiBrain, categories.LAND * categories.MOBILE * M28UnitInfo.ConvertTechLevelToCategory(aiBrain[M28Economy.refiOurHighestLandFactoryTech])) >= 6 then
                    --Still consider upgrading if we have a T2 land factory but no t2 support factory in the LZ and have built some T2 units already
                    local tLandFactoriesInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                    local iHQAndSupportCount = 0
                    for iUnit, oUnit in tLandFactoriesInZone do
                        if M28UnitInfo.GetUnitTechLevel(oUnit) >= aiBrain[M28Economy.refiOurHighestLandFactoryTech] then
                            iHQAndSupportCount = iHQAndSupportCount + 1
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iHQAndSupportCount='..iHQAndSupportCount) end
                    if iHQAndSupportCount <= 1 then
                        if ConsiderUpgrading() then return sBPIDToBuild end
                    end
                end
            end
        end

        --Do we want MAA, mobile shield or mobile stealth?
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if iFactoryTechLevel == 2 then
            local iEnemyPlateau, iEnemyLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.GetPrimaryEnemyBaseLocation(aiBrain))
            if iEnemyPlateau == iPlateau then
                local iDistToEnemyBaseToConsider = (M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iEnemyLandZone) or aiBrain[M28Overseer.refiDistanceToNearestEnemyBase]) * 0.5

                for iEntry, tLZPathing in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                    if tLZPathing[M28Map.subrefLZTravelDist] <= iDistToEnemyBaseToConsider then
                        --How far away is it?
                        if bDebugMessages == true then LOG(sFunctionRef..': T2 Considering whether to reinforce alternative LZ '..tLZPathing[M28Map.subrefLZNumber]..'; Travel dist='..tLZPathing[M28Map.subrefLZTravelDist]..'; iDistToEnemyBaseToConsider='..iDistToEnemyBaseToConsider) end
                        if tLZPathing[M28Map.subrefLZTravelDist] <= iDistToEnemyBaseToConsider then
                            local iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, tLZPathing[M28Map.subrefLZNumber], bDontConsiderBuildingMAA, bConsiderMobileShields, bConsiderMobileStealths, true)
                            if bDebugMessages == true then LOG(sFunctionRef..': T2 DO we have no category for this alternative LZ '..tLZPathing[M28Map.subrefLZNumber]..'='..tostring(iCategoryToGet==nil)..'; bDontConsiderBuildingMAA='..tostring(bDontConsiderBuildingMAA)) end
                            if iCategoryToGet then
                                if ConsiderBuildingCategory(iCategoryToGet) then return sBPIDToBuild end
                            end
                        end
                    else
                        break
                    end
                end
            end
        end
    end

    --Engineers if we have mass and dont have spare engineers
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want engineers if have mass: M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; bHaveHighestLZTech='..tostring(bHaveHighestLZTech)..'; subrefLZTbWantBP='..tostring(tLZTeamData[M28Map.subrefLZTbWantBP])) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.01 and ((bHaveHighestLZTech and tLZTeamData[M28Map.subrefLZTbWantBP]) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.4 and tLZTeamData[M28Map.subrefLZTCoreBase])) then
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then return sBPIDToBuild end
    end

    --T1 mobile arti if we dont ahve low mass and are below highest tech level, or normal tanks otherwise
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if not(bHaveLowMass) and (not(bSaveMassDueToEnemyFirebaseOrOurExperimental) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.45) then
        --Is there a relatively nearby enemy?

        local bEnemiesRelativelyNear = tLZData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]
        if not(bEnemiesRelativelyNear) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                    bEnemiesRelativelyNear = true
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Dont have low mass so considering if we have enemies adjacent to an adjacent LZ in which case will build T1 arti, bEnemiesRelativelyNear='..tostring(bEnemiesRelativelyNear)) end
        if bEnemiesRelativelyNear then
            if bHaveHighestLZTech then
                if bCanPathToEnemyWithLand then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategorySkirmisher) then return sBPIDToBuild end
                else
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryAmphibiousCombat) then return sBPIDToBuild end
                end
            else
                if bCanPathToEnemyWithLand and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryIndirect * categories.TECH1) <= 60 then
                    if ConsiderBuildingCategory(M28UnitInfo.refCategoryIndirect * categories.TECH1) then return sBPIDToBuild end
                end
            end
        end
    end



    --Upgrade T1 to T2 if we have multiple mex upgrades and T1 land facs in this land zone, and already have T2 land, even if have low mass
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if iFactoryTechLevel == 1 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 20 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] or -5) >= 3 then
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false and table.getn(tLZTeamData[M28Map.subrefActiveUpgrades]) >= 3 then
            local iCurMexUpgrades = 0
            local iCurT1FactoryUpgrades = 0
            for iUnit, oUnit in tLZTeamData[M28Map.subrefActiveUpgrades] do
                if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then iCurMexUpgrades = iCurMexUpgrades + 1
                elseif EntityCategoryContains(M28UnitInfo.refCategoryFactory * categories.TECH1, oUnit.UnitId) then iCurT1FactoryUpgrades = iCurT1FactoryUpgrades + 1
                end
            end
            if iCurT1FactoryUpgrades == 0 and iCurMexUpgrades >= 2 then
                --Do we have more than 1 T1 land factory in this land zone?
                local tT1LandFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory * categories.TECH1, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                if table.getn(tT1LandFactories) >= 2 then
                    if ConsiderUpgrading() then return sBPIDToBuild end
                end
            end
        end
    end

    --Build more engineers if we have multiple upgrades and need more engineers for the current LZ, even if relatively low mass
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 50 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] or -5) >= 5 and tLZTeamData[M28Map.subrefLZTbWantBP] and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) == false then
        if table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 3 then
            --Build engineers as we have lots of upgrades
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then return sBPIDToBuild end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DetermineWhatToBuild(aiBrain, oFactory)
    local sBPIDToBuild

    if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oFactory.UnitId) then
        sBPIDToBuild = GetBlueprintToBuildForLandFactory(aiBrain, oFactory)
    else
        M28Utilities.ErrorHandler('Need to add code')
    end

    return sBPIDToBuild
end

function IsFactoryReadyToBuild(oFactory)
    if oFactory:GetFractionComplete() == 1 and oFactory:GetWorkProgress() == 0 and oFactory:GetFractionComplete() == 1 and not (oFactory:IsUnitState('Building')) and not (oFactory:IsUnitState('Upgrading')) and not (oFactory:IsUnitState('Busy')) and M28Utilities.IsTableEmpty(oFactory:GetCommandQueue()) then
        return true
    end
    return false
end

function DecideAndBuildUnitForFactory(aiBrain, oFactory, bDontWait)
    --If factory is idle then gets it to build something; if its not idle then keeps checking for up to 20 seconds, but will abort if the factory appears to be building something
    local sFunctionRef = 'DecideAndBuildUnitForFactory'
    local bDebugMessages = false
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not (oFactory['M28ActiveBuilderCheck']) then
        oFactory['M28ActiveBuilderCheck'] = true
        local iTicksWaited = 0

        local bProceed = bDontWait
        if not (bProceed) then
            bProceed = IsFactoryReadyToBuild(oFactory)
        end

        local iWorkProgressStart = (oFactory:GetWorkProgress() or 0)

        while not (bProceed) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            iTicksWaited = iTicksWaited + 1
            if M28UnitInfo.IsUnitValid(oFactory) == false then
                return nil
            end
            bProceed = IsFactoryReadyToBuild(oFactory)
            if oFactory:GetWorkProgress() > iWorkProgressStart then
    if bDebugMessages == true then LOG(sFunctionRef..': Factory work progress is going up so will abort as it presumably already has an order') end
        break
    end
        if iTicksWaited >= 200 then
            M28Utilities.ErrorHandler('oFactory has waited more than 200 ticks and still isnt showing as ready to build, oFactory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; brain nickname=' .. oFactory:GetAIBrain().Nickname .. '; Work progress=' .. oFactory:GetWorkProgress() .. '; Factory fraction complete=' .. oFactory:GetFractionComplete() .. '; Factory status=' .. M28UnitInfo.GetUnitState(oFactory) .. '; Is command queue empty=' .. tostring(M28Utilities.IsTableEmpty(oFactory:GetCommandQueue())) .. '; iWorkProgressStart=' .. (iWorkProgressStart or 'nil'))
            break
        end
    end
        if bProceed then
            local sBPToBuild = DetermineWhatToBuild(aiBrain, oFactory)
        if bDebugMessages == true then LOG(sFunctionRef..': oFactory='..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; sBPToBuild='..(sBPToBuild or 'nil')..'; Does factory have an empty command queue='..tostring(M28Utilities.IsTableEmpty(oFactory:GetCommandQueue()))..'; Factory work progress='..oFactory:GetWorkProgress()..'; Factory unit state='..M28UnitInfo.GetUnitState(oFactory)) end
        if sBPToBuild then
            --Is this an upgrade or a unit to build?
            if EntityCategoryContains(M28UnitInfo.refCategoryFactory, sBPToBuild) then
                M28Economy.UpgradeUnit(oFactory, true)
            else
                M28Orders.IssueTrackedFactoryBuild(oFactory, sBPToBuild, bDontWait)
            end
        else
            WaitTicks(10)
            if M28UnitInfo.IsUnitValid(oFactory) then
                ForkThread(DecideAndBuildUnitForFactory, aiBrain, oFactory, false)
            end
        end
    end
    end
        oFactory['M28ActiveBuilderCheck'] = false
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end

function SetPreferredUnitsByCategory(aiBrain)
    --If have multiple units that can build for a particular category, this will specify what to build
    --special cases where want to prioritise one unit over another where multiple of same type satisfy the category
    --NOTE: This gets ignored if we have coded in special cases where we want to pick the fastest or slowest unit
    aiBrain[reftBlueprintPriorityOverride] = {}
    --T1
    aiBrain[reftBlueprintPriorityOverride]['ual0201'] = 1 --Aurora (instead of LAB)
    aiBrain[reftBlueprintPriorityOverride]['url0107'] = 1 --Mantis (instead of LAB)
    aiBrain[reftBlueprintPriorityOverride]['uel0201'] = 1 --Striker (instead of mechmarine)
    aiBrain[reftBlueprintPriorityOverride]['xsl0201'] = 1 --Thaam (instead of combat scout)
    --T2
    aiBrain[reftBlueprintPriorityOverride]['uel0202'] = 1 --Pillar (instead of mongoose or riptide)
    aiBrain[reftBlueprintPriorityOverride]['xsl0202'] = 1 --Ilshavoh (instead of hover tank)
    aiBrain[reftBlueprintPriorityOverride]['url0202'] = 1 --Rhino (instead of hover tank)
    aiBrain[reftBlueprintPriorityOverride]['ual0202'] = 1 --Obsidian (instead of blaze)
    --T3
    aiBrain[reftBlueprintPriorityOverride]['uel0303'] = 1 --Titan (instead of Percy)
    aiBrain[reftBlueprintPriorityOverride]['ual0303'] = 1 --Harby (instead of sniper bot)
    --aiBrain[reftBlueprintPriorityOverride]['ual0304'] = 1 --Mobile t3 arti instead of shield disrupter
    aiBrain[reftBlueprintPriorityOverride]['url0303'] = 1 --Loyalist (instead of Brick)
    --aiBrain[reftBlueprintPriorityOverride]['xrl0305'] = 1 --Brick
    aiBrain[reftBlueprintPriorityOverride]['xsl0303'] = 1 --Siege tank (instead of sniper bot)
    aiBrain[reftBlueprintPriorityOverride]['xsl0301'] = 1 --Seraphim basic SACU (instead of preset)

    --Engineers
    aiBrain[reftBlueprintPriorityOverride]['uel0208'] = 1 --T2 Engi (instead of sparky)

end

function IdleFactoryMonitor(aiBrain)
    --Cycles through every factory owned by aiBrain, max of 1 factory per tick, to check if it is idle
    local bDebugMessages = false
    if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IdleFactoryMonitor'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    while not (aiBrain.M28IsDefeated) do
        local tOurFactories = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryFactory, false, true)
        local tCommandQueue
        local sBPToBuild
        if M28Utilities.IsTableEmpty(tOurFactories) == false then
            for iFactory, oFactory in tOurFactories do
                if M28UnitInfo.IsUnitValid(oFactory) and oFactory:GetFractionComplete() == 1 then
                    tCommandQueue = oFactory:GetCommandQueue()
                    if IsFactoryReadyToBuild(oFactory) and GetGameTimeSeconds() - (oFactory[refiTimeSinceLastOrderCheck] or 0) >= 5 then
                        oFactory[refiTimeSinceLastOrderCheck] = GetGameTimeSeconds()
                        ForkThread(DecideAndBuildUnitForFactory, aiBrain, oFactory)
                    end
                end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
end