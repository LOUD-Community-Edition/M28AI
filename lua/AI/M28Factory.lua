---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 22:33
---
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')

local reftBlueprintPriorityOverride = 'M28FactoryPreferredBlueprintByCategory' --[x] is the blueprint ref, if there's a priority override it returns a numerical value (higher number = higher priority)
local refiTimeSinceLastOrderCheck = 'M28FactoryTimeSinceLastCheck' --against factory, gametime in seconds when the factory was last identified as idle with no order
--NOTE: Also have a blueprint blacklist in the landsubteam data - see M28Team

--Factory types (used by subteams)
refiFactoryTypeLand = 1
refiFactoryTypeAir = 2
refiFactoryTypeNaval = 3
refiFactoryTypeOther = 4

function GetBlueprintsThatCanBuildOfCategory(aiBrain, iCategoryCondition, oFactory, bGetSlowest, bGetFastest, bGetCheapest, iOptionalCategoryThatMustBeAbleToBuild, bIgnoreTechDifferences)
    --returns nil if cant find any blueprints that can build
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBlueprintsThatCanBuildOfCategory'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tBlueprints = EntityCategoryGetUnitList(iCategoryCondition)
    local tAllBlueprints = __blueprints
    local tValidBlueprints = {}
    local iValidBlueprints = 0
    local tBestBlueprints = {}
    local iBestBlueprints = 0
    local iHighestTech = 1
    local iCurrentTech = 1
    --if bGetSlowest == nil then bGetSlowest = false end
    --if bGetFastest == nil then bGetFastest = false end
    local iCurSpeed, iCurMass
    local tiLowestSpeedByTech = {1000, 1000, 1000}
    local tiLowestMassByTech = {100000000, 100000000, 100000000}
    local tiHighestSpeedByTech = {0,0,0}
    local oCurBlueprint
    local iHighestPriority = 0
    local bCanBuildRequiredCategory
    local iCategoriesThatBlueprintCanBuild
    local tsBlueprintsMeetingDesiredCategoriesToBuild
    if iOptionalCategoryThatMustBeAbleToBuild then
        tsBlueprintsMeetingDesiredCategoriesToBuild = EntityCategoryGetUnitList(iOptionalCategoryThatMustBeAbleToBuild)
        if bDebugMessages == true then LOG(sFunctionRef..': tsBlueprintsMeetingDesiredCategoriesToBuild='..repru(tsBlueprintsMeetingDesiredCategoriesToBuild)) end
    end





    if bDebugMessages == true then LOG(sFunctionRef..': reftBlueprintPriorityOverride='..repru(aiBrain[reftBlueprintPriorityOverride])) end
    if not(oFactory.CanBuild) then
        if oFactory.UnitId then
            M28Utilities.ErrorHandler('Factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..' doesnt have .canbuild')
        else
            M28Utilities.ErrorHandler('Factory has no UnitId and doesnt have .CanBuild')
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return nil
    else
        for _, sBlueprint in tBlueprints do
            if bDebugMessages == true then LOG(sFunctionRef..': About to see if factory '..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; can build blueprint '..sBlueprint..'; CanBuild='..tostring(oFactory:CanBuild(sBlueprint))) end
            if oFactory:CanBuild(sBlueprint) == true then
                --Check we can build the desired category
                if not(iOptionalCategoryThatMustBeAbleToBuild) then bCanBuildRequiredCategory = true
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Have said we need to build a particualr category, will see if sBLueprint='..sBlueprint..' can build this') end
                    bCanBuildRequiredCategory = false
                    iCategoriesThatBlueprintCanBuild = nil
                    if tAllBlueprints[sBlueprint].Economy.BuildableCategory and not(M28Utilities.IsTableEmpty(tsBlueprintsMeetingDesiredCategoriesToBuild)) then
                        if bDebugMessages == true then LOG(sFunctionRef..': sBlueprint has a buildablecategory set, will convert it into a category and see if it matches any of the blueprints we want to be able to build') end
                        for categoryIndex, category in tAllBlueprints[sBlueprint].Economy.BuildableCategory do
                            if categoryIndex == 1 then
                                iCategoriesThatBlueprintCanBuild = ParseEntityCategory(category)
                            else
                                iCategoriesThatBlueprintCanBuild = iCategoriesThatBlueprintCanBuild + ParseEntityCategory(category)
                            end
                        end

                        for iAltBlueprint, sAltBlueprint in tsBlueprintsMeetingDesiredCategoriesToBuild do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if sAltBlueprint='..(sAltBlueprint or 'nil')..' has a category that matches with what sBLueprint can build') end
                            if EntityCategoryContains(iCategoriesThatBlueprintCanBuild, sAltBlueprint) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Can build the desired category') end
                                bCanBuildRequiredCategory = true
                                break
                            end
                        end
                    end
                end

                if bCanBuildRequiredCategory then
                    --if EntityCategoryContains(iCategoryCondition, sBlueprint) then --tBlueprints is already filtered to just those that meet the categories
                    iValidBlueprints = iValidBlueprints + 1
                    tValidBlueprints[iValidBlueprints] = sBlueprint
                    if bIgnoreTechDifferences then iCurrentTech = 1
                    else
                        if EntityCategoryContains(categories.TECH3 + categories.EXPERIMENTAL, sBlueprint) then iCurrentTech = 3
                        elseif EntityCategoryContains(categories.TECH2, sBlueprint) then iCurrentTech = 2
                        else iCurrentTech = 1
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': '..sBlueprint..': iCurrentTech='..iCurrentTech..'; iHighestTech='..iHighestTech) end
                    if iCurrentTech > iHighestTech then
                        iHighestTech = iCurrentTech
                        iHighestPriority = 0
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if sBlueprint has a priority specified if we arent looking for slowest or fastest. sBlueprint='..sBlueprint..'; bGetSlowest='..tostring(bGetSlowest)..'; bGetFastest='..tostring(bGetFastest)..'; bGetCheapest='..tostring((bGetCheapest or false))) end
                    if not(bGetSlowest) and not(bGetFastest) and not(bGetCheapest) and aiBrain[reftBlueprintPriorityOverride][sBlueprint] then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have a priority specified='..aiBrain[reftBlueprintPriorityOverride][sBlueprint]..'; iHighestPriority='..iHighestPriority) end
                        iHighestPriority = math.max(aiBrain[reftBlueprintPriorityOverride][sBlueprint], iHighestPriority)
                    end
                    if bGetSlowest == true or bGetFastest == true then
                        oCurBlueprint = tAllBlueprints[sBlueprint]
                        iCurSpeed = oCurBlueprint.Physics.MaxSpeed
                        if bDebugMessages == true then LOG(sFunctionRef..': '..sBlueprint..': iCurSpeed='..iCurSpeed) end
                        if bGetSlowest == true then
                            if iCurSpeed < tiLowestSpeedByTech[iCurrentTech] then tiLowestSpeedByTech[iCurrentTech] = iCurSpeed end
                        elseif bGetFastest == true then
                            if iCurSpeed > tiHighestSpeedByTech[iCurrentTech] then tiHighestSpeedByTech[iCurrentTech] = iCurSpeed end
                        end
                    elseif bGetCheapest then
                        oCurBlueprint = tAllBlueprints[sBlueprint]
                        iCurMass = oCurBlueprint.Economy.BuildCostMass
                        if iCurMass < tiLowestMassByTech[iCurrentTech] then tiLowestMassByTech[iCurrentTech] = iCurMass end
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to get cheapest; iCurMass='..iCurMass..'; iCurrentTech='..iCurrentTech..'; tiLowestMassByTech[iCurrentTech]='..tiLowestMassByTech[iCurrentTech]) end
                    end
                    --end
                end
            end
        end
        --Now get a list of blueprints that are this tech level and of the highest priority
        --if bDebugMessages == true then LOG(sFunctionRef..': iHighestTech='..iHighestTech..'; tiHighestSpeedByTech='..tiHighestSpeedByTech[iHighestTech]..'; bGetSlowest='..tostring(bGetSlowest)..'; bGetFastest='..tostring(bGetFastest)) end
        local bIsValid, iCurrentPriority
        local iMinTechToUse = iHighestTech
        local iFastestSpeed = tiHighestSpeedByTech[iHighestTech]
        if bGetFastest == true and iHighestTech >= 3 then
            --If cybran, want loyalist instead of bomb; if Aeon want blaze instead of harbinger or shield disrupter; If sera probably want hover tank instead of siege tank; if UEF want titan
            if tiHighestSpeedByTech[3] <= 3.5 and tiHighestSpeedByTech[2] - tiHighestSpeedByTech[3] >= 0.6 then
                iMinTechToUse = 2
                iFastestSpeed = math.max(tiHighestSpeedByTech[3], tiHighestSpeedByTech[2])
            end
        end

        for _, sBlueprint in tValidBlueprints do
            bIsValid = false
            if EntityCategoryContains(categories.TECH3 + categories.EXPERIMENTAL, sBlueprint) then iCurrentTech = 3
            elseif EntityCategoryContains(categories.TECH2, sBlueprint) then iCurrentTech = 2
            else iCurrentTech = 1
            end
            if bDebugMessages == true then LOG(sFunctionRef..': sBlueprint='..sBlueprint..': Considering whether we have high enough tech to consider') end
            if iCurrentTech >= iMinTechToUse then
                if not(bGetFastest) and not(bGetSlowest) and not(bGetCheapest) then iCurrentPriority = aiBrain[reftBlueprintPriorityOverride][sBlueprint] end
                if iCurrentPriority == nil then iCurrentPriority = 0 end
                if bDebugMessages == true then LOG(sFunctionRef..': sBlueprint='..sBlueprint..'; iCurrentTech='..iCurrentTech..'; considering priority, iCurrentPriority='..iCurrentPriority..'; iHighestPriority='..iHighestPriority) end
                if iCurrentPriority >= iHighestPriority then
                    bIsValid = true

                    if not(bGetSlowest) and not(bGetFastest) and not(bGetCheapest) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Not interested in if slowest or fastest or cheapest so marking BP as valid') end
                        bIsValid = true
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to get either the slowest, fastest or cheapest') end
                        bIsValid = false
                        if bGetSlowest or bGetFastest then
                            oCurBlueprint = tAllBlueprints[sBlueprint]
                            iCurSpeed = oCurBlueprint.Physics.MaxSpeed
                            if bDebugMessages == true then LOG(sFunctionRef..': sBlueprint='..sBlueprint..'; iCurSpeed='..iCurSpeed) end
                            if bGetSlowest == true then
                                if iCurSpeed <= tiLowestSpeedByTech[iHighestTech] then bIsValid = true end
                            elseif iCurSpeed >= iFastestSpeed then
                                if bDebugMessages == true then LOG(sFunctionRef..': Have the highest speed for tech levels being considered') end
                                bIsValid = true
                            end
                        elseif bGetCheapest then
                            oCurBlueprint = tAllBlueprints[sBlueprint]
                            iCurMass = oCurBlueprint.Economy.BuildCostMass
                            if iCurMass <= tiLowestMassByTech[iCurrentTech] then bIsValid = true end
                            if bDebugMessages == true then LOG(sFunctionRef..': Want to get cheapest; iCurMass='..iCurMass..'; iCurrentTech='..iCurrentTech..'; tiLowestMassByTech[iCurrentTech]='..tiLowestMassByTech[iCurrentTech]..'; bIsValid='..tostring(bIsValid)) end
                        else M28Utilities.ErrorHandler('Missing code')
                        end
                    end
                end
                if bIsValid == true then
                    iBestBlueprints = iBestBlueprints + 1
                    tBestBlueprints[iBestBlueprints] = sBlueprint
                    if bDebugMessages == true then LOG(sFunctionRef..': Have valid blueprint='..sBlueprint) end
                end
            end
        end

        local iBPToBuild = math.random(1, iBestBlueprints)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return tBestBlueprints[iBPToBuild]
    end


end

function AdjustBlueprintForOverrides(aiBrain, sBPIDToBuild, tLZTeamData, iFactoryTechLevel)
    --Blacklisted units
    if M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subrefBlueprintBlacklist][sBPIDToBuild] then
        sBPIDToBuild = nil
    else
        --Special case - Cybran and UEF - if building loyalists or titans, then check if want to switch to bricks/percies
        if sBPIDToBuild == 'url0303' then --Loyalist
            if M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat * categories.TECH3) >= 2 then
                aiBrain[reftBlueprintPriorityOverride]['url0303'] = nil --loyalist
                aiBrain[reftBlueprintPriorityOverride]['xrl0305'] = 1 --brick
            end
        elseif sBPIDToBuild == 'uel0303' then --Titan
            if M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat * categories.TECH3) >= 15 then
                aiBrain[reftBlueprintPriorityOverride]['url0303'] = nil --Titan
                aiBrain[reftBlueprintPriorityOverride]['xel0305'] = 1 --Percival
            end
        end

        if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, sBPIDToBuild) then
            --Engineers - dont build if we have spare engineers at our current LZ
            local iMaxSpareWanted = 1
            if not(M28Conditions.TeamHasLowMass(aiBrain.M28Team)) then
                iMaxSpareWanted = math.max(2, 1 + math.floor(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamLowestMassPercentStored] * 10)) * M28Engineer.tiBPByTech[iFactoryTechLevel]
            end
            if tLZTeamData[M28Map.subrefLZSpareBPByTech][iFactoryTechLevel] > iMaxSpareWanted then
                sBPIDToBuild = nil
            end
        end
    end
    return sBPIDToBuild
end

function GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iTargetLandZone, bHaveLotsOfMAA)
    local sFunctionRef = 'GetLandZoneSupportCategoryWanted'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local iBaseCategoryWanted
    local bInSameIsland = false
    if NavUtils.GetLabel(M28Map.refPathingTypeLand, oFactory:GetPosition()) == NavUtils.GetLabel(M28Map.refPathingTypeLand, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZMidpoint]) then
        bInSameIsland = true
    end
    local tLZTargetTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][iTeam]
    if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateau '..iPlateau..'; iTargetLandZone='..iTargetLandZone..'; bInSameIsland='..tostring(bInSameIsland)..'; bHaveLotsOfMAA='..tostring(bHaveLotsOfMAA)..'; tLZTargetTeamData[M28Map.subrefbLZWantsIndirectSupport]='..tostring(tLZTargetTeamData[M28Map.subrefbLZWantsIndirectSupport])..'; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]..'; tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA]='..tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA]..'; tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted]='..tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted]..'; tLZTargetTeamData[M28Map.subrefbLZWantsSupport]='..tostring(tLZTargetTeamData[M28Map.subrefbLZWantsSupport])..'; LZ Air to ground enemy threat='..tLZTargetTeamData[M28Map.refiLZEnemyAirToGroundThreat]) end
    if tLZTargetTeamData[M28Map.subrefbLZWantsIndirectSupport] and tLZTargetTeamData[M28Map.subrefbLZWantsSupport] then
        --First consider if we need MAA more urgently than indirect
        local bWantMAANotIndirect = false
        if not(bHaveLotsOfMAA) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 500 and tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA] < tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted] then
            --We want more MAA for this LZ as well as wanting more indirect fire; prioritise MAA based on threat ratio and if enemy has a large air to ground force
            local iMAARatioWanted = 8
            if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 25000 then iMAARatioWanted = 4 end
            if tLZTargetTeamData[M28Map.refiLZEnemyAirToGroundThreat] >= 200 then iMAARatioWanted = iMAARatioWanted * 0.5 end
            if tLZTargetTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] < tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA] * iMAARatioWanted then
                bWantMAANotIndirect = true
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': tLZTargetTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]='..tLZTargetTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]..'; bWantMAANotIndirect='..tostring(bWantMAANotIndirect)) end
        if bWantMAANotIndirect then
            if M28UnitInfo.GetUnitTechLevel(oFactory) == 3 and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA) >= 50 or (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] >= 2000 and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.TECH3 * M28UnitInfo.refCategoryBomber, M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround])) == false) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 0 and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA - categories.TECH3) >  oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) * 4 then iBaseCategoryWanted = M28UnitInfo.refCategoryMAA
            else
                iBaseCategoryWanted = M28UnitInfo.refCategoryMAA - categories.TECH3
            end
            if not(bInSameIsland) then iBaseCategoryWanted = iBaseCategoryWanted * categories.AMPHIBIOUS + iBaseCategoryWanted * categories.HOVER end
            if bDebugMessages == true then LOG(sFunctionRef..': Will get MAA1') end
        else
            if bInSameIsland then
                iBaseCategoryWanted = M28UnitInfo.refCategoryIndirect
                if bDebugMessages == true then LOG(sFunctionRef..': Considering oFactory='..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; iTeam='..iTeam..'; iPlateau='..iPlateau..'; iTargetLandZone='..iTargetLandZone..'; We want indirect support for this LZ; Enemy structure threat by DF range='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZThreatEnemyStructureDFByRange])..'; Total indirect threat wanted for LZ='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZIndirectThreatWanted]) end
            else
                --Only consider amphibious indirect (so most factions wont build anything)
                iBaseCategoryWanted = M28UnitInfo.refCategoryIndirect * categories.AMPHIBIOUS + M28UnitInfo.refCategoryIndirect * categories.HOVER
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Will get Indirect') end
        end
    else
        --We dont want indirect fire units, do we want MAA units?
        if bDebugMessages == true then LOG(sFunctionRef..': Dont want indirect fire, do we want MAA? M28Map.subrefLZThreatAllyGroundAA='..M28Map.subrefLZThreatAllyGroundAA..'; M28Map.subrefLZMAAThreatWanted='..M28Map.subrefLZMAAThreatWanted..'; tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA]='..reprs(tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA])..'; tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted]='..tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted]) end
        if not(bHaveLotsOfMAA) and tLZTargetTeamData[M28Map.subrefLZThreatAllyGroundAA] < tLZTargetTeamData[M28Map.subrefLZMAAThreatWanted] and (M28UnitInfo.GetUnitTechLevel(oFactory) >= 2 or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoAllEnemyAir]) == false) then
            if M28UnitInfo.GetUnitTechLevel(oFactory) == 3 and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA) >= 50 or (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] >= 2000 and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.TECH3 * M28UnitInfo.refCategoryBomber, M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround])) == false) and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 0 and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA - categories.TECH3) >  oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) * 4 then iBaseCategoryWanted = M28UnitInfo.refCategoryMAA
            else
                iBaseCategoryWanted = M28UnitInfo.refCategoryMAA - categories.TECH3
            end
            if not(bInSameIsland) then iBaseCategoryWanted = iBaseCategoryWanted * categories.AMPHIBIOUS + iBaseCategoryWanted * categories.HOVER end
            if bDebugMessages == true then LOG(sFunctionRef..': Will build MAA2') end
        elseif tLZTargetTeamData[M28Map.subrefbLZWantsSupport] then

            --We want DF units (but not indirect fire units)
            if bInSameIsland then
                local iFactoryTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory)
                local iTechCategory = M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)

                iBaseCategoryWanted = M28UnitInfo.refCategorySkirmisher * iTechCategory
                if not(GetBlueprintsThatCanBuildOfCategory(oFactory:GetAIBrain(), iBaseCategoryWanted, oFactory)) then
                    iBaseCategoryWanted = M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategorySkirmisher
                else
                    --We can build skirmishers, but if we have built fewer than 15 T3 tanks, and enemy is using T2 and lower tech, consider building t3 tanks instead
                    if iFactoryTechLevel >= 3 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestEnemyGroundTech] <= 2 and M28Conditions.GetLifetimeBuildCount(oFactory:GetAIBrain(), M28UnitInfo.refCategoryDFTank * iTechCategory) <= 15 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Enemy is still at T2 or lower and we havent built many T3 normal tanks so will build normal tanks first before trying to build skrimishers') end
                        iBaseCategoryWanted = M28UnitInfo.refCategoryDFTank
                    end
                end

            else
                iBaseCategoryWanted = M28UnitInfo.refCategoryAmphibiousCombat
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iBaseCategoryWanted
end

function GetBlueprintToBuildForLandFactory(aiBrain, oFactory)
    local sFunctionRef = 'GetBlueprintToBuildForLandFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCategoryToBuild
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oFactory:GetPosition(), true, oFactory)
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
    local iFactoryTechLevel = M28UnitInfo.GetUnitTechLevel(oFactory)
    local iTeam = aiBrain.M28Team
    local bHaveLowMass = M28Conditions.TeamHasLowMass(iTeam)


    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, time='..GetGameTimeSeconds()..'; Checking if we have the highest tech land factory in the current land zone, iFactoryTechLevel='..iFactoryTechLevel..'; Highest friendly factory tech='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; Allied ground threat='..(M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] or 'nil')..'; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]='..(M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] or 'nil')..'; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat]='..(M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] or 'nil')..'; M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat]='..(M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] or 'nil')..'; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat]='..(M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat] or 'nil')..'; Is factory paused='..tostring(oFactory:IsPaused())..'; IsPaused value='..tostring(oFactory[M28UnitInfo.refbPaused])..'; Does LZ factory is in need BP='..tostring(tLZTeamData[M28Map.subrefLZTbWantBP])) end

    local bHaveLotsOfMAA = false
    if M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] >= 600 and M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] >= M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] + (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirAAThreat] + M28Team.tTeamData[iTeam][M28Team.refiEnemyTorpBombersThreat] + M28Team.tTeamData[iTeam][M28Team.refiEnemyAirOtherThreat]) * 0.25 then
        --Do we have more than 1/8 of our DF and indirect force in AA?
        if M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] < M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] * 8 then
            if bDebugMessages == true then LOG(sFunctionRef..': We have lots of MAA; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat]='..M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat]..'; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat]='..M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat]..'; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat]='..M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat]..'; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat]='..M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat]..'; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]) end
            bHaveLotsOfMAA = true
        end
    end

    local bHaveHighestLZTech = true
    if iFactoryTechLevel < 3 and iFactoryTechLevel < M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] then
        local tLandFactoriesInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        for iLZFactory, oLZFactory in  tLandFactoriesInLZ do
            if not(oLZFactory == oFactory) and M28UnitInfo.GetUnitTechLevel(oLZFactory) > iFactoryTechLevel then
                bHaveHighestLZTech = false
                break
            end
        end
    end



    iCategoryToBuild = M28UnitInfo.refCategoryEngineer --Placeholder
    local sBPIDToBuild

    --subfunctions to mean we can do away with the 'current condition == 1, == 2.....==999 type approach making it much easier to add to
    function ConsiderBuildingCategory(iCategoryToBuild)
        sBPIDToBuild = GetBlueprintsThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oFactory, nil, nil, nil, nil, false)
        if sBPIDToBuild then
            sBPIDToBuild = AdjustBlueprintForOverrides(aiBrain, sBPIDToBuild, tLZTeamData, iFactoryTechLevel)
        end
        if sBPIDToBuild then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd) --Assumes we will end code if we get to this point
            return sBPIDToBuild
        end
    end

    function ConsiderUpgrading()
        sBPIDToBuild = M28UnitInfo.GetUnitUpgradeBlueprint(oFactory, true)
        return sBPIDToBuild
    end

    local iCurrentConditionToTry = 0

    --MAIN BUILDER LOGIC:
    --Enemies nearby and have built fewer tanks of this tech level than engineers
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then LOG(sFunctionRef..': CHecking if nearby enemy threat and we are T2 plus, iFactoryTechLevel='..iFactoryTechLevel..'; Enemies in this or adjacent LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
    if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
        --Build tanks unless we have a LC of tanks of at least 5 and more than our LC of engineers
        local iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iLandZone)
        if not(iCategoryToGet) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iAdjLZ)
                if iCategoryToGet then break end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for support category wanted for this or adjacent LZ. Is iCategoryToGet nil='..tostring(iCategoryToGet == nil)) end
        if iCategoryToGet then
            local iTankLC = M28Conditions.GetLifetimeBuildCount(aiBrain, iCategoryToGet * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))
            if bDebugMessages == true then LOG(sFunctionRef..': Lifetime build count for this tech level='..iTankLC..'; Engi LC for this tech='..M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))) end
            if iTankLC < 3 or bHaveLowMass or iTankLC < M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) then
                if ConsiderBuildingCategory(iCategoryToGet) then return sBPIDToBuild end
            end
        end
    end

    --Initial engineers
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering high priority engineers, iFactoryTechLevel='..iFactoryTechLevel..'; Team highest factory tech level='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; Lifetime build count='..M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))..'; Current units='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel))) end
    if iFactoryTechLevel >= M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] then
        if M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) <= 4 or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(iFactoryTechLevel)) <= 2 then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then return sBPIDToBuild end
        end
    end

    --Initiail combat
    if bDebugMessages == true then LOG(sFunctionRef..': Considering initial combat units, lifetime count='..M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat)) end
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if iFactoryTechLevel == 1 and bHaveHighestLZTech and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryLandCombat) < 2 then
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryDFTank) then return sBPIDToBuild end
    end

    --Scouts if we want any
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want land scouts, does this LZ want scouts='..tostring(tLZTeamData[M28Map.refbWantLandScout])) end
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if tLZTeamData[M28Map.refbWantLandScout] then
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryLandScout) then return sBPIDToBuild end
    end

    --Engineers if we dont have low mass, and want more
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    local bNeedCurTech = true
    for iCurTech = 1, iFactoryTechLevel do
        if tLZTeamData[M28Map.subrefLZSpareBPByTech][iCurTech] > 0 then
            bNeedCurTech = false
            break
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': about to consider getting engineers, do we have low mass='..tostring(bHaveLowMass)..'; Highest team tech level='..M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]..'; bHaveHighestLZTech='..tostring(bHaveHighestLZTech)..'; bNeedCurTech='..tostring(bNeedCurTech)) end
    if bNeedCurTech and not(bHaveLowMass) and (iFactoryTechLevel >= M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5) then
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then return sBPIDToBuild end
    end

    --Engineers if we have few engineers in the current land zone and want more
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bNeedCurTech and not(tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal] > 10) then
        local tLZEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        local iEngisInLZ = 0
        if M28Utilities.IsTableEmpty(tLZEngineers) == false then
            iEngisInLZ = table.getn(tLZEngineers)
        end
        local iEngisWanted = 3
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] > 3 then
            iEngisWanted = math.min(6, math.ceil(M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]))
        end
        if iEngisInLZ < 5 then
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then return sBPIDToBuild end
        end
    end



    --Other actions - dont do unless we have lots of mass if this is lower than our highest tech level
    if bHaveHighestLZTech then

        --Combat or MAA if this LZ needs more units
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        --if tLZTeamData[M28Map.subrefbLZWantsSupport] then
        local iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, iLandZone)
        if iCategoryToGet then
            if ConsiderBuildingCategory(iCategoryToGet) then return sBPIDToBuild end
        end
        --end

        --MAA if this LZ has enemy air threat
        --[[if tLZTeamData[M28Map.refiLZEnemyAirToGroundThreat] > 0 then
            local iMAACat
            if oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA) >= 50 then iMAACat = M28UnitInfo.refCategoryMAA
            else
                iMAACat = M28UnitInfo.refCategoryMAA - categories.TECH3
            end
            if ConsiderBuildingCategory(iMAACat) then return sBPIDToBuild end
        end--]]


        --Maintain unit threat ratios
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if bDebugMessages == true then LOG(sFunctionRef..': Checking threat ratios, DF threat='..M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat]..'; Indirect='..M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat]) end
        if not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] > M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] * 16 then
            if bDebugMessages == true then LOG(sFunctionRef..': Will try to build more indirect fire units') end
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryIndirect) then return sBPIDToBuild end
        end
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if not(bHaveLowMass) and not(bHaveLotsOfMAA) then
            --Maintain MAA ratio vs overall combat threat - Only get MAA if we either have T2 land, or 50 gross mass, or enemy has air
            if bDebugMessages == true then LOG(sFunctionRef..': Checking MAA ratio overall, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]='..M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat]..'; M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir]='..tostring(M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir])..'; M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat]='..M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat]) end
            if iFactoryTechLevel >= 2 or M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.reftoAllEnemyAir]) == false or M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 5 then
                local iThreatFactor = 20
                if M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir] and M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 4000 then iThreatFactor = 8
                elseif not(M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbHaveAirControl]) and (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 4000 or M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.refbFarBehindOnAir]) then iThreatFactor = 13
                end

                if M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] + M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] > M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] * iThreatFactor then
                    local iMAACat
                    if oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA) >= 50 or (M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] >= 2000 and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(categories.TECH3 * M28UnitInfo.refCategoryBomber, M28Team.tTeamData[iTeam][M28Team.reftoEnemyAirToGround])) == false) and oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA - categories.TECH3) >  oFactory:GetAIBrain():GetCurrentUnits(M28UnitInfo.refCategoryMAA * categories.TECH3) * 4 then iMAACat = M28UnitInfo.refCategoryMAA
                    else
                        iMAACat = M28UnitInfo.refCategoryMAA - categories.TECH3
                    end
                    if ConsiderBuildingCategory(iMAACat) then return sBPIDToBuild end
                end
            end
        end

        --Combat or MAA if we have a LZ within half of dist between us and nearest enemy that wants more units
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        local iEnemyPlateau, iEnemyLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.GetPrimaryEnemyBaseLocation(aiBrain))
        if iEnemyPlateau == iPlateau then
            local iDistToEnemyBaseToConsider
            if not(bHaveLowMass) then iDistToEnemyBaseToConsider = M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iEnemyLandZone) * 0.75
            else iDistToEnemyBaseToConsider = M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iEnemyLandZone) * 0.5
            end

            for iEntry, tLZPathing in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                if tLZPathing[M28Map.subrefLZTravelDist] <= iDistToEnemyBaseToConsider then
                    --if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tLZPathing[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefbLZWantsSupport] then
                    --How far away is it?
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to reinforce alternative LZ '..tLZPathing[M28Map.subrefLZNumber]..'; Travel dist='..tLZPathing[M28Map.subrefLZTravelDist]..'; iDistToEnemyBaseToConsider='..iDistToEnemyBaseToConsider) end
                    --if tLZPathing[M28Map.subrefLZTravelDist] <= iDistToEnemyBaseToConsider then
                    local iCategoryToGet = GetLandZoneSupportCategoryWanted(oFactory, iTeam, iPlateau, tLZPathing[M28Map.subrefLZNumber], bHaveLotsOfMAA)
                    if bDebugMessages == true then LOG(sFunctionRef..': DO we have no category for this alternative LZ '..tLZPathing[M28Map.subrefLZNumber]..'='..tostring(iCategoryToGet==nil)..'; bHaveLotsOfMAA='..tostring(bHaveLotsOfMAA)) end
                    if iCategoryToGet then
                        if ConsiderBuildingCategory(iCategoryToGet) then return sBPIDToBuild end
                    end
                else
                    break
                end
            end
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Consideringi f we want to upgrade factory, iFactoryTechLevel='..iFactoryTechLevel..'; Brain highest tech='..aiBrain[M28Economy.refiOurHighestLandFactoryTech]) end
        iCurrentConditionToTry = iCurrentConditionToTry + 1
        if iFactoryTechLevel < aiBrain[M28Economy.refiOurHighestLandFactoryTech] then
            --Do we want ot upgrade a support factory? Check first if are upgrading anything here
            local bUpgradingLandFactory = false

            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false then
                for iUnit, oUnit in tLZTeamData[M28Map.subrefActiveUpgrades] do
                    if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnit.UnitId) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have an active land factory upgrade='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit.UnitId)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))..'; Fraction complete='..oUnit:GetFractionComplete()..'; Work progress='..oUnit:GetWorkProgress()) end
                        bUpgradingLandFactory = true
                        break
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': bUpgradingLandFactory='..tostring(bUpgradingLandFactory)..'; bHaveLowMass='..tostring(bHaveLowMass)..'; Lowest mass % stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]) end
            if not(bUpgradingLandFactory) or (not(bHaveLowMass) and aiBrain[M28Economy.refiOurHighestLandFactoryTech] == 3 and (iFactoryTechLevel == 1 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.5)) then

                if not(bHaveLowMass) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.3 and M28Conditions.GetLifetimeBuildCount(aiBrain, categories.LAND * categories.MOBILE * M28UnitInfo.ConvertTechLevelToCategory(aiBrain[M28Economy.refiOurHighestLandFactoryTech])) >= 3 then
                    if ConsiderUpgrading() then return sBPIDToBuild end
                elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.02 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.15 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] > 0) and M28Conditions.GetLifetimeBuildCount(aiBrain, categories.LAND * categories.MOBILE * M28UnitInfo.ConvertTechLevelToCategory(aiBrain[M28Economy.refiOurHighestLandFactoryTech])) >= 6 then
                    --Still consider upgrading if we have a T2 land factory but no t2 support factory in the LZ and have built some T2 units already
                    local tLandFactoriesInZone = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                    local iHQAndSupportCount = 0
                    for iUnit, oUnit in tLandFactoriesInZone do
                        if M28UnitInfo.GetUnitTechLevel(oUnit) >= aiBrain[M28Economy.refiOurHighestLandFactoryTech] then
                            iHQAndSupportCount = iHQAndSupportCount + 1
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iHQAndSupportCount='..iHQAndSupportCount) end
                    if iHQAndSupportCount <= 1 then
                        if ConsiderUpgrading() then return sBPIDToBuild end
                    end
                end
            end
        end
    end

    --Engineers if we have mass and dont have spare engineers
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if want engineers if have mass: M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored]..'; bHaveHighestLZTech='..tostring(bHaveHighestLZTech)..'; subrefLZTbWantBP='..tostring(tLZTeamData[M28Map.subrefLZTbWantBP])) end
    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.01 and ((bHaveHighestLZTech and tLZTeamData[M28Map.subrefLZTbWantBP]) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > 0.4) then
        if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then return sBPIDToBuild end
    end

    --T1 mobile arti if we dont ahve low mass and are below highest tech level, or normal tanks otherwise
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if not(bHaveLowMass) then
        --Is there a relatively nearby enemy?

        local bEnemiesRelativelyNear = tLZData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]
        if not(bEnemiesRelativelyNear) and M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                    bEnemiesRelativelyNear = true
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Dont have low mass so considering if we have enemies adjacent to an adjacent LZ in which case will build T1 arti, bEnemiesRelativelyNear='..tostring(bEnemiesRelativelyNear)) end
        if bEnemiesRelativelyNear then
            if bHaveHighestLZTech then
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategorySkirmisher) then return sBPIDToBuild end
            else
                if ConsiderBuildingCategory(M28UnitInfo.refCategoryIndirect * categories.TECH1) then return sBPIDToBuild end
            end
        end
    end



    --Upgrade T1 to T2 if we have multiple mex upgrades and T1 land facs in this land zone, and already have T2 land, even if have low mass
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if iFactoryTechLevel == 1 and M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyLandFactoryTech] >= 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 20 and GetGameTimeSeconds() - M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] >= 3 then
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false and table.getn(tLZTeamData[M28Map.subrefActiveUpgrades]) >= 3 then
            local iCurMexUpgrades = 0
            local iCurT1FactoryUpgrades = 0
            for iUnit, oUnit in tLZTeamData[M28Map.subrefActiveUpgrades] do
                if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then iCurMexUpgrades = iCurMexUpgrades + 1
                elseif EntityCategoryContains(M28UnitInfo.refCategoryFactory * categories.TECH1, oUnit.UnitId) then iCurT1FactoryUpgrades = iCurT1FactoryUpgrades + 1
                end
            end
            if iCurT1FactoryUpgrades == 0 and iCurMexUpgrades >= 2 then
                --Do we have more than 1 T1 land factory in this land zone?
                local tT1LandFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandFactory * categories.TECH1, tLZTeamData[M28Map.subrefLZTAlliedUnits])
                if table.getn(tT1LandFactories) >= 2 then
                    if ConsiderUpgrading() then return sBPIDToBuild end
                end
            end
        end
    end

    --Build more engineers if we have multiple upgrades and need more engineers for the current LZ, even if relatively low mass
    iCurrentConditionToTry = iCurrentConditionToTry + 1
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefActiveUpgrades]) == false and M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= 50 and GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastMassStall] or -5) >= 5 and tLZTeamData[M28Map.subrefLZTbWantBP] and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) == false then
        if table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingMexes]) / M28Team.tTeamData[iTeam][M28Team.subrefiActiveM28BrainCount] >= 3 then
            --Build engineers as we have lots of upgrades
            if ConsiderBuildingCategory(M28UnitInfo.refCategoryEngineer) then return sBPIDToBuild end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DetermineWhatToBuild(aiBrain, oFactory)
    local sBPIDToBuild

    if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oFactory.UnitId) then
        sBPIDToBuild = GetBlueprintToBuildForLandFactory(aiBrain, oFactory)
    else
        M28Utilities.ErrorHandler('Need to add code')
    end

    return sBPIDToBuild
end

function IsFactoryReadyToBuild(oFactory)
    if oFactory:GetFractionComplete() == 1 and oFactory:GetWorkProgress() == 0 and oFactory:GetFractionComplete() == 1 and not (oFactory:IsUnitState('Building')) and not (oFactory:IsUnitState('Upgrading')) and not (oFactory:IsUnitState('Busy')) and M28Utilities.IsTableEmpty(oFactory:GetCommandQueue()) then
        return true
    end
    return false
end

function DecideAndBuildUnitForFactory(aiBrain, oFactory, bDontWait)
    --If factory is idle then gets it to build something; if its not idle then keeps checking for up to 20 seconds, but will abort if the factory appears to be building something
    local sFunctionRef = 'DecideAndBuildUnitForFactory'
    local bDebugMessages = false
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not (oFactory['M28ActiveBuilderCheck']) then
        oFactory['M28ActiveBuilderCheck'] = true
        local iTicksWaited = 0

        local bProceed = bDontWait
        if not (bProceed) then
            bProceed = IsFactoryReadyToBuild(oFactory)
        end

        local iWorkProgressStart = (oFactory:GetWorkProgress() or 0)

        while not (bProceed) do
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            iTicksWaited = iTicksWaited + 1
            if M28UnitInfo.IsUnitValid(oFactory) == false then
                return nil
            end
            bProceed = IsFactoryReadyToBuild(oFactory)
            if oFactory:GetWorkProgress() > iWorkProgressStart then
    if bDebugMessages == true then LOG(sFunctionRef..': Factory work progress is going up so will abort as it presumably already has an order') end
        break
    end
        if iTicksWaited >= 200 then
            M28Utilities.ErrorHandler('oFactory has waited more than 200 ticks and still isnt showing as ready to build, oFactory=' .. oFactory.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oFactory) .. '; brain nickname=' .. oFactory:GetAIBrain().Nickname .. '; Work progress=' .. oFactory:GetWorkProgress() .. '; Factory fraction complete=' .. oFactory:GetFractionComplete() .. '; Factory status=' .. M28UnitInfo.GetUnitState(oFactory) .. '; Is command queue empty=' .. tostring(M28Utilities.IsTableEmpty(oFactory:GetCommandQueue())) .. '; iWorkProgressStart=' .. (iWorkProgressStart or 'nil'))
            break
        end
    end
        if bProceed then
            local sBPToBuild = DetermineWhatToBuild(aiBrain, oFactory)
        if bDebugMessages == true then LOG(sFunctionRef..': oFactory='..oFactory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFactory)..'; sBPToBuild='..(sBPToBuild or 'nil')..'; Does factory have an empty command queue='..tostring(M28Utilities.IsTableEmpty(oFactory:GetCommandQueue()))..'; Factory work progress='..oFactory:GetWorkProgress()..'; Factory unit state='..M28UnitInfo.GetUnitState(oFactory)) end
        if sBPToBuild then
            --Is this an upgrade or a unit to build?
            if EntityCategoryContains(M28UnitInfo.refCategoryFactory, sBPToBuild) then
                M28Economy.UpgradeUnit(oFactory, true)
            else
                M28Orders.IssueTrackedFactoryBuild(oFactory, sBPToBuild, bDontWait)
            end
        else
            WaitTicks(10)
            if M28UnitInfo.IsUnitValid(oFactory) then
                ForkThread(DecideAndBuildUnitForFactory, aiBrain, oFactory, false)
            end
        end
    end
    end
        oFactory['M28ActiveBuilderCheck'] = false
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end

function SetPreferredUnitsByCategory(aiBrain)
    --If have multiple units that can build for a particular category, this will specify what to build
    --special cases where want to prioritise one unit over another where multiple of same type satisfy the category
    --NOTE: This gets ignored if we have coded in special cases where we want to pick the fastest or slowest unit
    aiBrain[reftBlueprintPriorityOverride] = {}
    --T1
    aiBrain[reftBlueprintPriorityOverride]['ual0201'] = 1 --Aurora (instead of LAB)
    aiBrain[reftBlueprintPriorityOverride]['url0107'] = 1 --Mantis (instead of LAB)
    aiBrain[reftBlueprintPriorityOverride]['uel0201'] = 1 --Striker (instead of mechmarine)
    aiBrain[reftBlueprintPriorityOverride]['xsl0201'] = 1 --Thaam (instead of combat scout)
    --T2
    aiBrain[reftBlueprintPriorityOverride]['uel0202'] = 1 --Pillar (instead of mongoose or riptide)
    aiBrain[reftBlueprintPriorityOverride]['xsl0202'] = 1 --Ilshavoh (instead of hover tank)
    aiBrain[reftBlueprintPriorityOverride]['url0202'] = 1 --Rhino (instead of hover tank)
    aiBrain[reftBlueprintPriorityOverride]['ual0202'] = 1 --Obsidian (instead of blaze)
    --T3
    aiBrain[reftBlueprintPriorityOverride]['uel0303'] = 1 --Titan (instead of Percy)
    aiBrain[reftBlueprintPriorityOverride]['ual0303'] = 1 --Harby (instead of sniper bot)
    --aiBrain[reftBlueprintPriorityOverride]['ual0304'] = 1 --Mobile t3 arti instead of shield disrupter
    aiBrain[reftBlueprintPriorityOverride]['url0303'] = 1 --Loyalist (instead of Brick)
    --aiBrain[reftBlueprintPriorityOverride]['xrl0305'] = 1 --Brick
    aiBrain[reftBlueprintPriorityOverride]['xsl0303'] = 1 --Siege tank (instead of sniper bot)
    aiBrain[reftBlueprintPriorityOverride]['xsl0301'] = 1 --Seraphim basic SACU (instead of preset)

    --Engineers
    aiBrain[reftBlueprintPriorityOverride]['uel0208'] = 1 --T2 Engi (instead of sparky)

end

function IdleFactoryMonitor(aiBrain)
    --Cycles through every factory owned by aiBrain, max of 1 factory per tick, to check if it is idle
    local bDebugMessages = false
    if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IdleFactoryMonitor'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    while not (aiBrain.M28IsDefeated) do
        local tOurFactories = aiBrain:GetListOfUnits(M28UnitInfo.refCategoryFactory, false, true)
        local tCommandQueue
        local sBPToBuild
        if M28Utilities.IsTableEmpty(tOurFactories) == false then
            for iFactory, oFactory in tOurFactories do
                if M28UnitInfo.IsUnitValid(oFactory) and oFactory:GetFractionComplete() == 1 then
                    tCommandQueue = oFactory:GetCommandQueue()
                    if IsFactoryReadyToBuild(oFactory) and GetGameTimeSeconds() - (oFactory[refiTimeSinceLastOrderCheck] or 0) >= 5 then
                        oFactory[refiTimeSinceLastOrderCheck] = GetGameTimeSeconds()
                        ForkThread(DecideAndBuildUnitForFactory, aiBrain, oFactory)
                    end
                end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
end