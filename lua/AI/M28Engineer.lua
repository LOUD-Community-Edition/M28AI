---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 19:23
---
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local NavUtils = import("/lua/sim/navutils.lua")



--Global variables
bBuildLocationLoopActive = false --true if have a loop that is checking for build locations
tsBlueprintsBySize = {[1] = 'ueb2101', [2] = 'ueb1101', [6] = 'ueb1201', [8] = 'ueb1301', [9]='xrl0403', [10]='uab0304', [16] = 'xsa0402', [24] = 'uaa0310'} --Blueprints to use when trying to find locations that can buid on for a building of a particular size
tAllScathis = {} --If a scathis is constructed it gets recorded here (and we then check this for build locations to avoid trying to build on a scathis); for performance reasons will just use a single global table

--against brain:
--refiEngineerCurUniqueReference - this is also against unit so is declared in below section rather than here

--Against unit varaibles
refiEngineerCurUniqueReference = 'M28EngCurUniqueReference' --Against both aiBrain and engineer; aiBrain stores the xth engineer object its given an action to, so this can be used as a unique reference
refiAssignedAction = 'M28EngAssignedAction' --against Engineer, records the refAction value the engineer was given if it has an active order


--Actions for engineers (dont have as local variables due to cap on how many local variables we can have)
refActionBuildMex = 1
refActionBuildHydro = 2
refActionReclaimArea = 3
refActionBuildPower = 4
refActionBuildLandFactory = 5
refActionBuildEnergyStorage = 6
refActionSpare = 7
refActionHasNearbyEnemies = 8
refActionUpgradeBuilding = 9
refActionBuildSecondPower = 10
refActionBuildAirStaging = 11
refActionBuildAirFactory = 12
refActionBuildSMD = 13
refActionBuildMassStorage = 14
refActionBuildT1Radar = 15
refActionBuildT2Radar = 16
refActionBuildT3Radar = 17
refActionAssistSMD = 18
refActionAssistAirFactory = 19
refActionBuildThirdPower = 20
refActionBuildExperimental = 21
refActionReclaimUnit = 22
refActionBuildT3MexOverT2 = 23
refActionUpgradeHQ = 24 --Assists an HQ with its upgrade
refActionReclaimTrees = 25
refActionBuildT1Sonar = 26
refActionBuildT2Sonar = 27
refActionAssistNuke = 28
refActionBuildShield = 29
refActionBuildT3ArtiPower = 30
refActionBuildTMD = 31
refActionBuildAA = 32
refActionBuildEmergencyPD = 33
refActionBuildSecondLandFactory = 34
refActionBuildSecondAirFactory = 35
refActionBuildTML = 36
refActionBuildSecondExperimental = 37
refActionLoadOnTransport = 38
refActionFortifyFirebase = 39
refActionAssistShield = 40
refActionBuildSecondShield = 41
refActionBuildEmergencyArti = 42
refActionAssistTML = 43
refActionBuildQuantumGateway = 44
refActionBuildQuantumOptics = 45
refActionBuildHive = 46
refActionSelenMexBuild = 47
refActionBuildSecondTMD = 48
refActionBuildNavalFactory = 49
refActionAssistNavalFactory = 50
refActionNavalSpareAction = 51
refActionBuildWall = 52
refActionBuildT3MexOnly = 53
refActionAssistMexUpgrade = 54
refActionSAMCreep = 55 --Intended to gradually expand SAM coverage for mexes
refActionBuildMassFab = 56
tiEngiActionsThatDontBuild = {refActionReclaimArea, refActionSpare, refActionNavalSpareAction, refActionHasNearbyEnemies, refActionReclaimUnit, refActionReclaimTrees, refActionUpgradeBuilding, refActionAssistSMD, refActionAssistTML, refActionAssistMexUpgrade, refActionAssistAirFactory, refActionAssistNavalFactory, refActionUpgradeHQ, refActionAssistNuke, refActionLoadOnTransport, refActionAssistShield}

--Categories to use where no complex logic required (if it wont always be the same category then add logic to GetCategoryToBuildOrAssistFromAction
tiActionCategory = {
[refActionBuildMex] = M28UnitInfo.refCategoryT1Mex,
[refActionBuildHydro] = M28UnitInfo.refCategoryHydro,
[refActionBuildPower] = M28UnitInfo.refCategoryPower,
}

tiActionOrder = {
    [refActionBuildMex] = M28Orders.refiOrderIssueBuild,
    [refActionBuildHydro] = M28Orders.refiOrderIssueBuild,
    [refActionBuildPower] = M28Orders.refiOrderIssueBuild,
}

--Adjacent categories to search for for a particualr action
tiActionAdjacentCategory = {
    [refActionBuildPower] = M28UnitInfo.refCategoryAirFactory + M28UnitInfo.refCategoryRadar + M28UnitInfo.refCategorySMD + M28UnitInfo.refCategorySML,
}

--Include any actions where we wont be building a category or searching for a category to assist
tbActionsThatDontHaveCategory = {
}


function GetEngineerUniqueCount(oEngineer)
    local iUniqueRef = oEngineer[refiEngineerCurUniqueReference]
    if iUniqueRef == nil then
        local aiBrain = oEngineer:GetAIBrain()
        iUniqueRef = aiBrain[refiEngineerCurUniqueReference] + 1
        aiBrain[refiEngineerCurUniqueReference] = iUniqueRef
        oEngineer[refiEngineerCurUniqueReference] = iUniqueRef
    end
    return iUniqueRef
end

function CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, iOptionalPlateauGroup, iOptionalLandZone, iEngiActionToIgnore, bClearActionsIfNotStartedBuilding, bCheckForQueuedBuildings, bCheckForOverlappingBuildings)
    --iOptionalPlateauGroup, iOptionalLandZone, iEngiActionToIgnore, bClearActionsIfNotStartedBuilding and bCheckForOverlappingBuildings are optional
    --iOptionalPlateauGroup and iOptionalLandZone: If specified, then will check this zone for queued units, if bCheckForQueuedBuildings is true
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CanBuildAtLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if bDebugMessages == true then LOG(sFunctionRef..': About to see if we can build '..sBlueprintToBuild..' at '..repru(tTargetLocation)..'; iEngiActionToIgnore='..(iEngiActionToIgnore or 'nil')..'; bClearActionsIfNotStartedBuilding='..tostring((bClearActionsIfNotStartedBuilding or false))..'; surface height at target='..GetSurfaceHeight(tTargetLocation[1], tTargetLocation[3])..'; aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation)='..tostring(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation))) end

    local bCanBuildStructure = false
    if aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation) == true then
        bCanBuildStructure = true
        if bDebugMessages == true then LOG(sFunctionRef..': Passed hte basic aiBrain check of whether se can build a structure at the target location, bCheckForQueuedBuildings='..tostring(bCheckForQueuedBuildings or false)) end

        local iSkirtSizeRadius = __blueprints[sBlueprintToBuild].Physics.SkirtSizeX * 0.5
        if bCheckForQueuedBuildings == true then
            if iOptionalPlateauGroup and iOptionalLandZone then
                local tLZFriendlyUnits = M28Map.tAllPlateaus[iOptionalPlateauGroup][M28Map.subrefPlateauLandZones][iOptionalLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZTAlliedUnits]
                if M28Utilities.IsTableEmpty(tLZFriendlyUnits) == false then
                    local tFriendlyEngineers = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZFriendlyUnits)
                    if M28Utilities.IsTableEmpty(tFriendlyEngineers) == false then
                        for iEngi, oEngi in tFriendlyEngineers do
                            if M28UnitInfo.IsUnitValid(oEngi) and not(oEngi:IsUnitState('Building')) and oEngi[refiAssignedAction] then
                                M28Orders.UpdateRecordedOrders(oEngi)
                                if oEngi[M28Orders.reftiLastOrders] then
                                    local tLastOrder = oEngi[M28Orders.reftiLastOrders][table.getn(oEngi[M28Orders.reftiLastOrders])]
                                    if tLastOrder[M28Orders.subrefsOrderBlueprint] and M28Utilities.IsTableEmpty(tLastOrder[M28Orders.subreftOrderPosition]) == false and M28Utilities.GetDistanceBetweenPositions(tLastOrder[M28Orders.subreftOrderPosition], tTargetLocation) <= (iSkirtSizeRadius + __blueprints[tLastOrder[M28Orders.subrefsOrderBlueprint]].Physics.SkirtSizeX * 0.5) then
                                        bCanBuildStructure = false
                                        break
                                    end
                                end
                            end
                        end
                    end
                end
            else
                M28Utilities.ErrorHandler('Need to add code - have commented out old M27 code for now - change so it will consider any queued buildings by land zone locations rather than checking every single location')
            end
            --Check if any engi actions queued up that would stop this
            --[[local iBuildingRadius = math.max(__blueprints[sBlueprintToBuild].Physics.SkirtSizeX * 0.5 - 1,0)  --E.g. if building a t1 power, it has a size of 2, and radius of 1; when it's queued, the location and blocks within 1 of it will all be marked as being built on (i.e. a 3x3 area).  Hence, if considering building another power, if we dont reduce the search range by 1, it will lead to spacing things out more than needed
            local sLocationRef
            local tLocationToCheck
            local bIgnoreAction
            if bDebugMessages == true then LOG(sFunctionRef..': Can build structure at the location, checking if we already have building queued up for this location. iBuildingRadius='..iBuildingRadius) end
            --tiEngiActionsThatDontBuild
            for iAdjustX = -iBuildingRadius, iBuildingRadius, 1 do
                for iAdjustZ = -iBuildingRadius, iBuildingRadius, 1 do
                    tLocationToCheck = {tTargetLocation[1] + iAdjustX, 0, tTargetLocation[3] + iAdjustZ}
                    tLocationToCheck[2] = GetSurfaceHeight(tLocationToCheck[1], tLocationToCheck[3])
                    sLocationRef = M28Utilities.ConvertLocationToStringRef(tLocationToCheck)
                    if bDebugMessages == true then LOG(sFunctionRef..': iAdjustX='..iAdjustX..'; iAdjustZ='..iAdjustZ..'; sLocationRef='..sLocationRef..'; Is table empty for this='..tostring(M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][sLocationRef]))) end
                    if M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][sLocationRef]) == false then
                        for iActionRef, tSubtable in aiBrain[reftEngineerAssignmentsByLocation][sLocationRef] do
                            bIgnoreAction = false
                            for _, iActionToIgnore in tiEngiActionsThatDontBuild do
                                if iActionRef == iActionToIgnore then
                                    bIgnoreAction = true
                                    break
                                end
                            end
                            if iEngiActionToIgnore and iActionRef == iEngiActionToIgnore then bIgnoreAction = true end
                            if bDebugMessages == true then LOG(sFunctionRef..': iActionRef='..iActionRef..'; bIgnoreAction='..tostring(bIgnoreAction)) end                            if not(bIgnoreAction) then
                            bCanBuildStructure = false
                            --Do we want to cancel any blocking units?
                            if bClearActionsIfNotStartedBuilding then
                                for iUniqueEngiRef, oEngineer in tSubtable do
                                    if bDebugMessages == true then LOG(sFunctionRef..': About to clear oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' which was recorded as having iActionRef='..iActionRef) end
                                    M28Orders.IssueTrackedClearCommands({oEngineer})
                                    ClearEngineerActionTrackers(aiBrain, oEngineer, true)
                                end
                                bCanBuildStructure = M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][sLocationRef][iActionRef])
                                if bDebugMessages == true then LOG(sFunctionRef..': Have just cleared any blocking units; bCanBuildStructure='..tostring(bCanBuildStructure)) end
                            end
                            if not(bCanBuildStructure) then break end
                        end
                        end
                    end
                    if not(bCanBuildStructure) then break end
                end
                if not(bCanBuildStructure) then break end
            end--]]
        end
        if bCanBuildStructure then

            --Check in case scathis is blocking us
            if M28Utilities.IsTableEmpty(tAllScathis) == false then
                for iUnit, oUnit in tAllScathis do
                    if M28Utilities.GetDistanceBetweenPositions(tTargetLocation, oUnit:GetPosition()) < (iSkirtSizeRadius + oUnit:GetBlueprint().Physics.SkirtSizeX * 0.5) then
                        bCanBuildStructure = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Are too close to a scathis so wont build here') end
                        break
                    end
                end
            end

            if bCanBuildStructure and bCheckForOverlappingBuildings then

                --Thanks to jip for flagging there's an engine bug where in rare situations units can be built slightly overlapping even if aiBrain:CanBuildStructureAt returns true - comments in the code Jip linked to suggested this is only where a building has upgraded
                -- compute build locations and issue the capping

                -- find all units that may prevent us from building
                local tNearbyStructures = GetUnitsInRect(tTargetLocation[1] - (iSkirtSizeRadius + 4), tTargetLocation[3] - (iSkirtSizeRadius + 4), tTargetLocation[1] + (iSkirtSizeRadius + 4), tTargetLocation[3] + (iSkirtSizeRadius + 4))
                if M28Utilities.IsTableEmpty(tNearbyStructures) == false then
                    tNearbyStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryUpgraded, tNearbyStructures)
                    local iClosestDistance
                    if M28Utilities.IsTableEmpty(tNearbyStructures) == false then
                        for iStructure, oStructure in tNearbyStructures do
                            if not(oStructure.Dead) then
                                if bDebugMessages == true then LOG(sFunctionRef..': oStructure='..oStructure.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStructure)..'; position='..repru(oStructure:GetPosition())..'; target location='..repru(tTargetLocation)..'; target building ID='..sBlueprintToBuild..'; 50% of target building skirt size='..iSkirtSizeRadius..'; 50% of oStructure skrit size='..oStructure:GetBlueprint().Physics.SkirtSizeX * 0.5) end
                                iClosestDistance = math.max(math.abs(oStructure:GetPosition()[1] - tTargetLocation[1]), math.abs(oStructure:GetPosition()[3] - tTargetLocation[3]))
                                if iClosestDistance < (iSkirtSizeRadius + oStructure:GetBlueprint().Physics.SkirtSizeX * 0.5) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Cant build as iClosestDistance='..iClosestDistance..'which is less than the two skirt sizes') end
                                    bCanBuildStructure = false
                                    break
                                end
                            end
                        end
                    end
                end
            end
            if not(bCanBuildStructure) and bDebugMessages == true then LOG(sFunctionRef..': Skirt size is overlaping with a building that could have upgraded so will return false') end
        end
    elseif bDebugMessages == true then LOG(sFunctionRef..': Cant build structure at the location')
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bCanBuildStructure='..tostring(bCanBuildStructure)) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bCanBuildStructure
end

function CheckIfBuildableLocationsNearPositionStillValid(aiBrain, tLocation)
    local iPlateauGroup, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tLocation)
    if iLandZone > 0 then
        local sGenericBlueprint
        if M28Utilities.IsTableEmpty(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize])) == false then
            for iSize, tOldBuildableLocations in M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize] do
                sGenericBlueprint = tsBlueprintBySize[iSize]
                --Is the location still valid?
                local function StillKeepLocation(tArray, iEntry)
                    return aiBrain:CanBuildStructureAt(sGenericBlueprint, tArray[iEntry]) --Done instead of the detailed test since will have already passed the detailed test to get here and want something quick as will be running potentially tens of thousands of times
                end
                M28Utilities.RemoveEntriesFromArrayBasedOnCondition(tOldBuildableLocations, StillKeepLocation)    --Done instead of table.gen to avoid reindexing array multiple times in the same cycle
            end
        end
        --Search for more building locations for every building where we havent considered the full amount
        for iSize, tOldBuildableLocations in M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize] do
            if M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTotalSegmentCount] > (M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationSegmentCountBySize][iSize] or 0) then
                SearchForBuildableLocationsForLandZone(aiBrain, iPlateauGroup, iLandZone, iSize, tsBlueprintsBySize[iSize])
            end
        end
    end
end


function SearchForBuildableLocationsForLandZone(aiBrain, iPlateauGroup, iLandZone, iSize, sBlueprint, iOptionalMaxSegmentsToConsider)
    --Updates the plateau with a general buildable locations (if there are any) for iLandZone, based on sBlueprint; replaces the value for iSize with -1 if no such locations can be found
    --Will treat locations immediately adjacent to mexes as being unbuildable, to avoid taking up mass storage positions
    --iOptionalMaxSegmentsToConsider - will stop searching if reach this number of segments
    local sGenericBlueprint =  tsBlueprintsBySize[iSize]
    if not(sGenericBlueprint) then
        if sBlueprint then
            sGenericBlueprint = sBlueprint
            tsBlueprintsBySize[iSize] = sBlueprint
        else
            M28Utilities.ErrorHandler('Dont have a blueprint for unit size '..iSize..' and dont have a backup blueprint specified')
            return nil --Long term if come across this want to come up with logic to analyse every blueprint to look for such a unit; however in most cases we should be ok due to above recording if we try to build anything of an unexpected size anyway
        end
    end

    local tCurPosition
    local iLocationsFound = 0
    M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize] = {}
    local iSegmentStart = (M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationSegmentCountBySize][iSize] or 0) + 1
    local iTotalSegments = table.getn(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZSegments])
    if iSegmentStart > iTotalSegments then iSegmentStart = 1 end
    local iSegmentsConsidered = 0
    local tSegmentXZ
    local iMaxSegmentsToConsiderWithMatches = math.max(50, (iOptionalMaxSegmentsToConsider or 0))
    local iMaxSegmentsToConsiderWithoutMatches = math.max(500, (iOptionalMaxSegmentsToConsider or 0))


    --Cycle through every segment in the land zone and see if we can build the desired unit at the segment midpoint
    for iSegmentCount = iSegmentStart, iTotalSegments do
        iSegmentsConsidered = iSegmentsConsidered + 1
        tSegmentXZ = M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZSegments][iSegmentCount]
        tCurPosition = M28Map.GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])
        if CanBuildAtLocation(aiBrain, sGenericBlueprint, tCurPosition, iPlateauGroup, iLandZone, nil, false, false) then
            table.insert(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize], tCurPosition)
            iLocationsFound = iLocationsFound + 1
        end
        if (iOptionalMaxSegmentsToConsider and iSegmentsConsidered >= iOptionalMaxSegmentsToConsider) or (iLocationsFound >= 16 and iSegmentsConsidered >= iMaxSegmentsToConsiderWithMatches) or (iSegmentsConsidered >= iMaxSegmentsToConsiderWithoutMatches and iLocationsFound >= 1) then
            break
        end
    end
    M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationSegmentCountBySize][iSize] = math.min(iTotalSegments, iSegmentStart + iSegmentsConsidered - 1)
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize]) then
        M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize] = -1
    end
end


function GetAvailableLandZoneBuildLocations(aiBrain, tLocation, sBlueprint)
    --Returns locations assigned to the zone for building sBlueprint, if any exist, or returns nil if none exists
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetAvailableLandZoneBuildLocations'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iPlateauGroup, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tLocation)
    if iLandZone > 0 then
        local iSize = M28UnitInfo.GetBuildingSize(sBlueprint)
        --Have we tried to get a location for this size before?
        if bDebugMessages == true then LOG(sFunctionRef..': tLocation='..repru(tLocation)..'; sBlueprint='..sBlueprint..'; iSize='..iSize..'; iPlateauGroup='..iPlateauGroup..'; iLandZone='..iLandZone..'; M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize]='..repru(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize])..'; Segments considered for build locations='..repru(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationSegmentCountBySize])..'; Total segments in LZ='..M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTotalSegmentCount]) end
        if not(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize]) or M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationSegmentCountBySize] < M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTotalSegmentCount] then
            SearchForBuildableLocationsForLandZone(aiBrain, iPlateauGroup, iLandZone, iSize, sBlueprint)
            if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for more buildable locations, result of locations for this size='..repru(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize])..'; Segments considered='..(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationSegmentCountBySize][iSize] or 'nil')) end
        end
        if M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize] == -1 then
            if bDebugMessages == true then LOG(sFunctionRef..': No valid buildable locations for this land zone') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return nil
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Have valid buidlable locations so will return these') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize]
        end
    end
end

function SearchForBuildableLocationsNearDestroyedBuilding(oDestroyedBuilding)
    --Searhces all segments around oDestroyedBuilding in the same land zone, and if we can build in them for a particular size, then records that location as a buildable location for that size for the land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SearchForBuildableLocationsNearDestroyedBuilding'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iPlateauGroup, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oDestroyedBuilding:GetPosition())
    if iLandZone > 0 then
        --Cycle through each size that we ahve considered for this land zone
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize]) == false then
            if M28Utilities.IsTableEmpty(M28Overseer.tAllActiveM28Brains) == false then
                local aiBrain
                for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                    aiBrain = oBrain
                    if not(oBrain.M28IsDefeated) then
                        break
                    end
                end
                local tRelevantSegments
                local tPotentialValidLocationsToBuild
                local iBaseSegmentX, iBaseSegmentZ = M28Map.GetPathingSegmentFromPosition(oDestroyedBuilding:GetPosition())
                local iMaxLandSegmentX, iMaxLandSegmentZ = M28Map.GetPathingSegmentFromPosition({M28Map.rMapPlayableArea[3], 0, M28Map.rMapPlayableArea[4]})
                local iBuildingSize = M28UnitInfo.GetBuildingSize(oDestroyedBuilding.UnitId)
                local iMaxSegmentAdjust
                local iCurSearchCount = 0
                local tCurPosition
                local iTotalWaitCount = 0

                for iSize, tBuildableLocations in M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize] do
                    --Work out the segments of relevance for the building just destroyed that has now freed up some space
                    tRelevantSegments = {}
                    tPotentialValidLocationsToBuild = {}
                    iMaxSegmentAdjust = math.ceil((iBuildingSize + iSize) * 0.5 / M28Map.iLandZoneSegmentSize)
                    for iCurSegmentX = math.max(1, iBaseSegmentX - iMaxSegmentAdjust), math.min(iBaseSegmentX + iMaxSegmentAdjust, iMaxLandSegmentX) do
                        for iCurSegmentZ = math.max(1, iBaseSegmentZ - iMaxSegmentAdjust), math.min(iBaseSegmentZ + iMaxSegmentAdjust, iMaxLandSegmentZ) do
                            --Are we in the same land zone?
                            if M28Map.tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] == iLandZone then
                                tCurPosition = M28Map.GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                                if CanBuildAtLocation(aiBrain, tsBlueprintsBySize[iSize], tCurPosition, iPlateauGroup, iLandZone, nil, false, false) then
                                    table.insert(tPotentialValidLocationsToBuild, tCurPosition)
                                end

                                iCurSearchCount = iCurSearchCount + 1
                                if iCurSearchCount >= 50 then
                                    iCurSearchCount = 0
                                    iTotalWaitCount = iTotalWaitCount + 1
                                    WaitTicks(1)
                                end
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tPotentialValidLocationsToBuild) == false then
                        --Check they are all still valid
                        if iTotalWaitCount > 0 then
                            function StillValid(tArray, iEntry)
                                return aiBrain:CanBuildStructureAt(tsBlueprintsBySize[iSize], tArray[iEntry])
                            end
                            M28Utilities.RemoveEntriesFromArrayBasedOnCondition(tPotentialValidLocationsToBuild, StillValid)
                        end
                        if M28Utilities.IsTableEmpty(tPotentialValidLocationsToBuild) == false then --Incase no longer have any entries as a result of the above
                            local tValidLocations = {}
                            local bInTable
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering what potential locations are valid; iPlateauGroup='..iPlateauGroup..'; iLandZone='..iLandZone..'; tBuildableLocations='..repru(tBuildableLocations)..'; tPotentialValidLocationsToBuild='..repru(tPotentialValidLocationsToBuild)) end
                            if M28Utilities.IsTableEmpty(tBuildableLocations) then
                                tValidLocations = tPotentialValidLocationsToBuild
                                if bDebugMessages == true then LOG(sFunctionRef..': Dont have any buildable locations so valid locations will be all of the potential valid locations to build') end
                            else
                                for iPotentialLocation, tPotentialLocation in tPotentialValidLocationsToBuild do
                                    --Is it in the table already?
                                    bInTable = false

                                    for iExistingLocation, tExistingLocation in tBuildableLocations do
                                        if tExistingLocation[1] == tPotentialLocation[1] and tExistingLocation[3] == tPotentialLocation[3] then
                                            bInTable = true
                                            break
                                        end
                                    end
                                    if not(bInTable) then
                                        table.insert(tValidLocations, tPotentialLocation)
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': tValidLocations after considering whether potential locations are in existing buildabnle locations table='..repru(tValidLocations)) end
                                end
                            end
                            if M28Utilities.IsTableEmpty(tValidLocations) == false then
                                if tBuildableLocations == -1 then
                                    tBuildableLocations = {}
                                end
                                for iNewLocation, tNewLocation in tValidLocations do
                                    table.insert(tBuildableLocations, tNewLocation)
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetPotentialAdjacencyLocations(aiBrain, sBlueprintToBuild, tTargetLocation, iMaxAreaToSearch, iCatToBuildBy, oUnitToBuildBy, bStopWhenHaveValidLocation)
    --Returns a table of all locations that are valid buildable locations for sBlueprintToBuild where it will benefit from an adjacencybonus with iCatToBuildBy or oUnitToBuildBy
    --bStopWhenHaveValidLocation - if we are happy to get the first result then this will abort as soon as a valid location is found
    --Returns {} if no valid locations can be found
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPotentialAdjacencyLocations'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tPotentialLocations = {}
    local toPossibleBuildingsToBuildBy = {}
    local iPlateauGroup, iLandZone --Values are set if we have a cat to build by (but need here as refer to again later on)

    if iCatToBuildBy then
        --sBlueprintBuildBy = M28FactoryOverseer.GetBlueprintsThatCanBuildOfCategory(aiBrain, iCatToBuildBy, oEngineer)--, false, false)
        iPlateauGroup, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
        if bDebugMessages == true then LOG(sFunctionRef..': Have a cat to build by, tTargetLocation='..repru(tTargetLocation)..'; iPlateauGroup='..iPlateauGroup..'; iLandZone='..iLandZone..'; Is table of allied units in this LZ empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZTAlliedUnits]))) end
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZTAlliedUnits]) == false then
            local tRelevantBuildingsInSameLandZone = EntityCategoryFilterDown(iCatToBuildBy, M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZTAlliedUnits])
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of releevant buildings empty='..tostring(M28Utilities.IsTableEmpty(tRelevantBuildingsInSameLandZone))) end
            if M28Utilities.IsTableEmpty(tRelevantBuildingsInSameLandZone) == false then
                for iUnit, oUnit in tRelevantBuildingsInSameLandZone do
                    if oUnit:GetAIBrain() == aiBrain then
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering distance between unit of category wanted for adjacency and target location, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Dist='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation)..'; Position='..repru(oUnit:GetPosition())) end
                        if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation) <= iMaxAreaToSearch then
                            table.insert(toPossibleBuildingsToBuildBy, oUnit)
                        end
                    end
                end
            end
        end
    elseif oUnitToBuildBy and not(oUnitToBuildBy.Dead) then
        --sBlueprintBuildBy = oUnitToBuildBy.UnitId
        toPossibleBuildingsToBuildBy = {oUnitToBuildBy}
    else M28Utilities.ErrorHandler('No adjacency category or unit specified')
    end

    local bAbort = false
    local iNewBuildingRadius = M28UnitInfo.GetBuildingSize(sBlueprintToBuild) * 0.5
    local function AddAdjacencyLocationsToPotentialLocations(tAdjacencyBuildingPosition, iAdjacencyBuildingRadius, iNewBuildingRadius)
        local iCurZ, iCurX
        local iCycleSize = math.abs(iAdjacencyBuildingRadius - iNewBuildingRadius)
        if bDebugMessages == true then LOG(sFunctionRef..': tAdjacencyBuildingPosition='..repru(tAdjacencyBuildingPosition)..'; iAdjacencyBuildingRadius='..iAdjacencyBuildingRadius..'; iNewBuildingRadius='..iNewBuildingRadius..'; iCycleSize='..iCycleSize) end

        --First go along top and bottom:
        for iZFactor = -1, 1, 2 do
            iCurZ = tAdjacencyBuildingPosition[3] + (iAdjacencyBuildingRadius + iNewBuildingRadius) * iZFactor
            for iCurX = tAdjacencyBuildingPosition[1] - iCycleSize, tAdjacencyBuildingPosition[1] + iCycleSize, 1 do
                if CanBuildAtLocation(aiBrain, sBlueprintToBuild, { iCurX, 0, iCurZ}, nil, nil, nil, false, true, false) then
                    table.insert(tPotentialLocations, {iCurX, GetSurfaceHeight(iCurX, iCurZ), iCurZ})
                    if bStopWhenHaveValidLocation then bAbort = true break end
                end
            end
            if bAbort then break end
        end

        --Next go along the sides:
        if not(bAbort) then
            for iXFactor = -1, 1, 2 do
                iCurX = tAdjacencyBuildingPosition[1] + (iAdjacencyBuildingRadius + iNewBuildingRadius) * iXFactor
                for iCurZ = tAdjacencyBuildingPosition[3] - iCycleSize, tAdjacencyBuildingPosition[3] + iCycleSize, 1 do
                    if CanBuildAtLocation(aiBrain, sBlueprintToBuild, { iCurX, 0, iCurZ}, nil, nil, nil, false, true, false) then
                        table.insert(tPotentialLocations, {iCurX, GetSurfaceHeight(iCurX, iCurZ), iCurZ})
                        if bStopWhenHaveValidLocation then bAbort = true break end
                    end
                end
                if bAbort then break end
            end
        end
    end


    if M28Utilities.IsTableEmpty(toPossibleBuildingsToBuildBy) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Have possible buildings to build by, so will consider best location') end
        local iAdjacencyBuildingRadius
        for iBuilding, oBuilding in toPossibleBuildingsToBuildBy do
            iAdjacencyBuildingRadius = M28UnitInfo.GetBuildingSize(oBuilding.UnitId) * 0.5
            AddAdjacencyLocationsToPotentialLocations(oBuilding:GetPosition(), iAdjacencyBuildingRadius, iNewBuildingRadius)
            if bAbort then break end
        end
    else
        --No nearby buildings of the desired kind - if we want to build by a mex or hydro then consider unbuilt resource locations
        local tResourceLocations
        local iAdjacencyBuildingRadius
        if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryMex, iCatToBuildBy, false) then
            tResourceLocations = M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]
            iAdjacencyBuildingRadius = 1
            if bDebugMessages == true then LOG(sFunctionRef..': Want to build by a mex so recording tResourceLocations based on iPlateauGroup='..(iPlateauGroup or 'nil')..' and iLandZone='..(iLandZone or 'nil')) end
        elseif M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryHydro, iCatToBuildBy, false) then
            tResourceLocations = M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroLocations]
            iAdjacencyBuildingRadius = 3
        end
        if tResourceLocations then
            for iCurResource, tCurResource in tResourceLocations do
                AddAdjacencyLocationsToPotentialLocations(tCurResource, iAdjacencyBuildingRadius, iNewBuildingRadius)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tPotentialLocations
end

function GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy, tAlternativePositionToLookFrom, bLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure)
    --Returns blueprint and location for oEngineer to build at and returns these or nil if no suitable locations can be found
    --iCatToBuildBy: Optional, specify if want to look for adjacency locations; Note to factor in 50% of the builder's size and 50% of the likely adjacency building size

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBlueprintAndLocationToBuild'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Engineer UC='..GetEngineerUniqueCount(oEngineer)..'; Engineer LC='..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Techlevel='..M28UnitInfo.GetUnitTechLevel(oEngineer)..'; tAlternativePositionToLookFrom='..repru(tAlternativePositionToLookFrom or {'nil'})..'; bBuildCheapestStructure='..tostring((bBuildCheapestStructure or false))..'; All blueprints that meet the category='..repru(EntityCategoryGetUnitList(iCategoryToBuild))..'; iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')) end

    --Get the blueprint to build
    --GetBlueprintsThatCanBuildOfCategory(aiBrain, iCategoryCondition, oFactory, bGetSlowest, bGetFastest, iOptionalCategoryThatMustBeAbleToBuild, bGetCheapest)
    local sBlueprintToBuild = M28Factory.GetBlueprintsThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oEngineer, false, false, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure)

    if sBlueprintToBuild == nil then
        M28Utilities.ErrorHandler('sBlueprintToBuild is nil, could happen e.g. if try and get sparky to build sxomething it cant - refer to log for more details')
        if not(iCategoryToBuild) then LOG(sFunctionRef..': No category to build. oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer))
        else
            LOG(sFunctionRef..': Had category to build. oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..'; All blueprints that satisfy the category='..repru(EntityCategoryGetUnitList(iCategoryToBuild)))
        end
    else
        --Adjust the search range and record key info needed for the search
        local tEngineerPosition = oEngineer:GetPosition()
        local tTargetLocation = (tAlternativePositionToLookFrom or tEngineerPosition)
        local tPotentialBuildLocations = {}

        --Increase max area to search if dealing with czar or similarly large unit due to its size
        if __blueprints[sBlueprintToBuild].Physics.SkirtSizeX >= 10 then
            iMaxAreaToSearch = iMaxAreaToSearch * 1.5
            if bDebugMessages == true then LOG(sFunctionRef..': Building a large unit such as a czar, increased iMaxAreaToSearch to '..iMaxAreaToSearch) end
        end
        --Reduce max area to search if dealing with a shield
        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
            iMaxAreaToSearch = math.min(iMaxAreaToSearch, (__blueprints[sBlueprintToBuild].Defense.Shield.ShieldSize or 0) * 0.5)
            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with a shield so reduce max area to search based on half of shield size. iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')..'; shield size='..__blueprints[sBlueprintToBuild].Defense.Shield.ShieldSize or 0) end
        end

        if not(tTargetLocation) then tTargetLocation = tEngineerPosition end

        if bDebugMessages == true then LOG(sFunctionRef..': sBlueprintToBuild='..(sBlueprintToBuild or 'nil')..'; Location to look from='..repru(tTargetLocation)) end
        --Mex or hydro - consider the resource locations
        if EntityCategoryContains(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryHydro, sBlueprintToBuild) then
            local iPlateauGroup, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
            local tResourceLocations
            if EntityCategoryContains(M28UnitInfo.refCategoryMex, sBlueprintToBuild) then
                tResourceLocations = M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexUnbuiltLocations]
                if bDebugMessages == true then LOG(sFunctionRef..': Want to build mex so tResourceLocations for Plateau'..iPlateauGroup..' LZ '..iLandZone..'='..repru(tResourceLocations)) end
            else
                tResourceLocations = M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroUnbuiltLocations]
            end
            if tResourceLocations then
                --Cycle through and include any that are buildable
                for iCurResource, tCurResource in tResourceLocations do
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Checking if can build '..sBlueprintToBuild..' on resource location '..repru(tCurResource)..'; result='..tostring(CanBuildAtLocation(aiBrain, sBlueprintToBuild, tCurResource, nil, false, true, false))..'; will draw locations we can build on in blue, and those we cant in red')
                        if CanBuildAtLocation(aiBrain, sBlueprintToBuild, tCurResource, iPlateauGroup, iLandZone, nil, false, true, false) then
                            M28Utilities.DrawLocation(tCurResource, 1)
                        else
                            M28Utilities.DrawLocation(tCurResource, 2)
                        end
                    end
                    if CanBuildAtLocation(aiBrain, sBlueprintToBuild, tCurResource, iPlateauGroup, iLandZone, nil, false, true, false) then
                        table.insert(tPotentialBuildLocations, tCurResource)
                    end
                end
            end
        else
            --Get adjacency location if we want adjacency
            if iCatToBuildBy or oUnitToBuildBy then
                tPotentialBuildLocations = GetPotentialAdjacencyLocations(aiBrain, sBlueprintToBuild, tTargetLocation, iMaxAreaToSearch, iCatToBuildBy, oUnitToBuildBy)
                if bDebugMessages == true then LOG(sFunctionRef..': Finished getting potential adjacency locations, tPotentialBuildLocations='..repru(tPotentialBuildLocations)) end
            end
            if M28Utilities.IsTableEmpty(tPotentialBuildLocations) then
                --use the predefined build locations for the land zoneM28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone]M28Map.subrefLZBuildLocationSegmentCountBySize][iSize]
                local iPlateauGroup, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                local iSize = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
                if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have searched all segments in the land zone before, tLocation='..repru(tTargetLocation)..'; sBlueprintToBuild='..sBlueprintToBuild..'; iSize='..iSize..'; iPlateauGroup='..iPlateauGroup..'; iLandZone='..iLandZone..'; M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize]='..repru(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize])..'; Segments considered for build locations='..repru(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationSegmentCountBySize])..'; Total segments in LZ='..M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTotalSegmentCount]) end
                if (M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationSegmentCountBySize][iSize] or 0) < M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTotalSegmentCount] then
                    GetAvailableLandZoneBuildLocations(aiBrain, tTargetLocation, sBlueprintToBuild)
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for available build locations for the land zone, build locations for size '..iSize..'='..repru(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize])) end
                end
                tPotentialBuildLocations = M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][M28UnitInfo.GetBuildingSize(sBlueprintToBuild)]
                if bDebugMessages == true then LOG(sFunctionRef..': No adjacency locations or not looking for adjacency; tPotentialBuildLocations based on land zone build locations for iSize='..M28UnitInfo.GetBuildingSize(sBlueprintToBuild)..'='..repru(tPotentialBuildLocations)..'; will draw each location in light blue')
                    for iEntry, tEntry in tPotentialBuildLocations do
                        M28Utilities.DrawLocation(tEntry, 5)
                    end
                end
            end
        end

        --Pick the preferred build location
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of potential build locations empty='..tostring(M28Utilities.IsTableEmpty(tPotentialBuildLocations))) end
        if M28Utilities.IsTableEmpty(tPotentialBuildLocations) == false then
            --GetBestBuildLocationForTarget(oEngineer, sBlueprintToBuild, tTargetLocation, tPotentialBuildLocations, iOptionalMaxDistanceFromTargetLocation)
            local tBestLocation = GetBestBuildLocationForTarget(oEngineer, sBlueprintToBuild, tTargetLocation, tPotentialBuildLocations, iMaxAreaToSearch)
            if tBestLocation then return sBlueprintToBuild, tBestLocation end
        end
    end
    return nil, nil
end

function GetBestBuildLocationForTarget(oEngineer, sBlueprintToBuild, tTargetLocation, tPotentialBuildLocations, iOptionalMaxDistanceFromTargetLocation)
    --Assumes we have already checked for: Adjacency; In the same land zone; Valid location to build
    --WIll then consider: If engineer can build without moving; How far away it is from the engineer; if it will block mex adjacency, and (if we specify a maximum distance) if it is within the max distance
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBestBuildLocationForTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iHighestPriority = 0
    local iCurPriority, iCurDistance
    local iBestLocationRef
    local oEngiBP = oEngineer:GetBlueprint()
    local iNewBuildingRadius = M28UnitInfo.GetBuildingSize(sBlueprintToBuild) * 0.5
    local iBuilderRange = (oEngiBP.Economy.MaxBuildDistance or 5) + math.min(oEngiBP.SizeX, oEngiBP.SizeZ) + iNewBuildingRadius - 0.5
    local rBuildAreaRect
    local iMaxRange = iOptionalMaxDistanceFromTargetLocation or 200


    for iCurLocation, tCurLocation in tPotentialBuildLocations do
        iCurPriority = 0
        iCurDistance = M28Utilities.GetDistanceBetweenPositions(tTargetLocation, tCurLocation)
        if iCurDistance <= iMaxRange then
            if iCurDistance <= iBuilderRange then iCurPriority = iCurPriority + 3 end
            rBuildAreaRect = Rect(tCurLocation[1] - iNewBuildingRadius, tCurLocation[3] - iNewBuildingRadius, tCurLocation[1] + iNewBuildingRadius, tCurLocation[3] + iNewBuildingRadius)
            if M28Map.GetReclaimInRectangle(1, rBuildAreaRect) == false then iCurPriority = iCurPriority + 3 end
            if not(M28Conditions.AreMobileLandUnitsInRect(rBuildAreaRect)) then iCurPriority = iCurPriority + 3 end
            if iCurDistance <= 50 then
                if iCurDistance <= 10 then
                    iCurPriority = iCurPriority + 3
                elseif iCurDistance <= 25 then
                    iCurPriority = iCurPriority + 2
                else
                    iCurPriority = iCurPriority + 1
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Considering tCurLocation='..repru(tCurLocation)..'; iCurDistance='..iCurDistance..'; iCurPriority='..iCurPriority) end
        if iCurPriority > iHighestPriority then
            iHighestPriority = iCurPriority
            iBestLocationRef = iCurLocation
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if iBestLocationRef then return tPotentialBuildLocations[iBestLocationRef]
    else return nil
    end
end





function GetLocationToMoveForConstruction(oUnit, tTargetLocation, sBlueprintID, iBuildDistanceMod, bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation)
    --Gets the location that oBuilder should move to in order to be within range of building on tLocation, factoring in the size of buildingType
    --sBlueprintID - if nil, then will treat the action as having a size of 0
    --iBuildDistanceMod - increase or decrease if want to move closer/further away than build distance would send you; e.g. if want to get 3 inside the build distance, set this to -3
    --Returns nil if no valid location or are in range and bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation is not true

    --Note: Will always try to be a minimum of 1 away


    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetLocationToMoveForConstruction'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local sPathing = M28UnitInfo.GetUnitPathingType(oUnit)
    local iPathingGroupWanted = NavUtils.GetLabel(sPathing, oUnit:GetPosition())

    local tPotentialMoveLocation
    local iAngleFromTargetToBuilder = M28Utilities.GetAngleFromAToB(tTargetLocation, oUnit:GetPosition())
    local iBuildRange = oUnit:GetBlueprint().Economy.MaxBuildDistance
    local iDistanceWantedFromTarget = math.max(1, iBuildRange + (iBuildDistanceMod or 0))
    if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; tTargetLocation='..repru(tTargetLocation)..'; sBlueprintID='..(sBlueprintID or 'nil')..'; iBuildDistanceMod='..(iBuildDistanceMod or 'nil')..'bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation='..tostring(bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation or false)) end
    if not(bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation) then
        --Check if we are in range already
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if we are already in range of the target, distance='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation)..'; iDistanceWantedFromTarget='..iDistanceWantedFromTarget) end
        if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation) <= iDistanceWantedFromTarget then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return nil
        end
    end
    if sBlueprintID then iDistanceWantedFromTarget = iDistanceWantedFromTarget + M28UnitInfo.GetBuildingSize(sBlueprintID) * 0.5 end
    for iDistanceToMove = iDistanceWantedFromTarget, 1, -1 do
        tPotentialMoveLocation = M28Utilities.MoveInDirection(tTargetLocation,iAngleFromTargetToBuilder, iDistanceToMove, true, false)
        if NavUtils.GetLabel(sPathing, tPotentialMoveLocation) == iPathingGroupWanted then
            if bDebugMessages == true then LOG(sFunctionRef..': Have a valid location engi can move to='..repru(tPotentialMoveLocation)..'; Dist from target='..M28Utilities.GetDistanceBetweenPositions(tPotentialMoveLocation, tTargetLocation)..'; iDistanceToMove='..(iDistanceToMove or 'nil')) end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return tPotentialMoveLocation
        elseif bDebugMessages == true then LOG(sFunctionRef..': Cant move to the desired location, will draw in red') M28Utilities.DrawLocation(tPotentialMoveLocation, 2)
        end
        if iDistanceToMove <= 1 then
            if bDontReturnNilIfAlreadyInRangeOrNoNearbyLocation then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return {tTargetLocation[1], tTargetLocation[2], tTargetLocation[3]}
            end
            break
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return nil

    --Below was from M27 - left commented out as might be of use when introduce naval factory logic again
    --[[
    tPossibleTarget = GetPositionAtOrNearTargetInPathingGroup(tBuilderLocation, tLocation, iDistanceWantedFromTarget, 0, oBuilder, true, true, iMinDistanceFromCurrentBuilderMoveTarget)

    --Adjust further for naval factory to facilitate greater cliff-building
    if tPossibleTarget and EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, sBlueprintID) then
        --If we move from Possible target towards our currnet position do we come across a cliff very soon?

        local bHaveCliff = false

        local iAngleFromMoveTarget = M28Utilities.GetAngleFromAToB(tPossibleTarget, tBuilderLocation)

        local iMaxCliffSearchRange = 15 + math.floor(iBuildDistance)

        function IsCliffBlockingTarget(tTarget)
            local iDistToMoveTarget = M28Utilities.GetDistanceBetweenPositions(tBuilderLocation, tTarget)
            local tCliffPositionCheck
            if iDistToMoveTarget > 1 then
                for iDistAdjust = 1, math.min(iMaxCliffSearchRange, math.floor(iDistToMoveTarget)) do
                    tCliffPositionCheck = M28Utilities.MoveInDirection(tPossibleTarget, iAngleFromMoveTarget, iDistAdjust, true, false)
                    if not(NavUtils.GetLabel(sPathing, tCliffPositionCheck) == iEngiPathingGroup) then
                        return true
                    end
                end
            end
            return false
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Building naval factory, IsCliffBlockingTarget(tPossibleTarget='..tostring(IsCliffBlockingTarget(tPossibleTarget))..'; tPossibleTarget='..repru(tPossibleTarget)..'; tLocation (of where we want to build)='..repru(tLocation)) end
        if IsCliffBlockingTarget(tPossibleTarget) then
            --Can we get any closer to our build distance if we broaden the angle range?  Also increase the distance slightly
            iDistanceWantedFromTarget = iDistanceWantedFromTarget + 0.1
            local iAngleToEngi = M28Utilities.GetAngleFromAToB(tLocation, tBuilderLocation)
            local tReplacementTarget
            local tPathingPosition
            if bDebugMessages == true then LOG(sFunctionRef..': About to try different positions from tLocation '..repru(tLocation)..' to tBuilderLocation '..repru(tBuilderLocation)..'; Angle to here='..iAngleToEngi..'; iDistanceWantedFromTarget='..iDistanceWantedFromTarget) end
            for iAngleAdjust = 0, 40, 8 do
                for iAngleFactor = -1, 1, 2 do
                    --MoveInDirection(tStart, iAngle, iDistance, bKeepInMapBounds, bTravelUnderwater)
                    tPathingPosition = M28Utilities.MoveInDirection(tLocation, iAngleToEngi + iAngleAdjust * iAngleFactor, iDistanceWantedFromTarget, true, false)
                    if bDebugMessages == true then

                        local iColour = 3
                        if NavUtils.GetLabel(sPathing, tPathingPosition) == iEngiPathingGroup and not(IsCliffBlockingTarget(tPathingPosition)) then iColour = 7 end
                        LOG(sFunctionRef..': Considering tPathingPosition='..repru(tPathingPosition)..'; iAngleAdjust='..iAngleAdjust * iAngleFactor..'; Pathing group='..NavUtils.GetLabel(sPathing, tPathingPosition)..'; Engi pathing group='..iEngiPathingGroup..'; Is cliff blocking target='..tostring(IsCliffBlockingTarget(tPathingPosition))..'; will draw match in white, nonmatch in black. iColour='..iColour..'; Dist from original move target planned='..M28Utilities.GetDistanceBetweenPositions(tPathingPosition, tPossibleTarget))
                        M28Utilities.DrawLocation(tPathingPosition, false, iColour, 200)
                    end
                    if NavUtils.GetLabel(sPathing, tPathingPosition) == iEngiPathingGroup and not(IsCliffBlockingTarget(tPathingPosition)) then
                        tReplacementTarget = tPathingPosition
                    end

                    if iAngleAdjust == 0 or tReplacementTarget then break end
                end
                if tReplacementTarget then break end
            end
            if tReplacementTarget then
                if bDebugMessages == true then LOG(sFunctionRef..': Have a replacement position to use') end
                tPossibleTarget = {tReplacementTarget[1], tReplacementTarget[2], tReplacementTarget[3]}

            end
        end
    end
   --]]
end

function BuildStructureNearLocation(aiBrain, oEngineer, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy, tAlternativePositionToLookFrom, bLookForPartCompleteBuildings, bLookForQueuedBuildings, oUnitToBuildBy, bNeverBuildRandom, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, iOptionalEngiActionRef)
    --Determines the blueprint and location for oEngineer to build at; also returns the location
    --iCatToBuildBy: Optional, specify if want to look for adjacency locations; Note to factor in 50% of the builder's size and 50% of the likely adjacency building size
    --bLookForQueuedBuildings: Optional, if true, then doesnt choose a target if another engineer already has that target function ref assigned to build something
    --Returns nil if dealing with a non-resource based building

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'BuildStructureNearLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Engineer UC='..GetEngineerUniqueCount(oEngineer)..'; Engineer LC='..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Techlevel='..M28UnitInfo.GetUnitTechLevel(oEngineer)..'; tAlternativePositionToLookFrom='..repru(tAlternativePositionToLookFrom or {'nil'})..'; bBuildCheapestStructure='..tostring((bBuildCheapestStructure or false))..'; bNeverBuildRandom='..tostring((bNeverBuildRandom or false))..'; All blueprints that meet the category='..repru(EntityCategoryGetUnitList(iCategoryToBuild))..'; iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')) end


    local bAbortConstruction = false

    --Get the blueprint to build
    --GetBlueprintsThatCanBuildOfCategory(aiBrain, iCategoryCondition, oFactory, bGetSlowest, bGetFastest, iOptionalCategoryThatMustBeAbleToBuild, bGetCheapest)
    local sBlueprintToBuild = M28Factory.GetBlueprintsThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oEngineer, false, false, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure)
    local tTargetLocation
    if sBlueprintToBuild == nil then
        M28Utilities.ErrorHandler('sBlueprintToBuild is nil, could happen e.g. if try and get sparky to build sxomething it cant - refer to log for more details')
        if not(iCategoryToBuild) then LOG(sFunctionRef..': No category to build. oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer))
        else
            LOG(sFunctionRef..': Had category to build. oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..'; All blueprints that satisfy the category='..repru(EntityCategoryGetUnitList(iCategoryToBuild)))
        end
    else

        --Adjust the search range and record key info needed for the search
        local tEngineerPosition = oEngineer:GetPosition()
        tTargetLocation = (tAlternativePositionToLookFrom or tEngineerPosition)
        --Increase max area to search if dealing with czar or similarly large unit due to its size
        if __blueprints[sBlueprintToBuild].Physics.SkirtSizeX >= 10 then
            iMaxAreaToSearch = iMaxAreaToSearch * 1.5
            if bDebugMessages == true then LOG(sFunctionRef..': Building a large unit such as a czar, increased iMaxAreaToSearch to '..iMaxAreaToSearch) end
        end

        --Reduce max area to search if dealing with a shield
        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
            iMaxAreaToSearch = math.min(iMaxAreaToSearch, (__blueprints[sBlueprintToBuild].Defense.Shield.ShieldSize or 0) * 0.5)
            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with a shield so reduce max area to search based on half of shield size. iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')..'; shield size='..__blueprints[sBlueprintToBuild].Defense.Shield.ShieldSize or 0) end
        end


        if bDebugMessages == true then LOG(sFunctionRef..': sBlueprintToBuild='..(sBlueprintToBuild or 'nil')..'; Location to look from='..repru(tAlternativePositionToLookFrom or oEngineer:GetPosition())) end
        local sBlueprintBuildBy
        local bFindRandomLocation = false

        if not(tTargetLocation) then tTargetLocation = tEngineerPosition end
        local bFoundEnemyInstead = false

        local sPathing = M28UnitInfo.GetUnitPathingType(oEngineer)
        local iNewBuildingRadius = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)[1] * 0.5
        local iBuilderRange = oEngineer:GetBlueprint().Economy.MaxBuildDistance + math.min(oEngineer:GetBlueprint().SizeX, oEngineer:GetBlueprint().SizeZ)*0.5
        local iDistanceFromStart = M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), M28Map.PlayerStartPoints[aiBrain.M28StartPositionNumber])
        local bBuildNearToEnemy = false
        if iDistanceFromStart <= 80 then bBuildNearToEnemy = true end

        --Check we're not trying to buidl a mex or hydro or mass storage or mass fab
        local bMexHydroOrStorage = false
        if EntityCategoryContains(refCategoryMex, sBlueprintToBuild) or EntityCategoryContains(refCategoryHydro, sBlueprintToBuild) or EntityCategoryContains(M28UnitInfo.refCategoryMassStorage + M28UnitInfo.refCategoryMassFab, sBlueprintToBuild)  then
            bMexHydroOrStorage = true
        end


        --If specified, first check if there's an existing part complete building we can help complete instead of starting a new building
        --Check if is an existing building of the type wanted first:
        local oPartCompleteBuilding
        if bLookForPartCompleteBuildings then
            --GetPartCompleteBuilding(aiBrain, oBuilder, iCategoryToBuild, iBuildingSearchRange, iEnemySearchRange)
            --Returns nil if no nearby part complete building
            --iEnemySearchRange: nil if dont care about nearby enemies, otherwise will ignore buildings that have enemies within iEnemySearchRange
            oPartCompleteBuilding = GetPartCompleteBuilding(aiBrain, oEngineer, iCategoryToBuild, iBuilderRange + 15, nil)
        end
        if oPartCompleteBuilding then
            if bDebugMessages == true then LOG(sFunctionRef..': have partcompletebuilding so returning that as the position') end
            tTargetLocation = oPartCompleteBuilding:GetPosition()
        else
            if bDebugMessages == true then
                local sEngUniqueRef = GetEngineerUniqueCount(oEngineer)
                LOG(sFunctionRef..': Eng builder unique ref='..sEngUniqueRef..'; builder range='..iBuilderRange)
            end



            if not(bMexHydroOrStorage) then
                --For non-extraction buildings, if we have specified we want to build adjacent to something then look for nearby buildings that can give us the adjacency wanted
                if iCatToBuildBy or oUnitToBuildBy then
                    local toPossibleBuildingsToBuildBy
                    local iBuildingCount = 0
                    local tPossibleTargets = {}
                    local tBuildingPosition

                    if iCatToBuildBy then
                        --sBlueprintBuildBy = M28FactoryOverseer.GetBlueprintsThatCanBuildOfCategory(aiBrain, iCatToBuildBy, oEngineer)--, false, false)

                        toPossibleBuildingsToBuildBy = aiBrain:GetUnitsAroundPoint(iCatToBuildBy, tTargetLocation, iMaxAreaToSearch, 'Ally')
                        local iCurDist
                        local iClosestDist = 100000
                        --ACU specific - cant build by hydro, but might have nearby hydro
                        if bDebugMessages == true then LOG(sFunctionRef..': Engineer position='..repru(oEngineer:GetPosition())..'; tTargetLocation='..repru(tTargetLocation)..'; iMaxAreaToSearch='..iMaxAreaToSearch..'; is toPossibleBuildingsToBuildBy empty='..tostring(M28Utilities.IsTableEmpty(toPossibleBuildingsToBuildBy))) end
                        if M28Utilities.IsTableEmpty(toPossibleBuildingsToBuildBy) == false then
                            --Try to build by the closest unit of the category wanted
                            local oClosestBuilding
                            for iUnit, oUnit in  toPossibleBuildingsToBuildBy do
                                if oUnit:GetAIBrain() == aiBrain then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEngineer:GetPosition())
                                    if iCurDist < iClosestDist then
                                        oClosestBuilding = oUnit
                                        iClosestDist = iCurDist
                                    end
                                end
                            end
                            if oClosestBuilding then
                                sBlueprintBuildBy = oClosestBuilding.UnitId
                                if bDebugMessages == true then LOG(sFunctionRef..': Will update sBlueprintBuildBy to be the closest building for adjacency='..oClosestBuilding.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestBuilding)) end
                            end
                        end


                    elseif oUnitToBuildBy then
                        sBlueprintBuildBy = oUnitToBuildBy.UnitId
                        toPossibleBuildingsToBuildBy = {oUnitToBuildBy}
                    else M28Utilities.ErrorHandler('Missing code')
                    end


                    if M28Utilities.IsTableEmpty(toPossibleBuildingsToBuildBy) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have possible buildings to build by, so will consider best location') end
                        for iBuilding, oBuilding in toPossibleBuildingsToBuildBy do
                            if not(oBuilding.Dead) and oBuilding.GetPosition and oBuilding:GetAIBrain() == aiBrain then
                                tBuildingPosition = oBuilding:GetPosition()
                                if M28Utilities.GetDistanceBetweenPositions(tBuildingPosition, tTargetLocation) <= iMaxAreaToSearch then
                                    iBuildingCount = iBuildingCount + 1
                                    tPossibleTargets[iBuildingCount] = tBuildingPosition
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Found iBuildingCount='..iBuildingCount..' to build by') end
                        if iBuildingCount == 0 then bFindRandomLocation = not(bNeverBuildRandom) end
                    else
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Cant find any buildings for adjacency, getting random location to build unless we want to build by a mex/hydro and have an unbuilt one nearby')
                            local tNearestBuildingOfCategory = aiBrain:GetUnitsAroundPoint(iCatToBuildBy, tTargetLocation, 10000, 'Ally')
                            if M28Utilities.IsTableEmpty(tNearestBuildingOfCategory) then LOG(sFunctionRef..': Dont have any units of the desired category anywhere on map')
                            else
                                local oNearestBuildingOfCategory = M28Utilities.GetNearestUnit(tNearestBuildingOfCategory, oEngineer:GetPosition(), aiBrain)
                                LOG(sFunctionRef..': Nearest unit of desired category is '..oNearestBuildingOfCategory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestBuildingOfCategory)..' which is '..M28Utilities.GetDistanceBetweenPositions(oNearestBuildingOfCategory:GetPosition(), oEngineer:GetPosition())..' away from the engineer')
                            end
                        end
                        bFindRandomLocation = not(bNeverBuildRandom)
                    end

                    --Also check for unbuilt buildings if dealing with a mex or hydro, unless are building a shield
                    local tResourceLocations
                    if not(EntityCategoryContains(categories.SHIELD, sBlueprintToBuild)) then
                        --land factory - say that we're looking for a mex even if cant find one
                        if bDebugMessages == true then LOG(sFunctionRef..': About to check if building early fac and cant find mex/hydro. Does cat to build by contain mex or hydro='..tostring(M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryHydro + M28UnitInfo.refCategoryMex, iCatToBuildBy, false))..'; sBlueprintBuildBy='..(sBlueprintBuildBy or 'nil')..'; Does engi contain tech1 or ACU='..tostring(EntityCategoryContains(categories.TECH1 + categories.COMMAND, oEngineer.UnitId))..'; Does blueprint to build contain factory='..tostring(EntityCategoryContains(categories.FACTORY, sBlueprintToBuild))) end
                        if iCatToBuildBy and not(sBlueprintBuildBy) and EntityCategoryContains(categories.TECH1 + categories.COMMAND, oEngineer.UnitId) and EntityCategoryContains(categories.FACTORY, sBlueprintToBuild) then
                            if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryMex, iCatToBuildBy, false) then
                                sBlueprintBuildBy = 'ueb1103'
                            elseif M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryHydro, iCatToBuildBy, false) then
                                sBlueprintBuildBy = 'ueb1102'
                            end
                        end
                        if sBlueprintBuildBy then
                            if EntityCategoryContains(M28UnitInfo.refCategoryMex, sBlueprintBuildBy) then
                                local iPlateauGroup, iZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                                tResourceLocations = M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iZone][M28Map.subrefLZMexLocations]
                                if bDebugMessages == true then LOG(sFunctionRef..': Will add any mexes within 20 of target location to be considered') end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryHydro, sBlueprintBuildBy) or EntityCategoryContains(M28UnitInfo.refCategoryT2Power, sBlueprintBuildBy) then --Dont want to make this all power, because the adjacency code requires a building size, and only works for a single building size; i.e. if try and get adjacency for t1 power and include hydro locations, then it will think it needs to build within the hydro for adjacency
                                local iPlateauGroup, iZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                                tResourceLocations = M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iZone][M28Map.subrefLZHydroLocations]
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tResourceLocations) == false then
                        for iResource, tCurResourceLocation in tResourceLocations do
                            iBuildingCount = iBuildingCount + 1
                            tPossibleTargets[iBuildingCount] = tCurResourceLocation
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and build by resource location (mex or hydro); iBuildingCount including these locations='..iBuildingCount..'; table of building locations='..repru(tPossibleTargets)) end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of resource locations empty='..tostring(M28Utilities.IsTableEmpty(tResourceLocations))..'; iBuildingCount='..iBuildingCount) end
                    if iBuildingCount > 0 then
                        --GetBestBuildLocationForTarget(tablePosTarget, sTargetBuildingBPID, sNewBuildingBPID, bCheckValid, aiBrain, bReturnOnlyBestMatch, pBuilderPos, iMaxAreaToSearch, iBuilderRange, bIgnoreOutsideBuildArea, bBetterIfNoReclaim, bPreferCloseToEnemy, bPreferFarFromEnemy, bLookForQueuedBuildings)
                        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will try and build the shield anywhere near the target. iOptionalEngiActionRef='..(iOptionalEngiActionRef or 'nil')) end
                            local bBuildAwayFromEnemy = false
                            if iOptionalEngiActionRef == refActionFortifyFirebase then bBuildAwayFromEnemy = true end
                            tTargetLocation = GetBuildLocationForShield(aiBrain, sBlueprintToBuild, tAlternativePositionToLookFrom, bBuildAwayFromEnemy)
                            if not(tTargetLocation) then bAbortConstruction = true end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': About to call GetBestBuildLocation; iBuildingCount='..iBuildingCount..'; sBlueprintBuildBy='..(sBlueprintBuildBy or 'nil')) end
                            --Go through all possible adjacent build locations identified, and choose the best one
                            tTargetLocation = GetBestBuildLocationForTarget(tPossibleTargets, sBlueprintBuildBy, sBlueprintToBuild, true, aiBrain, true, tTargetLocation, iMaxAreaToSearch, iBuilderRange, false, true, bBuildNearToEnemy, not(bBuildNearToEnemy), bLookForQueuedBuildings)
                            --Double-check the resulting location is valid
                            if M28Utilities.IsTableEmpty(tTargetLocation) == true then
                                if bDebugMessages == true then LOG('Adjacency location is empty, will try finding anywhere to build') end
                                bFindRandomLocation = not(bNeverBuildRandom)
                            else
                                bFindRandomLocation = false
                                if bDebugMessages == true then LOG(sFunctionRef..': Have determined the best build location for target to be '..repru(tTargetLocation)..'; will double-check we can build here') end
                                if not(CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, nil, nil, nil, false, bLookForQueuedBuildings)) then
                                    --if aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation) == false or not(M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M28Utilities.ConvertLocationToReference(tTargetLocation)])) then
                                    M28Utilities.ErrorHandler('Cant build '..sBlueprintToBuild..' on adjacency location tTargetLocation='..repru({tTargetLocation[1], tTargetLocation[2],tTargetLocation[3]}))
                                    bFindRandomLocation = not(bNeverBuildRandom)
                                else
                                    --Check we're within mapBoundary
                                    if bDebugMessages == true then LOG(sFunctionRef..': Cant build at the location; Checking if tTargetLocation '..repru(tTargetLocation)..' is in the playable area '..repru(M28Map.rMapPlayableArea)..' based on building size radius='..iNewBuildingRadius) end
                                    if (tTargetLocation[1] - iNewBuildingRadius) < M28Map.rMapPlayableArea[1] or (tTargetLocation[3] - iNewBuildingRadius) < M28Map.rMapPlayableArea[2] or (tTargetLocation[1] + iNewBuildingRadius) > M28Map.rMapPlayableArea[3] or (tTargetLocation[3] + iNewBuildingRadius) > M28Map.rMapPlayableArea[4] then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Target location isnt in playable area so will find random place to build instead') end
                                        bFindRandomLocation = not(bNeverBuildRandom)
                                        tTargetLocation = tEngineerPosition
                                    end
                                    if bDebugMessages == true then M28Utilities.DrawLocation(tTargetLocation) end
                                end
                            end
                        end
                    else
                        bFindRandomLocation = not(bNeverBuildRandom)
                        if bDebugMessages == true then LOG(sFunctionRef..': Cant find any valid buildings for adjacency') end
                    end
                else
                    --If no was adjacency wanted, then either build at the target location, or find a random location to build (subject to some unit specific points)
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have a category to build by, will look for random location unless current target is valid or we are a shield') end
                    if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
                        local bBuildAwayFromEnemy = false
                        if iOptionalEngiActionRef == refActionFortifyFirebase then bBuildAwayFromEnemy = true end
                        tTargetLocation = GetBuildLocationForShield(aiBrain, sBlueprintToBuild, tAlternativePositionToLookFrom, bBuildAwayFromEnemy)
                        if tTargetLocation then bFindRandomLocation = false else bFindRandomLocation = not(bNeverBuildRandom) end
                    else
                        bFindRandomLocation = not(bNeverBuildRandom)
                    end
                end
            else
                --Dealing with mex or hydro or storage
                if bDebugMessages == true then LOG(sFunctionRef..': Are trying to build a mex, hydro or storage; tTargetLocation='..repru((tTargetLocation or {}))..'; oEngineer='..GetEngineerUniqueCount(oEngineer)..'; LC='..M28UnitInfo.GetUnitLifetimeCount(oEngineer)) end
                if M28Utilities.IsTableEmpty(tTargetLocation) == true then
                    M28Utilities.ErrorHandler('Trying to build mex, hydro or storage without defined location')
                else
                    if aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation) then --and M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M28Utilities.ConvertLocationToReference(tTargetLocation)]) then
                        --Not interested in if other units have queued up, as e.g. might be ACU that can build and is much closer, so just want whichever unit is closest to try and build
                        if bDebugMessages == true then LOG(sFunctionRef..': Can build structure at targetlocation='..repru(tTargetLocation)..'; if are buildling a t1 mex and there is a t3 mex queued up then will ignore though') end
                        --Are we trying to build a T1 mex? If so then only consider if have an order to build T3 mex
                        if EntityCategoryContains(refCategoryT1Mex, sBlueprintToBuild) then
                            local sLocationRef = M28Utilities.ConvertLocationToReference(tTargetLocation)
                            if aiBrain[reftEngineerAssignmentsByLocation][sLocationRef] and M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][sLocationRef][refActionBuildT3MexOverT2]) == false then
                                bAbortConstruction = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Trying to build t1 mex when want to build t3 here') end
                            end
                        end
                    else
                        --Cant build at location, is that because of enemy building blocking it, or we have a part-built building?
                        if bDebugMessages == true then LOG(sFunctionRef..': Are trying to build a mex or hydro or mass storage so cant get a random location, but we cant build a structure at the target') end
                        local tEnemyBuildingAtTarget = aiBrain:GetUnitsAroundPoint(iCategoryToBuild, tTargetLocation, 1, 'Enemy')
                        if M28Utilities.IsTableEmpty(tEnemyBuildingAtTarget) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have enemy buildings around target') end
                            M28PlatoonUtilities.MoveNearConstruction(aiBrain, oEngineer, tTargetLocation, sBlueprintToBuild, 0, false, false, false)
                            for iUnit, oUnit in tEnemyBuildingAtTarget do
                                if oUnit.GetPosition then
                                    IssueReclaim({oEngineer}, oUnit)
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy building is at the target mex/hydro so will try and reclaim that first') end

                            IssueBuildMobile({oEngineer}, tTargetLocation, sBlueprintToBuild, {})
                            if bDebugMessages == true then LOG(sFunctionRef..': 1 - Have sent issuebuildmobile order to engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..' to build blueprint '..sBlueprintToBuild..' at location '..repru(tTargetLocation)) end
                            bAbortConstruction = true
                            bFoundEnemyInstead = true

                        else
                            local tAllyBuildingAtTarget = aiBrain:GetUnitsAroundPoint(iCategoryToBuild, tTargetLocation, 1, 'Ally')
                            if M28Utilities.IsTableEmpty(tAllyBuildingAtTarget) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will target the ally building as its part complete') end
                                oPartCompleteBuilding = tAllyBuildingAtTarget[1]
                            else
                                --Are we stopped from building due to reclaim?

                                local tNewBuildingSize = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
                                local fSizeMod = 0.5

                                local rTargetRect = M28Utilities.GetRectAroundLocation(tTargetLocation, tNewBuildingSize[1] * fSizeMod)
                                if bDebugMessages == true then LOG(sFunctionRef..': tTargetLocation='..repru(tTargetLocation)..'; tNewBuildingSize='..repru(tNewBuildingSize)..'; rTargetRect='..repru(rTargetRect)) end
                                --GetReclaimInRectangle(iReturnType, rRectangleToSearch)
                                --iReturnType: 1 = true/false; 2 = number of wrecks; 3 = total mass, 4 = valid wrecks
                                local tReclaimables = M28Map.GetReclaimInRectangle(4, rTargetRect)

                                if M28Utilities.IsTableEmpty(tReclaimables) == false then
                                    for iReclaim, oReclaim in tReclaimables do
                                        --oEngineer:IssueReclaim(oReclaim)
                                        IssueReclaim({oEngineer}, oReclaim)
                                    end
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef..': Reclaim found that is blocking mex or hydro so will reclaim all wrecks in rectangle='..repru(rTargetRect))
                                        M28Utilities.DrawRectangle(rTargetRect, 7, 100)
                                    end

                                    IssueBuildMobile({oEngineer}, tTargetLocation, sBlueprintToBuild, {})
                                    if bDebugMessages == true then LOG(sFunctionRef..': 2 - Have sent issuebuildmobile order to engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..' to build blueprint '..sBlueprintToBuild..' at location '..repru(tTargetLocation)) end

                                else
                                    --Are we trying to build a T3 mex? If so then we probably are trying to replace a T2 mex which  can lead to problems with the canbuild check
                                    if iCategoryToBuild == M28UnitInfo.refCategoryT3Mex then
                                        IssueBuildMobile({oEngineer}, tTargetLocation, sBlueprintToBuild, {})
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef..': Not sure we can build here but will try anyway')
                                            LOG(sFunctionRef..': 3 - Have sent issuebuildmobile order to engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..' to build blueprint '..sBlueprintToBuild..' at location '..repru(tTargetLocation))
                                        end
                                    else
                                        --One likely explanation is that enemy has built on the mex and we cant see the building, in which case we only want to check this for debugging purposes, and proceed with the default action of having hte engineer try to move there
                                        local tUnits = GetUnitsInRect(rTargetRect)
                                        if M28Utilities.IsTableEmpty(tUnits) == true then
                                            M28Utilities.ErrorHandler(sFunctionRef..': Cant build at resource location but no units or reclaim on it, will just try moving near the target instead. sBlueprintToBuild='..sBlueprintToBuild..'; Engineer UC='..GetEngineerUniqueCount(oEngineer)..'; LC='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Location='..repru({tTargetLocation[1], tTargetLocation[2],tTargetLocation[3]})..'; Will draw white circle around the target if in debug mode. CanBuildStructure result='..tostring(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation))..'; Is the table of assigned engineer actions empty='..tostring(M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M28Utilities.ConvertLocationToReference(tTargetLocation)])), true)
                                            if bDebugMessages == true then
                                                M28Utilities.DrawLocation(tTargetLocation, nil, 7)
                                                LOG(sFunctionRef..': Cnat build at TargetLocation='..repru(tTargetLocation)..'; RectangleSearched='..repru(rTargetRect))
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will just move to the target location') end
                                        M28PlatoonUtilities.MoveNearConstruction(aiBrain, oEngineer, tTargetLocation, sBlueprintToBuild, 0, false, false, false)
                                        bAbortConstruction = true
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        --Switch to random location if an amphibious unit cant path there and its not a resource based location
        if not(bFindRandomLocation) and not(bAbortConstruction) then -- and not(bMexHydroOrStorage) then
            if not(NavUtils.GetLabel(sPathing, tTargetLocation) == NavUtils.GetLabel(sPathing, oEngineer:GetPosition())) then
                bFindRandomLocation = not(bNeverBuildRandom)
            end
        end

        if bFindRandomLocation and (bMexHydroOrStorage or EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild)) and not(bAbortConstruction) and not(iOptionalEngiActionRef == refActionFortifyFirebase) then
            --Backup - Trying to build a mex or hydro so no point getting random location
            if not(EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild)) then
                M28Utilities.ErrorHandler('Are trying to build in a random place for am ex/hydro/mass storage - figure out why as this shouldnt trigger; Engineer with UC='..GetEngineerUniqueCount(oEngineer)..'='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; trying to build blueprint='..sBlueprintToBuild)
                if bDebugMessages == true then LOG(sFunctionRef..': Trying to build mex or hydro so cant choose a random location') end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Trying to build a shield but couldnt find anywhere to build it so no point building it in the end. iOptionalEngiActionRef='..(iOptionalEngiActionRef or 'nil')) end
            end
            bFindRandomLocation = false
            bAbortConstruction = true
        end

        --Look for a random location if we failed to find a suitable location in the above steps
        if bFindRandomLocation == true and not(bAbortConstruction) then
            if bDebugMessages == true then LOG(sFunctionRef..': Are finding a random location to build unless current location is valid; sBlueprintToBuild='..sBlueprintToBuild..'; iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')) end
            if M28Utilities.IsTableEmpty(tTargetLocation) == true then tTargetLocation = (tAlternativePositionToLookFrom or tEngineerPosition) end

            --First check in build area for the best location assuming the target location isnt far away
            if M28Utilities.GetDistanceBetweenPositions(tTargetLocation, tEngineerPosition) <= 30 then tTargetLocation = GetBestBuildLocationForTarget(tTargetLocation, nil, sBlueprintToBuild, true, aiBrain, true, tTargetLocation, iMaxAreaToSearch, iBuilderRange, false, true, bBuildNearToEnemy, not(bBuildNearToEnemy), false) end
            if M28Utilities.IsTableEmpty(tTargetLocation) == true or not(CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, nil, nil, nil, false, bLookForQueuedBuildings)) then
                --if M28Utilities.IsTableEmpty(tTargetLocation) == true or not(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation)) or not(M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M28Utilities.ConvertLocationToReference(tTargetLocation)])) then
                if M28Utilities.IsTableEmpty(tTargetLocation) then tTargetLocation = (tAlternativePositionToLookFrom or tEngineerPosition) end
                if bDebugMessages == true then
                    LOG(sFunctionRef..' Cant build '..sBlueprintToBuild..'; will try and find a random place to build; target location for random place to build='..repru(tTargetLocation))
                    if iCategoryToBuild == nil then LOG(sFunctionRef..' iCategoryToBuild is nil somehow') end
                end
                --FindRandomPlaceToBuild(aiBrain, oBuilder, tStartPosition, sBlueprintToBuild, iSearchSizeMin, iSearchSizeMax, bForcedDebug)
                local bSuitableForLastSuccessfulLocation = EntityCategoryContains(M28UnitInfo.refCategoryStructure + categories.EXPERIMENTAL - M28UnitInfo.refCategorySatellite - M28UnitInfo.refCategoryFirebaseSuitable, sBlueprintToBuild) and M28Utilities.IsTableEmpty(aiBrain[reftLastSuccessfulLargeBuildingLocation]) == false
                local iSearchCycles = nil
                if bSuitableForLastSuccessfulLocation then iSearchCycles = 3 end
                tTargetLocation = FindRandomPlaceToBuild(aiBrain, oEngineer, (tTargetLocation or tAlternativePositionToLookFrom or tEngineerPosition), sBlueprintToBuild, 2, iMaxAreaToSearch, bDebugMessages, iSearchCycles)
                if M28Utilities.IsTableEmpty(tTargetLocation) == true then
                    --Try searching the last location we built at successfully for a couple of cycles if arent building a firebase unit
                    if bSuitableForLastSuccessfulLocation then
                        tTargetLocation = FindRandomPlaceToBuild(aiBrain, oEngineer, aiBrain[reftLastSuccessfulLargeBuildingLocation], sBlueprintToBuild, 2, iMaxAreaToSearch, false, math.min(3, (iSearchCycles or 3)))
                    end
                    if M28Utilities.IsTableEmpty(tTargetLocation) then
                        LOG(sFunctionRef..': WARNING - couldnt find a random place to build based on position='..repru(tTargetLocation)..'; will abort construction')
                        bAbortConstruction = true
                    end
                elseif bDebugMessages == true then LOG(sFunctionRef..': Found random place to build='..repru(tTargetLocation))
                end
            else if bDebugMessages == true then LOG(sFunctionRef..': No need for random place as current targetlocation is valid, ='..repru(tTargetLocation)) end
            end
        end
        --Only proceed with sending a build order (or repair order for a part complete building) if we had success in the earlier steps
        if bAbortConstruction == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Not aborting function so will try to move near construction if we have a valid location') end
            if M28Utilities.IsTableEmpty(tTargetLocation) == false and sBlueprintToBuild then
                --Adjust Target location if building PD
                if EntityCategoryContains(M28UnitInfo.refCategoryPD, sBlueprintToBuild) then
                    tTargetLocation = AdjustPDBuildLocation(aiBrain, tTargetLocation, sBlueprintToBuild)
                end
                --MoveNearConstruction(aiBrain, oBuilder, tLocation, sBlueprintID, iBuildDistanceMod, bReturnMovePathInstead, bUpdatePlatoonMovePath, bReturnNilIfAlreadyMovingNearConstruction, bReturnMoveLocationifGivenOne)
                local tMoveNearTargetLocation = M28PlatoonUtilities.MoveNearConstruction(aiBrain, oEngineer, tTargetLocation, sBlueprintToBuild, 0, false, false, false, true)
                if oPartCompleteBuilding then
                    if bDebugMessages == true then LOG(sFunctionRef..': Send order for oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to repair '..oPartCompleteBuilding.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPartCompleteBuilding)..' at '..repru(oPartCompleteBuilding:GetPosition())) end
                    IssueRepair({ oEngineer}, oPartCompleteBuilding)
                else
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Send order for oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to build '..sBlueprintToBuild..' at '..repru(tTargetLocation)..'; will draw target location in gold')
                        M28Utilities.DrawLocation(tTargetLocation, nil, 4, 500)
                    end

                    --MAIN ISSUEBUILDMOBILE FOR CONSTRUCTION (i.e. other issuebuilds here are for specific actions)
                    IssueBuildMobile({oEngineer}, tTargetLocation, sBlueprintToBuild, {})
                    if bDebugMessages == true then LOG(sFunctionRef..': 4 - Have sent issuebuildmobile order to engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..' to build blueprint '..sBlueprintToBuild..' at location '..repru(tTargetLocation)..' with surface height='..GetSurfaceHeight(tTargetLocation[1], tTargetLocation[3])..'; tMoveNearTargetLocation='..repru(tMoveNearTargetLocation)) end
                end
                if M28Utilities.IsTableEmpty(tMoveNearTargetLocation) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': About to start thread checking for when the engineer is in build range') end
                    ForkThread(TrackWhenEngineerInBuildRange, oEngineer, tMoveNearTargetLocation, (sBlueprintToBuild or oPartCompleteBuilding.UnitId), tTargetLocation, oPartCompleteBuilding)
                    if sBlueprintToBuild and not(oPartCompleteBuilding) then
                        ForkThread(CheckIfEngineerLikelyStuck, oEngineer, sBlueprintToBuild, tTargetLocation)
                    end

                end
            end
        else
            if bDebugMessages == true then LOG('Warning - couldnt find any places to build after looking randomly nearby, will abort construction. bFoundEnemyInstead='..tostring(bFoundEnemyInstead)) end
            if bDebugMessages == true then
                LOG(sFunctionRef..': Aborted construction, will draw target location in red')
                M28Utilities.DrawLocation(tTargetLocation, nil, 2, 100)
            end
            if not(bMexHydroOrStorage) then tTargetLocation = nil end
        end
    end
    if bDebugMessages == true then
        if sBlueprintToBuild == nil then LOG('sBlueprintToBuild is nil')
        else
            if tTargetLocation then
                LOG(sFunctionRef..': tTargetLocation='..repru(tTargetLocation)..'; aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation)='..tostring(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation))..'; sBlueprintToBuild='..(sBlueprintToBuild or 'nil'))
                if not(bAbortConstruction) then M28Utilities.DrawLocation(tTargetLocation, nil, 7, 100) end --show in white (colour 7)
                LOG(sFunctionRef..': About to list any units in 1x1 rectangle around targetlocation')
                local iSizeAdj = 3
                local rBuildAreaRect = Rect(tTargetLocation[1] - iSizeAdj, tTargetLocation[3] - iSizeAdj, tTargetLocation[1] + iSizeAdj, tTargetLocation[3] + iSizeAdj)
                local tUnitsInRect = GetUnitsInRect(rBuildAreaRect)
                local tsUnitRefs = {}
                if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
                    for iUnit, oUnit in tUnitsInRect do
                        table.insert(tsUnitRefs, iUnit, oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
                    end
                end
                LOG('tsUnitRefs='..repru(tsUnitRefs))
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tTargetLocation
end

function GetPartCompleteBuilding(aiBrain, oBuilder, iCategoryToBuild, iBuildingSearchRange)
    --Returns nil if no nearby part complete building
    --iEnemySearchRange: nil if dont care about nearby enemies, otherwise will ignore buildings that have enemies within iEnemySearchRange
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPartCompleteBuilding'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tBuilderPosition = oBuilder:GetPosition()
    local tAllBuildings = aiBrain:GetUnitsAroundPoint(iCategoryToBuild, tBuilderPosition, iBuildingSearchRange, 'Ally')
    local iCurDistanceToBuilder
    local iMinDistanceToBuilder = 10000
    local tBuildingPosition
    local oNearestPartCompleteBuilding
    if M28Utilities.IsTableEmpty(tAllBuildings) == false then
        for iBuilding, oBuilding in tAllBuildings do
            if oBuilding.GetFractionComplete and oBuilding.GetPosition and oBuilding:GetFractionComplete() < 1 then
                local tNearbyEnemies
                tBuildingPosition = oBuilding:GetPosition()
                iCurDistanceToBuilder = M28Utilities.GetDistanceBetweenPositions(tBuildingPosition, tBuilderPosition)
                if iCurDistanceToBuilder < iMinDistanceToBuilder then
                    iMinDistanceToBuilder = iCurDistanceToBuilder
                    oNearestPartCompleteBuilding = oBuilding
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oNearestPartCompleteBuilding
end

function SlowlyRefreshBuildableLandZoneLocations(oOrigBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SlowlyRefreshBuildableLandZoneLocations'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    bBuildLocationLoopActive = true
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iSearchesConsideredThisTick
    local iTicksWaitedThisCycle
    local iSegmentsBeforeWaiting = 16 --Must be a multiple of 2, i.e. 2^x results in this
    local aiBrain = oOrigBrain

    --First update every start position that has an M28 brain to make sure we have a decent number of options recorded for a land factory and smaller
    for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
        if bDebugMessages == true then LOG(sFunctionRef..': About to start recording buildable locations for the starting land zone for oBrain='..oBrain.Nickname..'; Index='..oBrain:GetArmyIndex()..'; Start pos='..repru(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])) end
        local iPlateauGroup, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
        local tiRelevantSizes = {1,2,6,8}
        for iRef, iSize in tiRelevantSizes do
            SearchForBuildableLocationsForLandZone(aiBrain, iPlateauGroup, iLandZone, iSize, tsBlueprintsBySize[iSize], iSegmentsBeforeWaiting * 10)
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    while true do
        --Get a new brain if needed
        if aiBrain.M28IsDefeated then
            aiBrain = nil
            for iBrain, oBrain in ArmyBrains do
                if oBrain.M28AI and not(oBrain.M28IsDefeated) then
                    aiBrain = oBrain
                    break
                end
            end
            if not(aiBrain) then
                break
            end
        end

        iTicksWaitedThisCycle = 0
        iSearchesConsideredThisTick = 0

        --Cycle through every plateau
        for iPlateauGroup, tPlateauSubtable in M28Map.tAllPlateaus do
            for iLandZone, tLandZoneInfo in tPlateauSubtable[M28Map.subrefPlateauLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Updating for iPlateauGroup='..iPlateauGroup..'; iLandZone='..iLandZone) end
                if tLandZoneInfo[M28Map.subrefLZBuildLocationsBySize] then
                    for iSize, tBuildLocations in tLandZoneInfo[M28Map.subrefLZBuildLocationsBySize] do
                        if tBuildLocations == -1 then
                            SearchForBuildableLocationsForLandZone(aiBrain, iPlateauGroup, iLandZone, iSize, tsBlueprintsBySize[iSize], iSegmentsBeforeWaiting)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitTicks(1)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                            iSearchesConsideredThisTick = 0
                            iTicksWaitedThisCycle = iTicksWaitedThisCycle + 1
                            while (tBuildLocations == -1 and tPlateauSubtable[M28Map.subrefLZBuildLocationSegmentCountBySize][iSize] < tLandZoneInfo[M28Map.subrefLZTotalSegmentCount]) do
                                SearchForBuildableLocationsForLandZone(aiBrain, iPlateauGroup, iLandZone, iSize, tsBlueprintsBySize[iSize], iSegmentsBeforeWaiting)
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                WaitTicks(1)
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                                iSearchesConsideredThisTick = 0
                                if iTicksWaitedThisCycle >= 10000 then
                                    M28Utilities.ErrorHandler('Potential infinite loop error as have waited 10k ticks, will abort current loop')
                                    break
                                end
                            end
                        end
                        if iSearchesConsideredThisTick > 0 then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitTicks(1)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                            iTicksWaitedThisCycle = iTicksWaitedThisCycle + 1
                            iSearchesConsideredThisTick = 0
                        end
                    end
                end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                iTicksWaitedThisCycle = iTicksWaitedThisCycle + 1
            end
        end
        if iTicksWaitedThisCycle < 1000 then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1000 - iTicksWaitedThisCycle)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            iSegmentsBeforeWaiting = math.max(2, iSegmentsBeforeWaiting * 0.5)
        elseif iTicksWaitedThisCycle >= 3000 then
            iSegmentsBeforeWaiting = math.min(64, iSegmentsBeforeWaiting * 2)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function FilterToAvailableEngineersByTech(tEngineers)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'FilterToAvailableEngineersByTech'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Returns a table of available engineers by tech
    local toAvailableEngineersByTech = {[1]= { },[2]={},[3]={}}
    local toAssignedEngineers = {}
    local bHaveAvailableEngi = false
    local iCurTechLevel
    if tEngineers then
        for iEngineer, oEngineer in tEngineers do
            if M28Conditions.IsEngineerAvailable(oEngineer) then
                table.insert(toAvailableEngineersByTech[M28UnitInfo.GetUnitTechLevel(oEngineer)], oEngineer)
                if bDebugMessages == true then LOG(sFunctionRef..': Just added engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to toAvailableEngineersByTech, Eng tech level='..M28UnitInfo.GetUnitTechLevel(oEngineer)..'; Size of table='..table.getn(toAvailableEngineersByTech[M28UnitInfo.GetUnitTechLevel(oEngineer)])) end
                bHaveAvailableEngi = true
            elseif oEngineer[refiAssignedAction] then
                table.insert(toAssignedEngineers, oEngineer)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bHaveAvailableEngi then return toAvailableEngineersByTech, toAssignedEngineers
    else return nil, toAssignedEngineers
    end
end

function GetCategoryToBuildOrAssistFromAction(iActionToAssign, iMinTechLevel, aiBrain)
    --Returns the building category type based on the action; iMinTechLevel is optional; aiBrain is required if dealing with construction of experimental
    local iCategoryToBuild = tiActionCategory[iActionToAssign]
    if not(iCategoryToBuild) and not(tbActionsThatDontHaveCategory[iActionToAssign]) then
        if iActionToAssign == refActionBuildEmergencyPD then
            if aiBrain[M28Overseer.refbCloseToUnitCap] then iCategoryToBuild = M28UnitInfo.refCategoryT2PlusPD
            else
                if aiBrain[M28Economy.refiGrossMassBaseIncome] >= 4 or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPD * categories.TECH1) > 0 then
                    --Want to build either T2 or T2+ PD
                    local iT2PD = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPD * categories.TECH2)
                    if iT2PD <= 5 or aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryPD * categories.TECH3) >= iT2PD then
                        iCategoryToBuild = M28UnitInfo.refCategoryPD - categories.TECH3
                    else
                        iCategoryToBuild = M28UnitInfo.refCategoryT2PlusPD
                    end
                else
                    iCategoryToBuild = M28UnitInfo.refCategoryPD * categories.TECH1
                end
            end
        elseif iActionToAssign == refActionFortifyFirebase then
            M28Utilities.ErrorHandler('Firebase logic not in place')
            --Calculate closest firebase and assume we are trying to build this
            if aiBrain[refiFirebaseBeingFortified] then
                iCategoryToBuild = aiBrain[refiFirebaseCategoryWanted][aiBrain[refiFirebaseBeingFortified]]
                if M28Utilities.IsTableEmpty(iCategoryToBuild, false) then M28Utilities.ErrorHandler('Dont have a category to build for firebase ref '..(aiBrain[refiFirebaseBeingFortified] or 'nil')..'; will just build T2 plus PD')
                    iCategoryToBuild = M28UnitInfo.refCategoryT2PlusPD
                end
            else
                M28Utilities.ErrorHandler('Dont have a firebase to be fortified so will just build T2 plus PD')
                iCategoryToBuild = M28UnitInfo.refCategoryT2PlusPD
            end
        elseif iActionToAssign == refActionBuildExperimental or iActionToAssign == refActionBuildSecondExperimental then
            iCategoryToBuild = DecideOnExperimentalToBuild(iActionToAssign, aiBrain)
        elseif iActionToAssign == refActionBuildShield or iActionToAssign == refActionBuildSecondShield then
            --NOTE: Separately this gets changed to tech3 if need increased range
            if aiBrain[M28Overseer.refbDefendAgainstArti] or aiBrain[M28Overseer.refbCloseToUnitCap] then
                iCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.TECH3
            else
                iCategoryToBuild = M28UnitInfo.refCategoryFixedShield * categories.TECH2
            end
        else
            M28Utilities.ErrorHandler('Need to add code for action='..(iActionToAssign or 'nil'))
        end
    end
    if iCategoryToBuild then
        if iMinTechLevel > 1 then
            if iMinTechLevel == 3 then iCategoryToBuild = iCategoryToBuild * categories.TECH3 + iCategoryToBuild*categories.EXPERIMENTAL
            else iCategoryToBuild = iCategoryToBuild - categories.TECH1
            end
        end
    end
    return iCategoryToBuild
end

function GetEngineersOfTechWanted(iMinTechLevelWanted, toAvailableEngineersByTech)
    local tEngineersOfTechWanted
    if iMinTechLevelWanted == 3 then
        tEngineersOfTechWanted = toAvailableEngineersByTech[3]
    else
        tEngineersOfTechWanted = {}
        if iMinTechLevelWanted == 2 then
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[2]) == false then
                for iEngi, oEngi in toAvailableEngineersByTech[2] do
                    table.insert(tEngineersOfTechWanted, oEngi)
                end
            end
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[3]) == false then
                for iEngi, oEngi in toAvailableEngineersByTech[3] do
                    table.insert(tEngineersOfTechWanted, oEngi)
                end
            end
        else
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[1]) == false then
                for iEngi, oEngi in toAvailableEngineersByTech[1] do
                    table.insert(tEngineersOfTechWanted, oEngi)
                end
            end
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[2]) == false then
                for iEngi, oEngi in toAvailableEngineersByTech[2] do
                    table.insert(tEngineersOfTechWanted, oEngi)
                end
            end
            if M28Utilities.IsTableEmpty(toAvailableEngineersByTech[3]) == false then
                for iEngi, oEngi in toAvailableEngineersByTech[3] do
                    table.insert(tEngineersOfTechWanted, oEngi)
                end
            end
        end
    end
    return tEngineersOfTechWanted
end

function GetPartCompleteBuildingInZone(iTeam, iPlateau, iLandZone, iCategoryWanted)
    local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
        local tBuildingsOfCategory = EntityCategoryFilterDown(iCategoryWanted, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        if M28Utilities.IsTableEmpty(tBuildingsOfCategory) == false then
            for iUnit, oUnit in tBuildingsOfCategory do
                if oUnit:GetFractionComplete() < 1 then
                    return oUnit
                end
            end
        end
    end
    return nil
end

function ClearEngineerTracking(oEngineer)
    oEngineer[refiAssignedAction] = nil
end

function TrackEngineerAction(oEngineer, iActionToAssign)
    oEngineer[refiAssignedAction] = iActionToAssign
end

function ConsiderActionToAssign(iActionToAssign, iMinTechWanted, iTotalBuildPowerWanted, iCurPriority, iTeam, iPlateau, iLandZone, toAvailableEngineersByTech, toAssignedEngineers)
    local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderActionToAssign'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Reduce the build power wanted by the existing build power assigned to that action for the LZ
    if M28Utilities.IsTableEmpty(toAssignedEngineers) == false then
        for iEngi, oEngi in toAssignedEngineers do
            if oEngi[refiAssignedAction] == iActionToAssign and M28UnitInfo.GetUnitTechLevel(oEngi) >= iMinTechWanted then
                iTotalBuildPowerWanted = iTotalBuildPowerWanted - oEngi:GetBlueprint().Economy.BuildRate
            end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': iActionToAssign='..iActionToAssign..'; iTeam='..iTeam..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Have just updated BP wanted for existing engineers with the same action, iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; Is toAvailableEngineersByTech empty='..tostring(M28Utilities.IsTableEmpty(toAvailableEngineersByTech))) end

    --Do we have an engineer of the tech level wanted? First assign any available engineers of the right tech level to the action
    if toAvailableEngineersByTech then
        local tEngineersOfTechWanted = GetEngineersOfTechWanted(iMinTechWanted, toAvailableEngineersByTech)
        if bDebugMessages == true then LOG(sFunctionRef..': Is tEngineersOfTechWanted empty='..tostring(M28Utilities.IsTableEmpty(tEngineersOfTechWanted))) end
        if M28Utilities.IsTableEmpty(tEngineersOfTechWanted) == false then
            local iEngiCount = table.getn(tEngineersOfTechWanted)
            local iCurEngiTechLevel
            local iCurEngiBuildPower
            local aiBrain = tEngineersOfTechWanted[1]:GetAIBrain()
            local iCategoryWanted = GetCategoryToBuildOrAssistFromAction(iActionToAssign, iMinTechWanted, aiBrain)

            function UpdateBPTracking()
                iCurEngiTechLevel = M28UnitInfo.GetUnitTechLevel(tEngineersOfTechWanted[iEngiCount])
                iCurEngiBuildPower = tEngineersOfTechWanted[iEngiCount]:GetBlueprint().Economy.BuildRate
                iTotalBuildPowerWanted = iTotalBuildPowerWanted - iCurEngiBuildPower
                for iEngi, oEngi in toAvailableEngineersByTech[iCurEngiTechLevel] do
                    if oEngi == tEngineersOfTechWanted[iEngiCount] then
                        table.insert(toAssignedEngineers, tEngineersOfTechWanted[iEngiCount])
                        table.remove(toAvailableEngineersByTech[iCurEngiTechLevel], iEngi)
                        break
                    end
                end

                tEngineersOfTechWanted[iEngiCount] = nil
                iEngiCount = iEngiCount - 1

            end

            if bDebugMessages == true then LOG(sFunctionRef..': iActionToAssign='..iActionToAssign..'; iEngiCount='..iEngiCount..'; Is category watned nil='..tostring(iCategoryWanted == nil)) end


            if iCategoryWanted then
                --Do we have a part complete unit of this category already under construction in this land zone?
                local oBuildingToAssist
                if not(iActionToAssign == refActionBuildMex) then oBuildingToAssist = GetPartCompleteBuildingInZone(iTeam, iPlateau, iLandZone, iCategoryWanted) end

                if oBuildingToAssist then
                    --Assist the building under construction that has the category we want
                    while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                        if bDebugMessages == true then LOG(sFunctionRef..': Assigning engineer for repair action '..iActionToAssign..'; iEngiCount='..iEngiCount..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted) end
                        M28Orders.IssueTrackedRepair(tEngineersOfTechWanted[iEngiCount], oBuildingToAssist, false)
                        TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign)
                        UpdateBPTracking()
                    end
                else
                    --Dont have any buildings of the type wanted under construction; do we have an engineer already assigned to build the category we want? If so then assist it
                    local oEngineerToAssist
                    if M28Utilities.IsTableEmpty(toAssignedEngineers) == false then

                        for iEngi, oEngi in toAssignedEngineers do
                            if oEngi[refiAssignedAction] == iActionToAssign then
                                --Only assist if engi last order was to build
                                if oEngi[M28Orders.reftiLastOrders] and oEngi[M28Orders.reftiLastOrders][table.getn(oEngi[M28Orders.reftiLastOrders])][M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild then
                                    oEngineerToAssist = oEngi
                                    break
                                end
                            end
                        end
                    end
                    if oEngineerToAssist and not(iActionToAssign == refActionBuildMex) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will assign engineers to build, iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; iEngiCount='..iEngiCount) end
                        while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                            if bDebugMessages == true then LOG(sFunctionRef..': Assigning engineer for assist engineer action '..iActionToAssign..'; iEngiCount='..iEngiCount..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted) end
                            M28Orders.IssueTrackedGuard(tEngineersOfTechWanted[iEngiCount], oEngineerToAssist, false)
                            TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign)
                            UpdateBPTracking()
                        end
                    else
                        --No building under construciton, and no existing engineer to assist - assign engineers to build instead
                        local oFirstEngineer = tEngineersOfTechWanted[iEngiCount]
                        if bDebugMessages == true then LOG(sFunctionRef..': Will get blueprint and location to build for oFirstEngineer='..oFirstEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFirstEngineer)..'; iActionTOAssign='..iActionToAssign) end
                        local sBlueprint, tBuildLocation = GetBlueprintAndLocationToBuild(aiBrain, oFirstEngineer, iCategoryWanted, 60, tiActionAdjacentCategory[iActionToAssign], nil, false, nil, nil, false)
                        if sBlueprint then
                            local tMoveLocation
                            while iTotalBuildPowerWanted > 0 and iEngiCount > 0 do
                                if bDebugMessages == true then LOG(sFunctionRef..': Assigning engineer for building action '..iActionToAssign..'; iEngiCount='..iEngiCount..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; tiActionOrder[iActionToAssign]='..(tiActionOrder[iActionToAssign] or 'nil')..'; sBlueprint='..sBlueprint..'; tBuildLocation='..repru(tBuildLocation)..'; Eng cur state='..M28UnitInfo.GetUnitState(tEngineersOfTechWanted[iEngiCount])) end
                                --Is our order to build or assist?
                                if tiActionOrder[iActionToAssign] then
                                    if tiActionOrder[iActionToAssign] == M28Orders.refiOrderIssueBuild then
                                        tMoveLocation = GetLocationToMoveForConstruction(tEngineersOfTechWanted[iEngiCount], tBuildLocation, sBlueprint, 0, false)
                                        if tMoveLocation then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Telling engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to move to '..repru(tMoveLocation)..' and then build '..sBlueprint..' and '..repru(tBuildLocation)) end
                                            M28Orders.IssueTrackedMoveAndBuild(tEngineersOfTechWanted[iEngiCount], tBuildLocation, sBlueprint, tMoveLocation, 1, false)
                                        else
                                            if bDebugMesages == true then LOG(sFunctionRef..': Telling engineer '..tEngineersOfTechWanted[iEngiCount].UnitId..M28UnitInfo.GetUnitLifetimeCount(tEngineersOfTechWanted[iEngiCount])..' to build '..sBlueprint..' at '..repru(tBuildLocation)) end
                                            M28Orders.IssueTrackedBuild(tEngineersOfTechWanted[iEngiCount], tBuildLocation, sBlueprint, false)
                                        end
                                        TrackEngineerAction(tEngineersOfTechWanted[iEngiCount], iActionToAssign)
                                        UpdateBPTracking()
                                    else
                                        M28Utilities.ErrorHandler('Need to add code for actions that dont involve building, ActionToAssign='..iActionToAssign..'; order ref='..(tiActionOrder[iActionToAssign] or 'nil'))
                                    end
                                else
                                    M28Utilities.ErrorHandler('Missing action order type for iActionToAssign '..iActionToAssign)
                                end
                            end
                        end
                    end
                end
            else --Dont have a category to search for
                M28Utilities.ErrorHandler('Need to add logic for where we dont have category to search for (to build or assist)')
            end

        end
    end

    --If we still have build power we want to assign, record in the land zone
    local tLZBuildPowerByTechWanted = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTBuildPowerByTechWanted]
    if bDebugMessages == true then LOG(sFunctionRef..': About to update BP wanted for iPlateau'..iPlateau..'; iLandZone='..iLandZone..'; iTeam='..iTeam..'; iTotalBuildPowerWanted='..iTotalBuildPowerWanted..'; tLZBuildPowerByTechWanted before update='..repru(tLZBuildPowerByTechWanted)) end
    if iTotalBuildPowerWanted > 0 then tLZBuildPowerByTechWanted[iMinTechWanted] = tLZBuildPowerByTechWanted[iMinTechWanted] + iTotalBuildPowerWanted end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderCoreBaseLandZoneEngineerAssignment(iTeam, iPlateau, iLandZone, tEngineers)
    local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderCoreBaseLandZoneEngineerAssignment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --For land zones in the core base
    local toAvailableEngineersByTech, toAssignedEngineers = FilterToAvailableEngineersByTech(tEngineers)
    M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTBuildPowerByTechWanted] = {[1]=0,[2]=0,[3]=0}
    if bDebugMessages == true then LOG(sFunctionRef..': Have just reset BPByTech to 0 for Plateau'..iPlateau..'; LZ='..iLandZone..'; repru='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTBuildPowerByTechWanted])) end
    --local iCurCondition = 0
    local iCurPriority = 0

    function HaveActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted)
        --Done as subfunction for convenience so can just note the key values for the action in question and add on the others that wont change
        --ConsiderActionToAssign(iActionToAssign, iMinTechWanted, iTotalBuildPowerWanted, iTeam, iPlateau, iLandZone, toAvailableEngineersByTech, toAssignedEngineers)
        ConsiderActionToAssign(iActionToAssign, iMinTechLevelWanted, iBuildPowerWanted, iCurPriority, iTeam, iPlateau, iLandZone, toAvailableEngineersByTech, toAssignedEngineers)
    end

    if bDebugMessages == true then LOG(sFunctionRef..': About to consider what actions we want to give engineers for iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iTeam='..iTeam) end

    --Start of game or low power - build hydro if one nearby, otherwise build pgen
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroUnbuiltLocations]) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..':  Will try and build a hydro') end
        HaveActionToAssign(refActionBuildHydro, 1, 5)
    elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < 0 then
        if bDebugMessages == true then LOG(sFunctionRef..': iCurPriority='..iCurPriority..': Will try and build PGens') end
        HaveActionToAssign(refActionBuildPower, 1, 5)
    end
    --Unclaimed mex in the zone
    iCurPriority = iCurPriority + 1
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexUnbuiltLocations]) == false then
        HaveActionToAssign(refActionBuildMex, 1, math.max(5, table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexUnbuiltLocations]) * 2.5))
    end

    iCurPriority = iCurPriority + 1 --do this after each action
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderLandZoneEngineerAssignment(iTeam, iPlateau, iLandZone, tEngineers)
    --tEngineers might be empty if e.g. we just want to record how much build power the land zone wants

    if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTCoreBase] then
        ConsiderCoreBaseLandZoneEngineerAssignment(iTeam, iPlateau, iLandZone, tEngineers)
    else
        --Not dealing with a core base
        M28Utilities.ErrorHandler('To add code for engineers not in core base')
    end

end

function EngineerInitialisation(aiBrain)
    --Variable declaration
    aiBrain[refiEngineerCurUniqueReference] = 0

    if not(bBuildLocationLoopActive) then
        ForkThread(SlowlyRefreshBuildableLandZoneLocations, aiBrain)
    end
end

