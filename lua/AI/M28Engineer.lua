---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 19:23
---
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local NavUtils = import("/lua/sim/navutils.lua")


--Global variables
bBuildLocationLoopActive = false --true if have a loop that is checking for build locations
tsBlueprintsBySize = {[1] = 'ueb2101', [2] = 'ueb1101', [6] = 'ueb1201', [8] = 'ueb1301', [9]='xrl0403', [10]='uab0304', [16] = 'xsa0402', [24] = 'uaa0310'} --Blueprints to use when trying to find locations that can buid on for a building of a particular size
tAllScathis = {} --If a scathis is constructed it gets recorded here (and we then check this for build locations to avoid trying to build on a scathis); for performance reasons will just use a single global table

--against brain:
--refiEngineerCurUniqueReference - this is also against unit so is declared in below section rather than here

--Against unit varaibles
refiEngineerCurUniqueReference = 'M28EngineerCurUniqueReference' --Against both aiBrain and engineer; aiBrain stores the xth engineer object its given an action to, so this can be used as a unique reference


--Actions for engineers (dont have as local variables due to cap on how many local variables we can have)
refActionBuildMex = 1
refActionBuildHydro = 2
refActionReclaimArea = 3
refActionBuildPower = 4
refActionBuildLandFactory = 5
refActionBuildEnergyStorage = 6
refActionSpare = 7
refActionHasNearbyEnemies = 8
refActionUpgradeBuilding = 9
refActionBuildSecondPower = 10
refActionBuildAirStaging = 11
refActionBuildAirFactory = 12
refActionBuildSMD = 13
refActionBuildMassStorage = 14
refActionBuildT1Radar = 15
refActionBuildT2Radar = 16
refActionBuildT3Radar = 17
refActionAssistSMD = 18
refActionAssistAirFactory = 19
refActionBuildThirdPower = 20
refActionBuildExperimental = 21
refActionReclaimUnit = 22
refActionBuildT3MexOverT2 = 23
refActionUpgradeHQ = 24 --Assists an HQ with its upgrade
refActionReclaimTrees = 25
refActionBuildT1Sonar = 26
refActionBuildT2Sonar = 27
refActionAssistNuke = 28
refActionBuildShield = 29
refActionBuildT3ArtiPower = 30
refActionBuildTMD = 31
refActionBuildAA = 32
refActionBuildEmergencyPD = 33
refActionBuildSecondLandFactory = 34
refActionBuildSecondAirFactory = 35
refActionBuildTML = 36
refActionBuildSecondExperimental = 37
refActionLoadOnTransport = 38
refActionFortifyFirebase = 39
refActionAssistShield = 40
refActionBuildSecondShield = 41
refActionBuildEmergencyArti = 42
refActionAssistTML = 43
refActionBuildQuantumGateway = 44
refActionBuildQuantumOptics = 45
refActionBuildHive = 46
refActionSelenMexBuild = 47
refActionBuildSecondTMD = 48
refActionBuildNavalFactory = 49
refActionAssistNavalFactory = 50
refActionNavalSpareAction = 51
refActionBuildWall = 52
refActionBuildT3MexOnly = 53
refActionAssistMexUpgrade = 54
refActionSAMCreep = 55 --Intended to gradually expand SAM coverage for mexes
refActionBuildMassFab = 56
tiEngiActionsThatDontBuild = {refActionReclaimArea, refActionSpare, refActionNavalSpareAction, refActionHasNearbyEnemies, refActionReclaimUnit, refActionReclaimTrees, refActionUpgradeBuilding, refActionAssistSMD, refActionAssistTML, refActionAssistMexUpgrade, refActionAssistAirFactory, refActionAssistNavalFactory, refActionUpgradeHQ, refActionAssistNuke, refActionLoadOnTransport, refActionAssistShield}

function GetEngineerUniqueCount(oEngineer)
    local iUniqueRef = oEngineer[refiEngineerCurUniqueReference]
    if iUniqueRef == nil then
        local aiBrain = oEngineer:GetAIBrain()
        iUniqueRef = aiBrain[refiEngineerCurUniqueReference] + 1
        aiBrain[refiEngineerCurUniqueReference] = iUniqueRef
        oEngineer[refiEngineerCurUniqueReference] = iUniqueRef
    end
    return iUniqueRef
end

function CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, iEngiActionToIgnore, bClearActionsIfNotStartedBuilding, bCheckForQueuedBuildings, bCheckForOverlappingBuildings)
    --iEngiActionToIgnore, bClearActionsIfNotStartedBuilding and bCheckForOverlappingBuildings are optional
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CanBuildAtLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --if EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, sBlueprintToBuild) then bDebugMessages = true end

    if bDebugMessages == true then LOG(sFunctionRef..': About to see if we can build '..sBlueprintToBuild..' at '..repru(tTargetLocation)..'; iEngiActionToIgnore='..(iEngiActionToIgnore or 'nil')..'; bClearActionsIfNotStartedBuilding='..tostring((bClearActionsIfNotStartedBuilding or false))..'; surface height at target='..GetSurfaceHeight(tTargetLocation[1], tTargetLocation[3])) end

    local bCanBuildStructure = false
    if aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation) == true then
        bCanBuildStructure = true
        if bCheckForQueuedBuildings == true then
            M28Utilities.ErrorHandler('Need to add code - have commented out old M27 code for now - change so it will consider any queued buildings by land zone locations rather than checking every single location')
            --Check if any engi actions queued up that would stop this
            --[[local iBuildingRadius = math.max(__blueprints[sBlueprintToBuild].Physics.SkirtSizeX * 0.5 - 1,0)  --E.g. if building a t1 power, it has a size of 2, and radius of 1; when it's queued, the location and blocks within 1 of it will all be marked as being built on (i.e. a 3x3 area).  Hence, if considering building another power, if we dont reduce the search range by 1, it will lead to spacing things out more than needed
            local sLocationRef
            local tLocationToCheck
            local bIgnoreAction
            if bDebugMessages == true then LOG(sFunctionRef..': Can build structure at the location, checking if we already have building queued up for this location. iBuildingRadius='..iBuildingRadius) end
            --tiEngiActionsThatDontBuild
            for iAdjustX = -iBuildingRadius, iBuildingRadius, 1 do
                for iAdjustZ = -iBuildingRadius, iBuildingRadius, 1 do
                    tLocationToCheck = {tTargetLocation[1] + iAdjustX, 0, tTargetLocation[3] + iAdjustZ}
                    tLocationToCheck[2] = GetSurfaceHeight(tLocationToCheck[1], tLocationToCheck[3])
                    sLocationRef = M28Utilities.ConvertLocationToStringRef(tLocationToCheck)
                    if bDebugMessages == true then LOG(sFunctionRef..': iAdjustX='..iAdjustX..'; iAdjustZ='..iAdjustZ..'; sLocationRef='..sLocationRef..'; Is table empty for this='..tostring(M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][sLocationRef]))) end
                    if M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][sLocationRef]) == false then
                        for iActionRef, tSubtable in aiBrain[reftEngineerAssignmentsByLocation][sLocationRef] do
                            bIgnoreAction = false
                            for _, iActionToIgnore in tiEngiActionsThatDontBuild do
                                if iActionRef == iActionToIgnore then
                                    bIgnoreAction = true
                                    break
                                end
                            end
                            if iEngiActionToIgnore and iActionRef == iEngiActionToIgnore then bIgnoreAction = true end
                            if bDebugMessages == true then LOG(sFunctionRef..': iActionRef='..iActionRef..'; bIgnoreAction='..tostring(bIgnoreAction)) end                            if not(bIgnoreAction) then
                            bCanBuildStructure = false
                            --Do we want to cancel any blocking units?
                            if bClearActionsIfNotStartedBuilding then
                                for iUniqueEngiRef, oEngineer in tSubtable do
                                    if bDebugMessages == true then LOG(sFunctionRef..': About to clear oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' which was recorded as having iActionRef='..iActionRef) end
                                    M28Orders.IssueTrackedClearCommands({oEngineer})
                                    ClearEngineerActionTrackers(aiBrain, oEngineer, true)
                                end
                                bCanBuildStructure = M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][sLocationRef][iActionRef])
                                if bDebugMessages == true then LOG(sFunctionRef..': Have just cleared any blocking units; bCanBuildStructure='..tostring(bCanBuildStructure)) end
                            end
                            if not(bCanBuildStructure) then break end
                        end
                        end
                    end
                    if not(bCanBuildStructure) then break end
                end
                if not(bCanBuildStructure) then break end
            end--]]
        end
        if bCanBuildStructure then
            local iSkirtSizeRadius = __blueprints[sBlueprintToBuild].Physics.SkirtSizeX * 0.5

            --Check in case scathis is blocking us
            if M28Utilities.IsTableEmpty(tAllScathis) == false then
                for iUnit, oUnit in tAllScathis do
                    if M28Utilities.GetDistanceBetweenPositions(tTargetLocation, oUnit:GetPosition()) < (iSkirtSizeRadius + oUnit:GetBlueprint().Physics.SkirtSizeX * 0.5) then
                        bCanBuildStructure = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Are too close to a scathis so wont build here') end
                        break
                    end
                end
            end

            if bCanBuildStructure and bCheckForOverlappingBuildings then

                --Thanks to jip for flagging there's an engine bug where in rare situations units can be built slightly overlapping even if aiBrain:CanBuildStructureAt returns true - comments in the code Jip linked to suggested this is only where a building has upgraded
                -- compute build locations and issue the capping

                -- find all units that may prevent us from building
                local tNearbyStructures = GetUnitsInRect(tTargetLocation[1] - (iSkirtSizeRadius + 4), tTargetLocation[3] - (iSkirtSizeRadius + 4), tTargetLocation[1] + (iSkirtSizeRadius + 4), tTargetLocation[3] + (iSkirtSizeRadius + 4))
                if M28Utilities.IsTableEmpty(tNearbyStructures) == false then
                    tNearbyStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryUpgraded, tNearbyStructures)
                    local iClosestDistance
                    if M28Utilities.IsTableEmpty(tNearbyStructures) == false then
                        for iStructure, oStructure in tNearbyStructures do
                            if not(oStructure.Dead) then
                                if bDebugMessages == true then LOG(sFunctionRef..': oStructure='..oStructure.UnitId..M28UnitInfo.GetUnitLifetimeCount(oStructure)..'; position='..repru(oStructure:GetPosition())..'; target location='..repru(tTargetLocation)..'; target building ID='..sBlueprintToBuild..'; 50% of target building skirt size='..iSkirtSizeRadius..'; 50% of oStructure skrit size='..oStructure:GetBlueprint().Physics.SkirtSizeX * 0.5) end
                                iClosestDistance = math.max(math.abs(oStructure:GetPosition()[1] - tTargetLocation[1]), math.abs(oStructure:GetPosition()[3] - tTargetLocation[3]))
                                if iClosestDistance < (iSkirtSizeRadius + oStructure:GetBlueprint().Physics.SkirtSizeX * 0.5) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Cant build as iClosestDistance='..iClosestDistance..'which is less than the two skirt sizes') end
                                    bCanBuildStructure = false
                                    break
                                end
                            end
                        end
                    end
                end
            end
            if not(bCanBuildStructure) and bDebugMessages == true then LOG(sFunctionRef..': Skirt size is overlaping with a building that could have upgraded so will return false') end
        end
    elseif bDebugMessages == true then LOG(sFunctionRef..': Cant build structure at the location')
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bCanBuildStructure='..tostring(bCanBuildStructure)) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bCanBuildStructure
end

function CheckIfBuildableLocationsNearPositionStillValid(aiBrain, tLocation)
    local iPlateauGroup, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tLocation)
    if iLandZone > 0 then
        local sGenericBlueprint
        if M28Utilities.IsTableEmpty(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize])) == false then
            for iSize, tOldBuildableLocations in M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize] do
                sGenericBlueprint = tsBlueprintBySize[iSize]
                --Is the location still valid?
                local function StillKeepLocation(tArray, iEntry)
                    return aiBrain:CanBuildStructureAt(sGenericBlueprint, tArray[iEntry]) --Done instead of the detailed test since will have already passed the detailed test to get here and want something quick as will be running potentially tens of thousands of times
                end
                M28Utilities.RemoveEntriesFromArrayBasedOnCondition(tOldBuildableLocations, StillKeepLocation)    --Done instead of table.gen to avoid reindexing array multiple times in the same cycle
            end
        end
        --Search for more building locations for every building where we havent considered the full amount
        for iSize, tOldBuildableLocations in M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize] do
            if M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTotalSegmentCount] > (M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationSegmentCountBySize][iSize] or 0) then
                SearchForBuildableLocationsForLandZone(aiBrain, iPlateauGroup, iLandZone, iSize, tsBlueprintsBySize[iSize])
            end
        end
    end
end


function SearchForBuildableLocationsForLandZone(aiBrain, iPlateauGroup, iLandZone, iSize, sBlueprint, iOptionalMaxSegmentsToConsider)
    --Updates the plateau with a general buildable locations (if there are any) for iLandZone, based on sBlueprint; replaces the value for iSize with -1 if no such locations can be found
    --Will treat locations immediately adjacent to mexes as being unbuildable, to avoid taking up mass storage positions
    --iOptionalMaxSegmentsToConsider - will stop searching if reach this number of segments
    local sGenericBlueprint =  tsBlueprintsBySize[iSize]
    if not(sGenericBlueprint) then
        if sBlueprint then
            sGenericBlueprint = sBlueprint
            tsBlueprintsBySize[iSize] = sBlueprint
        else
            M28Utilities.ErrorHandler('Dont have a blueprint for unit size '..iSize..' and dont have a backup blueprint specified')
            return nil --Long term if come across this want to come up with logic to analyse every blueprint to look for such a unit; however in most cases we should be ok due to above recording if we try to build anything of an unexpected size anyway
        end
    end

    local tCurPosition
    local iLocationsFound = 0
    M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize] = {}
    local iSegmentStart = (M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationSegmentCountBySize][iSize] or 0) + 1
    local iTotalSegments = table.getn(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZSegments])
    if iSegmentStart > iTotalSegments then iSegmentStart = 1 end
    local iSegmentsConsidered = 0
    local tSegmentXZ
    local iMaxSegmentsToConsiderWithMatches = math.max(50, (iOptionalMaxSegmentsToConsider or 0))
    local iMaxSegmentsToConsiderWithoutMatches = math.max(500, (iOptionalMaxSegmentsToConsider or 0))


    --Cycle through every segment in the land zone and see if we can build the desired unit at the segment midpoint
    for iSegmentCount = iSegmentStart, iTotalSegments do
        iSegmentsConsidered = iSegmentsConsidered + 1
        tSegmentXZ = M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZSegments][iSegmentCount]
        tCurPosition = M28Map.GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])
        if CanBuildAtLocation(aiBrain, sGenericBlueprint, tCurPosition, nil, false, false) then
            table.insert(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize], tCurPosition)
            iLocationsFound = iLocationsFound + 1
        end
        if (iOptionalMaxSegmentsToConsider and iSegmentsConsidered >= iOptionalMaxSegmentsToConsider) or (iLocationsFound >= 16 and iSegmentsConsidered >= iMaxSegmentsToConsiderWithMatches) or (iSegmentsConsidered >= iMaxSegmentsToConsiderWithoutMatches and iLocationsFound >= 1) then
            break
        end
    end
    M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationSegmentCountBySize][iSize] = math.min(iTotalSegments, iSegmentStart + iSegmentsConsidered - 1)
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize]) then
        M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize] = -1
    end
end


function GetAvailableLandZoneBuildLocations(aiBrain, tLocation, sBlueprint)
    --Returns locations assigned to the zone for building sBlueprint, if any exist, or returns nil if none exists
    local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetAvailableLandZoneBuildLocations'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iPlateauGroup, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tLocation)
    if iLandZone > 0 then
        local iSize = M28UnitInfo.GetBuildingSize(sBlueprint)
        --Have we tried to get a location for this size before?
        if bDebugMessages == true then LOG(sFunctionRef..': tLocation='..repru(tLocation)..'; sBlueprint='..sBlueprint..'; iSize='..iSize..'; iPlateauGroup='..iPlateauGroup..'; iLandZone='..iLandZone..'; M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize]='..repru(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize])..'; Segments considered for build locations='..repru(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationSegmentCountBySize])..'; Total segments in LZ='..M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTotalSegmentCount]) end
        if not(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize]) or M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationSegmentCountBySize] < M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTotalSegmentCount] then
            SearchForBuildableLocationsForLandZone(aiBrain, iPlateauGroup, iLandZone, iSize, sBlueprint)
            if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for more buildable locations, result of locations for this size='..repru(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize])..'; Segments considered='..(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationSegmentCountBySize][iSize] or 'nil')) end
        end
        if M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize] == -1 then
            if bDebugMessages == true then LOG(sFunctionRef..': No valid buildable locations for this land zone') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return nil
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Have valid buidlable locations so will return these') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize]
        end
    end
end

function SearchForBuildableLocationsNearDestroyedBuilding(oDestroyedBuilding)
    --Searhces all segments around oDestroyedBuilding in the same land zone, and if we can build in them for a particular size, then records that location as a buildable location for that size for the land zone
    local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SearchForBuildableLocationsNearDestroyedBuilding'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iPlateauGroup, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oDestroyedBuilding:GetPosition())
    if iLandZone > 0 then
        --Cycle through each size that we ahve considered for this land zone
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize]) == false then
            if M28Utilities.IsTableEmpty(M28Overseer.tAllActiveM28Brains) == false then
                local aiBrain
                for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
                    aiBrain = oBrain
                    if not(oBrain.M28IsDefeated) then
                        break
                    end
                end
                local tRelevantSegments
                local tPotentialValidLocationsToBuild
                local iBaseSegmentX, iBaseSegmentZ = M28Map.GetPathingSegmentFromPosition(oDestroyedBuilding:GetPosition())
                local iMaxLandSegmentX, iMaxLandSegmentZ = M28Map.GetPathingSegmentFromPosition({M28Map.rMapPlayableArea[3], 0, M28Map.rMapPlayableArea[4]})
                local iBuildingSize = M28UnitInfo.GetBuildingSize(oDestroyedBuilding.UnitId)
                local iMaxSegmentAdjust
                local iCurSearchCount = 0
                local tCurPosition
                local iTotalWaitCount = 0

                for iSize, tBuildableLocations in M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize] do
                    --Work out the segments of relevance for the building just destroyed that has now freed up some space
                    tRelevantSegments = {}
                    tPotentialValidLocationsToBuild = {}
                    iMaxSegmentAdjust = math.ceil((iBuildingSize + iSize) * 0.5 / M28Map.iLandZoneSegmentSize)
                    for iCurSegmentX = math.max(1, iBaseSegmentX - iMaxSegmentAdjust), math.min(iBaseSegmentX + iMaxSegmentAdjust, iMaxLandSegmentX) do
                        for iCurSegmentZ = math.max(1, iBaseSegmentZ - iMaxSegmentAdjust), math.min(iBaseSegmentZ + iMaxSegmentAdjust, iMaxLandSegmentZ) do
                            --Are we in the same land zone?
                            if M28Map.tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] == iLandZone then
                                tCurPosition = M28Map.GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                                if CanBuildAtLocation(aiBrain, tsBlueprintsBySize[iSize], tCurPosition, nil, false, false) then
                                    table.insert(tPotentialValidLocationsToBuild, tCurPosition)
                                end

                                iCurSearchCount = iCurSearchCount + 1
                                if iCurSearchCount >= 50 then
                                    iCurSearchCount = 0
                                    iTotalWaitCount = iTotalWaitCount + 1
                                    WaitTicks(1)
                                end
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tPotentialValidLocationsToBuild) == false then
                        --Check they are all still valid
                        if iTotalWaitCount > 0 then
                            function StillValid(tArray, iEntry)
                                return aiBrain:CanBuildStructureAt(tsBlueprintsBySize[iSize], tArray[iEntry])
                            end
                            M28Utilities.RemoveEntriesFromArrayBasedOnCondition(tPotentialValidLocationsToBuild, StillValid)
                        end
                        if M28Utilities.IsTableEmpty(tPotentialValidLocationsToBuild) == false then --Incase no longer have any entries as a result of the above
                            local tValidLocations = {}
                            local bInTable
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering what potential locations are valid; iPlateauGroup='..iPlateauGroup..'; iLandZone='..iLandZone..'; tBuildableLocations='..repru(tBuildableLocations)..'; tPotentialValidLocationsToBuild='..repru(tPotentialValidLocationsToBuild)) end
                            if M28Utilities.IsTableEmpty(tBuildableLocations) then
                                tValidLocations = tPotentialValidLocationsToBuild
                                if bDebugMessages == true then LOG(sFunctionRef..': Dont have any buildable locations so valid locations will be all of the potential valid locations to build') end
                            else
                                for iPotentialLocation, tPotentialLocation in tPotentialValidLocationsToBuild do
                                    --Is it in the table already?
                                    bInTable = false

                                    for iExistingLocation, tExistingLocation in tBuildableLocations do
                                        if tExistingLocation[1] == tPotentialLocation[1] and tExistingLocation[3] == tPotentialLocation[3] then
                                            bInTable = true
                                            break
                                        end
                                    end
                                    if not(bInTable) then
                                        table.insert(tValidLocations, tPotentialLocation)
                                    end
                                    if bDebugMessages == true then LOG(sFunctionRef..': tValidLocations after considering whether potential locations are in existing buildabnle locations table='..repru(tValidLocations)) end
                                end
                            end
                            if M28Utilities.IsTableEmpty(tValidLocations) == false then
                                if tBuildableLocations == -1 then
                                    tBuildableLocations = {}
                                end
                                for iNewLocation, tNewLocation in tValidLocations do
                                    table.insert(tBuildableLocations, tNewLocation)
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetPotentialAdjacencyLocations(aiBrain, sBlueprintToBuild, tTargetLocation, iMaxAreaToSearch, iCatToBuildBy, oUnitToBuildBy, bStopWhenHaveValidLocation)
    --Returns a table of all locations that are valid buildable locations for sBlueprintToBuild where it will benefit from an adjacencybonus with iCatToBuildBy or oUnitToBuildBy
    --bStopWhenHaveValidLocation - if we are happy to get the first result then this will abort as soon as a valid location is found
    --Returns {} if no valid locations can be found
    local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPotentialAdjacencyLocations'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tPotentialLocations = {}
    local toPossibleBuildingsToBuildBy = {}
    local iPlateauGroup, iLandZone --Values are set if we have a cat to build by (but need here as refer to again later on)

    if iCatToBuildBy then
        --sBlueprintBuildBy = M28FactoryOverseer.GetBlueprintsThatCanBuildOfCategory(aiBrain, iCatToBuildBy, oEngineer)--, false, false)
        iPlateauGroup, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
        if bDebugMessages == true then LOG(sFunctionRef..': Have a cat to build by, tTargetLocation='..repru(tTargetLocation)..'; iPlateauGroup='..iPlateauGroup..'; iLandZone='..iLandZone..'; Is table of allied units in this LZ empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZSubteamData][M28Map.subrefLZSTAlliedUnits]))) end
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZSubteamData][M28Map.subrefLZSTAlliedUnits]) == false then
            local tRelevantBuildingsInSameLandZone = EntityCategoryFilterDown(iCatToBuildBy, M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZSubteamData][M28Map.subrefLZSTAlliedUnits])
            if M28Utilities.IsTableEmpty(tRelevantBuildingsInSameLandZone) == false then
                for iUnit, oUnit in tRelevantBuildingsInSameLandZone do
                    if oUnit:GetAIBrain() == aiBrain then
                        if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetLocation) <= iMaxAreaToSearch then
                            table.insert(toPossibleBuildingsToBuildBy, oUnit)
                        end
                    end
                end
            end
        end
    elseif oUnitToBuildBy and not(oUnitToBuildBy.Dead) then
        --sBlueprintBuildBy = oUnitToBuildBy.UnitId
        toPossibleBuildingsToBuildBy = {oUnitToBuildBy}
    else M28Utilities.ErrorHandler('No adjacency category or unit specified')
    end

    local bAbort = false
    local iNewBuildingRadius = M28UnitInfo.GetBuildingSize(sBlueprintToBuild) * 0.5
    local function AddAdjacencyLocationsToPotentialLocations(tAdjacencyBuildingPosition, iAdjacencyBuildingRadius, iNewBuildingRadius)
        local iCurZ, iCurX
        local iCycleSize = math.abs(iAdjacencyBuildingRadius - iNewBuildingRadius)

        --First go along top and bottom:
        for iZFactor = -1, 1, 2 do
            iCurZ = tAdjacencyBuildingPosition[3] + (iAdjacencyBuildingRadius + iNewBuildingRadius) * iZFactor
            for iCurX = tAdjacencyBuildingPosition[1] - iCycleSize, tAdjacencyBuildingPosition[1] + iCycleSize, 1 do
                if CanBuildAtLocation(aiBrain, sBlueprintToBuild, { iCurX, 0, iCurZ}, nil, false, true, false) then
                    table.insert(tPotentialLocations, {iCurX, GetSurfaceHeight(iCurX, iCurZ), iCurZ})
                    if bStopWhenHaveValidLocation then bAbort = true break end
                end
            end
            if bAbort then break end
        end

        --Next go along the sides:
        if not(bAbort) then
            for iXFactor = -1, 1, 2 do
                iCurX = tAdjacencyBuildingPosition[1] + (iAdjacencyBuildingRadius + iNewBuildingRadius) * iXFactor
                for iCurZ = tAdjacencyBuildingPosition[3] - iCycleSize, tAdjacencyBuildingPosition[3] + iCycleSize, 1 do
                    if CanBuildAtLocation(aiBrain, sBlueprintToBuild, { iCurX, 0, iCurZ}, nil, false, true, false) then
                        table.insert(tPotentialLocations, {iCurX, GetSurfaceHeight(iCurX, iCurZ), iCurZ})
                        if bStopWhenHaveValidLocation then bAbort = true break end
                    end
                end
                if bAbort then break end
            end
        end
    end


    if M28Utilities.IsTableEmpty(toPossibleBuildingsToBuildBy) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Have possible buildings to build by, so will consider best location') end
        local iAdjacencyBuildingRadius
        local tAdjacencyBuildingPosition
        local iCurZ, iCurX
        local iCycleSize
        for iBuilding, oBuilding in toPossibleBuildingsToBuildBy do
            iAdjacencyBuildingRadius = M28UnitInfo.GetBuildingSize(oBuilding.UnitId)
            AddAdjacencyLocationsToPotentialLocations(oBuilding:GetPosition(), iAdjacencyBuildingRadius, iNewBuildingRadius)
            if bAbort then break end
        end
    else
        --No nearby buildings of the desired kind - if we want to build by a mex or hydro then consider unbuilt resource locations
        local tResourceLocations
        local iAdjacencyBuildingRadius
        if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryMex, iCatToBuildBy, false) then
            tResourceLocations = M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]
            iAdjacencyBuildingRadius = 1
            if bDebugMessages == true then LOG(sFunctionRef..': Want to build by a mex so recording tResourceLocations based on iPlateauGroup='..(iPlateauGroup or 'nil')..' and iLandZone='..(iLandZone or 'nil')) end
        elseif M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryHydro, iCatToBuildBy, false) then
            tResourceLocations = M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroLocations]
            iAdjacencyBuildingRadius = 3
        end
        if tResourceLocations then
            for iCurResource, tCurResource in tResourceLocations do
                AddAdjacencyLocationsToPotentialLocations(tCurResource, iAdjacencyBuildingRadius, iNewBuildingRadius)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tPotentialLocations
end

function GetLocationAndBlueprintToBuild(aiBrain, oEngineer, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy, tAlternativePositionToLookFrom, bLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure)
    --Determines the blueprint and location for oEngineer to build at and returns these or nil if no suitable locations can be found
    --iCatToBuildBy: Optional, specify if want to look for adjacency locations; Note to factor in 50% of the builder's size and 50% of the likely adjacency building size

    local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetLocationAndBlueprintToBuild'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Engineer UC='..GetEngineerUniqueCount(oEngineer)..'; Engineer LC='..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Techlevel='..M28UnitInfo.GetUnitTechLevel(oEngineer)..'; tAlternativePositionToLookFrom='..repru(tAlternativePositionToLookFrom or {'nil'})..'; bBuildCheapestStructure='..tostring((bBuildCheapestStructure or false))..'; All blueprints that meet the category='..repru(EntityCategoryGetUnitList(iCategoryToBuild))..'; iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')) end

    --Get the blueprint to build
    --GetBlueprintsThatCanBuildOfCategory(aiBrain, iCategoryCondition, oFactory, bGetSlowest, bGetFastest, iOptionalCategoryThatMustBeAbleToBuild, bGetCheapest)
    local sBlueprintToBuild = M28Factory.GetBlueprintsThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oEngineer, false, false, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure)

    if sBlueprintToBuild == nil then
        M28Utilities.ErrorHandler('sBlueprintToBuild is nil, could happen e.g. if try and get sparky to build sxomething it cant - refer to log for more details')
        if not(iCategoryToBuild) then LOG(sFunctionRef..': No category to build. oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer))
        else
            LOG(sFunctionRef..': Had category to build. oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..'; All blueprints that satisfy the category='..repru(EntityCategoryGetUnitList(iCategoryToBuild)))
        end
    else
        --Adjust the search range and record key info needed for the search
        local tEngineerPosition = oEngineer:GetPosition()
        local tTargetLocation = (tAlternativePositionToLookFrom or tEngineerPosition)
        local tPotentialBuildLocations = {}

        --Increase max area to search if dealing with czar or similarly large unit due to its size
        if __blueprints[sBlueprintToBuild].Physics.SkirtSizeX >= 10 then
            iMaxAreaToSearch = iMaxAreaToSearch * 1.5
            if bDebugMessages == true then LOG(sFunctionRef..': Building a large unit such as a czar, increased iMaxAreaToSearch to '..iMaxAreaToSearch) end
        end
        --Reduce max area to search if dealing with a shield
        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
            iMaxAreaToSearch = math.min(iMaxAreaToSearch, (__blueprints[sBlueprintToBuild].Defense.Shield.ShieldSize or 0) * 0.5)
            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with a shield so reduce max area to search based on half of shield size. iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')..'; shield size='..__blueprints[sBlueprintToBuild].Defense.Shield.ShieldSize or 0) end
        end

        if not(tTargetLocation) then tTargetLocation = tEngineerPosition end

        if bDebugMessages == true then LOG(sFunctionRef..': sBlueprintToBuild='..(sBlueprintToBuild or 'nil')..'; Location to look from='..repru(tTargetLocation)) end
        --Mex or hydro - consider the resource locations
        if EntityCategoryContains(M28UnitInfo.refCategoryMex + M28UnitInfo.refCategoryHydro, sBlueprintToBuild) then
            local iPlateauGroup, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
            local tResourceLocations
            if EntityCategoryContains(M28UnitInfo.refCategoryMex, sBlueprintToBuild) then
                tResourceLocations = M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]
            else
                tResourceLocations = M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroLocations]
            end
            if tResourceLocations then
                --Cycle through and include any that are buildable
                for iCurResource, tCurResource in tResourceLocations do
                    if CanBuildAtLocation(aiBrain, sBlueprintToBuild, tCurResource, nil, false, true, false) then
                        table.insert(tPotentialBuildLocations, tCurResource)
                    end
                end
            end
        else
            --Get adjacency location if we want adjacency
            if iCatToBuildBy or oUnitToBuildBy then
                tPotentialBuildLocations = GetPotentialAdjacencyLocations(aiBrain, sBlueprintToBuild, tTargetLocation, iMaxAreaToSearch, iCatToBuildBy, oUnitToBuildBy)
                if bDebugMessages == true then LOG(sFunctionRef..': Finished getting potential adjacency locations, tPotentialBuildLocations='..repru(tPotentialBuildLocations)) end
            end
            if M28Utilities.IsTableEmpty(tPotentialBuildLocations) then
                --use the predefined build locations for the land zoneM28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone]M28Map.subrefLZBuildLocationSegmentCountBySize][iSize]
                local iPlateauGroup, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                local iSize = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
                if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have searched all segments in the land zone before, tLocation='..repru(tTargetLocation)..'; sBlueprintToBuild='..sBlueprintToBuild..'; iSize='..iSize..'; iPlateauGroup='..iPlateauGroup..'; iLandZone='..iLandZone..'; M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize]='..repru(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize])..'; Segments considered for build locations='..repru(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationSegmentCountBySize])..'; Total segments in LZ='..M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTotalSegmentCount]) end
                if (M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationSegmentCountBySize][iSize] or 0) < M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTotalSegmentCount] then
                    GetAvailableLandZoneBuildLocations(aiBrain, tTargetLocation, sBlueprintToBuild)
                    if bDebugMessages == true then LOG(sFunctionRef..': Finished searching for available build locations for the land zone, build locations for size '..iSize..'='..repru(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][iSize])) end
                end
                tPotentialBuildLocations = M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZBuildLocationsBySize][M28UnitInfo.GetBuildingSize(sBlueprintToBuild)]
                if bDebugMessages == true then LOG(sFunctionRef..': No adjacency locations or not looking for adjacency; tPotentialBuildLocations based on land zone build locations for iSize='..M28UnitInfo.GetBuildingSize(sBlueprintToBuild)..'='..repru(tPotentialBuildLocations)..'; will draw each location in light blue')
                    for iEntry, tEntry in tPotentialBuildLocations do
                        M28Utilities.DrawLocation(tEntry, 5)
                    end
                end
            end
        end

        --Pick the preferred build location
        if M28Utilities.IsTableEmpty(tPotentialBuildLocations) == false then
                                --GetBestBuildLocationForTarget(oEngineer, sBlueprintToBuild, tTargetLocation, tPotentialBuildLocations, iOptionalMaxDistanceFromTargetLocation)
            local tBestLocation = GetBestBuildLocationForTarget(oEngineer, sBlueprintToBuild, tTargetLocation, tPotentialBuildLocations, iMaxAreaToSearch)
            if tBestLocation then return sBlueprintToBuild, tBestLocation end
        end
    end
    return nil, nil
end

function GetBestBuildLocationForTarget(oEngineer, sBlueprintToBuild, tTargetLocation, tPotentialBuildLocations, iOptionalMaxDistanceFromTargetLocation)
    --Assumes we have already checked for: Adjacency; In the same land zone; Valid location to build
    --WIll then consider: If engineer can build without moving; How far away it is from the engineer; if it will block mex adjacency, and (if we specify a maximum distance) if it is within the max distance
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBestBuildLocationForTarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iHighestPriority = 0
    local iCurPriority, iCurDistance
    local iBestLocationRef
    local oEngiBP = oEngineer:GetBlueprint()
    local iNewBuildingRadius = M28UnitInfo.GetBuildingSize(sBlueprintToBuild) * 0.5
    local iBuilderRange = (oEngiBP.Economy.MaxBuildDistance or 5) + math.min(oEngiBP.SizeX, oEngiBP.SizeZ) + iNewBuildingRadius - 0.5
    local rBuildAreaRect
    local iMaxRange = iOptionalMaxDistanceFromTargetLocation or 200


    for iCurLocation, tCurLocation in tPotentialBuildLocations do
        iCurPriority = 0
        iCurDistance = M28Utilities.GetDistanceBetweenPositions(tTargetLocation, tCurLocation)
        if iCurDistance <= iMaxRange then
            if iCurDistance <= iBuilderRange then iCurPriority = iCurPriority + 3 end
            rBuildAreaRect = Rect(tCurLocation[1] - iNewBuildingRadius, tCurLocation[3] - iNewBuildingRadius, tCurLocation[1] + iNewBuildingRadius, tCurLocation[3] + iNewBuildingRadius)
            if M28Map.GetReclaimInRectangle(1, rBuildAreaRect) == false then iCurPriority = iCurPriority + 3 end
            if M28Conditions.AreMobileLandUnitsInRect(rBuildAreaRect) then iCurPriority = iCurPriority + 3 end
            if iCurDistance <= 50 then
                if iCurDistance <= 10 then
                    iCurPriority = iCurPriority + 3
                elseif iCurDistance <= 25 then
                    iCurPriority = iCurPriority + 2
                else
                    iCurPriority = iCurPriority + 1
                end
            end
        end
        if iCurPriority > iHighestPriority then
            iHighestPriority = iCurPriority
            iBestLocationRef = iCurLocation
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if iBestLocationRef then return tPotentialBuildLocations[iBestLocationRef]
    else return nil
    end
end



function GetBestBuildLocationForTargetOld(tablePosTarget, sTargetBuildingBPID, sNewBuildingBPID, bCheckValid, aiBrain, bReturnOnlyBestMatch, pBuilderPos, iMaxAreaToSearch, iBuilderRange, bIgnoreOutsideBuildArea, bBetterIfNoReclaim, bPreferCloseToEnemy, bPreferFarFromEnemy, bLookForQueuedBuildings)
    --Returns all co-ordinates that will result in a sNewBuildingBPID being built adjacent to PosTarget; if bCheckValid is true (default) then will also check it's a valid location to build
    -- tablePosTarget can either be a table (e.g. a table of mex locations), or just a single position
    --bIgnoreOutsideBuildArea - if true then ignore any locations outside of the builder's build area
    --bReturnOnlyBestMatch: if true then applies prioritisation and returns only the best match
    --bBetterIfNoReclaim - if true, then will ignore any build location that contains any reclaim (to avoid ACU trying to build somewhere that it has to walk to and reclaim)
    --bPreferCloseToEnemy, bPreferFarFromEnemy - optional variables, if either is set then will give +0.5 priority to locations that are closer/further to enemy
    --bLookForQueuedBuildings - optional, defaults to true, if true then check if any engineer has been assigned to buidl to that location already

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --True if want most log messages to print
    local sFunctionRef = 'GetBestBuildLocationForTargetOld'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --if sNewBuildingBPID == 'uab1101' then bDebugMessages = true end
    --if EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, sNewBuildingBPID) then bDebugMessages = true end


    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, tablePosTarget='..repru(tablePosTarget)..'; sTargetBuildingBPID='..(sTargetBuildingBPID or 'nil')..'; sNewBuildingBPID='..(sNewBuildingBPID or 'nil')..'; bCheckValid='..tostring((bCheckValid or false))..'; bReturnOnlyBestMatch='..tostring(bReturnOnlyBestMatch or false)..'; pBuilderPos='..repru(pBuilderPos)..'; iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')..'; iBuilderRange='..(iBuilderRange or 'nil')..'; bIgnoreOutsideBuildArea='..tostring(bIgnoreOutsideBuildArea or false)..'; bBetterIfNoReclaim='..tostring(bBetterIfNoReclaim or false)..'; bPreferCloseToEnemy='..tostring(bPreferCloseToEnemy or false)..'; bPreferFarFromEnemy='..tostring(bPreferFarFromEnemy or false)..'; bLookForQueuedBuildings='..tostring(bLookForQueuedBuildings or false)) end



    if bCheckValid == nil then bCheckValid = false end
    if aiBrain == nil then bCheckValid = false end
    if bReturnOnlyBestMatch == nil then bReturnOnlyBestMatch = false end
    local tStartPosition = M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber]
    local tEnemyStartPosition = M27MapInfo.GetPrimaryEnemyBaseLocation(aiBrain)
    local iDistanceToEnemy
    local iMinDistanceToEnemy = 10000
    local iMaxDistanceToEnemy = 0
    if pBuilderPos == nil then
        ErrorHandler('pBuilderPos is nil')
        pBuilderPos = tStartPosition
        bIgnoreOutsideBuildArea = false
    end
    if iBuilderRange == nil then iBuilderRange = 5 end
    if iMaxAreaToSearch == nil then iMaxAreaToSearch = iBuilderRange + 10 end
    if bIgnoreOutsideBuildArea == nil then bIgnoreOutsideBuildArea = false end
    if bBetterIfNoReclaim == nil then bBetterIfNoReclaim = false end
    if bLookForQueuedBuildings == nil then bLookForQueuedBuildings = true end

    local bWantAdjacency = true

    if sTargetBuildingBPID == nil then
        bWantAdjacency = false
    end

    local bDontBuildByMex = true
    if bWantAdjacency and EntityCategoryContains(categories.MASSEXTRACTION, sTargetBuildingBPID) then bDontBuildByMex = false end
    if bDebugMessages == true then LOG(sFunctionRef..': sNewBuildingBPID='..sNewBuildingBPID..'; sTargetBuildingBPID='..(sTargetBuildingBPID or 'nil')..'; tablePosTarget='..repru(tablePosTarget)..'; bBetterIfNoReclaim='..tostring(bBetterIfNoReclaim or false)..'; bPreferCloseToEnemy='..tostring(bPreferCloseToEnemy or false)..'; bPreferFarFromEnemy='..tostring(bPreferFarFromEnemy or false)) end
    --local TargetSize = GetBuildingTypeInfo(TargetBuildingType, 1)
    local TargetSize
    if bWantAdjacency then TargetSize = M28UnitInfo.GetBuildingSize(sTargetBuildingBPID) end

    --local tNewBuildingSize = GetBuildingTypeInfo(NewBuildingType, 1)
    local tNewBuildingSize = M28UnitInfo.GetBuildingSize(sNewBuildingBPID)
    local fSizeMod = 0.5
    local iRectangleSizeReduction = 0
    local iNewBuildingRadius = tNewBuildingSize[1] * fSizeMod
    if bDebugMessages == true and bWantAdjacency then LOG(sFunctionRef..': TargetSize='..repru(TargetSize)..'; NewBuildingSize='..repru(tNewBuildingSize)..'; iBuilderRange='..iBuilderRange..'; Gross energy income='..aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome]..'; Does building contain t1 land fac='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryLandFactory * categories.TECH1, sNewBuildingBPID))) end
    local iBuildRangeExtension = iNewBuildingRadius
    local bBuildNearerHydro = false --If want to try and build factory closer to hydro so engi has less distance to travel
    local tNearestHydro
    local iHydroBaseDistance = 10000
    if aiBrain[M27EconomyOverseer.refiGrossEnergyBaseIncome] <= 10 and iBuilderRange >= 9 and EntityCategoryContains(M28UnitInfo.refCategoryLandFactory * categories.TECH1, sNewBuildingBPID) then --proxy for assuming are dealing with an ACU building factory
        --Do we have a nearby hydro?
        local tHydroTableToBuildNear
        bBuildNearerHydro, tHydroTableToBuildNear = M27Conditions.HydroNearACUAndBase(aiBrain, true, true, true)
        local iCurHydroDist
        for iHydroTable, tHydroLocation in tHydroTableToBuildNear do
            iCurHydroDist = M27Utilities.GetDistanceBetweenPositions(tHydroLocation, M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])
            if iCurHydroDist < iHydroBaseDistance then
                iHydroBaseDistance = iCurHydroDist
                tNearestHydro = {tHydroLocation[1], tHydroLocation[2], tHydroLocation[3]}
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Think are building our first factory, bBuildNearerHydro='..tostring(bBuildNearerHydro)) end

    end
    if bDebugMessages == true then LOG(sFunctionRef..': Increasing builder distance from '..iBuilderRange..' by '..iBuildRangeExtension..'; bBuildNearerHydro='..tostring(bBuildNearerHydro)..'; tNearestHydro='..repru(tNearestHydro)..'; iHydroBaseDistance='..iHydroBaseDistance) end
    iBuilderRange = iBuilderRange + iBuildRangeExtension
    iMaxAreaToSearch = math.max(iMaxAreaToSearch, iBuilderRange + tNewBuildingSize[1])


    local iMaxX, iMinX, iMaxZ, iMinZ, iTargetMaxX, iTargetMinX, iTargetMaxZ, iTargetMinZ, OptionsX, OptionsZ
    local iNewX, iNewZ
    local iValidPosCount = 0
    local CurPosition = {}
    local PossiblePositions = {}
    local iValidPositionPriorities = {}
    local iValidPositionDistanceToEnemy = {}
    local iPriority
    local iDistanceBetween
    local iMaxPriority = -100
    local tBestPosition = {}
    local bMultipleTargets = M28Utilities.IsTableArray(tablePosTarget[1])
    local iTotalTargets = 1
    local PosTarget = {}
    if bMultipleTargets == true then iTotalTargets = M27Utilities.GetTableSize(tablePosTarget) end
    local bNewBuildingLargerThanNewTarget = false
    if TargetSize[1] < tNewBuildingSize[1] or TargetSize[2] < tNewBuildingSize[2] then bNewBuildingLargerThanNewTarget = true end

    local rPlayableArea
    if M27MapInfo.bNoRushActive then
        rPlayableArea = {aiBrain[M27MapInfo.reftNoRushCentre][1] - M27MapInfo.iNoRushRange,aiBrain[M27MapInfo.reftNoRushCentre][3] - M27MapInfo.iNoRushRange, aiBrain[M27MapInfo.reftNoRushCentre][1] + M27MapInfo.iNoRushRange,aiBrain[M27MapInfo.reftNoRushCentre][3] + M27MapInfo.iNoRushRange}
    else
        rPlayableArea = M27MapInfo.rMapPlayableArea
    end
    local iMaxMapX = rPlayableArea[3]
    local iMaxMapZ = rPlayableArea[4]

    local bHaveGoodMatch
    local iMapBoundarySize = 4
    local iActualMaxSearchRange
    local iIncrementSize = 4
    if bWantAdjacency then
        iIncrementSize = 1
        iActualMaxSearchRange = math.min(iMaxAreaToSearch + iNewBuildingRadius, TargetSize[1] * fSizeMod + iNewBuildingRadius)
    else iActualMaxSearchRange = math.min(iMaxAreaToSearch + iNewBuildingRadius, iBuilderRange)
    end
    if bDebugMessages == true then LOG(sFunctionRef..': About to try and build '..sNewBuildingBPID..' adjacent to '..(sTargetBuildingBPID or 'nil')..'; bDontBuildByMex='..tostring(bDontBuildByMex)..'; iTotalTargets='..iTotalTargets) end

    for iCurTarget = 1, iTotalTargets do
        if bMultipleTargets == true then
            PosTarget = tablePosTarget[iCurTarget]
        else
            PosTarget = tablePosTarget
        end
        --LOG('PosTarget[1]='..PosTarget[1])
        --LOG('TargetSize[1]='..TargetSize[1])
        --LOG('tNewBuildingSize[1]='..tNewBuildingSize[1])
        if bWantAdjacency then
            iMaxX = PosTarget[1] + TargetSize[1] * fSizeMod + iNewBuildingRadius
            if iMaxX > (iMaxMapX - iNewBuildingRadius) then iMaxX = iMaxMapX - iNewBuildingRadius end
            iMinX = PosTarget[1] - TargetSize[1] * fSizeMod - tNewBuildingSize[1]* fSizeMod
            if iMinX < (rPlayableArea[1] + iMapBoundarySize + iNewBuildingRadius) then iMinX = rPlayableArea[1] + iMapBoundarySize + iNewBuildingRadius end
            iMaxZ = PosTarget[3] + TargetSize[2] * fSizeMod + tNewBuildingSize[2]* fSizeMod
            if iMaxZ > (iMaxMapZ - iNewBuildingRadius) then iMaxZ = iMaxMapZ - iNewBuildingRadius end
            iMinZ = PosTarget[3] - TargetSize[2] * fSizeMod - tNewBuildingSize[2]* fSizeMod
            if iMinZ < (rPlayableArea[2] + iMapBoundarySize + iNewBuildingRadius) then iMinZ = rPlayableArea[2] + iMapBoundarySize + iNewBuildingRadius end

            iTargetMaxX = PosTarget[1] + TargetSize[1] * fSizeMod
            iTargetMinX = PosTarget[1] - TargetSize[1] * fSizeMod
            iTargetMaxZ = PosTarget[3] + TargetSize[2] * fSizeMod
            iTargetMinZ = PosTarget[3] - TargetSize[2] * fSizeMod
        else --Not interested in adjacency
            iMaxX = math.min(PosTarget[1] + iActualMaxSearchRange, iMaxMapX - iNewBuildingRadius)
            iMinX = math.max(PosTarget[1] - iActualMaxSearchRange,  rPlayableArea[1] + iMapBoundarySize + iNewBuildingRadius)
            iMaxZ = math.min(PosTarget[3] + iActualMaxSearchRange, iMaxMapZ - iNewBuildingRadius)
            iMinZ = math.max(PosTarget[3] - iActualMaxSearchRange,  rPlayableArea[2] + iMapBoundarySize + iNewBuildingRadius)
            if bDebugMessages == true then LOG(sFunctionRef..': Dont have adjancy so X Min-Max='..iMinX..'-'..iMaxX..'; Z Min-Max='..iMinZ..'-'..iMaxZ..'; iActualMaxSearchRange='..iActualMaxSearchRange) end
        end
        OptionsX = math.floor(iMaxX - iMinX)
        OptionsZ = math.floor(iMaxZ - iMinZ)
        if bDebugMessages == true then LOG(sFunctionRef..':About to cycle through potential adjacency locations for iCurTarget='..iCurTarget..'; iTotalTargets='..iTotalTargets..'; iMinX-iMaxX='..iMinX..'-'..iMaxX..'; iMinZ-iMaxZ='..iMinZ..'-'..iMaxZ..'; OptionsX='..OptionsX..'; OptionsZ='..OptionsZ..'; bWantAdjacency='..tostring(bWantAdjacency))end

        for xi = 0, OptionsX, iIncrementSize do
            iNewX = iMinX + xi
            --if iNewX >= (iMinX + TargetSize[1]*fSizeMod) or iNewX >= (iTargetMaxX - iNewBuildingRadius) then
            for zi = 0, OptionsZ, iIncrementSize do
                iPriority = 0
                iNewZ = iMinZ + zi

                --if iNewZ < (iTargetMinZ + tNewBuildingSize[2]* fSizeMod) or iNewZ > (iTargetMaxZ - tNewBuildingSize[2]* fSizeMod) then
                --ignore corner results (new building larger than target):
                local bIgnore = false
                if bWantAdjacency then
                    if bNewBuildingLargerThanNewTarget == true then
                        if iNewX - iNewBuildingRadius > iTargetMinX or iNewX + iNewBuildingRadius < iTargetMaxX then
                            if iNewZ - iNewBuildingRadius > iTargetMinZ or iNewZ + iNewBuildingRadius < iTargetMaxZ then
                                iPriority = iPriority - 4
                                --bIgnore = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Corner position so no adjacency - priority decreased; iNewX='..iNewX..'; iNewZ='..iNewZ) end
                            end
                        end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Seeing if X or Z are within required range for adjacency. iNewX='..iNewX..'; iTargetMinX='..iTargetMinX..'; iTargetMaxX='..iTargetMaxX) end
                        if iNewX >= iTargetMinX and iNewX <= iTargetMaxX then
                            if bDebugMessages == true then LOG(sFunctionRef..': x value is within the required range for adjacency, now checking if z values are') end
                            --z value needs to be right by the min or max values:
                            if iNewZ == (iTargetMinZ - iNewBuildingRadius) or iNewZ == (iTargetMaxZ + iNewBuildingRadius) then
                                --valid co-ordinate
                                if bDebugMessages == true then LOG(sFunctionRef..': Should benefit from adjacency') end
                            else
                                --If it's within the target building area then ignore, otherwise record with lower priority as no adjacency:
                                if iNewZ < (iTargetMinZ - iNewBuildingRadius) or iNewZ > (iTargetMaxZ + iNewBuildingRadius) then
                                    iPriority = iPriority - 4
                                else bIgnore = true end
                                if bDebugMessages == true then LOG(sFunctionRef..': NewBuilding <= NewTarget size 1 - failed to find adjacency match so reducing priority by 4; iNewX='..iNewX..'; iNewZ='..iNewZ..'; iTargetMinX='..iTargetMinX..'; iTargetMaxX='..iTargetMaxX..'; iTargetMinZ='..iTargetMinZ..'; iTargetMaxZ='..iTargetMaxZ..'; iNewBuildingRadius='..iNewBuildingRadius..'; tNewBuildingSize[1] * fSizeMod='..tNewBuildingSize[1] * fSizeMod) end
                            end
                        else
                            if iNewZ >= iTargetMinZ and iNewZ <= iTargetMaxZ then
                                if iNewX == (iTargetMinX - iNewBuildingRadius) or iNewX == (iTargetMaxX + iNewBuildingRadius) then
                                    --Valid match
                                    if bDebugMessages == true then LOG(sFunctionRef..': Should benefit from adjacency') end
                                else
                                    --If it's within the target building area then ignore, otherwise record with lower priority as no adjacency:
                                    if iNewX < (iTargetMinX - iNewBuildingRadius) or iNewX > (iTargetMaxX + iNewBuildingRadius) then
                                        iPriority = iPriority - 4
                                    else bIgnore = true end
                                    if bDebugMessages == true then LOG(sFunctionRef..': NewBuilding <= NewTarget size 2 - failed to find adjacency match so reducing priority by 4; iNewX='..iNewX..'; iNewZ='..iNewZ..'; iTargetMinX='..iTargetMinX..'; iTargetMaxX='..iTargetMaxX..'; iTargetMinZ='..iTargetMinZ..'; iTargetMaxZ='..iTargetMaxZ..'; iNewBuildingRadius='..iNewBuildingRadius..'; tNewBuildingSize[1] * fSizeMod='..tNewBuildingSize[1] * fSizeMod) end
                                end
                            else
                                if (iNewX < (iTargetMinX - iNewBuildingRadius) or iNewX > (iTargetMaxX + iNewBuildingRadius)) and (iNewZ < (iTargetMinZ - iNewBuildingRadius) or iNewZ > (iTargetMaxZ + iNewBuildingRadius)) then
                                    --should be valid just no adjacency
                                    iPriority = iPriority - 4
                                else bIgnore = true end
                                if bDebugMessages == true then LOG(sFunctionRef..': NewBuilding <= NewTarget size 3 - failed to find adjacency match so reducing priority by 4; iNewX='..iNewX..'; iNewZ='..iNewZ..'; iTargetMinX='..iTargetMinX..'; iTargetMaxX='..iTargetMaxX..'; iTargetMinZ='..iTargetMinZ..'; iTargetMaxZ='..iTargetMaxZ..'; iNewBuildingRadius='..iNewBuildingRadius..'; tNewBuildingSize[1] * fSizeMod='..tNewBuildingSize[1] * fSizeMod) end
                            end
                        end
                        -- If bCheckValid then see if aiBrain can build the desired structure at the location
                    end
                end
                --Check if already queued up
                --if bIgnore == false and bLookForQueuedBuildings == true then
                --bIgnore = not(CanBuildAtLocation(aiBrain, sNewBuildingBPID, { iNewX, GetSurfaceHeight(iNewX, iNewZ), iNewZ }, nil, nil, bLookForQueuedBuildings))

                --[[local sLocationRef = M27Utilities.ConvertLocationToReference({iNewX, 0, iNewZ})
        --reftEngineerAssignmentsByLocation --[x][y][z];  x is the unique location ref (need to use ConvertLocationToReference in utilities to use), [y] is the actionref, z is the engineer unique ref assigned to this location
        if aiBrain[reftEngineerAssignmentsByLocation] and aiBrain[reftEngineerAssignmentsByLocation][sLocationRef] then
            if M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][sLocationRef]) == false then bIgnore = true end
        end--]]
                --end
                local rBuildAreaRect
                if bIgnore == false then
                    --Check for reclaim:
                    if bBetterIfNoReclaim == true then

                        rBuildAreaRect = Rect(iNewX - iNewBuildingRadius + iRectangleSizeReduction, iNewZ - iNewBuildingRadius + iRectangleSizeReduction, iNewX + iNewBuildingRadius - iRectangleSizeReduction, iNewZ + iNewBuildingRadius - iRectangleSizeReduction)
                        --ReturnType: 1 = true/false: GetReclaimInRectangle(iReturnType, rRectangleToSearch)
                        if M27MapInfo.GetReclaimInRectangle(1, rBuildAreaRect) == true then
                            if bBuildNearerHydro then iPriority = iPriority - 6 --backup to reduce the risk we build close to hydro despite reclaim blocking us in later priority adjustment
                            else
                                iPriority = iPriority - 4
                            end
                        end
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Want to avoid reclaim if we can; Checking if any reclaim in the area, rBuildAreaRec='..repru(rBuildAreaRect)..'; iNewBuildingRadius='..iNewBuildingRadius..'; iRectangleSizeReduction='..iRectangleSizeReduction..'; iNewX-Z='..iNewX..'-'..iNewZ..'; M27MapInfo.GetReclaimInRectangle(1, rBuildAreaRect)='..tostring((M27MapInfo.GetReclaimInRectangle(1, rBuildAreaRect) or false)))
                        end
                    end
                end
                if bIgnore ==  false then
                    CurPosition = {iNewX, GetSurfaceHeight(iNewX, iNewZ), iNewZ}

                    if bCheckValid then
                        if not(CanBuildAtLocation(aiBrain, sNewBuildingBPID, CurPosition, nil, false, bLookForQueuedBuildings)) then
                            --if aiBrain:CanBuildStructureAt(sNewBuildingBPID, CurPosition) == false or not(M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M27Utilities.ConvertLocationToReference(CurPosition)])) then
                            bIgnore = true
                            if bDebugMessages == true then
                                if bDebugMessages == true then
                                    LOG(sFunctionRef..': aiBrain cant build at iNewX='..iNewX..'; iNewZ='..iNewZ..'; CurPosition='..CurPosition[1]..'-'..CurPosition[2]..'-'..CurPosition[3])
                                end
                            end
                        end
                    end
                end
                --Ignore if -ve priority and already have better:
                if iPriority < 0 and iMaxPriority > iPriority then
                    if bDebugMessages == true then LOG(sFunctionRef..': Ignoring location as priority too low; iPriority='..iPriority..';iMaxPriority='..iMaxPriority..'; iNewX='..iNewX..'; iNewZ='..iNewZ) end
                    bIgnore = true end

                if bIgnore == false then
                    if not(bIgnore) and aiBrain[M27Overseer.refbDefendAgainstArti] then
                        if M27Logic.IsLocationUnderFriendlyFixedShield(aiBrain, CurPosition) then
                            iPriority = iPriority + 15
                        end
                    end
                    -- We now have a co-ordinate that should result in newbuilding being built adjacent to target building (unless negative priority); check other conditions/priorities
                    iPriority = iPriority + 1


                    if bDebugMessages == true then LOG(sFunctionRef..': Have valid build location, iPriority pre considering build distance='..iPriority..'; CurPosition[1]='..CurPosition[1]..'-'..CurPosition[2]..'-'..CurPosition[3]) end
                    if bIgnoreOutsideBuildArea == true or bReturnOnlyBestMatch == true then iDistanceBetween = M27Utilities.GetDistanceBetweenBuildingPositions(pBuilderPos, CurPosition, iNewBuildingRadius) end
                    --if bIgnoreOutsideBuildArea == true or bReturnOnlyBestMatch == true then iDistanceBetween = GetDistanceBetweenPositions(pBuilderPos, PosTarget) end
                    if bReturnOnlyBestMatch == true then
                        --Check if within build area:
                        if iDistanceBetween <= iMaxAreaToSearch then
                            if bDebugMessages == true then LOG(sFunctionRef..': Is within build area, iDistanceBetween='..iDistanceBetween..'; iMaxAreaToSearch='..iMaxAreaToSearch) end
                            if iDistanceBetween > 0 then
                                iPriority = iPriority + 4
                            else iPriority = iPriority + 1
                            end
                            if iDistanceBetween <= iBuilderRange then iPriority = iPriority + 2 end
                        end
                        --Deduct 3 if ACU would have to move to build - should hopefully be covered by above
                        --if pBuilderPos[1] >= iNewX - tNewBuildingSize[1] * fSizeMod and pBuilderPos[1] <= iNewX + tNewBuildingSize[1] * fSizeMod then
                        --if pBuilderPos[3] >= iNewZ - tNewBuildingSize[2] * fSizeMod and pBuilderPos[3] <= iNewX + tNewBuildingSize[2] * fSizeMod then
                        --iPriority = iPriority - 3
                        --end
                        --end
                        --Check if level with target (makes it easier for other buildings to get adjacency):
                        if bWantAdjacency then
                            if CurPosition[1] - iNewBuildingRadius == iTargetMinX then iPriority = iPriority + 1 end
                            if CurPosition[1] + iNewBuildingRadius == iTargetMaxX then iPriority = iPriority + 1 end
                            if CurPosition[3] - iNewBuildingRadius == iTargetMinZ then iPriority = iPriority + 1 end
                            if CurPosition[3] + iNewBuildingRadius == iTargetMaxZ then iPriority = iPriority + 1 end
                        end
                    end
                    if bIgnoreOutsideBuildArea == true then
                        if iDistanceBetween > iMaxAreaToSearch then
                            bIgnore = true
                            if bDebugMessages == true then LOG(sFunctionRef..': Ignoring as iDistanceBetween='..iDistanceBetween..'; normal dist='..M27Utilities.GetDistanceBetweenPositions(pBuilderPos, CurPosition)) end
                        else iPriority = iPriority - 2
                        end
                    end

                    --Check if any units in the area (if not then icnrease priority)
                    if AreMobileUnitsInRect(rBuildAreaRect) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': No mobile units are in the build area rectangle='..repru(rBuildAreaRect)) end
                        iPriority = iPriority + 1
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': mobile units are in the build area rectangle='..repru(rBuildAreaRect)) end
                    end

                    --Check if want to weight for if its closer or further from start (jsut enough that it affects equal priority locations)
                    if bPreferCloseToEnemy or bPreferFarFromEnemy then
                        iDistanceToEnemy = M27Utilities.GetDistanceBetweenPositions(CurPosition, tEnemyStartPosition)
                        if iDistanceToEnemy < iMinDistanceToEnemy then iMinDistanceToEnemy = iDistanceToEnemy end
                        if iDistanceToEnemy > iMaxDistanceToEnemy then iMaxDistanceToEnemy = iDistanceToEnemy end
                    end

                    --Adjust priority for first factory so build closer to hydro
                    if bBuildNearerHydro and not(bIgnore) then
                        if bDebugMessages == true then LOG(sFunctionRef..': Priority pre hydro adjust='..iPriority..'; iHydroBaseDistance='..iHydroBaseDistance) end
                        iPriority = iPriority + iHydroBaseDistance - M27Utilities.GetDistanceBetweenPositions(CurPosition, tNearestHydro)
                        if bDebugMessages == true then LOG(sFunctionRef..': Priority post hydro adjust='..iPriority) end
                    end

                    if bIgnore == false then
                        --Check not blocking a mex
                        if bDebugMessages == true then LOG(sFunctionRef..': About to check whether we will block a mex by building '..sNewBuildingBPID..' and CurPosition='..repru(CurPosition)) end
                        if bDontBuildByMex and WillBuildingBlockMex(sNewBuildingBPID, CurPosition) then bIgnore = true end

                        if bIgnore == false then
                            iValidPosCount = iValidPosCount + 1
                            PossiblePositions[iValidPosCount] = CurPosition
                            iValidPositionPriorities[iValidPosCount] = iPriority
                            iValidPositionDistanceToEnemy[iValidPosCount] = iDistanceToEnemy
                            if iPriority > iMaxPriority then
                                iMaxPriority = iPriority
                                if bReturnOnlyBestMatch == true then
                                    tBestPosition = CurPosition
                                end
                            end
                            if bDebugMessages == true then if bReturnOnlyBestMatch == true then LOG('iPriority='..iPriority..'; iDistanceBetween='..iDistanceBetween) end end
                            if bDebugMessages == true then LOG(sFunctionRef..': iValidPosCount='..iValidPosCount..'; PossiblePositions[iValidPosCount][1-2-3]='..PossiblePositions[iValidPosCount][1]..'-'..PossiblePositions[iValidPosCount][2]..'-'..PossiblePositions[iValidPosCount][3]..'; bReturnOnlyBestMatch='..tostring(bReturnOnlyBestMatch)) end
                        end
                    end
                end
                if bDebugMessages == true then
                    LOG(sFunctionRef..': End of considering this option, bIgnore='..tostring(bIgnore)..'; iPriority='..iPriority)
                    if bIgnore == true or iPriority < 0 then
                        if M28Utilities.IsTableEmpty(CurPosition) == false then
                            LOG(sFunctionRef..': WIll draw a red circle as are wanting to ignore or the location has negative priority')
                            M27Utilities.DrawLocation(CurPosition, nil, 2, 100)
                        else
                            LOG(sFunctionRef..': CurPosition is empty, will happen if we ignored all results')
                        end
                    else
                        LOG('WIll draw a white circle as dont want to ignore and priority is 0 or more')
                        M27Utilities.DrawLocation(CurPosition, nil, 7, 100)
                    end
                end
                --end
            end
            --end
        end
    end
    if iValidPosCount >= 1 then
        --Check if want to weight for if its closer or further from start (jsut enough that it affects equal priority locations)
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if closest or furthest from enemy; bPreferCloseToEnemy='..tostring(bPreferCloseToEnemy)..'; bPreferFarFromEnemy='..tostring(bPreferFarFromEnemy)) end
        if bPreferCloseToEnemy or bPreferFarFromEnemy then
            for iPosition, tPosition in PossiblePositions do
                iDistanceToEnemy = iValidPositionDistanceToEnemy[iPosition]
                iPriority = iValidPositionPriorities[iPosition]
                bHaveGoodMatch = false
                if bPreferFarFromEnemy == true and iDistanceToEnemy >= iMaxDistanceToEnemy then bHaveGoodMatch = true
                elseif bPreferCloseToEnemy == true and iDistanceToEnemy <= iMinDistanceToEnemy then bHaveGoodMatch = true end
                if bDebugMessages == true then LOG(sFunctionRef..': iPosition='..iPosition..'; tPosition='..repru(tPosition)..'iPriority pre distance='..iPriority..'; iDistanceToEnemy='..iDistanceToEnemy..'; iMaxDistanceToEnemy='..iMaxDistanceToEnemy..'; iMinDistanceToEnemy='..iMinDistanceToEnemy..'; bHaveGoodMatch='..tostring(bHaveGoodMatch)) end
                if bHaveGoodMatch == true then
                    iPriority = iPriority + 0.5
                    if iPriority > iMaxPriority then
                        iMaxPriority = iPriority
                        tBestPosition = tPosition
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Near end of code, will return value depending on specifics') end
        if bReturnOnlyBestMatch then
            --Firebase specific - build within shield if there is one nearby
            if tBestPosition and EntityCategoryContains(M28UnitInfo.refCategoryFirebaseSuitable, sNewBuildingBPID) then
                local iSearchRange = 20
                local iExtraDist = 0
                if EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryT2Radar + categories.TECH3, sNewBuildingBPID) then
                    iSearchRange = 40
                    iExtraDist = 20
                end
                local tNearbyShields = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryFixedShield, tBestPosition, iSearchRange, 'Ally')
                if M28Utilities.IsTableEmpty(tNearbyShields) == false and not(M27Logic.IsLocationUnderFriendlyFixedShield(aiBrain, tBestPosition)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have shields nearby so will see if can move closer to shield') end

                    local tClosestShield = M27Utilities.GetNearestUnit(tNearbyShields, tBestPosition, aiBrain):GetPosition()
                    local iDistToShield = M27Utilities.GetDistanceBetweenPositions(tClosestShield, tBestPosition)
                    if iDistToShield >= 4 then
                        local tValidCloserLocation
                        local tCloserBuildLocation
                        local iAngleToShield = M27Utilities.GetAngleFromAToB(tBestPosition, tClosestShield)
                        for iTravelDist = 2, math.min(math.floor(iDistToShield / 2)*2 - 2) + iExtraDist, 2 do
                            tCloserBuildLocation = M27Utilities.MoveInDirection(tBestPosition, iAngleToShield, iTravelDist, true)
                            if CanBuildAtLocation(aiBrain, sNewBuildingBPID, tCloserBuildLocation, nil, false, bLookForQueuedBuildings) then
                                tValidCloserLocation = {tCloserBuildLocation[1], tCloserBuildLocation[2], tCloserBuildLocation[3]}
                                if M27Logic.IsLocationUnderFriendlyFixedShield(aiBrain, tValidCloserLocation) then
                                    break
                                end
                            end
                        end
                        if not(tValidCloserLocation) and table.getn(tNearbyShields) > 1 then
                            --Try again for other shields, with random x and z movement
                            local tCurShieldPosition, iShieldSize, iRandX, iRandZ, iAngleToUnit
                            for iShield, oShield in tNearbyShields do
                                tCurShieldPosition = oShield:GetPosition()
                                iShieldSize = oShield:GetBlueprint().Defense.Shield.ShieldSize * 0.5
                                iAngleToUnit = M27Utilities.GetAngleFromAToB(tCurShieldPosition, tBestPosition)
                                if not(tCurShieldPosition[1] == tClosestShield[1]) and not(tCurShieldPosition[3] == tClosestShield[3]) then
                                    iDistToShield = M27Utilities.GetDistanceBetweenPositions(tCurShieldPosition, tBestPosition)
                                    if iDistToShield >= 6 then
                                        for iDistFromShieldToUnit = math.floor(iShieldSize / 2) * 2, 4, -2 do
                                            iRandX = math.random(-(iDistFromShieldToUnit - iShieldSize)*0.5, (iDistFromShieldToUnit - iShieldSize)*0.5)
                                            iRandZ = math.random(-(iDistFromShieldToUnit - iShieldSize)*0.5, (iDistFromShieldToUnit - iShieldSize)*0.5)
                                            tCloserBuildLocation = M27Utilities.MoveInDirection(tCurShieldPosition, iAngleToUnit, iDistFromShieldToUnit, true)
                                            tCloserBuildLocation[1] = tCloserBuildLocation[1] + iRandX
                                            tCloserBuildLocation[3] = tCloserBuildLocation[3] + iRandZ
                                            if CanBuildAtLocation(aiBrain, sNewBuildingBPID, tCloserBuildLocation, nil, false, bLookForQueuedBuildings) then
                                                tValidCloserLocation = {tCloserBuildLocation[1], tCloserBuildLocation[2], tCloserBuildLocation[3]}
                                                if M27Logic.IsLocationUnderFriendlyFixedShield(aiBrain, tValidCloserLocation) then
                                                    break
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        if tValidCloserLocation then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have a valid location that is closr to the shield='..repru(tValidCloserLocation)..'; prev best position was '..repru(tBestPosition)) end
                            tBestPosition = {tValidCloserLocation[1], tValidCloserLocation[2], tValidCloserLocation[3]}
                        end
                    end

                end
            end

            if bDebugMessages == true then
                LOG(sFunctionRef..': Returning best possible position; tBestPosition[1]='..tBestPosition[1]..'-'..tBestPosition[2]..'-'..tBestPosition[3]..'; iMaxPriority='..iMaxPriority)
                LOG(sFunctionRef..': iMaxMapX='..iMaxMapX..'; iMaxMapZ='..iMaxMapZ..'tBestPosition='..repru(tBestPosition)..'; our start position='..repru(M27MapInfo.PlayerStartPoints[aiBrain.M27StartPositionNumber])..'; PossiblePositions='..repru(PossiblePositions)..'; will draw in black with the best location in white')
                --DrawLocations(tableLocations, relativeStart, iColour, iDisplayCount, bSingleLocation, iCircleSize, bCopyTable)
                M27Utilities.DrawLocations(PossiblePositions, nil, 3, 10, false, nil, true)
                M27Utilities.DrawLocation(tBestPosition, nil, 7, 100) --draws best position in white
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return tBestPosition
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Returning table of possible positions; PossiblePositions[1][1]='..PossiblePositions[1][1]..'-'..PossiblePositions[1][2]..'-'..PossiblePositions[1][3]) end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return PossiblePositions
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': No valid matches found. PosTarget='..PosTarget[1]..'-'..PosTarget[3]) end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return nil
    end

end



function MoveNearConstruction(aiBrain, oBuilder, tLocation, sBlueprintID, iBuildDistanceMod, bReturnMovePathInstead, bUpdatePlatoonMovePath, bReturnNilIfAlreadyMovingNearConstruction, bReturnMoveLocationifGivenOne)
    --gives oBuilder a move command to get them within range of building on tLocation, factoring in the size of buildingType
    --sBlueprintID - if nil, then will treat the action as having a size of 0
    --iBuildDistanceMod - increase or decrease if want to move closer/further away than build distance would send you; e.g. if want to get 3 within the build distance, set this to -3
    --bReturnMovePathInstead - if true return move destination instead of moving there; returns oBuilder's current position if it doesnt need to move
    --bUpdatePlatoonMovePath - default false; if true then if oBuilder has a platoon, updates that platoon's movement path
    --bReturnNilIfAlreadyMovingNearConstruction - will return nil if bReturnMovePathInstead is set to true and unit is already moving towards target, otherwise will return current move target if its close enough, or the builder position if already in position
    --bReturnMoveLocationifGivenOne - defaults to false, if true then will return the location of the move target if gave one (or nil if didnt refresh/update)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MoveNearConstruction'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    M28Utilities.ErrorHandler('Want to redo to make use of pathing logic')
    --if EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, sBlueprintID) then bDebugMessages = true end
    --if oBuilder == M28Utilities.GetACU(aiBrain) then bDebugMessages = true end
    if bDebugMessages == true then
        local sBuilderName = oBuilder.UnitId
        sBuilderName = sBuilderName..M28UnitInfo.GetUnitLifetimeCount(oBuilder)
        LOG(sFunctionRef..': Start; oBuilderId and unique count='..sBuilderName..'; target location='..repru(tLocation)..'; Builder location='..repru(oBuilder:GetPosition())..'; dist between them='..M28Utilities.GetDistanceBetweenPositions(oBuilder:GetPosition(), tLocation)..'; Amphib pathing group of builder='..M28Map.GetSegmentGroupOfLocation(M28UnitInfo.refPathingTypeAmphibious, oBuilder:GetPosition())..'; Pathing group of target location='..M28Map.GetSegmentGroupOfLocation(M28UnitInfo.refPathingTypeAmphibious, tLocation))
        M28Utilities.DrawLocation(tLocation)
    end
    if iBuildDistanceMod == nil then iBuildDistanceMod = 0 end
    if bReturnMovePathInstead == nil then bReturnMovePathInstead = false end
    if bUpdatePlatoonMovePath == nil then bUpdatePlatoonMovePath = false end
    if bReturnNilIfAlreadyMovingNearConstruction == nil then bReturnNilIfAlreadyMovingNearConstruction = true end
    local bReturnMoveTarget = false
    local tBuilderLocation = oBuilder:GetPosition()
    local iBuildDistance = 0
    local oBuilderBP = oBuilder:GetBlueprint()
    if oBuilderBP.Economy and oBuilderBP.Economy.MaxBuildDistance then iBuildDistance = oBuilderBP.Economy.MaxBuildDistance end
    iBuildDistance = iBuildDistance + iBuildDistanceMod
    --if iBuildDistance <= 0 then iBuildDistance = 1 end
    local iBuildingSize
    if sBlueprintID == nil then
        iBuildingSize = 0
    else
        iBuildingSize = M28UnitInfo.GetBuildingSize(sBlueprintID)[1]
    end
    local fSizeMod = 0.5
    local iDistanceWantedFromTarget = iBuildingSize * fSizeMod + iBuildDistance + math.min(oBuilderBP.SizeX, oBuilderBP.SizeZ) * 0.5 - 0.01
    local tPossibleTarget
    local bIgnoreMove = false
    local bUseLocationInsteadOfMoveNearby = false
    local iPossibleDistanceFromTarget

    local sPathing = M28UnitInfo.GetUnitPathingType(oBuilder)
    local iEngiPathingGroup = NavUtils.GetLabel(sPathing, tBuilderLocation)

    --Determine target:
    local iCurrentDistanceFromTarget = M28Utilities.GetDistanceBetweenPositions(tBuilderLocation, tLocation)
    if bDebugMessages == true and oBuilder then LOG(sFunctionRef..': oBuilder='..oBuilder.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBuilder)..'; Distance between builder location and target location='..iCurrentDistanceFromTarget..'; iDistanceWantedFromTarget='..iDistanceWantedFromTarget..'; Angle from builder to target='..M28Utilities.GetAngleFromAToB(tBuilderLocation, tLocation)..'; Expected position to move to if reduce the build range slightly='..repru(M28Utilities.MoveInDirection(tBuilderLocation, M28Utilities.GetAngleFromAToB(tBuilderLocation, tLocation), iCurrentDistanceFromTarget - (iDistanceWantedFromTarget - 0.25), true))..'; If instead move from target towards start by the distance wanted from target, then angleTargetToStart='..M28Utilities.GetAngleFromAToB(tLocation, tBuilderLocation)..'; Location='..repru(M28Utilities.MoveInDirection(tLocation, M28Utilities.GetAngleFromAToB(tLocation, tBuilderLocation), iDistanceWantedFromTarget - 0.25, true))) end
    if iCurrentDistanceFromTarget > iDistanceWantedFromTarget then
        --Add slight buffer so move into place:
        if bDebugMessages == true then LOG(sFunctionRef..': About to get move position near the target '..repru(tLocation)..'; iCurrentDistanceFromTarget='..iCurrentDistanceFromTarget..'; iDistanceWantedFromTarget='..iDistanceWantedFromTarget..'; will decrease distance wanted very slightly; tBuilderLocation='..repru(tBuilderLocation)) end
        iDistanceWantedFromTarget = iDistanceWantedFromTarget - 0.25 --NOTE: If changing this, then also consider if the below adjustment for naval factories with cliffs needs changing

        --GetPositionNearTargetInSamePathingGroup(tStartPos, tTargetPos, iDistanceWantedFromTarget, iAngleBase, oPathingUnit, iNearbyMethodIfBlocked, bTrySidePositions)
        local iMinDistanceFromCurrentBuilderMoveTarget = 2 --dont want to change movement path from the one generated if it's not that different

        --tPossibleTarget = GetPositionNearTargetInSamePathingGroup(tBuilderLocation, tLocation, iDistanceWantedFromTarget, 0, oBuilder, 1, true, true, iMinDistanceFromCurrentBuilderMoveTarget)
        tPossibleTarget = GetPositionAtOrNearTargetInPathingGroup(tBuilderLocation, tLocation, iDistanceWantedFromTarget, 0, oBuilder, true, true, iMinDistanceFromCurrentBuilderMoveTarget)

        --Adjust further for naval factory to facilitate greater cliff-building
        if tPossibleTarget and EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, sBlueprintID) then
            --If we move from Possible target towards our currnet position do we come across a cliff very soon?

            local bHaveCliff = false

            local iAngleFromMoveTarget = M28Utilities.GetAngleFromAToB(tPossibleTarget, tBuilderLocation)

            local iMaxCliffSearchRange = 15 + math.floor(iBuildDistance)

            function IsCliffBlockingTarget(tTarget)
                local iDistToMoveTarget = M28Utilities.GetDistanceBetweenPositions(tBuilderLocation, tTarget)
                local tCliffPositionCheck
                if iDistToMoveTarget > 1 then
                    for iDistAdjust = 1, math.min(iMaxCliffSearchRange, math.floor(iDistToMoveTarget)) do
                        tCliffPositionCheck = M28Utilities.MoveInDirection(tPossibleTarget, iAngleFromMoveTarget, iDistAdjust, true, false)
                        if not(NavUtils.GetLabel(sPathing, tCliffPositionCheck) == iEngiPathingGroup) then
                            return true
                        end
                    end
                end
                return false
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Building naval factory, IsCliffBlockingTarget(tPossibleTarget='..tostring(IsCliffBlockingTarget(tPossibleTarget))..'; tPossibleTarget='..repru(tPossibleTarget)..'; tLocation (of where we want to build)='..repru(tLocation)) end
            if IsCliffBlockingTarget(tPossibleTarget) then
                --Can we get any closer to our build distance if we broaden the angle range?  Also increase the distance slightly
                iDistanceWantedFromTarget = iDistanceWantedFromTarget + 0.1
                local iAngleToEngi = M28Utilities.GetAngleFromAToB(tLocation, tBuilderLocation)
                local tReplacementTarget
                local tPathingPosition
                if bDebugMessages == true then LOG(sFunctionRef..': About to try different positions from tLocation '..repru(tLocation)..' to tBuilderLocation '..repru(tBuilderLocation)..'; Angle to here='..iAngleToEngi..'; iDistanceWantedFromTarget='..iDistanceWantedFromTarget) end
                for iAngleAdjust = 0, 40, 8 do
                    for iAngleFactor = -1, 1, 2 do
                        --MoveInDirection(tStart, iAngle, iDistance, bKeepInMapBounds, bTravelUnderwater)
                        tPathingPosition = M28Utilities.MoveInDirection(tLocation, iAngleToEngi + iAngleAdjust * iAngleFactor, iDistanceWantedFromTarget, true, false)
                        if bDebugMessages == true then

                            local iColour = 3
                            if NavUtils.GetLabel(sPathing, tPathingPosition) == iEngiPathingGroup and not(IsCliffBlockingTarget(tPathingPosition)) then iColour = 7 end
                            LOG(sFunctionRef..': Considering tPathingPosition='..repru(tPathingPosition)..'; iAngleAdjust='..iAngleAdjust * iAngleFactor..'; Pathing group='..NavUtils.GetLabel(sPathing, tPathingPosition)..'; Engi pathing group='..iEngiPathingGroup..'; Is cliff blocking target='..tostring(IsCliffBlockingTarget(tPathingPosition))..'; will draw match in white, nonmatch in black. iColour='..iColour..'; Dist from original move target planned='..M28Utilities.GetDistanceBetweenPositions(tPathingPosition, tPossibleTarget))
                            M28Utilities.DrawLocation(tPathingPosition, false, iColour, 200)
                        end
                        if NavUtils.GetLabel(sPathing, tPathingPosition) == iEngiPathingGroup and not(IsCliffBlockingTarget(tPathingPosition)) then
                            tReplacementTarget = tPathingPosition
                        end

                        if iAngleAdjust == 0 or tReplacementTarget then break end
                    end
                    if tReplacementTarget then break end
                end
                if tReplacementTarget then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have a replacement position to use') end
                    tPossibleTarget = {tReplacementTarget[1], tReplacementTarget[2], tReplacementTarget[3]}

                end
            end
        end


        if tPossibleTarget == nil then
            if bDebugMessages == true then LOG(sFunctionRef..': Cant get a nearby location for target; will return tLocation if can path to it') end
            bUseLocationInsteadOfMoveNearby = true
        else
            iPossibleDistanceFromTarget = M28Utilities.GetDistanceBetweenPositions(tLocation, tPossibleTarget)
            if iPossibleDistanceFromTarget - iDistanceWantedFromTarget > 0.01 then --Can sometimes get tiny rounding differences
                if bDebugMessages == true then LOG(sFunctionRef..': Possible target location is outside the build range, so want to just return the target position instead, iPossibleDistanceFromTarget='..iPossibleDistanceFromTarget..'; iDistanceWantedFromTarget='..iDistanceWantedFromTarget) end
                bUseLocationInsteadOfMoveNearby = true
            end
        end
        if bUseLocationInsteadOfMoveNearby == true then
            --Couldn't find anywhere; can we path to the target?
            bIgnoreMove = true
            if NavUtils.GetLabel(sPathing, tLocation) == iEngiPathingGroup then
                if bDebugMessages == true then LOG(sFunctionRef..': Can path to tLocation so returning that') end
                if tPossibleTarget == tLocation then M28Utilities.ErrorHandler('GetPositionAtOrNearTargetInPathingGroup should already consider if target location is valid and use that instead of pathing units current position, so investigate how this has triggered (this was added as quick fix backup for v6 hotfix, but hope was with other changes this wouldnt be needed/trigger') end
                tPossibleTarget = tLocation
            else
                M28Utilities.ErrorHandler('MoveNearConstructions target location cant be pathed to and cant find pathable positions near it, will return nil, may cause future error depending on what has called this')
            end
        end

        --Is this target different to current move target?
        if tPossibleTarget then
            if bDebugMessages == true then LOG(sFunctionRef..': tPossibleTarget='..repru(tPossibleTarget)) end
            local oNavigator = oBuilder:GetNavigator()
            if oNavigator.GetCurrentTargetPos then
                local tExistingTargetPos = oNavigator:GetCurrentTargetPos()
                if M28Utilities.IsTableEmpty(tExistingTargetPos) == false then
                    if M28Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tPossibleTarget) < iMinDistanceFromCurrentBuilderMoveTarget then
                        if bDebugMessages == true then LOG(sFunctionRef..': Existing move location '..repru(tExistingTargetPos)..' is close enough to possible target '..repru(tPossibleTarget)..' so will go with that, or return nil if have specified to') end
                        if bReturnNilIfAlreadyMovingNearConstruction == true then tPossibleTarget = nil
                        else tPossibleTarget = tExistingTargetPos end
                        bIgnoreMove = true
                    end
                end
            end
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Are already close enough to target position, so will return builder location or nil depending on function arguments') end
        --Are already in position
        if bReturnNilIfAlreadyMovingNearConstruction == true then tPossibleTarget = nil
        else tPossibleTarget = tBuilderLocation end
        bIgnoreMove = true
    end

    --Move to target:
    if bReturnMovePathInstead == false then
        --Check if unit's current move location is within 1 of this already (note the getpositionneartarget function will have more advanced logic for considering if no need to change current target
        if bIgnoreMove == false then
            --[[if oBuilder.GetNavigator then
                local oNavigator = oBuilder:GetNavigator()
                if oNavigator.GetCurrentTargetPos then
                    local tExistingTargetPos = oNavigator:GetCurrentTargetPos()
                    if M28Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tPossibleTarget) < 1 then
                        bIgnoreMove = true
                    end
                end
            end]]--
            if bIgnoreMove == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Issuing move command to tPossibleTarget='..repru(tPossibleTarget)) end
                if not(oBuilder[M28UnitInfo.refbSpecialMicroActive]) then
                    IssueMove({oBuilder}, tPossibleTarget)
                    if oBuilder.PlatoonHandle then
                        oBuilder.PlatoonHandle[refiLastOrderType] = refiOrderIssueMove
                        oBuilder.PlatoonHandle[reftLastOrderPosition] = tPossibleTarget
                    end

                    bReturnMoveTarget = bReturnMoveLocationifGivenOne
                end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Not issuing move command as tPossibleTarget is close to existing target') end
            end
        end
    end
    --Update platoon movement path:
    if bIgnoreMove == false then
        if bUpdatePlatoonMovePath == true and oBuilder.PlatoonHandle then
            if oBuilder.PlatoonHandle[reftMovementPath] == nil then oBuilder.PlatoonHandle[reftMovementPath] = {} end
            if oBuilder.PlatoonHandle[refiCurrentPathTarget] == nil then oBuilder.PlatoonHandle[refiCurrentPathTarget] = 1 end
            if oBuilder.PlatoonHandle[reftMovementPath][oBuilder.PlatoonHandle[refiCurrentPathTarget]] == nil then oBuilder.PlatoonHandle[reftMovementPath][oBuilder.PlatoonHandle[refiCurrentPathTarget]] = {} end
            oBuilder.PlatoonHandle[reftMovementPath][oBuilder.PlatoonHandle[refiCurrentPathTarget]] = tPossibleTarget
        end
    end
    --Return position if have asked for one:
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bReturnMovePathInstead == true or bReturnMoveTarget then
        if bDebugMessages == true then
            if tPossibleTarget == nil then LOG(sFunctionRef..': End of function, returning nil')
            else LOG(sFunctionRef..': End of function, returning '..repru(tPossibleTarget)) end
        end
        return tPossibleTarget
    end
end

function BuildStructureNearLocation(aiBrain, oEngineer, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy, tAlternativePositionToLookFrom, bLookForPartCompleteBuildings, bLookForQueuedBuildings, oUnitToBuildBy, bNeverBuildRandom, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure, iOptionalEngiActionRef)
    --Determines the blueprint and location for oEngineer to build at; also returns the location
    --iCatToBuildBy: Optional, specify if want to look for adjacency locations; Note to factor in 50% of the builder's size and 50% of the likely adjacency building size
    --bLookForQueuedBuildings: Optional, if true, then doesnt choose a target if another engineer already has that target function ref assigned to build something
    --Returns nil if dealing with a non-resource based building

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'BuildStructureNearLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Engineer UC='..GetEngineerUniqueCount(oEngineer)..'; Engineer LC='..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Techlevel='..M28UnitInfo.GetUnitTechLevel(oEngineer)..'; tAlternativePositionToLookFrom='..repru(tAlternativePositionToLookFrom or {'nil'})..'; bBuildCheapestStructure='..tostring((bBuildCheapestStructure or false))..'; bNeverBuildRandom='..tostring((bNeverBuildRandom or false))..'; All blueprints that meet the category='..repru(EntityCategoryGetUnitList(iCategoryToBuild))..'; iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')) end


    local bAbortConstruction = false

    --Get the blueprint to build
    --GetBlueprintsThatCanBuildOfCategory(aiBrain, iCategoryCondition, oFactory, bGetSlowest, bGetFastest, iOptionalCategoryThatMustBeAbleToBuild, bGetCheapest)
    local sBlueprintToBuild = M28Factory.GetBlueprintsThatCanBuildOfCategory(aiBrain, iCategoryToBuild, oEngineer, false, false, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure)
    local tTargetLocation
    if sBlueprintToBuild == nil then
        M28Utilities.ErrorHandler('sBlueprintToBuild is nil, could happen e.g. if try and get sparky to build sxomething it cant - refer to log for more details')
        if not(iCategoryToBuild) then LOG(sFunctionRef..': No category to build. oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer))
        else
            LOG(sFunctionRef..': Had category to build. oEngineer='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..'; All blueprints that satisfy the category='..repru(EntityCategoryGetUnitList(iCategoryToBuild)))
        end
    else

        --Adjust the search range and record key info needed for the search
        local tEngineerPosition = oEngineer:GetPosition()
        tTargetLocation = (tAlternativePositionToLookFrom or tEngineerPosition)
        --Increase max area to search if dealing with czar or similarly large unit due to its size
        if __blueprints[sBlueprintToBuild].Physics.SkirtSizeX >= 10 then
            iMaxAreaToSearch = iMaxAreaToSearch * 1.5
            if bDebugMessages == true then LOG(sFunctionRef..': Building a large unit such as a czar, increased iMaxAreaToSearch to '..iMaxAreaToSearch) end
        end

        --Reduce max area to search if dealing with a shield
        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
            iMaxAreaToSearch = math.min(iMaxAreaToSearch, (__blueprints[sBlueprintToBuild].Defense.Shield.ShieldSize or 0) * 0.5)
            if bDebugMessages == true then LOG(sFunctionRef..': Dealing with a shield so reduce max area to search based on half of shield size. iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')..'; shield size='..__blueprints[sBlueprintToBuild].Defense.Shield.ShieldSize or 0) end
        end


        if bDebugMessages == true then LOG(sFunctionRef..': sBlueprintToBuild='..(sBlueprintToBuild or 'nil')..'; Location to look from='..repru(tAlternativePositionToLookFrom or oEngineer:GetPosition())) end
        local sBlueprintBuildBy
        local bFindRandomLocation = false

        if not(tTargetLocation) then tTargetLocation = tEngineerPosition end
        local bFoundEnemyInstead = false

        local sPathing = M28UnitInfo.GetUnitPathingType(oEngineer)
        local iNewBuildingRadius = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)[1] * 0.5
        local iBuilderRange = oEngineer:GetBlueprint().Economy.MaxBuildDistance + math.min(oEngineer:GetBlueprint().SizeX, oEngineer:GetBlueprint().SizeZ)*0.5
        local iDistanceFromStart = M28Utilities.GetDistanceBetweenPositions(oEngineer:GetPosition(), M28Map.PlayerStartPoints[aiBrain.M28StartPositionNumber])
        local bBuildNearToEnemy = false
        if iDistanceFromStart <= 80 then bBuildNearToEnemy = true end

        --Check we're not trying to buidl a mex or hydro or mass storage or mass fab
        local bMexHydroOrStorage = false
        if EntityCategoryContains(refCategoryMex, sBlueprintToBuild) or EntityCategoryContains(refCategoryHydro, sBlueprintToBuild) or EntityCategoryContains(M28UnitInfo.refCategoryMassStorage + M28UnitInfo.refCategoryMassFab, sBlueprintToBuild)  then
            bMexHydroOrStorage = true
        end


        --If specified, first check if there's an existing part complete building we can help complete instead of starting a new building
        --Check if is an existing building of the type wanted first:
        local oPartCompleteBuilding
        if bLookForPartCompleteBuildings then
            --GetPartCompleteBuilding(aiBrain, oBuilder, iCategoryToBuild, iBuildingSearchRange, iEnemySearchRange)
            --Returns nil if no nearby part complete building
            --iEnemySearchRange: nil if dont care about nearby enemies, otherwise will ignore buildings that have enemies within iEnemySearchRange
            oPartCompleteBuilding = GetPartCompleteBuilding(aiBrain, oEngineer, iCategoryToBuild, iBuilderRange + 15, nil)
        end
        if oPartCompleteBuilding then
            if bDebugMessages == true then LOG(sFunctionRef..': have partcompletebuilding so returning that as the position') end
            tTargetLocation = oPartCompleteBuilding:GetPosition()
        else
            if bDebugMessages == true then
                local sEngUniqueRef = GetEngineerUniqueCount(oEngineer)
                LOG(sFunctionRef..': Eng builder unique ref='..sEngUniqueRef..'; builder range='..iBuilderRange)
            end



            if not(bMexHydroOrStorage) then
                --For non-extraction buildings, if we have specified we want to build adjacent to something then look for nearby buildings that can give us the adjacency wanted
                if iCatToBuildBy or oUnitToBuildBy then
                    local toPossibleBuildingsToBuildBy
                    local iBuildingCount = 0
                    local tPossibleTargets = {}
                    local tBuildingPosition

                    if iCatToBuildBy then
                        --sBlueprintBuildBy = M28FactoryOverseer.GetBlueprintsThatCanBuildOfCategory(aiBrain, iCatToBuildBy, oEngineer)--, false, false)

                        toPossibleBuildingsToBuildBy = aiBrain:GetUnitsAroundPoint(iCatToBuildBy, tTargetLocation, iMaxAreaToSearch, 'Ally')
                        local iCurDist
                        local iClosestDist = 100000
                        --ACU specific - cant build by hydro, but might have nearby hydro
                        if bDebugMessages == true then LOG(sFunctionRef..': Engineer position='..repru(oEngineer:GetPosition())..'; tTargetLocation='..repru(tTargetLocation)..'; iMaxAreaToSearch='..iMaxAreaToSearch..'; is toPossibleBuildingsToBuildBy empty='..tostring(M28Utilities.IsTableEmpty(toPossibleBuildingsToBuildBy))) end
                        if M28Utilities.IsTableEmpty(toPossibleBuildingsToBuildBy) == false then
                            --Try to build by the closest unit of the category wanted
                            local oClosestBuilding
                            for iUnit, oUnit in  toPossibleBuildingsToBuildBy do
                                if oUnit:GetAIBrain() == aiBrain then
                                    iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEngineer:GetPosition())
                                    if iCurDist < iClosestDist then
                                        oClosestBuilding = oUnit
                                        iClosestDist = iCurDist
                                    end
                                end
                            end
                            if oClosestBuilding then
                                sBlueprintBuildBy = oClosestBuilding.UnitId
                                if bDebugMessages == true then LOG(sFunctionRef..': Will update sBlueprintBuildBy to be the closest building for adjacency='..oClosestBuilding.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestBuilding)) end
                            end
                        end


                    elseif oUnitToBuildBy then
                        sBlueprintBuildBy = oUnitToBuildBy.UnitId
                        toPossibleBuildingsToBuildBy = {oUnitToBuildBy}
                    else M28Utilities.ErrorHandler('Missing code')
                    end


                    if M28Utilities.IsTableEmpty(toPossibleBuildingsToBuildBy) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': Have possible buildings to build by, so will consider best location') end
                        for iBuilding, oBuilding in toPossibleBuildingsToBuildBy do
                            if not(oBuilding.Dead) and oBuilding.GetPosition and oBuilding:GetAIBrain() == aiBrain then
                                tBuildingPosition = oBuilding:GetPosition()
                                if M28Utilities.GetDistanceBetweenPositions(tBuildingPosition, tTargetLocation) <= iMaxAreaToSearch then
                                    iBuildingCount = iBuildingCount + 1
                                    tPossibleTargets[iBuildingCount] = tBuildingPosition
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Found iBuildingCount='..iBuildingCount..' to build by') end
                        if iBuildingCount == 0 then bFindRandomLocation = not(bNeverBuildRandom) end
                    else
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Cant find any buildings for adjacency, getting random location to build unless we want to build by a mex/hydro and have an unbuilt one nearby')
                            local tNearestBuildingOfCategory = aiBrain:GetUnitsAroundPoint(iCatToBuildBy, tTargetLocation, 10000, 'Ally')
                            if M28Utilities.IsTableEmpty(tNearestBuildingOfCategory) then LOG(sFunctionRef..': Dont have any units of the desired category anywhere on map')
                            else
                                local oNearestBuildingOfCategory = M28Utilities.GetNearestUnit(tNearestBuildingOfCategory, oEngineer:GetPosition(), aiBrain)
                                LOG(sFunctionRef..': Nearest unit of desired category is '..oNearestBuildingOfCategory.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestBuildingOfCategory)..' which is '..M28Utilities.GetDistanceBetweenPositions(oNearestBuildingOfCategory:GetPosition(), oEngineer:GetPosition())..' away from the engineer')
                            end
                        end
                        bFindRandomLocation = not(bNeverBuildRandom)
                    end

                    --Also check for unbuilt buildings if dealing with a mex or hydro, unless are building a shield
                    local tResourceLocations
                    if not(EntityCategoryContains(categories.SHIELD, sBlueprintToBuild)) then
                        --land factory - say that we're looking for a mex even if cant find one
                        if bDebugMessages == true then LOG(sFunctionRef..': About to check if building early fac and cant find mex/hydro. Does cat to build by contain mex or hydro='..tostring(M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryHydro + M28UnitInfo.refCategoryMex, iCatToBuildBy, false))..'; sBlueprintBuildBy='..(sBlueprintBuildBy or 'nil')..'; Does engi contain tech1 or ACU='..tostring(EntityCategoryContains(categories.TECH1 + categories.COMMAND, oEngineer.UnitId))..'; Does blueprint to build contain factory='..tostring(EntityCategoryContains(categories.FACTORY, sBlueprintToBuild))) end
                        if iCatToBuildBy and not(sBlueprintBuildBy) and EntityCategoryContains(categories.TECH1 + categories.COMMAND, oEngineer.UnitId) and EntityCategoryContains(categories.FACTORY, sBlueprintToBuild) then
                            if M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryMex, iCatToBuildBy, false) then
                                sBlueprintBuildBy = 'ueb1103'
                            elseif M28Utilities.DoesCategoryContainCategory(M28UnitInfo.refCategoryHydro, iCatToBuildBy, false) then
                                sBlueprintBuildBy = 'ueb1102'
                            end
                        end
                        if sBlueprintBuildBy then
                            if EntityCategoryContains(M28UnitInfo.refCategoryMex, sBlueprintBuildBy) then
                                local iPlateauGroup, iZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                                tResourceLocations = M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iZone][M28Map.subrefLZMexLocations]
                                if bDebugMessages == true then LOG(sFunctionRef..': Will add any mexes within 20 of target location to be considered') end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryHydro, sBlueprintBuildBy) or EntityCategoryContains(M28UnitInfo.refCategoryT2Power, sBlueprintBuildBy) then --Dont want to make this all power, because the adjacency code requires a building size, and only works for a single building size; i.e. if try and get adjacency for t1 power and include hydro locations, then it will think it needs to build within the hydro for adjacency
                                local iPlateauGroup, iZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tTargetLocation)
                                tResourceLocations = M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iZone][M28Map.subrefLZHydroLocations]
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tResourceLocations) == false then
                        for iResource, tCurResourceLocation in tResourceLocations do
                            iBuildingCount = iBuildingCount + 1
                            tPossibleTargets[iBuildingCount] = tCurResourceLocation
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Will try and build by resource location (mex or hydro); iBuildingCount including these locations='..iBuildingCount..'; table of building locations='..repru(tPossibleTargets)) end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of resource locations empty='..tostring(M28Utilities.IsTableEmpty(tResourceLocations))..'; iBuildingCount='..iBuildingCount) end
                    if iBuildingCount > 0 then
                        --GetBestBuildLocationForTarget(tablePosTarget, sTargetBuildingBPID, sNewBuildingBPID, bCheckValid, aiBrain, bReturnOnlyBestMatch, pBuilderPos, iMaxAreaToSearch, iBuilderRange, bIgnoreOutsideBuildArea, bBetterIfNoReclaim, bPreferCloseToEnemy, bPreferFarFromEnemy, bLookForQueuedBuildings)
                        if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Will try and build the shield anywhere near the target. iOptionalEngiActionRef='..(iOptionalEngiActionRef or 'nil')) end
                            local bBuildAwayFromEnemy = false
                            if iOptionalEngiActionRef == refActionFortifyFirebase then bBuildAwayFromEnemy = true end
                            tTargetLocation = GetBuildLocationForShield(aiBrain, sBlueprintToBuild, tAlternativePositionToLookFrom, bBuildAwayFromEnemy)
                            if not(tTargetLocation) then bAbortConstruction = true end
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': About to call GetBestBuildLocation; iBuildingCount='..iBuildingCount..'; sBlueprintBuildBy='..(sBlueprintBuildBy or 'nil')) end
                            --Go through all possible adjacent build locations identified, and choose the best one
                            tTargetLocation = GetBestBuildLocationForTarget(tPossibleTargets, sBlueprintBuildBy, sBlueprintToBuild, true, aiBrain, true, tTargetLocation, iMaxAreaToSearch, iBuilderRange, false, true, bBuildNearToEnemy, not(bBuildNearToEnemy), bLookForQueuedBuildings)
                            --Double-check the resulting location is valid
                            if M28Utilities.IsTableEmpty(tTargetLocation) == true then
                                if bDebugMessages == true then LOG('Adjacency location is empty, will try finding anywhere to build') end
                                bFindRandomLocation = not(bNeverBuildRandom)
                            else
                                bFindRandomLocation = false
                                if bDebugMessages == true then LOG(sFunctionRef..': Have determined the best build location for target to be '..repru(tTargetLocation)..'; will double-check we can build here') end
                                if not(CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, nil, false, bLookForQueuedBuildings)) then
                                    --if aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation) == false or not(M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M28Utilities.ConvertLocationToReference(tTargetLocation)])) then
                                    M28Utilities.ErrorHandler('Cant build '..sBlueprintToBuild..' on adjacency location tTargetLocation='..repru({tTargetLocation[1], tTargetLocation[2],tTargetLocation[3]}))
                                    bFindRandomLocation = not(bNeverBuildRandom)
                                else
                                    --Check we're within mapBoundary
                                    if bDebugMessages == true then LOG(sFunctionRef..': Cant build at the location; Checking if tTargetLocation '..repru(tTargetLocation)..' is in the playable area '..repru(M28Map.rMapPlayableArea)..' based on building size radius='..iNewBuildingRadius) end
                                    if (tTargetLocation[1] - iNewBuildingRadius) < M28Map.rMapPlayableArea[1] or (tTargetLocation[3] - iNewBuildingRadius) < M28Map.rMapPlayableArea[2] or (tTargetLocation[1] + iNewBuildingRadius) > M28Map.rMapPlayableArea[3] or (tTargetLocation[3] + iNewBuildingRadius) > M28Map.rMapPlayableArea[4] then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Target location isnt in playable area so will find random place to build instead') end
                                        bFindRandomLocation = not(bNeverBuildRandom)
                                        tTargetLocation = tEngineerPosition
                                    end
                                    if bDebugMessages == true then M28Utilities.DrawLocation(tTargetLocation) end
                                end
                            end
                        end
                    else
                        bFindRandomLocation = not(bNeverBuildRandom)
                        if bDebugMessages == true then LOG(sFunctionRef..': Cant find any valid buildings for adjacency') end
                    end
                else
                    --If no was adjacency wanted, then either build at the target location, or find a random location to build (subject to some unit specific points)
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont have a category to build by, will look for random location unless current target is valid or we are a shield') end
                    if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild) then
                        local bBuildAwayFromEnemy = false
                        if iOptionalEngiActionRef == refActionFortifyFirebase then bBuildAwayFromEnemy = true end
                        tTargetLocation = GetBuildLocationForShield(aiBrain, sBlueprintToBuild, tAlternativePositionToLookFrom, bBuildAwayFromEnemy)
                        if tTargetLocation then bFindRandomLocation = false else bFindRandomLocation = not(bNeverBuildRandom) end
                    else
                        bFindRandomLocation = not(bNeverBuildRandom)
                    end
                end
            else
                --Dealing with mex or hydro or storage
                if bDebugMessages == true then LOG(sFunctionRef..': Are trying to build a mex, hydro or storage; tTargetLocation='..repru((tTargetLocation or {}))..'; oEngineer='..GetEngineerUniqueCount(oEngineer)..'; LC='..M28UnitInfo.GetUnitLifetimeCount(oEngineer)) end
                if M28Utilities.IsTableEmpty(tTargetLocation) == true then
                    M28Utilities.ErrorHandler('Trying to build mex, hydro or storage without defined location')
                else
                    if aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation) then --and M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M28Utilities.ConvertLocationToReference(tTargetLocation)]) then
                        --Not interested in if other units have queued up, as e.g. might be ACU that can build and is much closer, so just want whichever unit is closest to try and build
                        if bDebugMessages == true then LOG(sFunctionRef..': Can build structure at targetlocation='..repru(tTargetLocation)..'; if are buildling a t1 mex and there is a t3 mex queued up then will ignore though') end
                        --Are we trying to build a T1 mex? If so then only consider if have an order to build T3 mex
                        if EntityCategoryContains(refCategoryT1Mex, sBlueprintToBuild) then
                            local sLocationRef = M28Utilities.ConvertLocationToReference(tTargetLocation)
                            if aiBrain[reftEngineerAssignmentsByLocation][sLocationRef] and M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][sLocationRef][refActionBuildT3MexOverT2]) == false then
                                bAbortConstruction = true
                                if bDebugMessages == true then LOG(sFunctionRef..': Trying to build t1 mex when want to build t3 here') end
                            end
                        end
                    else
                        --Cant build at location, is that because of enemy building blocking it, or we have a part-built building?
                        if bDebugMessages == true then LOG(sFunctionRef..': Are trying to build a mex or hydro or mass storage so cant get a random location, but we cant build a structure at the target') end
                        local tEnemyBuildingAtTarget = aiBrain:GetUnitsAroundPoint(iCategoryToBuild, tTargetLocation, 1, 'Enemy')
                        if M28Utilities.IsTableEmpty(tEnemyBuildingAtTarget) == false then
                            if bDebugMessages == true then LOG(sFunctionRef..': Have enemy buildings around target') end
                            M28PlatoonUtilities.MoveNearConstruction(aiBrain, oEngineer, tTargetLocation, sBlueprintToBuild, 0, false, false, false)
                            for iUnit, oUnit in tEnemyBuildingAtTarget do
                                if oUnit.GetPosition then
                                    IssueReclaim({oEngineer}, oUnit)
                                end
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': Enemy building is at the target mex/hydro so will try and reclaim that first') end

                            IssueBuildMobile({oEngineer}, tTargetLocation, sBlueprintToBuild, {})
                            if bDebugMessages == true then LOG(sFunctionRef..': 1 - Have sent issuebuildmobile order to engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..' to build blueprint '..sBlueprintToBuild..' at location '..repru(tTargetLocation)) end
                            bAbortConstruction = true
                            bFoundEnemyInstead = true

                        else
                            local tAllyBuildingAtTarget = aiBrain:GetUnitsAroundPoint(iCategoryToBuild, tTargetLocation, 1, 'Ally')
                            if M28Utilities.IsTableEmpty(tAllyBuildingAtTarget) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will target the ally building as its part complete') end
                                oPartCompleteBuilding = tAllyBuildingAtTarget[1]
                            else
                                --Are we stopped from building due to reclaim?

                                local tNewBuildingSize = M28UnitInfo.GetBuildingSize(sBlueprintToBuild)
                                local fSizeMod = 0.5

                                local rTargetRect = M28Utilities.GetRectAroundLocation(tTargetLocation, tNewBuildingSize[1] * fSizeMod)
                                if bDebugMessages == true then LOG(sFunctionRef..': tTargetLocation='..repru(tTargetLocation)..'; tNewBuildingSize='..repru(tNewBuildingSize)..'; rTargetRect='..repru(rTargetRect)) end
                                --GetReclaimInRectangle(iReturnType, rRectangleToSearch)
                                --iReturnType: 1 = true/false; 2 = number of wrecks; 3 = total mass, 4 = valid wrecks
                                local tReclaimables = M28Map.GetReclaimInRectangle(4, rTargetRect)

                                if M28Utilities.IsTableEmpty(tReclaimables) == false then
                                    for iReclaim, oReclaim in tReclaimables do
                                        --oEngineer:IssueReclaim(oReclaim)
                                        IssueReclaim({oEngineer}, oReclaim)
                                    end
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef..': Reclaim found that is blocking mex or hydro so will reclaim all wrecks in rectangle='..repru(rTargetRect))
                                        M28Utilities.DrawRectangle(rTargetRect, 7, 100)
                                    end

                                    IssueBuildMobile({oEngineer}, tTargetLocation, sBlueprintToBuild, {})
                                    if bDebugMessages == true then LOG(sFunctionRef..': 2 - Have sent issuebuildmobile order to engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..' to build blueprint '..sBlueprintToBuild..' at location '..repru(tTargetLocation)) end

                                else
                                    --Are we trying to build a T3 mex? If so then we probably are trying to replace a T2 mex which  can lead to problems with the canbuild check
                                    if iCategoryToBuild == M28UnitInfo.refCategoryT3Mex then
                                        IssueBuildMobile({oEngineer}, tTargetLocation, sBlueprintToBuild, {})
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef..': Not sure we can build here but will try anyway')
                                            LOG(sFunctionRef..': 3 - Have sent issuebuildmobile order to engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..' to build blueprint '..sBlueprintToBuild..' at location '..repru(tTargetLocation))
                                        end
                                    else
                                        --One likely explanation is that enemy has built on the mex and we cant see the building, in which case we only want to check this for debugging purposes, and proceed with the default action of having hte engineer try to move there
                                        local tUnits = GetUnitsInRect(rTargetRect)
                                        if M28Utilities.IsTableEmpty(tUnits) == true then
                                            M28Utilities.ErrorHandler(sFunctionRef..': Cant build at resource location but no units or reclaim on it, will just try moving near the target instead. sBlueprintToBuild='..sBlueprintToBuild..'; Engineer UC='..GetEngineerUniqueCount(oEngineer)..'; LC='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; Location='..repru({tTargetLocation[1], tTargetLocation[2],tTargetLocation[3]})..'; Will draw white circle around the target if in debug mode. CanBuildStructure result='..tostring(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation))..'; Is the table of assigned engineer actions empty='..tostring(M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M28Utilities.ConvertLocationToReference(tTargetLocation)])), true)
                                            if bDebugMessages == true then
                                                M28Utilities.DrawLocation(tTargetLocation, nil, 7)
                                                LOG(sFunctionRef..': Cnat build at TargetLocation='..repru(tTargetLocation)..'; RectangleSearched='..repru(rTargetRect))
                                            end
                                        end
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will just move to the target location') end
                                        M28PlatoonUtilities.MoveNearConstruction(aiBrain, oEngineer, tTargetLocation, sBlueprintToBuild, 0, false, false, false)
                                        bAbortConstruction = true
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        --Switch to random location if an amphibious unit cant path there and its not a resource based location
        if not(bFindRandomLocation) and not(bAbortConstruction) then -- and not(bMexHydroOrStorage) then
            if not(NavUtils.GetLabel(sPathing, tTargetLocation) == NavUtils.GetLabel(sPathing, oEngineer:GetPosition())) then
                bFindRandomLocation = not(bNeverBuildRandom)
            end
        end

        if bFindRandomLocation and (bMexHydroOrStorage or EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild)) and not(bAbortConstruction) and not(iOptionalEngiActionRef == refActionFortifyFirebase) then
            --Backup - Trying to build a mex or hydro so no point getting random location
            if not(EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, sBlueprintToBuild)) then
                M28Utilities.ErrorHandler('Are trying to build in a random place for am ex/hydro/mass storage - figure out why as this shouldnt trigger; Engineer with UC='..GetEngineerUniqueCount(oEngineer)..'='..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; trying to build blueprint='..sBlueprintToBuild)
                if bDebugMessages == true then LOG(sFunctionRef..': Trying to build mex or hydro so cant choose a random location') end
            else
                if bDebugMessages == true then LOG(sFunctionRef..': Trying to build a shield but couldnt find anywhere to build it so no point building it in the end. iOptionalEngiActionRef='..(iOptionalEngiActionRef or 'nil')) end
            end
            bFindRandomLocation = false
            bAbortConstruction = true
        end

        --Look for a random location if we failed to find a suitable location in the above steps
        if bFindRandomLocation == true and not(bAbortConstruction) then
            if bDebugMessages == true then LOG(sFunctionRef..': Are finding a random location to build unless current location is valid; sBlueprintToBuild='..sBlueprintToBuild..'; iMaxAreaToSearch='..(iMaxAreaToSearch or 'nil')) end
            if M28Utilities.IsTableEmpty(tTargetLocation) == true then tTargetLocation = (tAlternativePositionToLookFrom or tEngineerPosition) end

            --First check in build area for the best location assuming the target location isnt far away
            if M28Utilities.GetDistanceBetweenPositions(tTargetLocation, tEngineerPosition) <= 30 then tTargetLocation = GetBestBuildLocationForTarget(tTargetLocation, nil, sBlueprintToBuild, true, aiBrain, true, tTargetLocation, iMaxAreaToSearch, iBuilderRange, false, true, bBuildNearToEnemy, not(bBuildNearToEnemy), false) end
            if M28Utilities.IsTableEmpty(tTargetLocation) == true or not(CanBuildAtLocation(aiBrain, sBlueprintToBuild, tTargetLocation, nil, false, bLookForQueuedBuildings)) then
                --if M28Utilities.IsTableEmpty(tTargetLocation) == true or not(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation)) or not(M28Utilities.IsTableEmpty(aiBrain[reftEngineerAssignmentsByLocation][M28Utilities.ConvertLocationToReference(tTargetLocation)])) then
                if M28Utilities.IsTableEmpty(tTargetLocation) then tTargetLocation = (tAlternativePositionToLookFrom or tEngineerPosition) end
                if bDebugMessages == true then
                    LOG(sFunctionRef..' Cant build '..sBlueprintToBuild..'; will try and find a random place to build; target location for random place to build='..repru(tTargetLocation))
                    if iCategoryToBuild == nil then LOG(sFunctionRef..' iCategoryToBuild is nil somehow') end
                end
                --FindRandomPlaceToBuild(aiBrain, oBuilder, tStartPosition, sBlueprintToBuild, iSearchSizeMin, iSearchSizeMax, bForcedDebug)
                local bSuitableForLastSuccessfulLocation = EntityCategoryContains(M28UnitInfo.refCategoryStructure + categories.EXPERIMENTAL - M28UnitInfo.refCategorySatellite - M28UnitInfo.refCategoryFirebaseSuitable, sBlueprintToBuild) and M28Utilities.IsTableEmpty(aiBrain[reftLastSuccessfulLargeBuildingLocation]) == false
                local iSearchCycles = nil
                if bSuitableForLastSuccessfulLocation then iSearchCycles = 3 end
                tTargetLocation = FindRandomPlaceToBuild(aiBrain, oEngineer, (tTargetLocation or tAlternativePositionToLookFrom or tEngineerPosition), sBlueprintToBuild, 2, iMaxAreaToSearch, bDebugMessages, iSearchCycles)
                if M28Utilities.IsTableEmpty(tTargetLocation) == true then
                    --Try searching the last location we built at successfully for a couple of cycles if arent building a firebase unit
                    if bSuitableForLastSuccessfulLocation then
                        tTargetLocation = FindRandomPlaceToBuild(aiBrain, oEngineer, aiBrain[reftLastSuccessfulLargeBuildingLocation], sBlueprintToBuild, 2, iMaxAreaToSearch, false, math.min(3, (iSearchCycles or 3)))
                    end
                    if M28Utilities.IsTableEmpty(tTargetLocation) then
                        LOG(sFunctionRef..': WARNING - couldnt find a random place to build based on position='..repru(tTargetLocation)..'; will abort construction')
                        bAbortConstruction = true
                    end
                elseif bDebugMessages == true then LOG(sFunctionRef..': Found random place to build='..repru(tTargetLocation))
                end
            else if bDebugMessages == true then LOG(sFunctionRef..': No need for random place as current targetlocation is valid, ='..repru(tTargetLocation)) end
            end
        end
        --Only proceed with sending a build order (or repair order for a part complete building) if we had success in the earlier steps
        if bAbortConstruction == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Not aborting function so will try to move near construction if we have a valid location') end
            if M28Utilities.IsTableEmpty(tTargetLocation) == false and sBlueprintToBuild then
                --Adjust Target location if building PD
                if EntityCategoryContains(M28UnitInfo.refCategoryPD, sBlueprintToBuild) then
                    tTargetLocation = AdjustPDBuildLocation(aiBrain, tTargetLocation, sBlueprintToBuild)
                end
                --MoveNearConstruction(aiBrain, oBuilder, tLocation, sBlueprintID, iBuildDistanceMod, bReturnMovePathInstead, bUpdatePlatoonMovePath, bReturnNilIfAlreadyMovingNearConstruction, bReturnMoveLocationifGivenOne)
                local tMoveNearTargetLocation = M28PlatoonUtilities.MoveNearConstruction(aiBrain, oEngineer, tTargetLocation, sBlueprintToBuild, 0, false, false, false, true)
                if oPartCompleteBuilding then
                    if bDebugMessages == true then LOG(sFunctionRef..': Send order for oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to repair '..oPartCompleteBuilding.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPartCompleteBuilding)..' at '..repru(oPartCompleteBuilding:GetPosition())) end
                    IssueRepair({ oEngineer}, oPartCompleteBuilding)
                else
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Send order for oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to build '..sBlueprintToBuild..' at '..repru(tTargetLocation)..'; will draw target location in gold')
                        M28Utilities.DrawLocation(tTargetLocation, nil, 4, 500)
                    end

                    --MAIN ISSUEBUILDMOBILE FOR CONSTRUCTION (i.e. other issuebuilds here are for specific actions)
                    IssueBuildMobile({oEngineer}, tTargetLocation, sBlueprintToBuild, {})
                    if bDebugMessages == true then LOG(sFunctionRef..': 4 - Have sent issuebuildmobile order to engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..'; UC='..GetEngineerUniqueCount(oEngineer)..' to build blueprint '..sBlueprintToBuild..' at location '..repru(tTargetLocation)..' with surface height='..GetSurfaceHeight(tTargetLocation[1], tTargetLocation[3])..'; tMoveNearTargetLocation='..repru(tMoveNearTargetLocation)) end
                end
                if M28Utilities.IsTableEmpty(tMoveNearTargetLocation) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..': About to start thread checking for when the engineer is in build range') end
                    ForkThread(TrackWhenEngineerInBuildRange, oEngineer, tMoveNearTargetLocation, (sBlueprintToBuild or oPartCompleteBuilding.UnitId), tTargetLocation, oPartCompleteBuilding)
                    if sBlueprintToBuild and not(oPartCompleteBuilding) then
                        ForkThread(CheckIfEngineerLikelyStuck, oEngineer, sBlueprintToBuild, tTargetLocation)
                    end

                end
            end
        else
            if bDebugMessages == true then LOG('Warning - couldnt find any places to build after looking randomly nearby, will abort construction. bFoundEnemyInstead='..tostring(bFoundEnemyInstead)) end
            if bDebugMessages == true then
                LOG(sFunctionRef..': Aborted construction, will draw target location in red')
                M28Utilities.DrawLocation(tTargetLocation, nil, 2, 100)
            end
            if not(bMexHydroOrStorage) then tTargetLocation = nil end
        end
    end
    if bDebugMessages == true then
        if sBlueprintToBuild == nil then LOG('sBlueprintToBuild is nil')
        else
            if tTargetLocation then
                LOG(sFunctionRef..': tTargetLocation='..repru(tTargetLocation)..'; aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation)='..tostring(aiBrain:CanBuildStructureAt(sBlueprintToBuild, tTargetLocation))..'; sBlueprintToBuild='..(sBlueprintToBuild or 'nil'))
                if not(bAbortConstruction) then M28Utilities.DrawLocation(tTargetLocation, nil, 7, 100) end --show in white (colour 7)
                LOG(sFunctionRef..': About to list any units in 1x1 rectangle around targetlocation')
                local iSizeAdj = 3
                local rBuildAreaRect = Rect(tTargetLocation[1] - iSizeAdj, tTargetLocation[3] - iSizeAdj, tTargetLocation[1] + iSizeAdj, tTargetLocation[3] + iSizeAdj)
                local tUnitsInRect = GetUnitsInRect(rBuildAreaRect)
                local tsUnitRefs = {}
                if M28Utilities.IsTableEmpty(tUnitsInRect) == false then
                    for iUnit, oUnit in tUnitsInRect do
                        table.insert(tsUnitRefs, iUnit, oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
                    end
                end
                LOG('tsUnitRefs='..repru(tsUnitRefs))
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tTargetLocation
end

function GetPartCompleteBuilding(aiBrain, oBuilder, iCategoryToBuild, iBuildingSearchRange)
    --Returns nil if no nearby part complete building
    --iEnemySearchRange: nil if dont care about nearby enemies, otherwise will ignore buildings that have enemies within iEnemySearchRange
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPartCompleteBuilding'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tBuilderPosition = oBuilder:GetPosition()
    local tAllBuildings = aiBrain:GetUnitsAroundPoint(iCategoryToBuild, tBuilderPosition, iBuildingSearchRange, 'Ally')
    local iCurDistanceToBuilder
    local iMinDistanceToBuilder = 10000
    local tBuildingPosition
    local oNearestPartCompleteBuilding
    if M28Utilities.IsTableEmpty(tAllBuildings) == false then
        for iBuilding, oBuilding in tAllBuildings do
            if oBuilding.GetFractionComplete and oBuilding.GetPosition and oBuilding:GetFractionComplete() < 1 then
                local tNearbyEnemies
                tBuildingPosition = oBuilding:GetPosition()
                iCurDistanceToBuilder = M28Utilities.GetDistanceBetweenPositions(tBuildingPosition, tBuilderPosition)
                if iCurDistanceToBuilder < iMinDistanceToBuilder then
                    iMinDistanceToBuilder = iCurDistanceToBuilder
                    oNearestPartCompleteBuilding = oBuilding
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return oNearestPartCompleteBuilding
end

function SlowlyRefreshBuildableLandZoneLocations(oOrigBrain)
    local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SlowlyRefreshBuildableLandZoneLocations'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    bBuildLocationLoopActive = true
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iSearchesConsideredThisTick
    local iTicksWaitedThisCycle
    local iSegmentsBeforeWaiting = 16 --Must be a multiple of 2, i.e. 2^x results in this
    local aiBrain = oOrigBrain

    --First update every start position that has an M28 brain to make sure we have a decent number of options recorded for a land factory and smaller
    for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
        if bDebugMessages == true then LOG(sFunctionRef..': About to start recording buildable locations for the starting land zone for oBrain='..oBrain.Nickname..'; Index='..oBrain:GetArmyIndex()..'; Start pos='..repru(M28Map.tPlayerStartPoints[oBrain:GetArmyIndex()])) end
        local iPlateauGroup, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.tPlayerStartPoints[oBrain:GetArmyIndex()])
        local tiRelevantSizes = {1,2,6,8}
        for iRef, iSize in tiRelevantSizes do
            SearchForBuildableLocationsForLandZone(aiBrain, iPlateauGroup, iLandZone, iSize, tsBlueprintsBySize[iSize], iSegmentsBeforeWaiting * 10)
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    while true do
        --Get a new brain if needed
        if aiBrain.M28IsDefeated then
            aiBrain = nil
            for iBrain, oBrain in ArmyBrains do
                if oBrain.M28AI and not(oBrain.M28IsDefeated) then
                    aiBrain = oBrain
                    break
                end
            end
            if not(aiBrain) then
                break
            end
        end

        iTicksWaitedThisCycle = 0
        iSearchesConsideredThisTick = 0

        --Cycle through every plateau
        for iPlateauGroup, tPlateauSubtable in M28Map.tAllPlateaus do
            for iLandZone, tLandZoneInfo in tPlateauSubtable do
                if tLandZoneInfo[M28Map.subrefLZBuildLocationsBySize] then
                    for iSize, tBuildLocations in tLandZoneInfo[M28Map.subrefLZBuildLocationsBySize] do
                        if tBuildLocations == -1 then
                            SearchForBuildableLocationsForLandZone(aiBrain, iPlateauGroup, iLandZone, iSize, tsBlueprintsBySize[iSize], iSegmentsBeforeWaiting)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitTicks(1)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                            iSearchesConsideredThisTick = 0
                            iTicksWaitedThisCycle = iTicksWaitedThisCycle + 1
                            while (tBuildLocations == -1 and tPlateauSubtable[M28Map.subrefLZBuildLocationSegmentCountBySize][iSize] < tLandZoneInfo[M28Map.subrefLZTotalSegmentCount]) do
                                SearchForBuildableLocationsForLandZone(aiBrain, iPlateauGroup, iLandZone, iSize, tsBlueprintsBySize[iSize], iSegmentsBeforeWaiting)
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                WaitTicks(1)
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                                iSearchesConsideredThisTick = 0
                                if iTicksWaitedThisCycle >= 10000 then
                                    M28Utilities.ErrorHandler('Potential infinite loop error as have waited 10k ticks, will abort current loop')
                                    break
                                end
                            end
                        end
                        if iSearchesConsideredThisTick > 0 then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            WaitTicks(1)
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                            iTicksWaitedThisCycle = iTicksWaitedThisCycle + 1
                            iSearchesConsideredThisTick = 0
                        end
                    end
                end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(1)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                iTicksWaitedThisCycle = iTicksWaitedThisCycle + 1
            end
        end
        if iTicksWaitedThisCycle < 1000 then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1000 - iTicksWaitedThisCycle)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            iSegmentsBeforeWaiting = math.max(2, iSegmentsBeforeWaiting * 0.5)
        elseif iTicksWaitedThisCycle >= 3000 then
            iSegmentsBeforeWaiting = math.min(64, iSegmentsBeforeWaiting * 2)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function EngineerInitialisation(aiBrain)
    --Variable declaration
    aiBrain[refiEngineerCurUniqueReference] = 0

    if not(bBuildLocationLoopActive) then
        ForkThread(SlowlyRefreshBuildableLandZoneLocations, aiBrain)
    end
end