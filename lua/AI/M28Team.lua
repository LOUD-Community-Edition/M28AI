---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 07/12/2022 07:50
---

local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')


--Team data variables
bRecordedAllPlayers = false
iPlayersAtGameStart = 0
iTotalTeamCount = 0 --Increased by 1 each time we create a new team
tTeamData = {} --[x] is the aiBrain.M28Team number - stores certain team-wide information
subrefbAllEnemiesDefeated = 'M28TeamAllEnemiesDefeated' --true if all enemies of the team have been defeated
subrefbTeamHasOmni = 'M28TeamHaveOmni' --True if our team has omni vision (i.e. one of our team is an AiX with omni vision)
subrefbEnemyHasOmni = 'M28EnemyHasOmni' --true if any enemy non-civilian brains have omni vision
subreftoFriendlyActiveM28Brains = 'M28TeamFriendlyM28Brains' --Stored against tTeamData[brain.M28Team], returns table of all M28 brains on the same team (including this one)
subreftoFriendlyActiveBrains = 'M28TeamFriendlyBrains' --as above, but all friendly brains on this team


--Subteam data variables
iTotalSubteamCount = 0
tSubteamData = {}
subreftoFriendlyM28Brains = 'M28TeamSubteamBrains' --table of friendly M28 brains
subrefiMaxScoutRadius = 'M28MaxScoutRadius' --Search range for scouts for this subteam

function CreateNewSubteam(aiBrain)
    local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CreateNewSubteam'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    iTotalSubteamCount = iTotalSubteamCount + 1
    aiBrain.M28Subteam = iTotalSubteamCount
    tSubteamData[aiBrain.M28Subteam] = {}
    tSubteamData[aiBrain.M28Subteam][subreftoFriendlyM28Brains] = {}


    table.insert(tSubteamData[aiBrain.M28Subteam][subreftoFriendlyM28Brains], aiBrain)
    local tNearestEnemyBase = M28Map.GetPrimaryEnemyBaseLocation(aiBrain)
    if bDebugMessages == true then LOG(sFunctionRef..': aiBrain='..aiBrain.Nickname..'; Index='..aiBrain:GetArmyIndex()..'; tNearestEnemyBase='..repru(tNearestEnemyBase)..'; Our start point='..repru(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()])) end
    local iOurAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()], tNearestEnemyBase)
    local bSameSubteam
    --Low threshold - if within this dist will be grouped regardless of angle difference
    --High threshold - if within certain angle differential then will group if satisfy this distance
    local iDistThresholdLow = math.max(math.min(aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.8, 100), aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.3)
    local iDistThresholdHigh = math.max(math.min(aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.9, 130), aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.5)
    if bDebugMessages == true then LOG(sFunctionRef..': Our dist to enemy='..aiBrain[M28Overseer.refiDistanceToNearestEnemyBase]..'; Low threshold='..iDistThresholdLow..'; High threshold='..iDistThresholdHigh..'; Angle to nearest enemy='..iOurAngleToNearestEnemy) end

    --Cycle through each brain in our team without a subteam and consider if they should be in the same subteam as this brain
    for iBrain, oBrain in tTeamData[aiBrain.M28Team][subreftoFriendlyActiveM28Brains] do
        --Make sure we have a primary base and distance to nearest enemy recorded
        M28Map.GetPrimaryEnemyBaseLocation(oBrain)
        if not(oBrain.M28Subteam) and not(oBrain == aiBrain) then
            bSameSubteam = false
            local iBaseDistDif = M28Utilities.GetDistanceBetweenPositions(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()])
            if bDebugMessages == true then LOG(sFunctionRef..': Considering ally brain '..oBrain.Nickname..'; iBaseDistDif='..iBaseDistDif..'; iAngleDif='..M28Utilities.GetAngleDifference(iOurAngleToNearestEnemy, M28Utilities.GetAngleFromAToB(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], tNearestEnemyBase))) end
            if iBaseDistDif <= iDistThresholdLow then
                bSameSubteam = true
            else
                local iAngleDif = M28Utilities.GetAngleDifference(iOurAngleToNearestEnemy, M28Utilities.GetAngleFromAToB(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], tNearestEnemyBase))
                if iAngleDif <= 40 or (iAngleDif <= 60 and iBaseDistDif <= iDistThresholdHigh) then
                    bSameSubteam = true
                else
                    --Are we close to the start position of any of the other brains already recorded in this subteam?
                    for iSubteamBrain, oSubteamBrain in tSubteamData[aiBrain.M28Subteam][subreftoFriendlyM28Brains] do
                        if not(oSubteamBrain == aiBrain) and not(oSubteamBrain == oBrain) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Dist to alternative subteam member '..oSubteamBrain.Nickname..' = '..M28Utilities.GetDistanceBetweenPositions(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], M28Map.PlayerStartPoints[oSubteamBrain:GetArmyIndex()])) end
                            if M28Utilities.GetDistanceBetweenPositions(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], M28Map.PlayerStartPoints[oSubteamBrain:GetArmyIndex()]) <= iDistThresholdLow then
                                bSameSubteam = true
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': On same subteam='..tostring(bSameSubteam)) end
            if bSameSubteam then
                oBrain.M28Subteam = aiBrain.M28Subteam
                table.insert(tSubteamData[aiBrain.M28Subteam][subreftoFriendlyM28Brains], oBrain)
            end
        end
    end


    SubteamInitialisation(aiBrain.M28Subteam) --Dont fork thread
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CreateNewTeam(aiBrain)
    local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CreateNewTeam'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    iTotalTeamCount = iTotalTeamCount + 1
    tTeamData[iTotalTeamCount] = {}
    tTeamData[iTotalTeamCount][subreftoFriendlyActiveM28Brains] = {}
    tTeamData[iTotalTeamCount][subreftoFriendlyActiveBrains] = {}
    tTeamData[iTotalTeamCount][subrefbTeamHasOmni] = false
    tTeamData[iTotalTeamCount][subrefbEnemyHasOmni] = false


    local bHaveM28BrainInTeam = false
    local bHaveOmniVision = false
    for iCurBrain, oBrain in ArmyBrains do
        if IsAlly(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()) then
            oBrain.M28Team = iTotalTeamCount
            table.insert(tTeamData[iTotalTeamCount][subreftoFriendlyActiveBrains], oBrain)
            if oBrain.M28AI then table.insert(tTeamData[iTotalTeamCount][subreftoFriendlyActiveM28Brains], oBrain) end
            bHaveM28BrainInTeam = true
            --Check if we have omni vision for the team
            if oBrain.CheatEnabled and ScenarioInfo.Options.OmniCheat == 'on' then
                tTeamData[iTotalTeamCount][subrefbTeamHasOmni] = true
            end
        elseif IsEnemy(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()) and not(M28Conditions.IsCivilianBrain(oBrain)) then
            --Check if anyone on enemy team has omni
            if oBrain.CheatEnabled and ScenarioInfo.Options.OmniCheat == 'on' then
                tTeamData[iTotalTeamCount][subrefbEnemyHasOmni] = true
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Setup a team with team ref/iTotalTeamCount='..iTotalTeamCount..'; do we have M28 brain in this team='..tostring(bHaveM28BrainInTeam)) end
    if bHaveM28BrainInTeam then
        --Group allies into subteams based on nearest enemy
        for iBrain, oBrain in tTeamData[iTotalTeamCount][subreftoFriendlyActiveM28Brains] do
            if not(oBrain.M28Subteam) then
                CreateNewSubteam(oBrain)
            end
        end

        ForkThread(TeamInitialisation, iTotalTeamCount)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordAllPlayers()

    --Call via forkthread from initialisation, so 1 tick after the first brain will have been created
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAllPlayers'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if not(bRecordedAllPlayers) then
        bRecordedAllPlayers = true
        for iBrain, oBrain in ArmyBrains do
            if not(M28Conditions.IsCivilianBrain(oBrain)) then
                iPlayersAtGameStart = iPlayersAtGameStart + 1
                if not(oBrain.M28Team) then
                    CreateNewTeam(oBrain)
                end
            end
        end
    end


    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RemoveUnitFromCurrentLandZone(aiBrain, oUnit)
    M28Utilities.ErrorHandler('To add code')
end

function AddUnitToLandZoneForBrain(aiBrain, oUnit, iPlateauGroup, iLandZone)
    --If unit already has a land zone assigned then remove this
    local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddUnitToLandZoneForBrain'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local bAddToZone = true
    if oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] and oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][aiBrain.M28Team] then
        --Is the unit already assigned to this zone?
        if oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][aiBrain.M28Team][1] == iPlateauGroup and oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][aiBrain.M28LandTeam][2] == iLandZone then
            if bDebugMessages == true then LOG(sFunctionRef..': Unit is already assigned to this plateau and land zone so will abort adding it') end
            bAddToZone = false
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Unit already has a plateau and LZ assigned but is dif from the desired one so will remove from its current zone first') end
            RemoveUnitFromCurrentLandZone(aiBrain, oUnit)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Considering adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to iPlateauGroup '..iPlateauGroup..'; iLandZone='..iLandZone..' for brain '..aiBrain.Nickname..'; bAddToZone='..tostring(bAddToZone)..'; Is enemy='..tostring(IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()))..'; Is ally='..tostring(IsAlly(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()))) end
    if bAddToZone then
        if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) then oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] = {} end
        oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][aiBrain.M28Team] = {iPlateauGroup, iLandZone}
        if IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()) then
            table.insert(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZTEnemyUnits])
        elseif IsAlly(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()) then
            table.insert(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZTAlliedUnits], oUnit)
            if bDebugMessages == true then LOG(sFunctionRef..': Add unit as a friendly unit to Plateau-LZ='..iPlateauGroup..'-'..iLandZone..' and team='..aiBrain.M28Team..'; Is table of friendly units empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateauGroup][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZTAlliedUnits]))) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function UpdateUnitLastKnownPosition(aiBrain, oUnit, bDontCheckIfCanSeeUnit)
    --Only updates the position if the unit isnt on the same team as us (to save space), since we can use :GetPosition() for allied units
    --Checks if the unti needs reassigning if it is a land or naval unit
    local oUnitBrain = oUnit:GetAIBrain()

    if not(oUnitBrain == aiBrain or IsAlly(aiBrain:GetArmyIndex(), oUnitBrain:GetArmyIndex())) then
        if bDontCheckIfCanSeeUnit or M28Conditions.CanSeeUnit(aiBrain, oUnit) then
            if not(oUnit[M28UnitInfo.reftLastKnownPositionByTeam]) then oUnit[M28UnitInfo.reftLastKnownPositionByTeam] = {} end
            local tCurPosition = oUnit:GetPosition()
            oUnit[M28UnitInfo.reftLastKnownPositionByTeam][aiBrain.M28Team] = {tCurPosition[1], tCurPosition[2], tCurPosition[3]} --Do a copy of table as :GetPosition() means it will always update for the unit's latest position even when we lack intel of it
        end
    end
end

function ConsiderAssigningUnitToZoneForBrain(aiBrain, oUnit)
    --Assumes called from an event that menas we will have visibility of the unit (e.g. directly via intel, or indirectly via weapon firing)
    if aiBrain.M28AI and aiBrain.M28Team then
        local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'ConsiderAssigningUnitToZoneForBrain'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if should assign unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to a plateau/other table. Considered for assignment repru='..repru(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam])..'; Unit brain team='..(oUnit:GetAIBrain().M28Team or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
        if (not(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam]) or not(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][aiBrain.M28Team])) and M28UnitInfo.IsUnitValid(oUnit) and not(aiBrain.M28IsDefeated) then
            AssignUnitToZoneOrPond(aiBrain, oUnit)
        else
            UpdateUnitLastKnownPosition(aiBrain, oUnit, true)
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

---@param aiBrain userdata
---@param oUnit userdata
function AssignUnitToZoneOrPond(aiBrain, oUnit, bAlreadyUpdatedPosition)
    --Assigns oUnit to relevant table for aiBrain; Should be called if we have a unit that hasn't been considered before (check by referencing oUnit[reftbConsideredForAssignmentByTeam][iTeam]) - will decide whether the unit should be assigned to a pond, a land zone, or air units, based partially on the unit category and partially on its current position
    local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignUnitToZoneOrPond'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if not(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam]) then oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam] = {} end
    if not(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][aiBrain.M28Team]) then oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][aiBrain.M28Team] = true end

    if not(bAlreadyUpdatedPosition) then UpdateUnitLastKnownPosition(aiBrain, oUnit, true) end
    if bDebugMessages == true then LOG(sFunctionRef..': aiBrain '..aiBrain.Nickname..' is Considering how to assign unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that is owned by brain '..oUnit:GetAIBrain().Nickname) end
    --Air units - always assign to air groups
    if EntityCategoryContains(M28UnitInfo.refCategoryAllAir - M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
        M28Utilities.ErrorHandler('To add code for air units')
    else
        local iPlateauGroup, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
        if bDebugMessages == true then LOG(sFunctionRef..': Unit iPlateauGroup='..(iPlateauGroup or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
        if iLandZone > 0 then
            --Unit is in a land zone so assign it to a land zone instead of a pond
            AddUnitToLandZoneForBrain(aiBrain, oUnit, iPlateauGroup, iLandZone)
        else
            --If unit is on water then assign it to a pond
            local iCurPond = NavUtils.GetLabel(M28Map.refPathingTypeNavy, oUnit:GetPosition())
            if iCurPond > 0 then
                M28Utilities.ErrorHandler('#To add code for naval units')
            else
                --Not an air unit; no land zone or pond; assign to backup list of units - e.g. it could be the unit is attached to a transport
                M28Utilities.ErrorHandler('To add code for nonair units not on land or water')
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Is plateau 12 LZ 2 empty of allies for team 2='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[12][M28Map.subrefPlateauLandZones][2][M28Map.subrefLZTeamData][2][M28Map.subrefLZTAlliedUnits]))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end



--[[function UpdateUnitPond(oUnit, iM28TeamUpdatingFor, bIsEnemy, iPondRefOverride)
    --Check the unit's pond; ignore this for non-M28 friendly units
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateUnitPond'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --if bDebugMessages == true then M28Utilities.ErrorHandler('Audit trail', true) end

    --if oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit) == 'xes02051' and oUnit:GetAIBrain():GetArmyIndex() == 2 and GetGameTimeSeconds() >= 840 then bDebugMessages = true end
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, bIsEnemy='..tostring((bIsEnemy or false))..'; Unit brain index='..oUnit:GetAIBrain():GetArmyIndex()..'; Unit assigned pond='..(oUnit[refiAssignedPond] or 'nil')..'; Contains fixed pond category='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryPondFixedCategory, oUnit.UnitId))) end

    if bIsEnemy or (oUnit:GetAIBrain().M28AI and (not(oUnit[refiAssignedPond]) or not(EntityCategoryContains(M28UnitInfo.refCategoryPondFixedCategory, oUnit.UnitId)))) then --and not(oUnit[reftisubrefsUpdatedFor][iM28TeamUpdatingFor])) then
        local iCurPond = iPondRefOverride or M28MapInfo.GetSegmentGroupOfLocation(M28UnitInfo.refPathingTypeNavy, oUnit:GetPosition())
        if bDebugMessages == true then LOG(sFunctionRef..': bIsEnemy='..tostring(bIsEnemy)..'; Updating for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iPondRefOverride='..(iPondRefOverride or 'nil')..'; iCurPond='..(iCurPond or 'nil')..'; oUnit[refiAssignedPond]='..(oUnit[refiAssignedPond] or 'nil')) end --LOG('iCurPond pre adj='..(iCurPond or 'nil'))
        --if tPondDetails[iCurPond] then LOG('Pond size='..(tPondDetails[iCurPond][subrefPondSize] or 'nil')) end
        if not(tPondDetails[iCurPond]) or (tPondDetails[iCurPond][subrefPondSize] or 0) <= iMinPondSize then
            --If have a naval unit that isnt amphibious then update pathing
            if bDebugMessages == true then LOG(sFunctionRef..': Dont have details for the pond recorded, if its a naval unit then will check for if there is a pond nearby') end
            if EntityCategoryContains(categories.NAVAL * categories.MOBILE - categories.HOVER - categories.AMPHIBIOUS - categories.AIR - categories.LAND, oUnit.UnitId) then
                iCurPond = CheckForPondNearNavalUnit(oUnit)
                if bDebugMessages == true then LOG(sFunctionRef..': iCurPond after checking for pond near naval unit='..iCurPond) end
            else
                iCurPond = 0
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iCurPond after updating for naval unit and min pond size='..(iCurPond or 'nil')..'; oUnit[refiAssignedPond]='..(oUnit[refiAssignedPond] or 'nil')) end
        if iCurPond > 0 then
            oUnit[M28UnitInfo.reftLastKnownPosition] = {oUnit:GetPosition()[1], oUnit:GetPosition()[2], oUnit:GetPosition()[3]}
            if bDebugMessages == true then LOG(sFunctionRef..': Updated unit last known position') end
        end
        if oUnit[refiAssignedPond] then
            if not(iCurPond == oUnit[refiAssignedPond]) then
                if bDebugMessages == true then LOG('Removing unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from old pond '..(oUnit[refiAssignedPond] or 'nil')..' and adding to new pond iCurPond='..iCurPond) end
                RemoveUnitFromAssignedPond(oUnit)
                AddUnitToPond(oUnit, iCurPond, iM28TeamUpdatingFor, bIsEnemy)
            elseif not(oUnit[reftisubrefsUpdatedFor][iM28TeamUpdatingFor]) then
                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to pond '..iCurPond) end
                AddUnitToPond(oUnit, iCurPond, iM28TeamUpdatingFor, bIsEnemy)
            end
        else
            if iCurPond > 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to pond '..iCurPond) end
                AddUnitToPond(oUnit, iCurPond, iM28TeamUpdatingFor, bIsEnemy)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end--]]

function TeamInitialisation(iM28Team)
    --First check if we have any M28 brains in this team (otherwise dont do anything further)
    local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TeamInitialisation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Will initialise team based logic for the team '..iM28Team..'; Is the table of friendly active M28 brains empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftoFriendlyActiveM28Brains]))..'; Do we already have an active team cycler='..tostring(tTeamData[iM28Team]['M28TeamActiveTeamCycler'] or false)) end

    if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftoFriendlyActiveM28Brains]) == false then
        if not(tTeamData[iM28Team]['M28TeamActiveTeamCycler']) then
            tTeamData[iM28Team]['M28TeamActiveTeamCycler'] = true
            if bDebugMessages == true then LOG(sFunctionRef..': About to start land zone overseer which carries out main over time loop') end
            ForkThread(M28Land.LandZoneOverseer, iM28Team)
        end
    end

    --Include variables for land zones
    for iPlateau, tPlateauData in M28Map.tAllPlateaus do
        for iLZ, tLZData in tPlateauData[M28Map.subrefPlateauLandZones] do
            tLZData[M28Map.subrefLZTeamData] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZTAlliedUnits] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZTEnemyUnits] = {}
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SubteamInitialisation(iM28Subteam)
    M28Utilities.ErrorHandler('To add subteam code')
end