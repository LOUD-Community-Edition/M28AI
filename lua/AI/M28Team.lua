---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 07/12/2022 07:50
---

local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')

--Team data variables
bRecordedAllPlayers = false
iPlayersAtGameStart = 0
iTotalTeamCount = 0 --Increased by 1 each time we create a new team
tTeamData = {} --[x] is the aiBrain.M28Team number - stores certain team-wide information
    --Brain details
    subrefbAllEnemiesDefeated = 'M28TeamAllEnemiesDefeated' --true if all enemies of the team have been defeated
    subreftoFriendlyActiveM28Brains = 'M28TeamFriendlyM28Brains' --Stored against tTeamData[brain.M28Team], returns table of all M28 brains on the same team (including this one)
    subrefiActiveM28BrainCount = 'ActiveM28Count' --number of active m28 brains we have in the team
    subreftoFriendlyActiveBrains = 'M28TeamFriendlyBrains' --as above, but all friendly brains on this team, tTeamData[brain.M28Team][subreftoFriendlyActiveBrains]
    subreftoEnemyBrains = 'M28TeamEnemyBrains'

    --Team economy subrefs
    subrefiTeamGrossEnergy = 'M28TeamGrossEnergy'
    subrefiTeamNetEnergy = 'M28TeamNetEnergy'
    subrefiTeamGrossMass = 'M28TeamGrossMass'
    subrefiTeamNetMass = 'M28TeamNetMass'
    subreftiPrevTeamNetMass = 'M28TeamPrevNetMass' --{[1]=x, [2]=y... up to [5]} -i.e. the net mass value for the prev 5 checks (so can take average)
    subrefiTeamEnergyStored = 'M28TeamEnergyStored'
    subrefiTeamMassStored = 'M28TeamMassStored'
    subrefiTeamLowestEnergyPercentStored = 'M28TeamLowestEnergyPercent'
    subrefiTeamLowestMassPercentStored = 'M28TeamLowestMassPercent'
    subrefbTeamIsStallingEnergy = 'M28TeamStallingEnergy'
    subrefbTeamIsStallingMass = 'M28TeamStallingMass'
    subrefbTooLittleEnergyForUpgrade = 'M28TeamTooLittleEnergyForUpgrade' --true if we havent got an upgrade due to lack of power
    subrefbActiveT1PowerReclaimer = 'M28TeamActiveT1PowerReclaimer'
    subrefbActiveT2PowerReclaimer = 'M28TeamActiveT2PowerReclaimer'
    refbJustBuiltLotsOfPower = 'M28TeamJustBuiltPower' --temporarily set to true after building an early T2/T3 PGen so we dont think for hte few seconds after building it that we are power stalling if we have low % of power
    subrefiLowestEnergyStorageCount = 'M28TeamLowestEStorage' --Lowest number of EStorage owned by an M28 brain on the team
    subrefiGrossEnergyWhenStalled = 'M28TeamGrossEWhenStalled' --Amount of energy team had (gross) when we had a power stall
    refiTimeOfLastEnergyStall = 'M28TeamTimeOfLastEnergyStall'
    refiTimeOfLastEngiSelfDestruct = 'M28TeamTimeOfLastEnegiSelfDestruct'
    refbNeedResourcesForMissile = 'M28TeamNeedResourcesForMissile' --true if are building nuke or smd that needs a missile

    subreftTeamUpgradingHQs = 'M28TeamUpgradingHQs'
    subreftTeamUpgradingMexes = 'M28TeamUpgradingMexes'
    subreftTeamUpgradingOther = 'M28TeamUpgradingOther'
    subrefiMassUpgradesStartedThisCycle = 'M28TeamMassUpgradesThisCycle' --Amount of mass per tick that we have committed in upgrades this cycle
    subrefiEnergyUpgradesStartedThisCycle = 'M28TeamEnergyUpgradesThisCycle' --Amount of energy per tick that we have committed in upgrades this cycle

    --Tech level details
    subrefiHighestEnemyGroundTech = 'M28TeamHighestEnemyGround'
    subrefiHighestEnemyAirTech = 'M28TeamHighestEnemyAir'
    subrefiHighestEnemyNavyTech = 'M28TeamHighestEnemyNavy'
    subrefiLowestFriendlyLandFactoryTech = 'M28TeamLowestFriendlyGround' --Returns the lowest M28Brain's highest tech of this type, i.e. if an M28 brain has a T1 and T2 land factory, and another has a T3 land factory, then this would return 2.
    subrefiLowestFriendlyAirFactoryTech = 'M28TeamLowestFriendlyAir' --Returns the lowest M28Brain's highest tech of this type, i.e. if an M28 brain has a T1 and T2 air factory, and another has a T3 air factory, then this would return 2.
    subrefiLowestFriendlyNavalFactoryTech = 'M28TeamLowestFriendlyNaval'
    subrefiHighestFriendlyFactoryTech = 'M28TeamHighestFriendlyFactory'
    subrefiHighestFriendlyLandFactoryTech = 'M28TeamHighestFriendlyGround' --Returns the Highest M28Brain's highest tech of this type, i.e. if an M28 brain has a T1 and T2 land factory, and another has a T3 land factory, then this would return 3.
    subrefiHighestFriendlyAirFactoryTech = 'M28TeamHighestFriendlyAir' --Returns the Highest M28Brain's highest tech of this type, i.e. if an M28 brain has a T1 and T2 air factory, and another has a T3 air factory, then this would return 3.
    subrefiHighestFriendlyNavalFactoryTech = 'M28TeamHighestFriendlyNaval'
    subrefiHighestEnemyMexTech = 'M28TeamHighestEnemyMex' --I.e. 1, 2 or 3


    --Intel details
    subrefbTeamHasOmni = 'M28TeamHaveOmni' --True if our team has omni vision (i.e. one of our team is an AiX with omni vision)
    subrefbEnemyHasOmni = 'M28EnemyHasOmni' --true if any enemy non-civilian brains have omni vision


    --Notable unit count details
    refbDefendAgainstArti = 'M28TeamDefendAgainstArti' --true if enemy has t3 arti or equivelnt
    subreftoT3Arti = 'M28TeamT3Arti' --table of T3 and experimental arti that M28 players on the team have

    --Land combat related
    subrefiLandZonesWantingSupportByPlateau = 'M28TeamLZWantingSupport' --[x] is the plateau ref, [y] is the land zone ref, returns true if we want support for the plateau
    subrefiRallyPointLandZonesByPlateau = 'M28TeamLZRallyPoint' --[x] is the plateau ref, y is the land zone ref
    refiTimeOfLastRallyPointRefresh = 'M28TeamRallyPointRefreshTime' --Game time in seconds that last refreshed rally points

    --Misc details
    reftiTeamMessages = 'M28TeamMessages' --against tTeamData[aiBrain.M28Team], [x] is the message type string, returns the gametime that last sent a message of this type to the team

--AirSubteam data variables
iTotalAirSubteamCount = 0
tAirSubteamData = {}
    subreftoFriendlyM28Brains = 'M28ASTBrains' --table of friendly M28 brains
    subrefiMaxScoutRadius = 'M28ASTMaxScoutRadius' --Search range for scouts for this AirSubteam


--Land subteam data varaibles (used for factory production logic)
iTotalLandSubteamCount = 0
tLandSubteamData = {} --tLandSubteamData[oBrain.M28LandSubteam] results in the below subrefs
    subrefiLandCorePlateau = 'M28LSTPlateau' --Plateau number that the land subteam is based on
    subrefiLandCoreIsland = 'M28LSTIsland' --Island number that the land subteam is based on
    subreftoFriendlyM28Brains = 'M28LSTBrains'
    subrefFactoriesByTypeFactionAndTech = 'M28LSTFactoriesByPlateau' --First value is factory type; secont value is faction (M28UnitInfo.refFactionxxxx), third is tech level
    subrefBlueprintBlacklist = 'M28LSTBlueprintBlacklist' --Check with M28Team.tLandSubteamData[aiBrain.M28LandSubteam][M28Team.subrefBlueprintBlacklist][sUnitId] - returns true if we have blacklisted the unit

function CreateNewLandSubteam(iPlateau, iIsland, tM28BrainsInSubteam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CreateNewLandSubteam'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    iTotalLandSubteamCount = iTotalLandSubteamCount + 1
    tLandSubteamData[iTotalLandSubteamCount] = {}
    tLandSubteamData[iTotalLandSubteamCount][subrefiLandCorePlateau] = iPlateau
    tLandSubteamData[iTotalLandSubteamCount][subrefiLandCoreIsland] = iIsland
    tLandSubteamData[iTotalLandSubteamCount][subrefBlueprintBlacklist] = {}

    tLandSubteamData[iTotalLandSubteamCount][subreftoFriendlyM28Brains] = {}
    for iBrain, oBrain in tM28BrainsInSubteam do
        table.insert(tLandSubteamData[iTotalLandSubteamCount][subreftoFriendlyM28Brains], oBrain)
        oBrain.M28LandSubteam = iTotalLandSubteamCount
    end
    tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech] = {[M28Factory.refiFactoryTypeLand] = {},
                                                                                     [M28Factory.refiFactoryTypeAir] = {},
                                                                                     [M28Factory.refiFactoryTypeNaval] = {},
                                                                                     [M28Factory.refiFactoryTypeOther] = {}}
    for iFactoryType, tSubtable in tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech] do
        tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech][iFactoryType] = {[M28UnitInfo.refFactionUEF] = {},
                     [M28UnitInfo.refFactionAeon] = {},
                     [M28UnitInfo.refFactionCybran] = {},
                     [M28UnitInfo.refFactionSeraphim] = {},
                     [M28UnitInfo.refFactionNomads] = {},
                     [M28UnitInfo.refFactionUnrecognised] = {}}
        for iFaction, tSubtable in tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech][iFactoryType] do
            tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFaction] = {[1]=0,[2]=0,[3]=0}
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Finished creating subteam for '..iTotalLandSubteamCount..'; tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech]='..repru(tLandSubteamData[iTotalLandSubteamCount][subrefFactoriesByTypeFactionAndTech])) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end



function CreateNewAirSubteam(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CreateNewAirSubteam'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    iTotalAirSubteamCount = iTotalAirSubteamCount + 1
    aiBrain.M28AirSubteam = iTotalAirSubteamCount
    tAirSubteamData[aiBrain.M28AirSubteam] = {}
    tAirSubteamData[aiBrain.M28AirSubteam][subreftoFriendlyM28Brains] = {}


    table.insert(tAirSubteamData[aiBrain.M28AirSubteam][subreftoFriendlyM28Brains], aiBrain)
    local tNearestEnemyBase = M28Map.GetPrimaryEnemyBaseLocation(aiBrain)
    if bDebugMessages == true then LOG(sFunctionRef..': aiBrain='..aiBrain.Nickname..'; Index='..aiBrain:GetArmyIndex()..'; tNearestEnemyBase='..repru(tNearestEnemyBase)..'; Our start point='..repru(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()])) end
    local iOurAngleToNearestEnemy = M28Utilities.GetAngleFromAToB(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()], tNearestEnemyBase)
    local bSameAirSubteam
    --Low threshold - if within this dist will be grouped regardless of angle difference
    --High threshold - if within certain angle differential then will group if satisfy this distance
    local iDistThresholdLow = math.max(math.min(aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.8, 100), aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.3)
    local iDistThresholdHigh = math.max(math.min(aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.9, 130), aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 0.5)
    if bDebugMessages == true then LOG(sFunctionRef..': Our dist to enemy='..aiBrain[M28Overseer.refiDistanceToNearestEnemyBase]..'; Low threshold='..iDistThresholdLow..'; High threshold='..iDistThresholdHigh..'; Angle to nearest enemy='..iOurAngleToNearestEnemy) end

    --Cycle through each brain in our team without a AirSubteam and consider if they should be in the same AirSubteam as this brain
    for iBrain, oBrain in tTeamData[aiBrain.M28Team][subreftoFriendlyActiveM28Brains] do
        --Make sure we have a primary base and distance to nearest enemy recorded
        M28Map.GetPrimaryEnemyBaseLocation(oBrain)
        if not(oBrain.M28AirSubteam) and not(oBrain == aiBrain) then
            bSameAirSubteam = false
            local iBaseDistDif = M28Utilities.GetDistanceBetweenPositions(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()])
            if bDebugMessages == true then LOG(sFunctionRef..': Considering ally brain '..oBrain.Nickname..'; iBaseDistDif='..iBaseDistDif..'; iAngleDif='..M28Utilities.GetAngleDifference(iOurAngleToNearestEnemy, M28Utilities.GetAngleFromAToB(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], tNearestEnemyBase))) end
            if iBaseDistDif <= iDistThresholdLow then
                bSameAirSubteam = true
            else
                local iAngleDif = M28Utilities.GetAngleDifference(iOurAngleToNearestEnemy, M28Utilities.GetAngleFromAToB(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], tNearestEnemyBase))
                if iAngleDif <= 40 or (iAngleDif <= 60 and iBaseDistDif <= iDistThresholdHigh) then
                    bSameAirSubteam = true
                else
                    --Are we close to the start position of any of the other brains already recorded in this AirSubteam?
                    for iAirSubteamBrain, oAirSubteamBrain in tAirSubteamData[aiBrain.M28AirSubteam][subreftoFriendlyM28Brains] do
                        if not(oAirSubteamBrain == aiBrain) and not(oAirSubteamBrain == oBrain) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Dist to alternative AirSubteam member '..oAirSubteamBrain.Nickname..' = '..M28Utilities.GetDistanceBetweenPositions(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], M28Map.PlayerStartPoints[oAirSubteamBrain:GetArmyIndex()])) end
                            if M28Utilities.GetDistanceBetweenPositions(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()], M28Map.PlayerStartPoints[oAirSubteamBrain:GetArmyIndex()]) <= iDistThresholdLow then
                                bSameAirSubteam = true
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': On same AirSubteam='..tostring(bSameAirSubteam)) end
            if bSameAirSubteam then
                oBrain.M28AirSubteam = aiBrain.M28AirSubteam
                table.insert(tAirSubteamData[aiBrain.M28AirSubteam][subreftoFriendlyM28Brains], oBrain)
            end
        end
    end


    AirSubteamInitialisation(aiBrain.M28AirSubteam) --Dont fork thread
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateUpgradeTrackingOfUnit(oUnitDoingUpgrade, bUnitDeadOrCompletedUpgrade, sUnitUpgradingRef)
    --bUnitDeadOrCompletedUpgrade is true if  a structure has just died or completed building a structure, in which case the unit might not have been upgrading but want to check
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateUpgradeTrackingOfUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, oUnitDoingUpgrade rerps='..reprs(oUnitDoingUpgrade)..'; bUnitDeadOrCompletedUpgrade='..tostring(bUnitDeadOrCompletedUpgrade)..'; sUnitUpgradingRef='..(sUnitUpgradingRef or 'nil')) end

    local sUpgradeTableRef
    if EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnitDoingUpgrade.UnitId) then
        sUpgradeTableRef = subreftTeamUpgradingHQs
    elseif EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnitDoingUpgrade.UnitId) then
        sUpgradeTableRef = subreftTeamUpgradingMexes
    else
        sUpgradeTableRef = subreftTeamUpgradingOther
    end
    local iTableRefOfUnit

    if M28Utilities.IsTableEmpty(tTeamData[oUnitDoingUpgrade:GetAIBrain().M28Team][sUpgradeTableRef]) == false then
        for iUnit, oUnit in tTeamData[oUnitDoingUpgrade:GetAIBrain().M28Team][sUpgradeTableRef] do
            if oUnit == oUnitDoingUpgrade then
                iTableRefOfUnit = iUnit
                break
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': sUpgradeTableRef='..sUpgradeTableRef..'; Is table of upgrading units empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[oUnitDoingUpgrade:GetAIBrain().M28Team][sUpgradeTableRef]))..'; iTableRefOfUnit if already in table='..(iTableRefOfUnit or 'nil')) end
    if iTableRefOfUnit then
        if bUnitDeadOrCompletedUpgrade then
            local iTeam = oUnitDoingUpgrade:GetAIBrain().M28Team
            table.remove(tTeamData[iTeam][sUpgradeTableRef], iTableRefOfUnit)
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnitDoingUpgrade:GetPosition(), true, oUnitDoingUpgrade)
            local tTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
            if M28Utilities.IsTableEmpty(tTeamData[iTeam][M28Map.subrefActiveUpgrades]) == false then
                for iUnit, oUnit in tTeamData[iTeam][M28Map.subrefActiveUpgrades] do
                    if oUnit == oUnitDoingUpgrade then
                        if bDebugMessages == true then LOG(sFunctionRef..': About to remove unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from the table of upgrades for iPlateau '..iPlateau..'; iLZ='..iLandZone) end
                        table.remove(tTeamData[iTeam][M28Map.subrefActiveUpgrades], iUnit)
                        break
                    end
                end
            end
        elseif bDebugMessages == true then LOG(sFunctionRef..': Unit already in the table so wont readd it')
        end
    else
        if not(bUnitDeadOrCompletedUpgrade) then
            local iTeam = oUnitDoingUpgrade:GetAIBrain().M28Team
            table.insert(tTeamData[iTeam][sUpgradeTableRef], oUnitDoingUpgrade)
            if sUnitUpgradingRef then
                local oNewUnitBP = __blueprints[sUnitUpgradingRef]
                if bDebugMessages == true then LOG(sFunctionRef..': About to update the energy and mass upgrades started this cycle for the unti energy and amss costs. Mass upgrade before this='..tTeamData[iTeam][subrefiMassUpgradesStartedThisCycle]) end
                if oNewUnitBP then
                    local iOurBuildPower = oUnitDoingUpgrade:GetBlueprint().Economy.BuildRate
                    local iBuildCost = oNewUnitBP.Economy.BuildTime
                    if iBuildCost > 0 and iOurBuildPower > 0 then
                        local iResourceFactor = 0.1 * iOurBuildPower / iBuildCost
                        tTeamData[iTeam][subrefiEnergyUpgradesStartedThisCycle] = tTeamData[iTeam][subrefiEnergyUpgradesStartedThisCycle] + oNewUnitBP.Economy.BuildCostEnergy * iResourceFactor
                        tTeamData[iTeam][subrefiMassUpgradesStartedThisCycle] = tTeamData[iTeam][subrefiMassUpgradesStartedThisCycle] + oNewUnitBP.Economy.BuildCostMass * iResourceFactor
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Updated this cycle check, tTeamData[iTeam][subrefiMassUpgradesStartedThisCycle]='..tTeamData[iTeam][subrefiMassUpgradesStartedThisCycle]) end
            end

            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnitDoingUpgrade:GetPosition(), true, oUnitDoingUpgrade)
            local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
            if bDebugMessages == true then LOG(sFunctionRef..': tTeamData[iTeam][M28Map.subrefActiveUpgrades] before adding unit='..reprs(tTeamData[iTeam][M28Map.subrefActiveUpgrades])) end
            if not(tLZTeamData[M28Map.subrefActiveUpgrades]) then
                tLZTeamData[M28Map.subrefActiveUpgrades] = {}
                if bDebugMessages == true then LOG(sFunctionRef..': LZ Upgrade was nil so making it a table, reprs='..reprs(tLZTeamData[M28Map.subrefActiveUpgrades])) end
            end
            table.insert(tLZTeamData[M28Map.subrefActiveUpgrades], oUnitDoingUpgrade)
            if bDebugMessages == true then LOG(sFunctionRef..': Just added unit to the upgrade table for the team '..iTeam..'; Plateau '..iPlateau..'; LZ='..iLandZone..'; Is table of active upgrades empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefActiveUpgrades]))..'; Reprs of tLZTeamData[activeupgrades]='..reprs(tLZTeamData[M28Map.subrefActiveUpgrades])) end
        elseif bDebugMessages == true then LOG(sFunctionRef..': Unit dead or compelted, but not in the table so no need to remove it')
        end
    end

    --Clear trackers from the unit that was doing the upgrade

    if bUnitDeadOrCompletedUpgrade and oUnitDoingUpgrade.UnitId then
        if bDebugMessages == true then LOG(sFunctionRef..': Just finished upgrading '..(oUnitDoingUpgrade.UnitId or 'nil')..M28UnitInfo.GetUnitLifetimeCount(oUnitDoingUpgrade)..'; is table of units assisting this empty='..tostring(M28Utilities.IsTableEmpty(oUnitDoingUpgrade[M28UnitInfo.reftoUnitsAssistingThis]))) end
        if M28Utilities.IsTableEmpty(oUnitDoingUpgrade[M28UnitInfo.reftoUnitsAssistingThis]) == false then
            local tUnitsToClear = {}
            for iUnit, oUnit in oUnitDoingUpgrade[M28UnitInfo.reftoUnitsAssistingThis] do
                if M28UnitInfo.IsUnitValid(oUnit) and EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) and oUnit[M28Engineer.refiAssignedAction] == M28Engineer.refActionAssistUpgrade then
                    table.insert(tUnitsToClear, oUnit)
                end
            end
            if M28Utilities.IsTableEmpty(tUnitsToClear) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Just finished upgrading '..oUnitDoingUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitDoingUpgrade)..'; will clear assisting engineers, table size='..table.getn(tUnitsToClear)) end
                for iUnit, oUnit in tUnitsToClear do
                    M28Orders.IssueTrackedClearCommands(oUnit)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CreateNewTeam(aiBrain)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CreateNewTeam'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    iTotalTeamCount = iTotalTeamCount + 1
    tTeamData[iTotalTeamCount] = {}
    tTeamData[iTotalTeamCount][subreftoFriendlyActiveM28Brains] = {}
    tTeamData[iTotalTeamCount][subreftoFriendlyActiveBrains] = {}
    tTeamData[iTotalTeamCount][subrefbTeamHasOmni] = false
    tTeamData[iTotalTeamCount][subrefbEnemyHasOmni] = false
    tTeamData[iTotalTeamCount][subreftoEnemyBrains] = {}
    tTeamData[iTotalTeamCount][subrefiActiveM28BrainCount] = 0
    tTeamData[iTotalTeamCount][subreftTeamUpgradingOther] = {}
    tTeamData[iTotalTeamCount][subreftTeamUpgradingMexes] = {}
    tTeamData[iTotalTeamCount][subreftTeamUpgradingHQs] = {}
    tTeamData[iTotalTeamCount][subrefiHighestEnemyGroundTech] = 0
    tTeamData[iTotalTeamCount][subrefiHighestEnemyAirTech] = 0
    tTeamData[iTotalTeamCount][subrefiHighestEnemyNavyTech] = 0
    tTeamData[iTotalTeamCount][subrefbTeamIsStallingEnergy] = false
    tTeamData[iTotalTeamCount][subrefbTeamIsStallingMass] = false
    tTeamData[iTotalTeamCount][subreftiPrevTeamNetMass] = {}
    tTeamData[iTotalTeamCount][subrefiGrossEnergyWhenStalled] = 0
    tTeamData[iTotalTeamCount][refiTimeOfLastEnergyStall] = 0
    tTeamData[iTotalTeamCount][refiTimeOfLastEngiSelfDestruct] = 0
    tTeamData[iTotalTeamCount][refbNeedResourcesForMissile] = false
    tTeamData[iTotalTeamCount][subrefiLandZonesWantingSupportByPlateau] = {}


    local bHaveM28BrainInTeam = false
    local bHaveOmniVision = false
    for iCurBrain, oBrain in ArmyBrains do
        if IsAlly(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()) then
            oBrain.M28Team = iTotalTeamCount
            table.insert(tTeamData[iTotalTeamCount][subreftoFriendlyActiveBrains], oBrain)
            if oBrain.M28AI then
                table.insert(tTeamData[iTotalTeamCount][subreftoFriendlyActiveM28Brains], oBrain)
                tTeamData[iTotalTeamCount][subrefiActiveM28BrainCount] = tTeamData[iTotalTeamCount][subrefiActiveM28BrainCount] + 1
            end
            bHaveM28BrainInTeam = true
            --Check if we have omni vision for the team
            if oBrain.CheatEnabled and ScenarioInfo.Options.OmniCheat == 'on' then
                tTeamData[iTotalTeamCount][subrefbTeamHasOmni] = true
            end
        elseif IsEnemy(oBrain:GetArmyIndex(), aiBrain:GetArmyIndex()) and not(M28Conditions.IsCivilianBrain(oBrain)) then
            table.insert(tTeamData[iTotalTeamCount][subreftoEnemyBrains], oBrain)
            --Check if anyone on enemy team has omni
            if oBrain.CheatEnabled and ScenarioInfo.Options.OmniCheat == 'on' then
                tTeamData[iTotalTeamCount][subrefbEnemyHasOmni] = true
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Setup a team with team ref/iTotalTeamCount='..iTotalTeamCount..'; do we have M28 brain in this team='..tostring(bHaveM28BrainInTeam)) end
    if bHaveM28BrainInTeam then
        UpdateTeamHighestAndLowestFactories(iTotalTeamCount)

        --Group allies into AirSubteams based on nearest enemy; then split the air subteam between land subteams if they are in different plateaus
        for iBrain, oBrain in tTeamData[iTotalTeamCount][subreftoFriendlyActiveM28Brains] do
            if not(oBrain.M28AirSubteam) then
                CreateNewAirSubteam(oBrain)
                local tiIslandBrainsInSubteam = {}
                local tiPlateauByIslandRefs = {}
                local iStartPlateau, iStartIsland
                for iBrain, oBrain in tAirSubteamData[oBrain.M28AirSubteam][subreftoFriendlyM28Brains] do
                    iStartPlateau = NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                    iStartIsland = NavUtils.GetLabel(M28Map.refPathingTypeLand, M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])

                    if not(tiIslandBrainsInSubteam[iStartIsland]) then tiIslandBrainsInSubteam[iStartIsland] = {} end
                    table.insert(tiIslandBrainsInSubteam[iStartIsland], oBrain)
                    tiPlateauByIslandRefs[iStartIsland] = iStartPlateau
                end
                for iStartIsland, tBrains in tiIslandBrainsInSubteam do
                    CreateNewLandSubteam(tiPlateauByIslandRefs[iStartIsland], iStartIsland, tBrains)
                end
            end
        end

        ForkThread(TeamInitialisation, iTotalTeamCount)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordAllPlayers()

    --Call via forkthread from initialisation, so 1 tick after the first brain will have been created
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAllPlayers'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if not(bRecordedAllPlayers) then
        bRecordedAllPlayers = true
        for iBrain, oBrain in ArmyBrains do
            if not(M28Conditions.IsCivilianBrain(oBrain)) then
                iPlayersAtGameStart = iPlayersAtGameStart + 1
                if not(oBrain.M28Team) then
                    CreateNewTeam(oBrain)
                end
            end
        end
    end


    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RemoveUnitFromCurrentLandZone(aiBrain, oUnit)
    M28Utilities.ErrorHandler('To add code')
end

function AddUnitToLandZoneForBrain(aiBrain, oUnit, iPlateau, iLandZone)
    --If unit already has a land zone assigned then remove this
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddUnitToLandZoneForBrain'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local bAddToZone = true
    if oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] and oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][aiBrain.M28Team] then
        --Is the unit already assigned to this zone?
        if oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][aiBrain.M28Team][1] == iPlateau and oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][aiBrain.M28LandTeam][2] == iLandZone then
            if bDebugMessages == true then LOG(sFunctionRef..': Unit is already assigned to this plateau and land zone so will abort adding it') end
            bAddToZone = false
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Unit already has a plateau and LZ assigned but is dif from the desired one so will remove from its current zone first') end
            RemoveUnitFromCurrentLandZone(aiBrain, oUnit)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Considering adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to iPlateau '..iPlateau..'; iLandZone='..iLandZone..' for brain '..aiBrain.Nickname..'; bAddToZone='..tostring(bAddToZone)..'; Is enemy='..tostring(IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()))..'; Is ally='..tostring(IsAlly(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()))) end
    if bAddToZone then
        if not(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) then oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] = {} end
        oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][aiBrain.M28Team] = {iPlateau, iLandZone}
        if IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()) then
            table.insert(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZTEnemyUnits], oUnit)
        elseif IsAlly(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()) then
            table.insert(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZTAlliedUnits], oUnit)
            if bDebugMessages == true then LOG(sFunctionRef..': Add unit as a friendly unit to Plateau-LZ='..iPlateau..'-'..iLandZone..' and team='..aiBrain.M28Team..'; Is table of friendly units empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZTAlliedUnits]))) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function UpdateUnitLastKnownPosition(aiBrain, oUnit, bDontCheckIfCanSeeUnit)
    --Only updates the position if the unit isnt on the same team as us (to save space), since we can use :GetPosition() for allied units
    --Checks if the unti needs reassigning if it is a land or naval unit
    local oUnitBrain = oUnit:GetAIBrain()

    if not(oUnitBrain == aiBrain or IsAlly(aiBrain:GetArmyIndex(), oUnitBrain:GetArmyIndex())) then
        if bDontCheckIfCanSeeUnit or M28Conditions.CanSeeUnit(aiBrain, oUnit) then
            if not(oUnit[M28UnitInfo.reftLastKnownPositionByTeam]) then oUnit[M28UnitInfo.reftLastKnownPositionByTeam] = {} end
            local tCurPosition = oUnit:GetPosition()
            oUnit[M28UnitInfo.reftLastKnownPositionByTeam][aiBrain.M28Team] = {tCurPosition[1], tCurPosition[2], tCurPosition[3]} --Do a copy of table as :GetPosition() means it will always update for the unit's latest position even when we lack intel of it
        end
    end
end

function ConsiderAssigningUnitToZoneForBrain(aiBrain, oUnit)
    --Assumes called from an event that menas we will have visibility of the unit (e.g. directly via intel, or indirectly via weapon firing)
    if aiBrain.M28AI and aiBrain.M28Team then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'ConsiderAssigningUnitToZoneForBrain'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if should assign unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to a plateau/other table. Considered for assignment repru='..repru(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam])..'; Unit brain team='..(oUnit:GetAIBrain().M28Team or 'nil')..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oUnit))) end
        if (not(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam]) or not(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][aiBrain.M28Team])) and M28UnitInfo.IsUnitValid(oUnit) and not(aiBrain.M28IsDefeated) then
            AssignUnitToZoneOrPond(aiBrain, oUnit)
        else
            UpdateUnitLastKnownPosition(aiBrain, oUnit, true)
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

--TO HELP WITH LOCATING - use AssignUnitToZoneOrPond
function RecordUnitInZoneOrPond()  end
---@param aiBrain userdata
---@param oUnit userdata
function AssignUnitToZoneOrPond(aiBrain, oUnit, bAlreadyUpdatedPosition)
    --Assigns oUnit to relevant table for aiBrain; Should be called if we have a unit that hasn't been considered before (check by referencing oUnit[reftbConsideredForAssignmentByTeam][iTeam]) - will decide whether the unit should be assigned to a pond, a land zone, or air units, based partially on the unit category and partially on its current position
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignUnitToZoneOrPond'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if not(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam]) then oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam] = {} end
    if not(oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][aiBrain.M28Team]) then oUnit[M28UnitInfo.reftbConsideredForAssignmentByTeam][aiBrain.M28Team] = true end

    if not(bAlreadyUpdatedPosition) then
        UpdateUnitLastKnownPosition(aiBrain, oUnit, true)
        if IsEnemy(aiBrain:GetArmyIndex(), oUnit:GetAIBrain():GetArmyIndex()) and aiBrain.M28AI then UpdateEnemyTechTracking(aiBrain.M28Team, oUnit) end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': aiBrain '..aiBrain.Nickname..' is Considering how to assign unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that is owned by brain '..oUnit:GetAIBrain().Nickname) end


    --Air units - always assign to air groups
    if EntityCategoryContains(M28UnitInfo.refCategoryAllAir - M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
        M28Utilities.ErrorHandler('To add code for air units')
    else
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
        if bDebugMessages == true then LOG(sFunctionRef..': Unit iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
        if iLandZone > 0 then
            --Unit is in a land zone so assign it to a land zone instead of a pond
            AddUnitToLandZoneForBrain(aiBrain, oUnit, iPlateau, iLandZone)
        elseif iPlateau > 0 then
            --If unit is on water then assign it to a pond
            local iCurPond = NavUtils.GetLabel(M28Map.refPathingTypeNavy, oUnit:GetPosition())
            if iCurPond > 0 then
                M28Utilities.ErrorHandler('#To add code for naval units')
            else
                --Not an air unit; no land zone or pond; assign to backup list of units - e.g. it could be the unit is attached to a transport
                M28Utilities.ErrorHandler('To add code for nonair units not on land or water')
            end
        else
            --No valid plateau or land zone for unit so likely a pathing error; have unit move randomly if we are updating for the owner
            ForkThread(HaveGroundUnitWithNoPlateau, aiBrain, oUnit)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Is plateau 12 LZ 2 empty of allies for team 2='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[12][M28Map.subrefPlateauLandZones][2][M28Map.subrefLZTeamData][2][M28Map.subrefLZTAlliedUnits]))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function HaveGroundUnitWithNoPlateau(oTrackingBrain, oUnit)
    --Give new orders to the unit if it is an M28 unit; aiBrain should be on the same team and is the brain that we will be updating the plateau and LZ tracking for
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'HaveGroundUnitWithNoPlateau'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local refsTrackingVariable = 'M28ActiveNoPlateau'..oTrackingBrain:GetArmyIndex()

    if M28UnitInfo.IsUnitValid(oUnit) and not(oUnit[refsTrackingVariable]) then --Brain check is a redundancy
        if bDebugMessages == true then
            LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' doesnt appear to have a valid location, will monitor until it has a valid location; will draw unit cur position')
            M28Utilities.DrawLocation(oUnit:GetPosition())
        end
        oUnit[refsTrackingVariable] = true
        local iPlateau, iLandZone
        local iBaseAngle, iBaseDistance
        local tPotentialTempMoveLocation
        local iPlateauToTryAndFind
        local sPathing = M28UnitInfo.GetUnitPathingType
        local bConsiderMoving = false
        if oUnit:GetAIBrain().M28AI then bConsiderMoving = true end
        while M28UnitInfo.IsUnitValid(oUnit) do
            iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
            if bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' postiion='..repru(oUnit:GetPosition())..'; Unit plateau group='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; Actual plateau group ignoring segment='..(NavUtils.GetLabel(sPathing, tPotentialTempMoveLocation) or 'nil')) end
            if iPlateau > 0 then break end
            if bConsiderMoving then
                M28Orders.UpdateRecordedOrders(oUnit)
                if not(oUnit[M28Orders.reftiLastOrders]) then
                    --Give a move order to a random place
                    iBaseAngle = math.random(1, 360)
                    iBaseDistance = math.random(5, 10)
                    iPlateauToTryAndFind = NavUtils.GetLabel(sPathing, oUnit:GetPosition())
                    if not(iPlateauToTryAndFind > 0) then iPlateauToTryAndFind = nil end
                    for iAngleAdjust = 0, 45, 360 do
                        tPotentialTempMoveLocation = M28Utilities.MoveInDirection(oUnit:GetPosition(), iBaseAngle + iAngleAdjust, iBaseDistance, true, false)
                        if not(iPlateauToTryAndFind) or NavUtils.GetLabel(sPathing, tPotentialTempMoveLocation) == iPlateauToTryAndFind then
                            break --Use this as the move location
                        end
                    end
                    M28Orders.IssueTrackedMove(oUnit, tPotentialTempMoveLocation, 3, false, 'RandPath')

                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitSeconds(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
        --Have a valid plateau so stop tracking and send for reassignment
        oUnit[refsTrackingVariable] = false
        AssignUnitToZoneOrPond(oTrackingBrain, oUnit)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


--[[function UpdateUnitPond(oUnit, iM28TeamUpdatingFor, bIsEnemy, iPondRefOverride)
    --Check the unit's pond; ignore this for non-M28 friendly units
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateUnitPond'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --if bDebugMessages == true then M28Utilities.ErrorHandler('Audit trail', true) end

    --if oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit) == 'xes02051' and oUnit:GetAIBrain():GetArmyIndex() == 2 and GetGameTimeSeconds() >= 840 then bDebugMessages = true end
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, bIsEnemy='..tostring((bIsEnemy or false))..'; Unit brain index='..oUnit:GetAIBrain():GetArmyIndex()..'; Unit assigned pond='..(oUnit[refiAssignedPond] or 'nil')..'; Contains fixed pond category='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryPondFixedCategory, oUnit.UnitId))) end

    if bIsEnemy or (oUnit:GetAIBrain().M28AI and (not(oUnit[refiAssignedPond]) or not(EntityCategoryContains(M28UnitInfo.refCategoryPondFixedCategory, oUnit.UnitId)))) then --and not(oUnit[reftisubrefsUpdatedFor][iM28TeamUpdatingFor])) then
        local iCurPond = iPondRefOverride or M28MapInfo.GetSegmentGroupOfLocation(M28UnitInfo.refPathingTypeNavy, oUnit:GetPosition())
        if bDebugMessages == true then LOG(sFunctionRef..': bIsEnemy='..tostring(bIsEnemy)..'; Updating for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iPondRefOverride='..(iPondRefOverride or 'nil')..'; iCurPond='..(iCurPond or 'nil')..'; oUnit[refiAssignedPond]='..(oUnit[refiAssignedPond] or 'nil')) end --LOG('iCurPond pre adj='..(iCurPond or 'nil'))
        --if tPondDetails[iCurPond] then LOG('Pond size='..(tPondDetails[iCurPond][subrefPondSize] or 'nil')) end
        if not(tPondDetails[iCurPond]) or (tPondDetails[iCurPond][subrefPondSize] or 0) <= iMinPondSize then
            --If have a naval unit that isnt amphibious then update pathing
            if bDebugMessages == true then LOG(sFunctionRef..': Dont have details for the pond recorded, if its a naval unit then will check for if there is a pond nearby') end
            if EntityCategoryContains(categories.NAVAL * categories.MOBILE - categories.HOVER - categories.AMPHIBIOUS - categories.AIR - categories.LAND, oUnit.UnitId) then
                iCurPond = CheckForPondNearNavalUnit(oUnit)
                if bDebugMessages == true then LOG(sFunctionRef..': iCurPond after checking for pond near naval unit='..iCurPond) end
            else
                iCurPond = 0
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iCurPond after updating for naval unit and min pond size='..(iCurPond or 'nil')..'; oUnit[refiAssignedPond]='..(oUnit[refiAssignedPond] or 'nil')) end
        if iCurPond > 0 then
            oUnit[M28UnitInfo.reftLastKnownPosition] = {oUnit:GetPosition()[1], oUnit:GetPosition()[2], oUnit:GetPosition()[3]}
            if bDebugMessages == true then LOG(sFunctionRef..': Updated unit last known position') end
        end
        if oUnit[refiAssignedPond] then
            if not(iCurPond == oUnit[refiAssignedPond]) then
                if bDebugMessages == true then LOG('Removing unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from old pond '..(oUnit[refiAssignedPond] or 'nil')..' and adding to new pond iCurPond='..iCurPond) end
                RemoveUnitFromAssignedPond(oUnit)
                AddUnitToPond(oUnit, iCurPond, iM28TeamUpdatingFor, bIsEnemy)
            elseif not(oUnit[reftisubrefsUpdatedFor][iM28TeamUpdatingFor]) then
                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to pond '..iCurPond) end
                AddUnitToPond(oUnit, iCurPond, iM28TeamUpdatingFor, bIsEnemy)
            end
        else
            if iCurPond > 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to pond '..iCurPond) end
                AddUnitToPond(oUnit, iCurPond, iM28TeamUpdatingFor, bIsEnemy)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end--]]

function UpdateFactionBlueprintBlacklist(iSubteam)
    --Considers any blueprint specific overrides (only supports the 4 core factions and not modded units since blueprint values are hardcoded)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateFactionBlueprintBlacklist'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    tLandSubteamData[iSubteam][subrefBlueprintBlacklist] = {}


    --Land scouts
    if M28Conditions.HaveFactionTech(iSubteam, M28Factory.refiFactoryTypeLand, M28UnitInfo.refFactionAeon, 1) then
        --Only want Aeon land scouts
        tLandSubteamData[iSubteam][subrefBlueprintBlacklist]['uel0101'] = true --UEF land scout
        tLandSubteamData[iSubteam][subrefBlueprintBlacklist]['url0101'] = true --Cybran land scout
        tLandSubteamData[iSubteam][subrefBlueprintBlacklist]['xsl0101'] = true --Seraphim land scout
    elseif M28Conditions.HaveFactionTech(iSubteam, M28Factory.refiFactoryTypeLand, M28UnitInfo.refFactionCybran, 1) then
        --If have cybran tech then prioritise this
        tLandSubteamData[iSubteam][subrefBlueprintBlacklist]['uel0101'] = true --UEF land scout
        tLandSubteamData[iSubteam][subrefBlueprintBlacklist]['xsl0101'] = true --Seraphim land scout
    elseif M28Conditions.HaveFactionTech(iSubteam, M28Factory.refiFactoryTypeLand, M28UnitInfo.refFactionUEF, 1) then
        tLandSubteamData[iSubteam][subrefBlueprintBlacklist]['xsl0101'] = true --Seraphim land scout
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, blacklist for subteam '..iSubteam..' = '..repru(tLandSubteamData[iSubteam][subrefBlueprintBlacklist])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)



end

function CheckForSubteamFactoryChange(oUnit, bJustBuiltNotDied)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckForSubteamFactoryChange'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnit.UnitId) then
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
        local iSubteam = oUnit:GetAIBrain().M28LandSubteam
        if iPlateau == tLandSubteamData[iSubteam][subrefiLandCorePlateau] and NavUtils.GetLabel(M28Map.refPathingTypeLand, oUnit:GetPosition()) == tLandSubteamData[iSubteam][subrefiLandCoreIsland] then
            local iFactoryType = M28UnitInfo.GetFactoryType(oUnit)
            local iFactoryTechLevel = M28UnitInfo.GetUnitTechLevel(oUnit)
            local iFactoryFaction = M28UnitInfo.GetUnitFaction(oUnit)


            local bChangedFactoryTech = false
            --Do we have any higher tech than this?
            local bHaveHigherTech = false
            if iFactoryTechLevel < 3 then
                for iHigherTech = iFactoryTechLevel + 1, 2 do
                    if (tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iHigherTech] or 0) > 0 then
                        bHaveHigherTech = true
                        break
                    end
                end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have had a factory tech change, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bJustBuiltNotDied='..tostring(bJustBuiltNotDied or false)..'; iFactoryType='..iFactoryType..'; iPlateau='..iPlateau..'; IslandRef='..NavUtils.GetLabel(M28Map.refPathingTypeLand, oUnit:GetPosition())..'; iFactoryTechLevel='..iFactoryTechLevel..'; iFactoryFaction='..iFactoryFaction..'; iSubteam='..iSubteam..'; tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech]='..repru(tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech])) end

            if bJustBuiltNotDied then
                --Check if need to add the unit to the subteam table
                if (tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] or 0) <= 0 then
                    if not(bHaveHigherTech) then bChangedFactoryTech = true end
                    tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] = 1
                else
                    tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] = tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] + 1
                end
            else
                if tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] == 1 then
                    if not(bHaveHigherTech) then bChangedFactoryTech = true end
                end
                tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] = math.max(0, tLandSubteamData[iSubteam][subrefFactoriesByTypeFactionAndTech][iFactoryType][iFactoryFaction][iFactoryTechLevel] - 1)
            end

            if bChangedFactoryTech then
                UpdateFactionBlueprintBlacklist(iSubteam)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateTeamHighestAndLowestFactories(iM28Team)
    --Called whenever an M28 brain gains or loses an HQ factory; for convenience will update all factory types (even thoguh marginally more efficient to only update the type in question)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateTeamHighestAndLowestFactories'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] = 3
    tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] = 3
    tTeamData[iM28Team][subrefiLowestFriendlyNavalFactoryTech] = 3
    tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] = 0
    tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech] = 0
    tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech] = 0

    if bDebugMessages == true then LOG(sFunctionRef..': Lowest friendly land fac start point (will decrease to lower of this and actual tech)='..tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]) end

    for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
        if not(oBrain[M28Economy.refiOurHighestFactoryTechLevel]) then --saves having to define the variables earlier
            oBrain[M28Economy.refiOurHighestFactoryTechLevel] = 0
            oBrain[M28Economy.refiOurHighestLandFactoryTech] = 0
            oBrain[M28Economy.refiOurHighestAirFactoryTech] = 0
            oBrain[M28Economy.refiOurHighestNavalFactoryTech] = 0
        end
        if bDebugMessages == true then LOG(sFunctionRef..': subrefiLowestFriendlyLandFactoryTech before reducing='..tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]..'; oBrain[M28Economy.refiOurHighestLandFactoryTech]='..oBrain[M28Economy.refiOurHighestLandFactoryTech]..'; lower of these two='..math.min(tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech], oBrain[M28Economy.refiOurHighestLandFactoryTech])) end
        tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] = math.min(tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech], oBrain[M28Economy.refiOurHighestLandFactoryTech])
        if bDebugMessages == true then LOG(sFunctionRef..': tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] after update='..tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]) end
        tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] = math.min(tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech], oBrain[M28Economy.refiOurHighestAirFactoryTech])
        tTeamData[iM28Team][subrefiLowestFriendlyNavalFactoryTech] = math.min(tTeamData[iM28Team][subrefiLowestFriendlyNavalFactoryTech], oBrain[M28Economy.refiOurHighestNavalFactoryTech])

        tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] = math.max(tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech], oBrain[M28Economy.refiOurHighestLandFactoryTech])
        tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech] = math.max(tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech], oBrain[M28Economy.refiOurHighestAirFactoryTech])
        tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech] = math.max(tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech], oBrain[M28Economy.refiOurHighestNavalFactoryTech])
        if bDebugMessages == true then LOG(sFunctionRef..': Considering brain '..oBrain.Nickname..'; tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]='..tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]..'; oBrain[M28Economy.refiOurHighestLandFactoryTech]='..oBrain[M28Economy.refiOurHighestLandFactoryTech]) end
    end
    tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] = math.max(tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech], tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech], tTeamData[iM28Team][subrefiHighestFriendlyNavalFactoryTech])
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DoesBrainHaveActiveHQUpgradesOfCategory(aiBrain, iFactoryBeingUpgradedCategory)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DoesBrainHaveActiveHQUpgradesOfCategory'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Does our team have an empty table of upgrading HQs='..tostring(M28Utilities.IsTableEmpty(tTeamData[aiBrain.M28Team][subreftTeamUpgradingHQs]))) end
    if M28Utilities.IsTableEmpty(tTeamData[aiBrain.M28Team][subreftTeamUpgradingHQs]) == false then
        for iUpgrading, oUpgrading in tTeamData[aiBrain.M28Team][subreftTeamUpgradingHQs] do
            if EntityCategoryContains(iFactoryBeingUpgradedCategory, oUpgrading.UnitId) then
                if M28UnitInfo.IsUnitValid(oUpgrading) and oUpgrading:GetAIBrain() == aiBrain then
                    if bDebugMessages == true then LOG(sFunctionRef..': The upgrading unit '..oUpgrading.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUpgrading)..' brain is equal to aiBrain '..aiBrain.Nickname) end
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function ConsiderPriorityLandFactoryUpgrades(iM28Team)
    --Starts a land factory upgrade if we need one urgently
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderPriorityLandFactoryUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Enemy has better land tech than us, and we have no active land upgrades

    if bDebugMessages == true then LOG(sFunctionRef..': tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech]='..(tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] or 'nil')..'; tTeamData[iM28Team][subrefiHighestEnemyGroundTech]='..(tTeamData[iM28Team][subrefiHighestEnemyGroundTech] or 'nil')) end
    if tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] > 0 and tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech] < tTeamData[iM28Team][subrefiHighestEnemyGroundTech] then
        local bWantUpgrade = false
        for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
            --Can we path to the nearest enemy with land, and we are behind enemy tech level with land?
            if bDebugMessages == true then LOG(sFunctionRef..': Considering oBrain '..oBrain.Nickname..'; oBrain[M28Map.refbCanPathToEnemyBaseWithLand]='..tostring(oBrain[M28Map.refbCanPathToEnemyBaseWithLand])..'; oBrain[M28Economy.refiOurHighestLandFactoryTech]='..oBrain[M28Economy.refiOurHighestLandFactoryTech]) end
            if oBrain[M28Map.refbCanPathToEnemyBaseWithLand] and oBrain[M28Economy.refiOurHighestLandFactoryTech] > 0 and oBrain[M28Economy.refiOurHighestLandFactoryTech] < tTeamData[iM28Team][subrefiHighestEnemyGroundTech] then
                --Do we have any active land factory upgrades?
                bWantUpgrade = not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ))

                if bWantUpgrade then
                    M28Economy.FindAndUpgradeUnitOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ * M28UnitInfo.ConvertTechLevelToCategory(oBrain[M28Economy.refiOurHighestLandFactoryTech]))
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderPriorityAirFactoryUpgrades(iM28Team)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderPriorityAirFactoryUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]..'; tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]) end

    if tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech] > 0 and tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech] < 3 then
        local bWantUpgrade = false
        --Prioritise air factory if we dont have T2 air and enemy has navy - TODO
        if tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] < 2 and tTeamData[iM28Team][subrefiHighestEnemyNavyTech] > 0 then
            for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
                if oBrain[M28Economy.refiOurHighestAirFactoryTech] > 0 and oBrain[M28Economy.refiOurHighestAirFactoryTech] < 2 then
                    bWantUpgrade = true
                    M28Economy.FindAndUpgradeUnitOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ * categories.TECH1)
                end
            end
        end
        --Prioritise air factory if enemy has T3 air and we dont
        if not(bWantUpgrade) and tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech] < tTeamData[iM28Team][subrefiHighestEnemyAirTech] and tTeamData[iM28Team][subrefiHighestEnemyAirTech] >= 3 then
            for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
                if oBrain[M28Economy.refiOurHighestAirFactoryTech] > 0 and oBrain[M28Economy.refiOurHighestAirFactoryTech] < 3 then
                    --Do we have any active air factory upgrades?
                    bWantUpgrade = not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ))

                    if bWantUpgrade then
                        M28Economy.FindAndUpgradeUnitOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ * M28UnitInfo.ConvertTechLevelToCategory(oBrain[M28Economy.refiOurHighestAirFactoryTech]))
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderPriorityMexUpgrades(iM28Team)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderPriorityMexUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of upgrading mexes empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]))..'; tTeamData[iM28Team][subrefiTeamMassStored]='..tTeamData[iM28Team][subrefiTeamMassStored]..'; tTeamData[iM28Team][subrefiTeamNetMass]='..tTeamData[iM28Team][subrefiTeamNetMass]..'; tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]='..tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]) end
    if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) or (tTeamData[iM28Team][subrefiTeamMassStored] >= 200 or (tTeamData[iM28Team][subrefiTeamNetMass] - tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]) > 0) then
        --Do we have enough energy?
        if tTeamData[iM28Team][subrefiTeamNetEnergy] - tTeamData[iM28Team][subrefiEnergyUpgradesStartedThisCycle] > 0 and (tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] >= 0.75 or tTeamData[iM28Team][subrefiTeamNetEnergy] - tTeamData[iM28Team][subrefiEnergyUpgradesStartedThisCycle] >= 5) then
            --Do we have mexes in start positions that are lower than the enemy's highest tech?
            local iTechLevelToUpgrade = math.min(3, (tTeamData[iM28Team][subrefiHighestEnemyMexTech] or 0)) - 1
            if iTechLevelToUpgrade >= 1 then
                local iPlateau, iLandZone, tMexesToConsiderUpgrading
                local bAbort = false

                --Want to be upgrading at least 1 mex on our team, or more if we have positive mass income
                local tiExtraMassStoredPerUpgrade = {[1] = 300, [2] = 1000}
                local iMassStoredToKeepUpgrading = 0
                if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) == false then
                    for iUnit, oUnit in tTeamData[iM28Team][subreftTeamUpgradingMexes] do
                        iMassStoredToKeepUpgrading = iMassStoredToKeepUpgrading + tiExtraMassStoredPerUpgrade[M28UnitInfo.GetUnitTechLevel(oUnit)]
                    end
                end



                for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
                    bAbort = false
                    iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
                    --Dont do priority upgrade if this location already has an upgrade
                    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iM28Team][M28Map.subrefActiveUpgrades]) then
                        for iMexTech = 1, iTechLevelToUpgrade do
                            if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iM28Team][M28Map.subrefMexCountByTech][iMexTech] > 0 then
                                tMexesToConsiderUpgrading = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex * M28UnitInfo.ConvertTechLevelToCategory(iMexTech), M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZTAlliedUnits])
                                if M28Utilities.IsTableEmpty(tMexesToConsiderUpgrading) == false then
                                    for iMex, oMex in tMexesToConsiderUpgrading do
                                        if not(oMex:IsUnitState('Upgrading')) and oMex:GetFractionComplete() == 1 then
                                            if oMex:GetAIBrain().M28AI and oMex:GetAIBrain().M28Team == iM28Team then
                                                M28Economy.UpgradeUnit(oMex, true)
                                                iMassStoredToKeepUpgrading = iMassStoredToKeepUpgrading + tiExtraMassStoredPerUpgrade[iMexTech]
                                                bAbort = true
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                            if bAbort then break end
                        end
                    end
                    if bAbort then
                        --Do we have positive mass income or lots of mass stored? If so then proceed to upgrade for other brains
                        if tTeamData[iM28Team][subrefiTeamNetEnergy] - tTeamData[iM28Team][subrefiEnergyUpgradesStartedThisCycle] > 0 then
                            if (tTeamData[iM28Team][subrefiTeamNetMass] - tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]) > 0 or tTeamData[iM28Team][subrefiTeamMassStored] >= iMassStoredToKeepUpgrading then
                                bAbort = false
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AddPotentialUnitsToShortlist(toUnitShortlist, tPotentialUnits, bDontCheckIfSafe)
    if M28Utilities.IsTableEmpty(tPotentialUnits) == false then
        for iUnit, oUnit in tPotentialUnits do
            if not(oUnit:IsUnitState('Upgrading')) and oUnit:GetFractionComplete() == 1 and (bDontCheckIfSafe or M28Conditions.SafeToUpgradeUnit(oUnit)) then
                table.insert(toUnitShortlist, oUnit)
            end
        end
    end
end

function GetSafeMexToUpgrade(iM28Team)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetSafeMexToUpgrade'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local toSafeUnitsToUpgrade = {}
    local tPotentialUnits
    --First prioritise T1 mexes
    local tiMexCategory = {[1] = M28UnitInfo.refCategoryT1Mex, [2]=M28UnitInfo.refCategoryT2Mex}
    for iTech = 1, 2 do
        for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
            local tPotentialUnits = oBrain:GetListOfUnits(tiMexCategory[iTech], false, true)
            AddPotentialUnitsToShortlist(toSafeUnitsToUpgrade, tPotentialUnits)
        end
        if M28Utilities.IsTableEmpty(toSafeUnitsToUpgrade) == false then
            break
        end
    end
    if M28Utilities.IsTableEmpty(toSafeUnitsToUpgrade) == false then
        local oUnitToUpgrade = M28Economy.GetBestUnitToUpgrade(toSafeUnitsToUpgrade)
        if oUnitToUpgrade then
            M28Economy.UpgradeUnit(oUnitToUpgrade, true)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetSafeHQUpgrade(iM28Team, bOnlyConsiderLandFactory)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetSafeHQUpgrade'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local toSafeUnitsToUpgrade = {}
    local tPotentialUnits

    --First identify any players that have a T1 land or air HQ
    for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
        if bDebugMessages == true then LOG(sFunctionRef..': Considering brain '..oBrain.Nickname..'; Highest air fac tech='..oBrain[M28Economy.refiOurHighestAirFactoryTech]..'; Highest land fac tech='..oBrain[M28Economy.refiOurHighestLandFactoryTech]..'; bOnlyConsiderLandFactory='..tostring(bOnlyConsiderLandFactory or false)) end
        if oBrain[M28Economy.refiOurHighestAirFactoryTech] == 1 and not(bOnlyConsiderLandFactory) then
            if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ)) then
                --Check we dont already have an active upgrade
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryAirHQ * categories.TECH1, false, true)
                AddPotentialUnitsToShortlist(toSafeUnitsToUpgrade, tPotentialUnits)
            end
        end
        if oBrain[M28Economy.refiOurHighestLandFactoryTech] == 1 then
            if bDebugMessages == true then LOG(sFunctionRef..': Does brain have active Land HQ upgrades='..tostring(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ))) end
            if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ)) then
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryLandHQ * categories.TECH1, false, true)
                if bDebugMessages == true then LOG(sFunctionRef..': Adding T1 land HQs to shortlist, is tPotentialUnits empty='..tostring(M28Utilities.IsTableEmpty(tPotentialUnits))) end
                AddPotentialUnitsToShortlist(toSafeUnitsToUpgrade, tPotentialUnits)
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking for units to upgrade, is table of safe units empty='..tostring(M28Utilities.IsTableEmpty(toSafeUnitsToUpgrade))) end
    if M28Utilities.IsTableEmpty(toSafeUnitsToUpgrade) then
        --Get T2 upgrades if all our land and air are at T2
        for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
            if oBrain[M28Economy.refiOurHighestAirFactoryTech] == 2 and not(bOnlyConsiderLandFactory) then
                if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ)) then
                    tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryAirHQ * categories.TECH2, false, true)
                    AddPotentialUnitsToShortlist(toSafeUnitsToUpgrade, tPotentialUnits)
                end
            end
            if oBrain[M28Economy.refiOurHighestLandFactoryTech] == 2 then
                if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ)) then
                    tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryLandHQ * categories.TECH2, false, true)
                    AddPotentialUnitsToShortlist(toSafeUnitsToUpgrade, tPotentialUnits)
                end
            end
        end
    end

    if M28Utilities.IsTableEmpty(toSafeUnitsToUpgrade) == false then
        local oUnitToUpgrade = M28Economy.GetBestUnitToUpgrade(toSafeUnitsToUpgrade)
        if oUnitToUpgrade then
            if bDebugMessages == true then LOG(sFunctionRef..': Will upgrade factory '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)) end
            M28Economy.UpgradeUnit(oUnitToUpgrade, true)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetAnyMexOrHQToUpgrade(iM28Team)
    --Backup logic for finding an upgrade if we have failed to find one through previous searches for a mex or factory

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetAnyMexOrHQToUpgrade'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local toUnitsThatCouldUpgrade = {}
    local tPotentialUnits
    local bPrioritiseFactory = false

    --First identify any players that have a T1 land or air HQ
    for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
        if oBrain[M28Economy.refiOurHighestAirFactoryTech] == 1 then
            if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ)) then
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryAirHQ * categories.TECH1, false, true)
                AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true)
            end
        elseif oBrain[M28Economy.refiOurHighestAirFactoryTech] == 2 then
            if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryAirHQ)) then
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryAirHQ * categories.TECH2, false, true)
                AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true)
            end
        end
        if oBrain[M28Economy.refiOurHighestLandFactoryTech] == 1 then
            if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ)) then
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryLandHQ * categories.TECH1, false, true)
                AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true)
            end
        elseif oBrain[M28Economy.refiOurHighestLandFactoryTech] == 2 then
            if not(DoesBrainHaveActiveHQUpgradesOfCategory(oBrain, M28UnitInfo.refCategoryLandHQ)) then
                tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryLandHQ * categories.TECH2, false, true)
                AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true)
            end
        end
        tPotentialUnits = oBrain:GetListOfUnits(M28UnitInfo.refCategoryT1Mex + M28UnitInfo.refCategoryT2Mex, false, true)
        AddPotentialUnitsToShortlist(toUnitsThatCouldUpgrade, tPotentialUnits, true)
    end
    if M28Utilities.IsTableEmpty(toUnitsThatCouldUpgrade) == false then
        local oUnitToUpgrade = M28Economy.GetBestUnitToUpgrade(toUnitsThatCouldUpgrade)
        if oUnitToUpgrade then
            M28Economy.UpgradeUnit(oUnitToUpgrade, true)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function HaveEcoToSupportUpgrades(iM28Team)
    --Returns true if we think we can support another upgrade (for normal non-priority logic
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'HaveEcoToSupportUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    --Do we have enough energy?
    tTeamData[iM28Team][subrefbTooLittleEnergyForUpgrade] = true --will change to false below if we have enough
    if bDebugMessages == true then LOG(sFunctionRef..': Start, GameTime='..GetGameTimeSeconds()..'; Gross energy='..tTeamData[iM28Team][subrefiTeamGrossEnergy]..'; % stored='..tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored]..'; Net energy='..tTeamData[iM28Team][subrefiTeamNetEnergy]..'; tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]) end

    if (tTeamData[iM28Team][subrefiTeamGrossEnergy] >= M28Economy.tiMinEnergyPerTech[tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]] or (tTeamData[iM28Team][subrefiTeamNetEnergy] > 5 * tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] * tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] and tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] >= 0.99)) and tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] >= 0.4 and (tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 25 or tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] >= 0.9) and tTeamData[iM28Team][subrefiTeamNetEnergy] > 0 then

        local iNetEnergyIncomeWanted
        if tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] >= 0.99 then iNetEnergyIncomeWanted = math.max(-tTeamData[iM28Team][subrefiTeamGrossEnergy] * 0.03, -25)
        elseif tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] >= 0.95 then iNetEnergyIncomeWanted = tTeamData[iM28Team][subrefiTeamGrossEnergy] * 0.01
        elseif tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] >= 0.9 then iNetEnergyIncomeWanted = math.max(4, tTeamData[iM28Team][subrefiTeamGrossEnergy] * 0.03)
        elseif tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] >= 0.7 then iNetEnergyIncomeWanted = math.max(6, tTeamData[iM28Team][subrefiTeamGrossEnergy] * 0.06)
        else iNetEnergyIncomeWanted = 100
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Have enough gross energy, iNetEnergyIncomeWanted='..iNetEnergyIncomeWanted) end

        if (tTeamData[iM28Team][subrefiTeamNetEnergy] - tTeamData[iM28Team][subrefiEnergyUpgradesStartedThisCycle] > iNetEnergyIncomeWanted) then
            tTeamData[iM28Team][subrefbTooLittleEnergyForUpgrade] = false
            --Do we have enough mass to support the upgrade?
            local iNetMassIncomeWanted
            if tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.9 then iNetMassIncomeWanted = math.min(-50, -tTeamData[iM28Team][subrefiTeamGrossMass] * 0.3)
            elseif tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.7 then iNetMassIncomeWanted = math.min(-25, -tTeamData[iM28Team][subrefiTeamGrossMass] * 0.25)
            elseif tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.4 then iNetMassIncomeWanted = -tTeamData[iM28Team][subrefiTeamGrossMass] * 0.2
            elseif tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.3 then iNetMassIncomeWanted = - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.15
            elseif tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.2 and tTeamData[iM28Team][subrefiTeamMassStored] >= 600 then iNetMassIncomeWanted = - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.1
            elseif tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.1 and tTeamData[iM28Team][subrefiTeamMassStored] >= 300 then iNetMassIncomeWanted = - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.075
            elseif tTeamData[iM28Team][subrefiTeamMassStored] >= 300 then iNetMassIncomeWanted = - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.05
            else iNetMassIncomeWanted = 0.1
            end

            if tTeamData[iM28Team][subrefiTeamMassStored] >= 5000 then iNetMassIncomeWanted = math.min(-5, iNetMassIncomeWanted - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.02) end

            if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) then
                iNetMassIncomeWanted = iNetMassIncomeWanted - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.05
                if tTeamData[iM28Team][subrefiTeamMassStored] >= 600 then iNetMassIncomeWanted = iNetMassIncomeWanted - tTeamData[iM28Team][subrefiTeamGrossMass] * 0.05 end
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Consideringi f have enough mass, tTeamData[iM28Team][subrefiTeamMassStored]='..tTeamData[iM28Team][subrefiTeamMassStored]..'; % mass stored='..tTeamData[iM28Team][subrefiTeamLowestMassPercentStored]..'; Gross mass income='..tTeamData[iM28Team][subrefiTeamGrossMass]..'; Net mass income='..tTeamData[iM28Team][subrefiTeamNetMass]..'; Net mass wanted='..iNetMassIncomeWanted..'; Is table of upgrading mexes empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]))..'; tTeamData[iM28Team][subreftiPrevTeamNetMass]='..repru(tTeamData[iM28Team][subreftiPrevTeamNetMass])) end
            --Average out our mass from the last 5 cycles as well
            local iLowestNetMass = tTeamData[iM28Team][subrefiTeamNetMass]
            for iLastEntry = 1, 5 do
                iLowestNetMass = math.min(iLowestNetMass, (tTeamData[iM28Team][subreftiPrevTeamNetMass][iLastEntry] or tTeamData[iM28Team][subrefiTeamNetMass]))
            end

            if (iLowestNetMass - tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]) > iNetMassIncomeWanted then
                if bDebugMessages == true then LOG(sFunctionRef..': We have enough energy and mass to get an upgrade') end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return true
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end


function ConsiderNormalUpgrades(iM28Team)
    --We should have already considered high priority upgrades before, now we want to consider upgrades if we have the eco to support upgrades generally
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderNormalUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iMassUpgradesAtLoopStart
    local iCycleCount = 0

    local bLookForMexNotHQ
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, HaveEcoToSupportUpgrades for iM28Team '..iM28Team..'='..tostring(HaveEcoToSupportUpgrades(iM28Team))..'; Is table of mex upgrades empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]))..'; Is table of factory upgrades empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]))) end
    while HaveEcoToSupportUpgrades(iM28Team) do
        iCycleCount = iCycleCount + 1
        iMassUpgradesAtLoopStart = tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] --so we can check we actually upgraded something

        bLookForMexNotHQ = true

        --Get preferred upgrade type - ideally are always improving mass income (if have safe mexes to upgrade)
        if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) == false then
            --Already have mexes upgrading - do we want to also upgrade an HQ instead of a mex?
            if (tTeamData[iM28Team][subrefiTeamGrossMass] >= 3 and (tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] == 1 or tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] == 1)) or ((tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] == 2 or tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] == 2) and tTeamData[iM28Team][subrefiTeamGrossMass] >= 8) then
                --Do we already ahve a factory HQ upgrading? If so then consider income based on player count
                if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) then
                    bLookForMexNotHQ = false
                else
                    if (tTeamData[iM28Team][subrefiTeamGrossMass] >= math.max(1.5, tTeamData[iM28Team][subrefiActiveM28BrainCount]) * 5 and (tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] == 1 or tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] == 1)) or ((tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] == 2 or tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech] == 2) and tTeamData[iM28Team][subrefiTeamGrossMass] >= math.max(1.5, tTeamData[iM28Team][subrefiActiveM28BrainCount]) * 8) then
                        bLookForMexNotHQ = false
                    end
                end
            end
        else
            --No mex ugprading, but might want factory if we dont have access to T2/T3 yet and have high mass income
            if bDebugMessages == true then LOG(sFunctionRef..': Dont have a mex upgrading, will see if want a factory instead of a mex, tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech='..tTeamData[iM28Team][subrefiHighestFriendlyLandFactoryTech]..'; tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyAirFactoryTech]..'; tTeamData[iM28Team][subrefiTeamGrossMass]='..tTeamData[iM28Team][subrefiTeamGrossMass]..'; Player count='..tTeamData[iM28Team][subrefiActiveM28BrainCount]..'; tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]) end
            if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) then --since no mex upgrading, dont want to upgrade more than 1 factory at once
                if tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] == 1 then
                    if tTeamData[iM28Team][subrefiTeamGrossMass] >= math.max(1, tTeamData[iM28Team][subrefiActiveM28BrainCount] * 0.7) * 4 and tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 25 * math.max(1, tTeamData[iM28Team][subrefiActiveM28BrainCount] * 0.75) then
                        bLookForMexNotHQ = false
                    end
                elseif tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] == 2 then
                    if tTeamData[iM28Team][subrefiTeamGrossMass] > 8 * math.max(1, tTeamData[iM28Team][subrefiActiveM28BrainCount] * 0.7) and tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 100 then
                        bLookForMexNotHQ = false
                    end
                end
            end

        end
        if bDebugMessages == true then LOG(sFunctionRef..': iCycleCount='..iCycleCount..'; bLookForMexNotHQ='..tostring(bLookForMexNotHQ)..'; Is table of upgrading mexes empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]))..'; Is table of upgrading HQs empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]))..'; Team gross mass='..tTeamData[iM28Team][subrefiTeamGrossMass]..'; Lowest land fac tech='..tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]..'; Lowest air fac tech='..tTeamData[iM28Team][subrefiLowestFriendlyAirFactoryTech]) end
        if bLookForMexNotHQ then
            GetSafeMexToUpgrade(iM28Team)
            --Backup - if didnt find anything then get a HQ upgrade if we dont already ahve a HQ upgrade active
            if bDebugMessages == true then LOG(sFunctionRef..': Tried to get a mex upgrade, tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]='..tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]..'; iMassUpgradesAtLoopStart='..iMassUpgradesAtLoopStart) end
            if tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] == iMassUpgradesAtLoopStart then
                if tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] == 1 or (tTeamData[iM28Team][subrefiTeamGrossMass] == 2 and tTeamData[iM28Team][subrefiTeamGrossMass] >= 8 and M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs])) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Trying backup HQ upgrade as no mexes could be found') end
                    GetSafeHQUpgrade(iM28Team)
                end
            end
        else
            GetSafeHQUpgrade(iM28Team)
            if tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] == iMassUpgradesAtLoopStart then
                GetSafeMexToUpgrade(iM28Team)
            end
        end
        --If failed to find a mex or HQ upgrade from above:
        if tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] == iMassUpgradesAtLoopStart then
            --Only consider upgrading if have lots of mass
            if tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] >= 0.5 and tTeamData[iM28Team][subrefiTeamMassStored] >= 600 then
                if bDebugMessages == true then LOG(sFunctionRef..': Will try and get any mex or HQ to upgrade as failed to find something to upgrade and have lots of mass') end
                GetAnyMexOrHQToUpgrade(iM28Team)
            end
        end

        --Keep searching for upgrades (if we have the eco to support) if we have just found something to upgrade
        if tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] > iMassUpgradesAtLoopStart then
            if iCycleCount >= 50 then
                M28Utilities.ErrorHandler('Likely infinite loop')
                break
            end
        else
            --Failed ot upgrade anything so abort to avoid risk of infinite loop
            break
        end
    end

    --T2 land factory exception even if dont have eco to support upgrades - if have a lot of mass, then consider upgrading even if lack energy
    if bDebugMessages == true then LOG(sFunctionRef..': Finished considering normal upgrades; will now consider if we want a T2 factory even if we have low energy. tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]='..tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech]..'; tTeamData[iM28Team][subrefiTeamGrossMass]='..tTeamData[iM28Team][subrefiTeamGrossMass]..'; tTeamData[iM28Team][subrefiTeamGrossEnergy]='..tTeamData[iM28Team][subrefiTeamGrossEnergy]..'; tTeamData[iM28Team][subrefiTeamNetEnergy]='..tTeamData[iM28Team][subrefiTeamNetEnergy]..'; Stored mass='..tTeamData[iM28Team][subrefiTeamMassStored]..'; Is table of upgrading HQs empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]))..'; tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]='..tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech]..'; tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]='..tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle]) end
    if tTeamData[iM28Team][subrefiHighestFriendlyFactoryTech] == 1 and tTeamData[iM28Team][subrefiLowestFriendlyLandFactoryTech] == 1 and tTeamData[iM28Team][subrefiTeamGrossMass] >= 4 and tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 25 and (tTeamData[iM28Team][subrefiTeamNetEnergy] > 0 or tTeamData[iM28Team][subrefiTeamGrossEnergy] >= 40) and tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] == 0 and (M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingMexes]) or tTeamData[iM28Team][subrefiTeamMassStored] >= 500) and M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftTeamUpgradingHQs]) then
        if bDebugMessages == true then LOG(sFunctionRef..': Dont have good eco but will get land fac upgrade anyway to help improve energy long term as are only at T1') end
        GetSafeHQUpgrade(iM28Team, true)
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderGettingUpgrades(iM28Team)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderGettingUpgrades'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored]='..tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored]..'; Stalling energy='..tostring(tTeamData[iM28Team][subrefbTeamIsStallingEnergy])) end
    if tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] >= 0.6 and GetGameTimeSeconds() >= 180 and not(tTeamData[iM28Team][subrefbTeamIsStallingEnergy]) then
        tTeamData[iM28Team][subrefiMassUpgradesStartedThisCycle] = 0
        tTeamData[iM28Team][subrefiEnergyUpgradesStartedThisCycle] = 0

        --Priority upgrades even with poor eco:
        ConsiderPriorityLandFactoryUpgrades(iM28Team)

        ConsiderPriorityAirFactoryUpgrades(iM28Team)

        --Consider priority mex upgrades (e.g. we are falling far behind enemy on eco)
        ConsiderPriorityMexUpgrades(iM28Team)

        ConsiderNormalUpgrades(iM28Team)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TeamEconomyRefresh(iM28Team)
    tTeamData[iM28Team][subrefiTeamGrossEnergy] = 0
    tTeamData[iM28Team][subrefiTeamNetEnergy] = 0
    tTeamData[iM28Team][subrefiTeamGrossMass] = 0
    tTeamData[iM28Team][subrefiTeamNetMass] = 0
    tTeamData[iM28Team][subrefiTeamEnergyStored] = 0
    tTeamData[iM28Team][subrefiTeamMassStored] = 0
    tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] = 1
    tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] = 1

    for iLastEntry = 5, 2, -1 do
        tTeamData[iM28Team][subreftiPrevTeamNetMass][iLastEntry] = (tTeamData[iM28Team][subreftiPrevTeamNetMass][iLastEntry-1] or 0)
    end
    tTeamData[iM28Team][subreftiPrevTeamNetMass][1] = tTeamData[iM28Team][subrefiTeamNetMass]
    tTeamData[iM28Team][subrefiLowestEnergyStorageCount] = 100




    for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
        tTeamData[iM28Team][subrefiTeamGrossEnergy] = tTeamData[iM28Team][subrefiTeamGrossEnergy] + oBrain[M28Economy.refiGrossEnergyBaseIncome]
        tTeamData[iM28Team][subrefiTeamNetEnergy] = tTeamData[iM28Team][subrefiTeamNetEnergy] + oBrain[M28Economy.refiNetEnergyBaseIncome]
        tTeamData[iM28Team][subrefiTeamGrossMass] = tTeamData[iM28Team][subrefiTeamGrossMass] + oBrain[M28Economy.refiGrossMassBaseIncome]
        tTeamData[iM28Team][subrefiTeamNetMass] = tTeamData[iM28Team][subrefiTeamNetMass] + oBrain[M28Economy.refiNetMassBaseIncome]

        tTeamData[iM28Team][subrefiTeamEnergyStored] = tTeamData[iM28Team][subrefiTeamEnergyStored] + oBrain:GetEconomyStored('ENERGY')
        tTeamData[iM28Team][subrefiTeamMassStored] = tTeamData[iM28Team][subrefiTeamMassStored] + oBrain:GetEconomyStored('MASS')
        tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] = math.min(tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored], oBrain:GetEconomyStoredRatio('ENERGY'))
        tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] = math.min(tTeamData[iM28Team][subrefiTeamLowestMassPercentStored], oBrain:GetEconomyStoredRatio('MASS'))
        tTeamData[iM28Team][subrefiLowestEnergyStorageCount] = math.min(tTeamData[iM28Team][subrefiLowestEnergyStorageCount], oBrain:GetCurrentUnits(M28UnitInfo.refCategoryEnergyStorage))
    end

    if tTeamData[iM28Team][subrefiTeamLowestEnergyPercentStored] <= 0.05 then tTeamData[iM28Team][subrefbTeamIsStallingEnergy] = true end
    if tTeamData[iM28Team][subrefiTeamLowestMassPercentStored] == 0 and tTeamData[iM28Team][subrefiTeamMassStored] < tTeamData[iM28Team][subrefiActiveM28BrainCount] * 25 then tTeamData[iM28Team][subrefbTeamIsStallingMass] = true end

    ForkThread(ConsiderGettingUpgrades, iM28Team)

    ForkThread(M28Economy.ManageEnergyStalls, iM28Team)
end

function TeamOverseer(iM28Team)
    while M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftoFriendlyActiveM28Brains]) == false do
        ForkThread(TeamEconomyRefresh, iM28Team)
        WaitTicks(10)
    end
end

function TeamInitialisation(iM28Team)
    --First check if we have any M28 brains in this team (otherwise dont do anything further)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'TeamInitialisation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Will initialise team based logic for the team '..iM28Team..'; Is the table of friendly active M28 brains empty='..tostring(M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftoFriendlyActiveM28Brains]))..'; Do we already have an active team cycler='..tostring(tTeamData[iM28Team]['M28TeamActiveTeamCycler'] or false)) end

    if M28Utilities.IsTableEmpty(tTeamData[iM28Team][subreftoFriendlyActiveM28Brains]) == false then
        if not(tTeamData[iM28Team]['M28TeamActiveTeamCycler']) then
            tTeamData[iM28Team]['M28TeamActiveTeamCycler'] = true
            if bDebugMessages == true then LOG(sFunctionRef..': About to start land zone overseer which carries out main over time loop') end
            ForkThread(M28Land.LandZoneOverseer, iM28Team)
            ForkThread(TeamOverseer, iM28Team)
            ForkThread(M28Economy.TeamResourceSharingMonitor, iM28Team)
        end
    end

    --Include variables for land zones
    for iPlateau, tPlateauData in M28Map.tAllPlateaus do
        for iLZ, tLZData in tPlateauData[M28Map.subrefPlateauLandZones] do
            if bDebugMessages == true then LOG(sFunctionRef..': Recording team data for iPlateau='..iPlateau..'; iLZ='..iLZ..'; iTeam='..iM28Team) end
            if not(tLZData[M28Map.subrefLZTeamData]) then tLZData[M28Map.subrefLZTeamData] = {} end
            tLZData[M28Map.subrefLZTeamData][iM28Team] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZTAlliedUnits] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZTEnemyUnits] = {}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefMexCountByTech] = {[1]=0,[2]=0,[3]=0}
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZTValue] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZTThreatEnemyCombatTotal] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatEnemyBestMobileDFRange] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatEnemyBestStructureDFRange] = 0
            tLZData[M28Map.subrefLZTeamData][iM28Team][M28Map.subrefLZThreatEnemyBestMobileIndirectRange] = 0
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AirSubteamInitialisation(iM28AirSubteam)
    M28Utilities.ErrorHandler('To add AirSubteam code')
end

function UpdateEnemyTechTracking(iM28Team, oUnit)
    local iUnitTechLevel = M28UnitInfo.GetUnitTechLevel(oUnit)
    if EntityCategoryContains(categories.LAND, oUnit.UnitId) then
        tTeamData[iM28Team][subrefiHighestEnemyGroundTech] = math.max(tTeamData[iM28Team][subrefiHighestEnemyGroundTech], iUnitTechLevel)
    elseif EntityCategoryContains(categories.AIR, oUnit.UnitId) then tTeamData[iM28Team][subrefiHighestEnemyAirTech] = math.max(tTeamData[iM28Team][subrefiHighestEnemyAirTech], iUnitTechLevel)
    elseif EntityCategoryContains(categories.NAVAL, oUnit.UnitId) then tTeamData[iM28Team][subrefiHighestEnemyNavyTech] = math.max(tTeamData[iM28Team][subrefiHighestEnemyNavyTech], iUnitTechLevel)
    end
end

function GetCurrentUnitsOfCategory(iM28Team, iCategory)
    local iCurUnits = 0
    for iBrain, oBrain in tTeamData[iM28Team][subreftoFriendlyActiveM28Brains] do
        iCurUnits = iCurUnits + oBrain:GetCurrentUnits(iCategory)
    end
    return iCurUnits
end

function TransferUnitsToPlayer(tUnits, iArmyIndex, bCaptured)
    import('/lua/SimUtils.lua').TransferUnitsOwnership(tUnits, iArmyIndex, bCaptured)
end