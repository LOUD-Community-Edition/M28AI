---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 08:37
---

local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')


--Variables against aiBrain:
--ECONOMY VARIABLES - below 4 are to track values based on base production, ignoring reclaim. Provide per tick values so 10% of per second)
refiGrossEnergyBaseIncome = 'M28EnergyGrossIncome' --against aiBrain
refiNetEnergyBaseIncome = 'M28EnergyNetIncome' --against aiBrain
refiGrossMassBaseIncome = 'M28MassGrossIncome' --against aiBrain
refiNetMassBaseIncome = 'M28MassNetIncome' --against aiBrain

--Factory tech variables
refiOurHighestFactoryTechLevel = 'M28EOurHighestFactoryTech' --against aiBrain
refiOurHighestAirFactoryTech = 'M28EOurHighestAirFactoryTech' --against aiBrain
refiOurHighestLandFactoryTech = 'M28EOurHighestLandFactoryTech' --against aiBrain
refiOurHighestNavalFactoryTech = 'M28EOurHighestNavalFactoryTech' --against aiBrain

reftPausedUnits = 'M28EconomyPausedUnits' --against aibrain, table of paused units for this brain

--Against unit variables:
refoBrainRecordedForEconomy = 'M28EconomyBrainRecordedUnit' --Stores the M28 brain that has factored in this unit's mass and energy income
refiLastEnergyUsage = 'M28EconomyLastEnergyUsage' --per tick energy usage of the unit (set when the unit is paused)
refiLastMassUsage = 'M28EconomyLastMassUsage' --per tick massu sage of the unit set when unit is paused

--global variables
tiMinEnergyPerTech = {[1]=20,[2]=60,[3]=250}
iSpecialHQCategory = 'M28EconomyFactoryHQ' --Used as a way of choosing to pause HQ

function UpgradeUnit(oUnitToUpgrade, bUpdateUpgradeTracker)
    --Work out the upgrade ID wanted; if bUpdateUpgradeTracker is true then records upgrade against unit's aiBrain
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpgradeUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Do we have any HQs of the same factory type of a higher tech level?
    local sUpgradeID = M28UnitInfo.GetUnitUpgradeBlueprint(oUnitToUpgrade, true) --If not a factory or dont recognise the faction then just returns the normal unit ID
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, sUpgradeID='..(sUpgradeID or 'nil')..'; bUpdateUpgradeTracker='..tostring((bUpdateUpgradeTracker or false))) end

    if sUpgradeID and M28UnitInfo.IsUnitValid(oUnitToUpgrade) then
        local aiBrain = oUnitToUpgrade:GetAIBrain()
        if bDebugMessages == true then LOG(sFunctionRef..': About to issue ugprade to unit '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)..'; Current state='..M28UnitInfo.GetUnitState(oUnitToUpgrade)..'; Work progress='..(oUnitToUpgrade:GetWorkProgress() or 'nil')..'; Is unit upgrading='..tostring(oUnitToUpgrade:IsUnitState('Upgrading'))) end

        if not(oUnitToUpgrade:IsUnitState('Upgrading')) then
            local bAddToExistingQueue = true



            --Factory specific - if work progress is <=5% then cancel so can do the upgrade
            if EntityCategoryContains(M28UnitInfo.refCategoryFactory, oUnitToUpgrade.UnitId) then
                if bDebugMessages == true then LOG(sFunctionRef..': Are upgrading a factory '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)..'; work progress='..oUnitToUpgrade:GetWorkProgress()) end
                if oUnitToUpgrade.GetWorkProgress and oUnitToUpgrade:GetWorkProgress() <= 0.05 then
                    --Are we building an engineer or transport?
                    local oUnitThatAreBuilding = oUnitToUpgrade:GetFocusUnit()
                    if not(M28UnitInfo.IsUnitValid(oUnitThatAreBuilding) and EntityCategoryContains(M28UnitInfo.refCategoryTransport + M28UnitInfo.refCategoryEngineer, oUnitThatAreBuilding.UnitId)) then
                        bAddToExistingQueue = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Have barely started with current construction so will cancel so can get upgrade sooner') end
                    end
                end
            end

            --Air factory upgrades - if we are upgrading from T1 to T2 and havent build a transport, and have plateaus, then want to get a transport first
            if EntityCategoryContains(M28UnitInfo.refCategoryAirFactory * categories.TECH1, oUnitToUpgrade.UnitId) and aiBrain[refiOurHighestAirFactoryTech] == 1 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory * categories.TECH1) == 1 then
                M28Map.UpdatePlateausToExpandTo(aiBrain)
                if M28Utilities.IsTableEmpty(aiBrain[M28Map.reftPlateausOfInterest]) == false and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryTransport) == 0 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have already queued up transport for this unit='..tostring(oUnitToUpgrade[refsQueuedTransport] or false)) end
                    if not(oUnitToUpgrade[refsQueuedTransport]) then
                        --Havent built any transports yet so build a T1 transport before we upgrade to T2 air

                        local sTransportID = M28Factory.GetBlueprintsThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryTransport, oUnitToUpgrade)
                        if sTransportID then
                            oUnitToUpgrade[refsQueuedTransport] = true
                            M28Orders.IssueTrackedFactoryBuild(oUnitToUpgrade, sTransportID, false, 'PreUp')
                            if bDebugMessages == true then LOG(sFunctionRef..': Will queue up a transport for factory '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)) end
                        end
                    end
                end
            elseif EntityCategoryContains(M28UnitInfo.refCategoryLandFactory * categories.TECH2 + M28UnitInfo.refCategoryAirFactory * categories.TECH2, oUnitToUpgrade.UnitId) and aiBrain[refiOurHighestFactoryTechLevel] <= 2 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer - categories.TECH1) <= 5 then
                --About to go for T3 factory but have hardl yany engineers so queue up an extra one
                local sEngiID = M28Factory.GetBlueprintsThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryEngineer, oUnitToUpgrade)
                if sEngiID then
                    M28Orders.IssueTrackedFactoryBuild(oUnitToUpgrade, sEngiID, false, 'PreUp')
                end
                if bDebugMessages == true then LOG(sFunctionRef..': About to go to T3 on factory '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)..' but only have '..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer - categories.TECH1)..' T2 plus engis so will queue up another engi before the upgrade. sEngiID='..(sEngiID or 'nil')) end
            end

            --Issue upgrade
            M28Orders.IssueTrackedUpgrade(oUnitToUpgrade, sUpgradeID, bAddToExistingQueue)
        end

        --Clear any pausing of the unit
        oUnitToUpgrade:SetPaused(false)
        oUnitToUpgrade[M28UnitInfo.refbPaused] = false

        if bUpdateUpgradeTracker then
            M28Team.UpdateUpgradeTrackingOfUnit(oUnitToUpgrade, false, sUpgradeID)
        end

        --T1 mexes - if start upgrading, then flag for TML protection --TODO in a future version (is on todo list)
    else
        M28Utilities.ErrorHandler('Dont have a valid upgrade ID; UnitID=' .. oUnitToUpgrade.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade))
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetBestUnitToUpgrade(toPotentialUnits, bPrioritiseFactoryHQ)
    --Assumes have already checked units are valid/not upgrading and factored in whether safe or not already, so just need to do distance type check
    local iClosestUnitToBase = 100000
    local oClosestUnitToBase
    local iCurModDist
    for iUnit, oUnit in toPotentialUnits do
        iCurModDist = M28Map.GetModDistanceFromStart(oUnit:GetAIBrain(), oUnit:GetPosition(), false)
        if bPrioritiseFactoryHQ and not(EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnit.UnitId)) then iCurModDist = iCurModDist + 1000 end
        if iCurModDist < iClosestUnitToBase then
            iClosestUnitToBase = iCurModDist
            oClosestUnitToBase = oUnit
        end
    end
    return oClosestUnitToBase
end

function UpdateLandZoneM28AllMexByTech(aiBrain, iPlateau, iLandZone, oOptionalUnitThatDied, iOptionalWait)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateLandZoneM28AllMexByTech'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team]
    if iOptionalWait then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(iOptionalWait)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    tLZTeamData[M28Map.subrefMexCountByTech] = {[1]=0,[2]=0,[3]=0} --starting point
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
        local tAllMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        --Update list of units in this LZ in case some of the mexes are dead now
        M28Land.UpdateUnitPositionsAndLandZone(aiBrain, tAllMexes, aiBrain.M28Team, iPlateau, iLandZone, false)

        local tMexesByTech = {}
        local iMexCount = 0
        tMexesByTech[1] = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex * categories.TECH1, tAllMexes)
        tMexesByTech[2] = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex * categories.TECH2, tAllMexes)
        tMexesByTech[3] = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex * categories.TECH3, tAllMexes)
        if bDebugMessages == true and oOptionalUnitThatDied then LOG(sFunctionRef..': oOptionalUnitThatDied='..oOptionalUnitThatDied.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOptionalUnitThatDied)) end

        for iTech = 1, 3 do
            if M28Utilities.IsTableEmpty(tMexesByTech[iTech]) == false then
                for iMex, oCurMex in tMexesByTech[iTech] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Plateau='..iPlateau..'; iLandZone='..iLandZone..'; oCurMex='..oCurMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oCurMex)..'; Unit state='..M28UnitInfo.GetUnitState(oCurMex)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oCurMex))..'; Position='..repru(oCurMex:GetPosition())..'; iTech='..iTech..'; iMexCount pre increase='..iMexCount..'; tLZTeamData[M28Map.subrefMexCountByTech] pre increase='..repru(tLZTeamData[M28Map.subrefMexCountByTech])) end
                    if oCurMex:GetAIBrain().M28AI and M28UnitInfo.IsUnitValid(oCurMex) and oCurMex:GetFractionComplete() == 1 and not(oOptionalUnitThatDied == oCurMex) then
                        tLZTeamData[M28Map.subrefMexCountByTech][iTech] = tLZTeamData[M28Map.subrefMexCountByTech][iTech] + 1
                        iMexCount = iMexCount + 1
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished updating mex count, tLZTeamData[M28Map.subrefMexCountByTech]='..repru(tLZTeamData[M28Map.subrefMexCountByTech])) end
        --If have somehow ended up with more mexes than there are locations, then redo the check this time seeing if the units are all valid
        if iMexCount > table.getn( M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]) then
            M28Utilities.ErrorHandler('Somehow we have more mexes than we should, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iMexCount='..iMexCount..'; tLZTeamData[M28Map.subrefMexCountByTech]='..reprs(tLZTeamData[M28Map.subrefMexCountByTech]))
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateLandZoneM28MexByTechCount(oMexJustBuiltOrDied, bJustDied, iOptionalWait)
    local aiBrain = oMexJustBuiltOrDied:GetAIBrain()
    if aiBrain.M28AI then
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oMexJustBuiltOrDied:GetPosition())
        --should be called whenever a mex is created or destroyed in a land zone; ideally call via fork thread so reduced risk of it being called inbetween a mex say upgrading from one to another and being claled before both the creation and destroy events have happened
        if (iLandZone or 0) > 0 then
            if not(iOptionalWait) then
                if bJustDied then
                    UpdateLandZoneM28AllMexByTech(aiBrain, iPlateau, iLandZone, oMexJustBuiltOrDied)
                else
                    UpdateLandZoneM28AllMexByTech(aiBrain, iPlateau, iLandZone, nil)
                end
            else
                if bJustDied then
                    ForkThread(UpdateLandZoneM28AllMexByTech, aiBrain, iPlateau, iLandZone, oMexJustBuiltOrDied, iOptionalWait)
                else
                    ForkThread(UpdateLandZoneM28AllMexByTech, aiBrain, iPlateau, iLandZone, nil, iOptionalWait)
                end
            end
        end
    end
end

function FindAndUpgradeUnitOfCategory(aiBrain, iCategoryWanted)
    --e.g. intended for upgrading factory HQs
    local tUnitsOfCategory = aiBrain:GetListOfUnits(iCategoryWanted, false, true)
    if M28Utilities.IsTableEmpty(tUnitsOfCategory) == false then
        local tUnitsToSearch = {}
        local tUnsafeUnitsOfCategory = {}
        local iCurPlateau, iCurLZ
        for iUnit, oUnit in tUnitsOfCategory do
            if oUnit:GetFractionComplete() == 1 and not(oUnit:IsUnitState('Upgrading')) then
                --Are we in a safe land zone?
                iCurPlateau, iCurLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                if M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLZ][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                    table.insert(tUnsafeUnitsOfCategory, oUnit)
                else
                    table.insert(tUnitsToSearch, oUnit)
                end
            end
        end
        if M28Utilities.IsTableEmpty(tUnitsToSearch) then tUnitsToSearch = tUnsafeUnitsOfCategory end
        if M28Utilities.IsTableEmpty(tUnitsToSearch) == false then
            local iCurDist
            local iClosestDist = 100000
            local oClosestUnit
            for iUnit, oUnit in tUnitsToSearch do
                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()])
                if iCurDist < iClosestDist then
                    iClosestDist = iCurDist
                    oClosestUnit = oUnit
                end
            end
            if oClosestUnit then
                UpgradeUnit(aiBrain, oClosestUnit, true) --Will queue up transport or engineer for factories as well as figuring out whether to upgrade a support factory or an HQ
            end
        end
    end
end

function UpdateHighestFactoryTechLevelForBuiltUnit(oUnitJustBuilt)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateHighestFactoryTechLevelForBuiltUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Checking if just built a factory HQ, Have just built unit '..oUnitJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitJustBuilt)..'; Fraction complete='..oUnitJustBuilt:GetFractionComplete()..'; Is it a factory HQ='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnitJustBuilt.UnitId))) end

    if oUnitJustBuilt:GetFractionComplete() == 1 and EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnitJustBuilt.UnitId) then
        local iUnitTechLevel = M28UnitInfo.GetUnitTechLevel(oUnitJustBuilt)
        local sFactoryRef
        if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnitJustBuilt.UnitId) then sFactoryRef = refiOurHighestLandFactoryTech
        elseif EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oUnitJustBuilt.UnitId) then sFactoryRef = refiOurHighestAirFactory
        elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oUnitJustBuilt.UnitId) then sFactoryRef = refiOurHighestNavalFactoryTech
        else M28Utilities.ErrorHandler('Unrecognised factory type')
        end
        local aiBrain = oUnitJustBuilt:GetAIBrain()
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if factory HQ is a higher tech than we already have, sFactoryRef='..sFactoryRef..'; iUnitTechLevel='..iUnitTechLevel..'; aiBrain[sFactoryRef]='..aiBrain[sFactoryRef]) end
        if iUnitTechLevel > aiBrain[sFactoryRef] then
            aiBrain[sFactoryRef] = math.max(aiBrain[sFactoryRef], iUnitTechLevel)
            aiBrain[refiOurHighestFactoryTechLevel] = math.max(iUnitTechLevel, aiBrain[refiOurHighestFactoryTechLevel])
            --Update team details
            M28Team.UpdateTeamHighestAndLowestFactories(aiBrain.M28Team)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateHighestFactoryTechLevelForDestroyedUnit(oUnitJustDestroyed)
    if oUnitJustDestroyed:GetFractionComplete() == 1 and EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories) then
        local aiBrain = oUnitJustDestroyed:GetAIBrain()
        local iUnitTechLevel = M28UnitInfo.GetUnitTechLevel(oUnitJustDestroyed)
        if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory) then
            if iUnitTechLevel >= (aiBrain[refiOurHighestLandFactoryTech] or 0) then
                aiBrain[refiOurHighestLandFactoryTech] = 0
                for iTechLevel = 3, 1, -1 do
                    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory * M28UnitInfo.ConvertTechLevelToCategory(iTechLevel) - categories.SUPPORTFACTORY) > 0 then
                        aiBrain[refiOurHighestLandFactoryTech] = iTechLevel
                        break
                    end
                end
            end
        elseif EntityCategoryContains(M28UnitInfo.refCategoryAirFactory) then sFactoryRef = refiOurHighestAirFactory
            if iUnitTechLevel >= aiBrain[refiOurHighestAirFactoryTech] then
                aiBrain[refiOurHighestAirFactoryTech] = 0
                for iTechLevel = 3, 1, -1 do
                    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory * M28UnitInfo.ConvertTechLevelToCategory(iTechLevel) - categories.SUPPORTFACTORY) > 0 then
                        aiBrain[refiOurHighestAirFactoryTech] = iTechLevel
                        break
                    end
                end
            end
        elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory) then sFactoryRef = refiOurHighestNavalFactoryTech
            if iUnitTechLevel >= aiBrain[refiOurHighestNavalFactoryTech] then
                aiBrain[refiOurHighestNavalFactoryTech] = 0
                for iTechLevel = 3, 1, -1 do
                    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalFactory * M28UnitInfo.ConvertTechLevelToCategory(iTechLevel) - categories.SUPPORTFACTORY) > 0 then
                        aiBrain[refiOurHighestNavalFactoryTech] = iTechLevel
                        break
                    end
                end
            end
        else M28Utilities.ErrorHandler('Unrecognised factory type')
        end

        --Updated highest factory type across all types
        aiBrain[refiOurHighestFactoryTechLevel] = math.max(aiBrain[refiOurHighestLandFactoryTech], aiBrain[refiOurHighestAirFactoryTech], aiBrain[refiOurHighestNavalFactoryTech])

        --Update team details
        M28Team.UpdateTeamHighestAndLowestFactories(aiBrain.M28Team)
    end
end

function UpdateGrossIncomeForUnit(oUnit, bDestroyed)
    --Logs are enabled below

    if oUnit.GetAIBrain and EntityCategoryContains(categories.MASSPRODUCTION + categories.MASSFABRICATION + categories.ENERGYPRODUCTION, oUnit.UnitId) then
        --Does the unit have an M28 aiBrain?
        local aiBrain = oUnit:GetAIBrain()
        if aiBrain.M28AI then
            local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
            local sFunctionRef = 'UpdateGrossIncomeForUnit'
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

            if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..' oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bDestroyed='..tostring(bDestroyed or false)..': Unit aiBrain='..oUnit:GetAIBrain().Nickname..'; Brain recorded for economy='..((oUnit[refoBrainRecordedForEconomy] or {'nil'}).Nickname or 'nil')..'; Fraction complete='..oUnit:GetFractionComplete()) end
            if oUnit:GetFractionComplete() < 1 then M28Utilities.ErrorHandler('Trying to update income for unit whose fraction isnt complete') end

            if (bDestroyed and oUnit[refoBrainRecordedForEconomy] == aiBrain) or (not(bDestroyed) and not(oUnit[refoBrainRecordedForEconomy] == aiBrain)) then
                local iMassGen
                local iEnergyGen
                if EntityCategoryContains(M28UnitInfo.refCategoryParagon, oUnit.UnitId) then
                    iMassGen = 10000
                    iEnergyGen = 1000000
                else
                    local oBP = oUnit:GetBlueprint()
                    iMassGen = math.max(oBP.Economy.ProductionPerSecondMass or 0) * 0.1
                    iEnergyGen = math.max(oBP.Economy.ProductionPerSecondEnergy or 0) * 0.1
                end
                if bDestroyed then
                    iMassGen = iMassGen * -1
                    iEnergyGen = iEnergyGen * -1
                    oUnit[refoBrainRecordedForEconomy] = nil
                else
                    oUnit[refoBrainRecordedForEconomy] = aiBrain
                    --Set temporary flag that we have just built a lot of power (if we have)
                    bDebugMessages = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if should temporarily say we have enough power; iEnergyGen='..iEnergyGen..'; Gross energy='..(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossEnergy] or 'nil')..'; Net energy='..(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamNetEnergy] or 'nil')..'; Flag for lots of power='..tostring(M28Team.tTeamData[aiBrain.M28Team][M28Team.refbJustBuiltLotsOfPower] or false)) end
                    if iEnergyGen >= math.max(20, (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossEnergy] or 0) * 0.15, -(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamNetEnergy] or 0)) and not(M28Team.tTeamData[aiBrain.M28Team][M28Team.refbJustBuiltLotsOfPower]) then
                        M28Team.tTeamData[aiBrain.M28Team][M28Team.refbJustBuiltLotsOfPower] = true
                        M28Utilities.DelayChangeVariable(M28Team.tTeamData[aiBrain.M28Team], M28Team.refbJustBuiltLotsOfPower, false, 5)
                        if bDebugMessages == true then LOG(sFunctionRef..': Just built a lot of power so will temporarily say we dont need more power') end
                    end
                    --Update team eco values to factor in impact of this on any decisions made before the next team eco refresh
                    M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass] = (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossMass] or 0) + iMassGen
                    M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamNetMass] = (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamNetMass] or 0) + iMassGen
                    M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossEnergy] = (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamGrossEnergy] or 0) + iEnergyGen
                    M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamNetEnergy] = (M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefiTeamNetEnergy] or 0) + iEnergyGen
                end
                aiBrain[refiGrossEnergyBaseIncome] = aiBrain[refiGrossEnergyBaseIncome] + iEnergyGen
                aiBrain[refiNetEnergyBaseIncome] = aiBrain[refiNetEnergyBaseIncome] + iEnergyGen
                aiBrain[refiGrossMassBaseIncome] = aiBrain[refiGrossMassBaseIncome] + iMassGen
                aiBrain[refiNetMassBaseIncome] = aiBrain[refiNetMassBaseIncome] + iMassGen

                if iEnergyGen >= 25 then
                    ConsiderReclaimingPower(aiBrain.M28Team, oUnit)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Updated gross and net resources for iMassGen='..iMassGen..'; iEnergyGen='..iEnergyGen..'; aiBrain[refiNetMassBaseIncome]='..aiBrain[refiNetMassBaseIncome]..'; aiBrain[refiGrossMassBaseIncome]='..aiBrain[refiGrossMassBaseIncome]) end
            end


            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        end
    end
end

function RefreshEconomyGrossValues(aiBrain)
    --Updates recorded gross mass and energy for each unit
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshEconomyGrossValues'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tEconomyUnits = aiBrain:GetListOfUnits(categories.MASSPRODUCTION + categories.MASSFABRICATION + categories.ENERGYPRODUCTION, false, true)
    if bDebugMessages == true then LOG(sFunctionRef..': refreshing gross income for every unit we own time='..GetGameTimeSeconds()..'; size of tEconomyUnits='..table.getn(tEconomyUnits)) end
    for iUnit, oUnit in tEconomyUnits do
        if oUnit:GetFractionComplete() == 1 then
            UpdateGrossIncomeForUnit(oUnit)
        end
    end

end

function RefreshEconomyData(aiBrain)
   local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshEconomyData'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    aiBrain[refiNetEnergyBaseIncome] = math.min(aiBrain[refiGrossEnergyBaseIncome] - aiBrain:GetEconomyRequested('ENERGY'), aiBrain:GetEconomyTrend('ENERGY'))
    aiBrain[refiNetMassBaseIncome] = math.min(aiBrain[refiGrossMassBaseIncome] - aiBrain:GetEconomyRequested('MASS'), aiBrain:GetEconomyTrend('MASS'))

    if bDebugMessages == true then LOG(sFunctionRef..': Finished refreshing economy data, time='..GetGameTimeSeconds()..'; Energy gross='..aiBrain[refiGrossEnergyBaseIncome]..'; Energy net='..aiBrain[refiNetEnergyBaseIncome]..'; Mass gross='..aiBrain[refiGrossMassBaseIncome]..'; Mass net='..aiBrain[refiNetMassBaseIncome]..'; aiBrain:GetEconomyRequested(\'MASS\')='..aiBrain:GetEconomyRequested('MASS')..'; aiBrain:GetEconomyTrend(\'MASS\')='..aiBrain:GetEconomyTrend('MASS')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function EconomyMainLoop(aiBrain)
    local iSlowRefreshCount = 0

    while not(aiBrain.M28IsDefeated) do
        --Slow refresh logic - every 30s update economy values for every unit as redundancy
        if iSlowRefreshCount == 0 then
            ForkThread(RefreshEconomyGrossValues, aiBrain)
        end
        iSlowRefreshCount = iSlowRefreshCount + 1
        if iSlowRefreshCount >= 30 then iSlowRefreshCount = 0 end

        --Frequent refresh logic:
        ForkThread(RefreshEconomyData, aiBrain)
        WaitSeconds(1)
    end
end

function EconomyInitialisation(aiBrain)
    aiBrain[refiGrossEnergyBaseIncome] = 0
    aiBrain[refiNetEnergyBaseIncome] = 0
    aiBrain[refiGrossMassBaseIncome] = 0
    aiBrain[refiNetMassBaseIncome] = 0
    aiBrain[reftPausedUnits] = {}

    --Some values are set when creating a team to avoid errors

    ForkThread(EconomyMainLoop, aiBrain)
end

function RecordUnitsOfCategoryToBeReclaimed(iTeam, iCategory)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordUnitsOfCategoryToBeReclaimed'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bAddCurUnit
    local bCheckForExistingUnits
    for iPlateau, tPlateauData in M28Map.tAllPlateaus do
        if M28Utilities.IsTableEmpty(tPlateauData[M28Map.subrefPlateauLandZones]) == false then
            for iLandZone, tLZData in tPlateauData[M28Map.subrefPlateauLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if iPlateau-LZ '..iPlateau..'-'..iLandZone..' has units of the category wanted') end
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTAlliedUnits]) == false then
                    if not(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftoUnitsToReclaim]) then
                        bCheckForExistingUnits = false
                        tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftoUnitsToReclaim] = {}
                    else
                        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftoUnitsToReclaim]) == false then
                            bCheckForExistingUnits = true
                        end
                    end
                    local tUnitsToReclaim = EntityCategoryFilterDown(iCategory, tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTAlliedUnits])
                    if bDebugMessages == true then LOG(sFunctionRef..': Is table of untis of category wanted empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToReclaim))) end
                    if M28Utilities.IsTableEmpty(tUnitsToReclaim) == false then
                        for iUnit, oUnit in tUnitsToReclaim do
                            bAddCurUnit = true
                            if bCheckForExistingUnits then
                                for iExistingUnit, oExistingUnit in tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftoUnitsToReclaim] do
                                    if oUnit == oExistingUnit then
                                        bAddCurUnit = false
                                        break
                                    end
                                end
                            end
                            if bAddCurUnit then table.insert(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.subreftoUnitsToReclaim], oUnit) end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshUnitsToReclaim(iTeam, iPlateau, iLandZone)
    --Removes any dead units
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshUnitsToReclaim'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tUnitsToReclaim = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subreftoUnitsToReclaim]
    if bDebugMessages == true then
        LOG(sFunctionRef..': About to remove any dead units from tUnitsToReclaim for iPlateau-iLandZone='..iPlateau..'-'..iLandZone..', is table empty at start='..tostring(M28Utilities.IsTableEmpty(tUnitsToReclaim)))
        if M28Utilities.IsTableEmpty(tUnitsToReclaim) == false then
            LOG(sFunctionRef..': Size of tUnitsToReclaim='..table.getn(tUnitsToReclaim))
        end
    end

    function KeepCurEntry(tArray, iEntry)
        return M28UnitInfo.IsUnitValid(tArray[iEntry])
    end
    M28Utilities.RemoveEntriesFromArrayBasedOnCondition(tUnitsToReclaim, KeepCurEntry)
    if bDebugMessages == true then LOG(sFunctionRef..': Is table empty after removing dead units='..tostring(M28Utilities.IsTableEmpty(tUnitsToReclaim))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function CheckForUnitsToReclaimOfCategory(iTeam, iCategory, sTeamSubrefFlag)
    --Checks if we have any units of iCategory, and if so then checks if we have low enough mass to reclaim them; if we have enough mass then starts a while loop and only aborts once we no longer have any units of the category
    --CheckForUnitsToReclaimOfCategory - e.g. subrefbActiveT2PowerReclaimer
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CheckForUnitsToReclaimOfCategory'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    M28Team.tTeamData[iTeam][sTeamSubrefFlag] = true
    local bDontCheckForPower = true
    if M28UnitInfo.DoesCategoryContainCategory(M28UnitInfo.refCategoryPower, iCategory, false) then bDontCheckForPower = false end
    if bDebugMessages == true then LOG(sFunctionRef..': Checking to see if we have any units to reclaim for the specified category.  bDontCheckForPower='..tostring(bDontCheckForPower)) end
    while M28Team.GetCurrentUnitsOfCategory(iTeam, iCategory) > 0 do
        --Are we low on mass and not low on power?
        if bDebugMessages == true then LOG(sFunctionRef..': Will only add units to be reclaimed if we have low mass, and have power (if checking for power). Has low mass='..tostring(M28Conditions.TeamHasLowMass(iTeam))..'; Have low power='..tostring(M28Conditions.HaveLowPower(iTeam))) end
        if M28Conditions.TeamHasLowMass(iTeam) and (bDontCheckForPower or not(M28Conditions.HaveLowPower(iTeam))) then
            RecordUnitsOfCategoryToBeReclaimed(iTeam, iCategory)
            if bDebugMessages == true then LOG(sFunctionRef..': Have added any units to be reclaimed, will stop looping now') end
            break
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end

    M28Team.tTeamData[iTeam][sTeamSubrefFlag] = false
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderReclaimingPower(iTeam, oPowerJustBuilt)
    --Intended to be called whenever we build a PGen
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderReclaimingPower'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iPowerTechLevel = M28UnitInfo.GetUnitTechLevel(oPowerJustBuilt)
    if bDebugMessages == true then LOG(sFunctionRef..': Just built power='..oPowerJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPowerJustBuilt)..'; Gross energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Do we have active reclaimer logic for T1='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbActiveT1PowerReclaimer] or false)..'; Do we ahve active t2 reclaimer='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbActiveT2PowerReclaimer])) end
    if iPowerTechLevel == 2 then
        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 100 and not(M28Team.tTeamData[iTeam][M28Team.subrefbActiveT1PowerReclaimer]) and not(M28Team.tTeamData[iTeam][M28Team.subrefbActiveT2PowerReclaimer]) then
            if bDebugMessages == true then LOG(sFunctionRef..': Will check for t1 power that we can reclaim') end
            CheckForUnitsToReclaimOfCategory(iTeam, M28UnitInfo.refCategoryT1Power, M28Team.subrefbActiveT1PowerReclaimer)
        end
    elseif iPowerTechLevel == 3 then
        if not(M28Team.tTeamData[iTeam][M28Team.subrefbActiveT2PowerReclaimer]) then
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 500 then
                CheckForUnitsToReclaimOfCategory(iTeam, M28UnitInfo.refCategoryT1Power + M28UnitInfo.refCategoryT2Power, M28Team.subrefbActiveT2PowerReclaimer)
            elseif not(M28Team.tTeamData[iTeam][M28Team.subrefbActiveT1PowerReclaimer]) then
                if bDebugMessages == true then LOG(sFunctionRef..': Built T3 PGen, but sitll low gross energy, Will check for t1 power that we can reclaim') end
                CheckForUnitsToReclaimOfCategory(iTeam, M28UnitInfo.refCategoryT1Power, M28Team.subrefbActiveT1PowerReclaimer)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function GetCategoriesAndActionsToPause(iTeam, bStallingMass)
    local tCategoriesByPriority, tEngineerActionsByPriority
    if bStallingMass then
        tCategoriesByPriority = { M28UnitInfo.refCategorySMD, M28UnitInfo.refCategoryEngineerStation, M28UnitInfo.refCategoryLandFactory, M28UnitInfo.refCategoryRASSACU, M28UnitInfo.refCategoryEngineer, M28UnitInfo.refCategoryTML, M28UnitInfo.refCategoryAirFactory, iSpecialHQCategory, categories.COMMAND, M28UnitInfo.refCategoryMex, M28UnitInfo.refCategoryEngineer }

        tEngineerActionsByPriority = { { M28Engineer.refActionBuildQuantumOptics, M28Engineer.refActionBuildHive, M28Engineer.refActionBuildT3Radar, M28Engineer.refActionBuildSecondExperimental, M28Engineer.refActionNavalSpareAction, M28Engineer.refActionBuildT2Sonar, M28Engineer.refActionBuildThirdPower, M28Engineer.refActionBuildSecondAirFactory, M28Engineer.refActionBuildSecondLandFactory, M28Engineer.refActionBuildLandFactory, M28Engineer.refActionSAMCreep, M28Engineer.refActionBuildNavalFactory, M28Engineer.refActionAssistNavalFactory, M28Engineer.refActionBuildAirFactory, M28Engineer.refActionBuildT1Sonar, M28Engineer.refActionBuildT2Radar, M28Engineer.refActionBuildT1Radar, M28Engineer.refActionBuildSecondPower, M28Engineer.refActionBuildTML, M28Engineer.refActionBuildEnergyStorage, M28Engineer.refActionBuildAirStaging, M28Engineer.refActionBuildShield, M28Engineer.refActionBuildSecondShield, M28Engineer.refActionBuildExperimental, M28Engineer.refActionAssistAirFactory, M28Engineer.refActionUpgradeBuilding, M28Engineer.refActionBuildPower },
                                       { M28Engineer.refActionBuildHydro, M28Engineer.refActionFortifyFirebase, M28Engineer.refActionAssistShield, M28Engineer.refActionBuildSecondTMD, M28Engineer.refActionBuildMassStorage, M28Engineer.refActionAssistMexUpgrade, M28Engineer.refActionSpare, M28Engineer.refActionBuildTMD, M28Engineer.refActionBuildSMD, M28Engineer.refActionBuildEmergencyArti, M28Engineer.refActionBuildEmergencyPD }}
    else

        tCategoriesByPriority = { M28UnitInfo.refCategoryQuantumOptics, M28UnitInfo.refCategorySMD, M28UnitInfo.refCategoryEngineerStation, M28UnitInfo.refCategoryQuantumOptics, M28UnitInfo.refCategoryTML, M28UnitInfo.refCategoryAirFactory, M28UnitInfo.refCategoryRASSACU, M28UnitInfo.refCategoryEngineer, M28UnitInfo.refCategoryT3Radar, M28UnitInfo.refCategoryMex, categories.COMMAND, M28UnitInfo.refCategoryLandFactory, M28UnitInfo.refCategoryEngineer, M28UnitInfo.refCategorySML - categories.EXPERIMENTAL, iSpecialHQCategory, M28UnitInfo.refCategoryStealthGenerator, M28UnitInfo.refCategoryStealthAndCloakPersonal, M28UnitInfo.refCategoryRadar, M28UnitInfo.refCategoryPersonalShield, M28UnitInfo.refCategoryFixedShield, M28UnitInfo.refCategoryMobileLandShield, M28UnitInfo.refCategoryEngineer }
        tEngineerActionsByPriority = { { M28Engineer.refActionBuildQuantumOptics, M28Engineer.refActionBuildHive, M28Engineer.refActionBuildT3Radar, M28Engineer.refActionBuildSecondExperimental, M28Engineer.refActionNavalSpareAction, M28Engineer.refActionBuildT2Sonar, M28Engineer.refActionBuildT1Sonar, M28Engineer.refActionBuildT2Radar, M28Engineer.refActionBuildT1Radar, M28Engineer.refActionBuildTML, M28Engineer.refActionBuildEnergyStorage, M28Engineer.refActionBuildAirStaging, M28Engineer.refActionBuildShield, M28Engineer.refActionBuildSecondShield, M28Engineer.refActionBuildThirdPower, M28Engineer.refActionBuildExperimental, M28Engineer.refActionBuildSecondAirFactory, M28Engineer.refActionBuildAirFactory, M28Engineer.refActionBuildSecondLandFactory, M28Engineer.refActionSAMCreep, M28Engineer.refActionBuildLandFactory, M28Engineer.refActionBuildNavalFactory, M28Engineer.refActionAssistNavalFactory, M28Engineer.refActionAssistNavalFactory, M28Engineer.refActionBuildMassStorage,M28Engineer.refActionAssistMexUpgrade, M28Engineer.refActionUpgradeBuilding },
                                       { M28Engineer.refActionAssistAirFactory, M28Engineer.refActionSpare, M28Engineer.refActionBuildSecondPower, M28Engineer.refActionFortifyFirebase },
                                       { M28Engineer.refActionBuildTMD, M28Engineer.refActionBuildSMD, M28Engineer.refActionBuildEmergencyArti, M28Engineer.refActionBuildEmergencyPD, M28Engineer.refActionAssistShield, M28Engineer.refActionBuildSecondTMD, M28Engineer.refActionBuildMex } }
    end

    return tCategoriesByPriority, tEngineerActionsByPriority
end

function ManageMassStalls(iTeam)
    M28Utilities.ErrorHandler('To add code')

    M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] = false --placeholder
end

function ManageMassStalls(iTeam)
    --For now focus is on if we are trying to build a missile for an SML, or we are massively mass stalling
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMassStalls'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --if GetGameTimeSeconds() >= 960 and (aiBrain:GetEconomyStoredRatio('ENERGY') <= 0.05 or aiBrain[refbStallingEnergy]) then bDebugMessages = true end

    local bPauseNotUnpause = true
    local bChangeRequired = false
    local iUnitsAdjusted = 0
    local iMassStallPercentAdjust = 0
    if M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] then iMassStallPercentAdjust = 0.02 end
    --Dont consider pausing or unpausing if are stalling energy or early game, as our energy stall manager is likely to be operating
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, GetGameTimeSeconds='..GetGameTimeSeconds()..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Team stalling mass already='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass])..'; Team stalling energy='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])) end
    if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] or (GetGameTimeSeconds() >= 120 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 3 and not(aiBrain[refbStallingEnergy]) and GetGameTimeSeconds() - (aiBrain[refiLastEnergyStall] or -100) >= 10 and aiBrain:GetEconomyStoredRatio('ENERGY') == 1) then
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': About to consider if we have a mass stall or not. aiBrain:GetEconomyStoredRatio(MASS)=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] .. '; M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] .. '; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]))
        end
        --First consider unpausing
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': If we have flagged that we are stalling mass then will check if we have enough to start unpausing things')
        end

        if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] > (0.005 + iMassStallPercentAdjust) then
            --aiBrain[refbStallingEnergy] = false
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Have enough mass stored or income to start unpausing things')
            end
            bChangeRequired = true
            bPauseNotUnpause = false
        end
        if bDebugMessages == true then LOG(sFunctionRef .. ': Checking if we shoudl flag that we are mass stalling. bChangeRequired='..tostring(bChangeRequired)..'; Mass stored='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored]..'; Need resources for missile='..tostring((M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] or false))..'; Gross mass income='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]) end
        --Check if should manage mass stall
        if bChangeRequired == false and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] <= (0.001 + iMassStallPercentAdjust) and (M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] < -1 and (-M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] / M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 0.2))) then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': We are stalling mass, will look for units to pause')
            end
            bChangeRequired = true
            bPauseNotUnpause = true
            M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] = true
        end

        if bDebugMessages == true then LOG(sFunctionRef..': bChangeRequired='..tostring(bChangeRequired)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)) end

        if bChangeRequired then
            --Decide on order to pause/unpause

            local tCategoriesByPriority, tEngineerActionsByPriority = GetCategoriesAndActionsToPause(iTeam, true)

            local iMassPerTickSavingNeeded
            if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] then
                if M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] then iMassPerTickSavingNeeded = math.max(1, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass])
                else
                    iMassPerTickSavingNeeded = math.max(1, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] * 0.8)
                end
            else
                iMassPerTickSavingNeeded = math.min(-1, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] * 1.2)
                if M28Team.tTeamData[iTeam][M28Team.refbNeedResourcesForMissile] then iMassPerTickSavingNeeded = math.min(-1, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass])
                else
                    iMassPerTickSavingNeeded = math.min(-1, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] * 1.2)
                end
            end

            local iMassSavingManaged = 0
            local iEngineerSubtableCount = 0
            local tEngineerActionSubtable
            local tRelevantUnits, oUnit

            local bAbort = false
            local iTotalUnits = 0
            local iCategoryStartPoint, iIntervalChange, iCategoryEndPoint, iCategoryRef
            local bWasUnitPaused
            local bConsiderReclaimingEngineer = false
            local iKillCount = 0
            local iCurPlateau, iCurLandZone
            local bPausedUnitsTableIsEmptyForAllBrains = true

            if bPauseNotUnpause then
                iCategoryStartPoint = 1
                iIntervalChange = 1
                iCategoryEndPoint = table.getn(tCategoriesByPriority)
                if GetGameTimeSeconds() - M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEngiSelfDestruct] > 0.99 then
                    local iEngiCategoryWanted
                    if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer * categories.TECH3
                    elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] == 2 then iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer - categories.TECH1
                    else iEngiCategoryWanted = M28UnitInfo.refCategoryEngineer
                    end
                    local iCurEngis = 0
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                        iCurEngis = iCurEngis + oBrain:GetCurrentUnits(iEngiCategoryWanted)
                    end

                    if iCurEngis >= 10 then
                        --If are defending against arti then want a lot more engineers before start considering ctrl-king any
                        if not(M28Team.tTeamData[iTeam][M28Team.refbDefendAgainstArti]) or iCurEngis >= 70 then
                            bConsiderReclaimingEngineer = true
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Time of last engi self destruct='..M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEngiSelfDestruct]..'; bConsiderReclaimingEngineer='..tostring(bConsiderReclaimingEngineer)) end
            else
                iCategoryStartPoint = table.getn(tCategoriesByPriority)
                iIntervalChange = -1
                iCategoryEndPoint = 1
            end

            local bConsideringHQ
            local bNoRelevantUnits = true

            if bDebugMessages == true then
                LOG(sFunctionRef .. ': About to cycle through every category, bPauseNotUnpause=' .. tostring(bPauseNotUnpause) .. '; iCategoryStartPoint=' .. iCategoryStartPoint .. '; iCategoryEndPoint=' .. iCategoryEndPoint)
            end
            for iCategoryCount = iCategoryStartPoint, iCategoryEndPoint, iIntervalChange do
                iCategoryRef = tCategoriesByPriority[iCategoryCount]

                --Are we considering upgrading factory HQs?
                if iCategoryRef == iSpecialHQCategory then
                    iCategoryRef = M28UnitInfo.refCategoryAllHQFactories
                    bConsideringHQ = true
                else
                    bConsideringHQ = false
                end

                local iCurUnitMassUsage
                local bApplyActionToUnit
                local oBP
                local oFocusUnitBP

                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                    if bPauseNotUnpause then
                        tRelevantUnits = oBrain:GetListOfUnits(iCategoryRef, false, true)
                    else
                        tRelevantUnits = EntityCategoryFilterDown(iCategoryRef, oBrain[reftPausedUnits])
                    end

                    --for iBrain, oBrain in M28Team.tTeamDetails[iTeam][
                    if M28Utilities.IsTableEmpty(tRelevantUnits) == false then
                        bNoRelevantUnits = false
                        iTotalUnits = table.getn(tRelevantUnits)
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': iCategoryCount=' .. iCategoryCount .. '; iTotalUnits=' .. iTotalUnits .. '; bPauseNotUnpause=' .. tostring(bPauseNotUnpause))
                        end
                        if iCategoryRef == M28UnitInfo.refCategoryEngineer then
                            iEngineerSubtableCount = iEngineerSubtableCount + 1
                            tEngineerActionSubtable = tEngineerActionsByPriority[iEngineerSubtableCount]
                        end
                        for iUnit = iTotalUnits, 1, -1 do
                            oUnit = tRelevantUnits[iUnit]
                            --for iUnit, oUnit in tRelevantUnits do
                            bApplyActionToUnit = false
                            iCurUnitMassUsage = 0
                            if M28UnitInfo.IsUnitValid(oUnit, true) then --Only consider unit if it has been constructed
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': About to consider pausing/unpausingunit ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. '; will first check category specific logic for if we want to go ahead with pausing4')
                                end


                                --Do we actually want to pause the unit? check any category specific logic
                                bApplyActionToUnit = true
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': UnitState=' .. M28UnitInfo.GetUnitState(oUnit) .. '; Is ActiveHQUpgrades Empty=' .. tostring(M28Utilities.IsTableEmpty(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]))))
                                end
                                --Factories, ACU and engineers - dont pause if >=85% done
                                if bPauseNotUnpause and oUnit.GetWorkProgress and EntityCategoryContains(M28UnitInfo.refCategoryEngineer + categories.COMMAND + M28UnitInfo.refCategoryFactory, oUnit.UnitId) and (oUnit:GetWorkProgress() or 0) >= 0.85 then
                                    bApplyActionToUnit = false
                                    --SMD LOGIC - Check if already have 1 missile loaded before pausing
                                elseif iCategoryRef == M28UnitInfo.refCategorySMD and oUnit.GetTacticalSiloAmmoCount and oUnit:GetTacticalSiloAmmoCount() >= 1 then
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': Have SMD with at least 1 missile so will pause it')
                                    end
                                    bApplyActionToUnit = false
                                elseif iCategoryRef == M28UnitInfo.refCategoryEngineer then
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': Have an engineer with action=' .. (oUnit[M28Engineer.refiAssignedAction] or 'nil') .. '; tEngineerActionSubtable=' .. repru(tEngineerActionSubtable))
                                    end
                                    bApplyActionToUnit = false
                                    if not(bPauseNotUnpause) or not(oUnit:IsUnitState('Attached')) then
                                        for iActionCount, iActionRef in tEngineerActionSubtable do
                                            if iActionRef == oUnit[M28Engineer.refiAssignedAction] then
                                                bApplyActionToUnit = true
                                                if bDebugMessages == true then LOG(sFunctionRef..': Have an action match, iActionRef='..iActionRef..'; will apply action to unitunless have an override such as priamry power builder, oUnit[M28Engineer.refbPrimaryBuilder]='..tostring(oUnit[M28Engineer.refbPrimaryBuilder])) end
                                                --Dont pause the last engi building power, and also dont pause if are building PD/T2 Arti/Shield/Experimental and have a fraction complete of at least 70%
                                                if bPauseNotUnpause and iActionRef == M28Engineer.refActionBuildPower and oUnit[M28Engineer.refbPrimaryBuilder] then
                                                    bApplyActionToUnit = false
                                                elseif bPauseNotUnpause and oUnit.GetFocusUnit then
                                                    local oFocusUnit = oUnit:GetFocusUnit()
                                                    if bDebugMessages == true then
                                                        if M28UnitInfo.IsUnitValid(oFocusUnit) then
                                                            LOG(sFunctionRef..': Considering engineer '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; UC='..M28Engineer.GetEngineerUniqueCount(oUnit)..'; Focus unit='..oFocusUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFocusUnit)..'; Fraction complete='..oFocusUnit:GetFractionComplete())
                                                        else LOG(sFunctionRef..': Focus unit for engineer '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; UC='..M28Engineer.GetEngineerUniqueCount(oUnit)..' isnt valid') end
                                                    end
                                                    if M28UnitInfo.IsUnitValid(oFocusUnit) and oFocusUnit:GetFractionComplete() >= 0.7 and oFocusUnit:GetFractionComplete() < 1 then
                                                        if EntityCategoryContains(M28UnitInfo.refCategoryPD + M28UnitInfo.refCategoryFixedT2Arti + M28UnitInfo.refCategoryExperimentalLevel, oFocusUnit.UnitId) then
                                                            if bDebugMessages == true then LOG(sFunctionRef..': Wont apply action to unit as it is PD/Arti/Experimental') end
                                                            bApplyActionToUnit = false
                                                        elseif bDebugMessages == true then LOG(sFunctionRef..': Will apply action to focus unit as it isnt PD/Experimental level')
                                                        end
                                                    end
                                                end
                                                if bApplyActionToUnit and bConsiderReclaimingEngineer and not(oUnit[M28Engineer.refbPrimaryBuilder]) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), M28Map.PlayerStartPoints[oBrain:GetArmyIndex()]) <= 90 then
                                                    --Is there reclaim near the engineer? If so clear its orders and have it reclaim, otherwise kill it
                                                    local oBP = oUnit:GetBlueprint()
                                                    if oBP.Economy.BuildCostMass < 500 and oBP.Economy.MaxBuildDistance then --redundancy so we dont ctrl-K SACUs or a unit with no build radius
                                                        bApplyActionToUnit = false


                                                        function KillEngineer(oUnit)
                                                            if bDebugMessages == true then LOG(sFunctionRef..': About to kill engineer '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                                            M28Orders.IssueTrackedKillUnit(oUnit)
                                                            iKillCount = iKillCount + 1
                                                            if iKillCount >= 2 then
                                                                bConsiderReclaimingEngineer = false
                                                            end
                                                            M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEngiSelfDestruct] = GetGameTimeSeconds()
                                                        end
                                                        iCurPlateau, iCurLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                                                        if (iCurPlateau or 0) > 0 and (iCurLandZone or 0) > 0 then
                                                            if M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefLZReclaimMass] > 30 then
                                                                M28Engineer.GetEngineerToReclaimNearbyArea(oUnit, M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefLZTeamData][iTeam], iCurPlateau, iCurLandZone, false, true)
                                                                --Kill engineers if htey are in a core LZ
                                                            elseif M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTCoreBase] then
                                                                KillEngineer(oUnit)
                                                            end
                                                        end
                                                    end
                                                end
                                                break
                                            end
                                        end
                                    end
                                elseif iCategoryRef == M28UnitInfo.refCategoryPersonalShield or iCategoryRef == M28UnitInfo.refCategoryFixedShield or iCategoryRef == M28UnitInfo.refCategoryMobileLandShield then
                                    --Mass stalling so pausing shield not expected to do anything
                                    if bPauseNotUnpause then bApplyActionToUnit = false end
                                end



                                if iCategoryRef == categories.COMMAND then
                                    --want in addition to above as ACU might have personal shield
                                    if bPauseNotUnpause then
                                        if oUnit:IsUnitState('Upgrading') then
                                            bApplyActionToUnit = false
                                        elseif oUnit.GetWorkProgress then
                                            --if oUnit:GetWorkProgress() >= 0.85 then
                                            bApplyActionToUnit = false
                                            --dont pause t1 mex construction
                                            if oUnit.GetFocusUnit and oUnit:GetFocusUnit() and oUnit:GetFocusUnit().UnitId and EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oUnit:GetFocusUnit().UnitId) then
                                                bApplyActionToUnit = false
                                            end
                                        end
                                    end
                                end


                                --Pause the unit

                                if bApplyActionToUnit then
                                    bWasUnitPaused = oUnit[M28UnitInfo.refbPaused] --Means we will ignore the mass usage when calculating how much we have saved
                                    oBP = oUnit:GetBlueprint()
                                    iCurUnitMassUsage = oBP.Economy.MaintenanceConsumptionPerSecondMass

                                    if (iCurUnitMassUsage or 0) == 0 or iCategoryRef == M28UnitInfo.refCategoryEngineer or iCategoryRef == M28UnitInfo.refCategoryMex or iCategoryRef == categories.COMMAND then
                                        --Approximate mass usage based on build rate as a very rough guide
                                        --examples: Upgrading mex to T3 costs 11E per BP; T3 power is 8.4; T1 power is 6; Guncom is 30; Laser is 178; Strat bomber is 15
                                        local iMassPerBP = 0.25 --e.g. building t1 land factory uses 4; building a titan uses 1.1; divide by 10 as dealing with values per tick
                                        if EntityCategoryContains(categories.SILO, oUnit.UnitId) and oBP.Economy.BuildRate then
                                            --Dealing with a silo so need to calculate mass usage differently
                                            iCurUnitMassUsage = 0
                                            for iWeapon, tWeapon in oBP.Weapon do
                                                if tWeapon.MaxProjectileStorage and tWeapon.ProjectileId then
                                                    local oProjectileBP = __blueprints[tWeapon.ProjectileId]
                                                    if oProjectileBP.Economy and oProjectileBP.Economy.BuildCostMass and oProjectileBP.Economy.BuildTime > 0 and oBP.Economy.BuildRate > 0 then
                                                        iCurUnitMassUsage = oProjectileBP.Economy.BuildCostMass * oBP.Economy.BuildRate / oProjectileBP.Economy.BuildTime
                                                        --If are power stalling then assume we only save 80% of this, as might have adjacency
                                                        if bPauseNotUnpause then iCurUnitMassUsage = iCurUnitMassUsage * 0.8 end
                                                        break
                                                    end
                                                end
                                            end
                                        else
                                            if iCategoryRef == categories.COMMAND and oUnit[M28UnitInfo.refsUpgradeRef] then
                                                --Determine mass cost per BP
                                                if bDebugMessages == true then LOG(sFunctionRef..': aiBrain='..oUnit:GetAIBrain():GetArmyIndex()..'; Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[M28UnitInfo.refsUpgradeRef]='..(oUnit[M28UnitInfo.refsUpgradeRef] or 'nil')..'; Upgrade mass cost='..(M28UnitInfo.GetUpgradeMassCost(oUnit, oUnit[M28UnitInfo.refsUpgradeRef]) or 'nil')..'; Upgrade build time='..(M28UnitInfo.GetUpgradeBuildTime(oUnit, oUnit[M28UnitInfo.refsUpgradeRef]) or 'nil')) end
                                                iMassPerBP = M28UnitInfo.GetUpgradeMassCost(oUnit, oUnit[M28UnitInfo.refsUpgradeRef]) / (M28UnitInfo.GetUpgradeBuildTime(oUnit, oUnit[M28UnitInfo.refsUpgradeRef]) or 1)
                                            end

                                            if oBP.Economy.BuildRate then
                                                --iCurUnitEnergyUsage = oBP.Economy.BuildRate * iEnergyPerBP
                                                --Reduce this massively if unit isn't actually building anything
                                                if bPauseNotUnpause then
                                                    if (not(oUnit:IsUnitState('Building')) and not(oUnit:IsUnitState('Repairing')) and not(oUnit.GetWorkProgress and oUnit:GetWorkProgress() > 0)) then
                                                        iCurUnitMassUsage = oBP.Economy.BuildRate * 0.01
                                                    else
                                                        if M28UnitInfo.IsUnitValid(oUnit:GetFocusUnit()) then
                                                            oFocusUnitBP = oUnit:GetFocusUnit():GetBlueprint()
                                                            iCurUnitMassUsage = oBP.Economy.BuildRate / oFocusUnitBP.Economy.BuildTime * oFocusUnitBP.Economy.BuildCostMass * 0.1
                                                            oUnit[refiLastMassUsage] = iCurUnitMassUsage
                                                        else
                                                            iCurUnitMassUsage = oBP.Economy.BuildRate * iMassPerBP
                                                        end
                                                    end
                                                else
                                                    iCurUnitMassUsage = (oUnit[refiLastMassUsage] or oBP.Economy.BuildRate * iMassPerBP)
                                                end
                                            end
                                        end
                                    end
                                    --We're working in ticks so adjust mass usage accordingly
                                    iCurUnitMassUsage = iCurUnitMassUsage * 0.1
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': Estimated mass usage=' .. iCurUnitMassUsage..'; About to call the function PauseOrUnpauseMassUsage on unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; iUnitsAdjusted before counting this unit='..iUnitsAdjusted)
                                    end

                                    if not((iCurUnitMassUsage or 0) == 0) then iUnitsAdjusted = iUnitsAdjusted + 1 end
                                    M28UnitInfo.PauseOrUnpauseMassUsage(oUnit, bPauseNotUnpause)
                                    --Cant move the below into unitinfo as get a crash if unitinfo tries to refernce the table of paused units
                                        --Have made localised variable which looks to fix the issue
                                end
                            end
                            if not (bWasUnitPaused) and bPauseNotUnpause then
                                iMassSavingManaged = iMassSavingManaged + iCurUnitMassUsage
                            elseif bWasUnitPaused and not (bPauseNotUnpause) then
                                iMassSavingManaged = iMassSavingManaged - iCurUnitMassUsage
                            end
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': iMassSavingManaged=' .. iMassSavingManaged .. '; iMassPerTickSavingNeeded=' .. iMassPerTickSavingNeeded .. '; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]))
                            end

                            if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] then
                                if iMassSavingManaged > iMassPerTickSavingNeeded then
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': Estimate we have saved ' .. iMassSavingManaged .. ' which is more tahn we wanted so will pause')
                                    end
                                    bAbort = true
                                    break
                                end
                            else
                                if iMassSavingManaged < iMassPerTickSavingNeeded then
                                    bAbort = true
                                    break
                                end
                            end
                        end
                    elseif bDebugMessages == true then
                        LOG(sFunctionRef .. ': We have no units for iCategoryCount=' .. iCategoryCount)
                    end

                    if bPausedUnitsTableIsEmptyForAllBrains and M28Utilities.IsTableEmpty(oBrain[reftPausedUnits]) == false then
                        bPausedUnitsTableIsEmptyForAllBrains = false
                    end

                    if bAbort then
                        break
                    end
                end
                if bAbort then
                    break
                end
            end
            if bDebugMessages == true then
                LOG(sFunctionRef .. 'If we have no paused units then will set us as not having a mass stall')
            end
            if bPausedUnitsTableIsEmptyForAllBrains then
                M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] = false
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': We are no longer stalling mass')
                end
            else
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': About to check if we wanted to unpause units but havent unpaused anything; iUnitsAdjusted=' .. iUnitsAdjusted .. '; bNoRelevantUnits=' .. tostring(bNoRelevantUnits) .. '; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]))
                end
                --Backup - sometimes we still have units in the table listed as being paused (e.g. if an engineer changes action to one that isnt listed as needing pausing) - unpause them if we couldnt find via category search
                if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] and not (bPauseNotUnpause) and (iUnitsAdjusted == 0 or bNoRelevantUnits) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.03 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] >= 0.9 then
                    --Have a decent amount of mass, are flagged as stalling mass, but couldnt find any categories to unpause
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': werent able to find any units to unpause with normal approach so will unpause all remaining units')
                    end
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                        local iLoopCountCheck = 0
                        local iMaxLoop = math.max(20, table.getn(oBrain[reftPausedUnits]) + 1)
                        while M28Utilities.IsTableEmpty(oBrain[reftPausedUnits]) == false do
                            iLoopCountCheck = iLoopCountCheck + 1
                            if iLoopCountCheck >= iMaxLoop then
                                M28Utilities.ErrorHandler('Infinite loop likely')
                                break
                            end
                            if M28Utilities.IsTableEmpty(oBrain[reftPausedUnits]) == false then
                                for iUnit, oUnit in oBrain[reftPausedUnits] do
                                    if bDebugMessages == true then
                                        if M28UnitInfo.IsUnitValid(oUnit) then
                                            LOG(sFunctionRef .. ': About to unpause ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit))
                                        else
                                            LOG('Removing iUnit=' .. iUnit .. ' which is no longer valid')
                                        end
                                        LOG('Size of oBrain[reftPausedUnits] before removal=' .. table.getn(oBrain[reftPausedUnits]) .. '; will double check this size')
                                        local iActualSize = 0
                                        for iAltUnit, oAltUnit in oBrain[reftPausedUnits] do
                                            iActualSize = iActualSize + 1
                                        end
                                        LOG('Actual size=' .. iActualSize)
                                    end
                                    if M28UnitInfo.IsUnitValid(oUnit) then
                                        M28UnitInfo.PauseOrUnpauseMassUsage(oUnit, false)
                                    end
                                    table.remove(oBrain[reftPausedUnits], iUnit)
                                    break
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': FInished unpausing units')
                    end
                end
            end
        end
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': End of code, M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass]) .. '; Stalling energy='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; bPauseNotUnpause=' .. tostring(bPauseNotUnpause) .. '; iUnitsAdjusted=' .. iUnitsAdjusted .. '; Game time=' .. GetGameTimeSeconds() .. '; Mass stored %=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] .. '; Net mass income=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] .. '; gross mass income=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass])
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageEnergyStalls(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageEnergyStalls'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --if GetGameTimeSeconds() >= 1080 and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= 0.05 or M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) then bDebugMessages = true end

    local bPauseNotUnpause = true
    local bChangeRequired = false
    local iUnitsAdjusted = 0
    local bHaveWeCappedUnpauseAmount = false
    if (GetGameTimeSeconds() >= 120 or (GetGameTimeSeconds() >= 40 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 15)) then
        --Only consider power stall management after 2m, otherwise risk pausing things such as early microbots when we would probably be ok after a couple of seconds; lower time limit put in as a theroetical possibility due to AIX
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': About to consider if we have an energy stall or not. Lowest energy % stored=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] .. '; M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] .. '; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]))
        end
        --First consider unpausing
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': If we have flagged that we are stalling energy then will check if we have enough to start unpausing things')
        end
        local iT3Arti = 0
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoT3Arti]) == false then
            iT3Arti = table.getn(M28Team.tTeamData[iTeam][M28Team.subreftoT3Arti])
            -- = oBrain:GetCurrentUnits(M28UnitInfo.refCategoryFixedT3Arti + M28UnitInfo.refCategoryExperimentalArti)
        end
        local iPercentMod = 0
        local iNetMod = 0
        if iT3Arti > 0 then
            iPercentMod = 0.1
            --Already factored in to the net income, this gives a further buffer
            iNetMod = 25 + (iT3Arti - 1) * 100
        end
        --Also increase net energy if are at tech 3 and lack 3k power
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] <= 300 then iNetMod = iNetMod + 25 end

            iPercentMod = math.max(0.05, iPercentMod)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': If are in stall mode will check if want to come out. M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; Gross income='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Stored ratio='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored]..'; Net income='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; iNetMod='..iNetMod..'; iPercentMod='..iPercentMod..'; GameTime='..GetGameTimeSeconds()..'; M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled]='..M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled]..'; Changei n power since then='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] - M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled]) end

        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 800 then iPercentMod = math.max(iPercentMod,  math.min(iPercentMod + 0.2, 0.275)) end

        if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] and M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] - M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] >= 45 then
            iPercentMod = iPercentMod -0.3
        end

        if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 100000 or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] > math.min(0.95, (0.8 + iPercentMod)) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] > (0.7 + iPercentMod) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > (1 + iNetMod)) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] > (0.5 + iPercentMod) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] > (4 + iNetMod)) or (GetGameTimeSeconds() <= 180 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] >= 0.3))) then
            --M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] = false
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': Have enough energy stored or income to start unpausing things')
            end
            bChangeRequired = true
            bPauseNotUnpause = false
        end
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': Checking if we shoudl flag that we are energy stalling')
        end
        --Check if should manage energy stall
        if bChangeRequired == false and (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= (0.08 + iPercentMod) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= (0.6 + iPercentMod) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < (2 + iNetMod)) or (M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= (0.4 + iPercentMod) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] < (0.5 + (M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] - 1) * 5 + iNetMod))) then
            if bDebugMessages == true then
                LOG(sFunctionRef .. ': We are stalling energy, will look for units to pause, subject to early game check')
            end
            --If this is early game then add extra check
            if GetGameTimeSeconds() >= 180 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= 0.04 then
                M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] = true
                bChangeRequired = true
                M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] = M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]
                if bDebugMessages == true then LOG(sFunctionRef..': early game check cleared, so are stalling energy') end
            end
        end

        if bChangeRequired then
            if bPauseNotUnpause then
                if bDebugMessages == true then LOG(sFunctionRef..': Change is required and we want to pause units') end
                M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] = true
                M28Team.tTeamData[iTeam][M28Team.subrefiGrossEnergyWhenStalled] = M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]
            end --redundancy
            M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] = GetGameTimeSeconds()
            --Decide on order to pause/unpause

            local tCategoriesByPriority, tEngineerActionsByPriority = GetCategoriesAndActionsToPause(iTeam)

            local iEnergyPerTickSavingNeeded
            if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] then
                iEnergyPerTickSavingNeeded = math.max(1, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] + iNetMod * 0.5 + M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.02)
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= 0.15 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have less than 15% energy stored so increasing the energy saving wanted. iEnergyPerTickSavingNeeded pre increase='..iEnergyPerTickSavingNeeded..'; Gross base income='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Cur energy storage units='..oBrain:GetCurrentUnits(M28UnitInfo.refCategoryEnergyStorage)) end
                    local iStorageFactor = 50
                    if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 1000 then iStorageFactor = 100 end
                    iEnergyPerTickSavingNeeded = math.max(iEnergyPerTickSavingNeeded * 1.3, iEnergyPerTickSavingNeeded + M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.03)
                    iEnergyPerTickSavingNeeded = math.max(iEnergyPerTickSavingNeeded, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.06, math.min(oBrain:GetCurrentUnits(M28UnitInfo.refCategoryEnergyStorage) * iStorageFactor, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]*0.15))
                elseif M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= 0.225 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Less than 22.5% energy stored so increasing energy saving slightly') end
                    iEnergyPerTickSavingNeeded = math.max(iEnergyPerTickSavingNeeded * 1.15, iEnergyPerTickSavingNeeded + M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] * 0.015)
                end
            else
                iEnergyPerTickSavingNeeded = math.min(-1, -M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy])
                iEnergyPerTickSavingNeeded = math.max(iEnergyPerTickSavingNeeded, -300)
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] <= 0.75 then iEnergyPerTickSavingNeeded = iEnergyPerTickSavingNeeded * 0.75 end
            end

            local iEnergySavingManaged = 0
            local iEngineerSubtableCount = 0
            local tEngineerActionSubtable
            local tRelevantUnits, oUnit

            local bAbort = false
            local iTotalUnits = 0
            local iCategoryStartPoint, iIntervalChange, iCategoryEndPoint, iCategoryRef
            local bWasUnitPaused
            if bPauseNotUnpause then
                iCategoryStartPoint = 1
                iIntervalChange = 1
                iCategoryEndPoint = table.getn(tCategoriesByPriority)
            else
                iCategoryStartPoint = table.getn(tCategoriesByPriority)
                iIntervalChange = -1
                iCategoryEndPoint = 1
            end

            local bConsideringHQ
            local bNoRelevantUnits = true

            if bDebugMessages == true then
                LOG(sFunctionRef .. ': About to cycle through every category, bPauseNotUnpause=' .. tostring(bPauseNotUnpause) .. '; iCategoryStartPoint=' .. iCategoryStartPoint .. '; iCategoryEndPoint=' .. iCategoryEndPoint)
            end

            local bPausedUnitsTableIsEmptyForAllBrains = true
            for iCategoryCount = iCategoryStartPoint, iCategoryEndPoint, iIntervalChange do
                iCategoryRef = tCategoriesByPriority[iCategoryCount]

                --Are we considering upgrading factory HQs?
                if iCategoryRef == iSpecialHQCategory then
                    iCategoryRef = M28UnitInfo.refCategoryAllHQFactories
                    bConsideringHQ = true
                else
                    bConsideringHQ = false
                end

                local iCurUnitEnergyUsage
                local bApplyActionToUnit
                local oBP
                local oFocusUnitBP

                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                    if bPauseNotUnpause then
                        tRelevantUnits = oBrain:GetListOfUnits(iCategoryRef, false, true)
                    else
                        tRelevantUnits = EntityCategoryFilterDown(iCategoryRef, oBrain[reftPausedUnits])
                    end


                    if M28Utilities.IsTableEmpty(tRelevantUnits) == false then
                        bNoRelevantUnits = false
                        iTotalUnits = table.getn(tRelevantUnits)
                        if bDebugMessages == true then
                            LOG(sFunctionRef .. ': iCategoryCount=' .. iCategoryCount .. '; iTotalUnits=' .. iTotalUnits .. '; bPauseNotUnpause=' .. tostring(bPauseNotUnpause))
                        end
                        if iCategoryRef == M28UnitInfo.refCategoryEngineer then
                            iEngineerSubtableCount = iEngineerSubtableCount + 1
                            tEngineerActionSubtable = tEngineerActionsByPriority[iEngineerSubtableCount]
                        end

                        for iUnit = iTotalUnits, 1, -1 do
                            oUnit = tRelevantUnits[iUnit]
                            --for iUnit, oUnit in tRelevantUnits do
                            bApplyActionToUnit = false
                            iCurUnitEnergyUsage = 0
                            if M28UnitInfo.IsUnitValid(oUnit, true) then --Only consider unit if it has been constructed
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': About to consider pausing/unpausingunit ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit) .. '; will first check category specific logic for if we want to go ahead with pausing4')
                                end


                                --Do we actually want to pause the unit? check any category specific logic
                                bApplyActionToUnit = true
                                if bDebugMessages == true then
                                    LOG(sFunctionRef .. ': UnitState=' .. M28UnitInfo.GetUnitState(oUnit) .. '; Is ActiveHQUpgrades Empty=' .. tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs])))
                                end
                                --SMD LOGIC - Check if already have 1 missile loaded before pausing
                                if iCategoryRef == M28UnitInfo.refCategorySMD and oUnit.GetTacticalSiloAmmoCount and oUnit:GetTacticalSiloAmmoCount() >= 1 then
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': Have SMD with at least 1 missile so will pause it')
                                    end
                                    bApplyActionToUnit = false
                                elseif iCategoryRef == M28UnitInfo.refCategoryEngineer then
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': Have an engineer with action=' .. (oUnit[M28Engineer.refiAssignedAction] or 'nil') .. '; tEngineerActionSubtable=' .. repru(tEngineerActionSubtable))
                                    end
                                    bApplyActionToUnit = false
                                    if not(oUnit[M28Engineer.refiAssignedAction]) and not(bPauseNotUnpause) then bApplyActionToUnit = true
                                    else
                                        for iActionCount, iActionRef in tEngineerActionSubtable do
                                            if iActionRef == oUnit[M28Engineer.refiAssignedAction] then
                                                bApplyActionToUnit = true
                                                --Dont pause the last engi building power
                                                if bPauseNotUnpause and iActionRef == M28Engineer.refActionBuildPower and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestMassPercentStored] >= 0.7 then
                                                    bApplyActionToUnit = false
                                                end
                                                break
                                            end
                                        end
                                    end
                                elseif iCategoryRef == M28UnitInfo.refCategoryPersonalShield or iCategoryRef == M28UnitInfo.refCategoryFixedShield or iCategoryRef == M28UnitInfo.refCategoryMobileLandShield then
                                    --Dont disable shield if unit has enemies nearby
                                    if bPauseNotUnpause and M28UnitInfo.IsUnitShieldEnabled(oUnit) and M28Utilities.IsTableEmpty(oBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryDangerousToLand, oUnit:GetPosition(), 40, 'Enemy')) == false then
                                        bApplyActionToUnit = false
                                    end
                                elseif iCategoryRef == M28UnitInfo.refCategoryAirFactory or iCategoryRef == M28UnitInfo.refCategoryLandFactory then
                                    --Dont want to pause an HQ upgrade since it will give us better power
                                    if bPauseNotUnpause and not (bConsideringHQ) and oUnit:IsUnitState('Upgrading') and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]) == false and EntityCategoryContains(categories.FACTORY, oUnit) then
                                        for iFactory, oFactory in M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs] do
                                            if oUnit == oFactory then
                                                bApplyActionToUnit = false
                                                break
                                            end
                                        end
                                    elseif not (bPauseNotUnpause) and bConsideringHQ then
                                        --Only unpause HQs
                                        bApplyActionToUnit = false
                                        if oUnit:IsUnitState('Upgrading') and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs]) == false then
                                            for iFactory, oFactory in M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingHQs] do
                                                if oUnit == oFactory then
                                                    bApplyActionToUnit = true
                                                    break
                                                end
                                            end
                                        end
                                    end
                                    if bApplyActionToUnit and bPauseNotUnpause then
                                        --Dont pause factory that is building an engineer or is an air factory that isnt building an air unit, if its our highest tech level and we dont have at least 5 engis of that tech level
                                        if M28UnitInfo.GetUnitTechLevel(oUnit) >= math.max(2, M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]) and oBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer * M28UnitInfo.ConvertTechLevelToCategory(M28UnitInfo.GetUnitTechLevel(oUnit))) < 2 then
                                            --Dont pause factory as have too few engis and want to build power with those engis
                                            if bDebugMessages == true then
                                                LOG(sFunctionRef .. ': Have too few engineers so wont pause factory')
                                            end
                                            bApplyActionToUnit = false
                                        end
                                    end
                                end

                                if iCategoryRef == categories.COMMAND then
                                    --want in addition to above as ACU might have personal shield
                                    if bPauseNotUnpause then
                                        if not (oUnit:IsUnitState('Upgrading')) then
                                            bApplyActionToUnit = false
                                        elseif oUnit.GetWorkProgress then
                                            if oUnit:GetWorkProgress() >= 0.85 then
                                                bApplyActionToUnit = false
                                                --dont pause t1 mex construction
                                            elseif oUnit.GetFocusUnit and oUnit:GetFocusUnit() and oUnit:GetFocusUnit().UnitId and EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oUnit:GetFocusUnit().UnitId) then
                                                bApplyActionToUnit = false
                                            end
                                        end
                                    else
                                        bApplyActionToUnit = true --redundancy - are unpausing units so want to unpause ACU asap
                                    end
                                end


                                --Pause the unit

                                if bDebugMessages == true then LOG(sFunctionRef..': bApplyActionToUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'='..tostring(bApplyActionToUnit)) end

                                if bApplyActionToUnit then
                                    bWasUnitPaused = oUnit[M28UnitInfo.refbPaused] --Means we will ignore the energy usage when calculating how much we have saved
                                    oBP = oUnit:GetBlueprint()
                                    iCurUnitEnergyUsage = oBP.Economy.MaintenanceConsumptionPerSecondEnergy

                                    if (iCurUnitEnergyUsage or 0) == 0 or iCategoryRef == M28UnitInfo.refCategoryEngineer or iCategoryRef == M28UnitInfo.refCategoryMex or iCategoryRef == categories.COMMAND then
                                        --Approximate energy usage based on build rate as a very rough guide
                                        --examples: Upgrading mex to T3 costs 11E per BP; T3 power is 8.4; T1 power is 6; Guncom is 30; Laser is 178; Strat bomber is 15
                                        local iEnergyPerBP = 9
                                        if EntityCategoryContains(categories.SILO, oUnit.UnitId) and oBP.Economy.BuildRate then
                                            --Dealing with a silo so need to calculate energy usage differently
                                            iCurUnitEnergyUsage = 0
                                            for iWeapon, tWeapon in oBP.Weapon do
                                                if tWeapon.MaxProjectileStorage and tWeapon.ProjectileId then
                                                    local oProjectileBP = __blueprints[tWeapon.ProjectileId]
                                                    if oProjectileBP.Economy and oProjectileBP.Economy.BuildCostEnergy and oProjectileBP.Economy.BuildTime > 0 and oBP.Economy.BuildRate > 0 then
                                                        --(will multiply cost by 10% in later step)
                                                        iCurUnitEnergyUsage = oProjectileBP.Economy.BuildCostEnergy * oBP.Economy.BuildRate / oProjectileBP.Economy.BuildTime
                                                        --If are power stalling then assume we only save 80% of this, as might have adjacency
                                                        if bPauseNotUnpause then iCurUnitEnergyUsage = iCurUnitEnergyUsage * 0.8 end
                                                        break
                                                    end
                                                end
                                            end
                                        else
                                            if iCategoryRef == categories.COMMAND and oUnit[M28UnitInfo.refsUpgradeRef] then
                                                --Determine energy cost per BP
                                                iEnergyPerBP = M28UnitInfo.GetUpgradeEnergyCost(oUnit, oUnit[M28UnitInfo.refsUpgradeRef]) / (M28UnitInfo.GetUpgradeBuildTime(oUnit, oUnit[M28UnitInfo.refsUpgradeRef]) or 1)
                                                oUnit[refiLastEnergyUsage] = iCurUnitEnergyUsage
                                            else
                                                --Engineer - adjust energy consumption based on what are building
                                                iEnergyPerBP = 3
                                            end

                                            if oBP.Economy.BuildRate then
                                                --iCurUnitEnergyUsage = oBP.Economy.BuildRate * iEnergyPerBP
                                                --Reduce this massively if unit isn't actually building anything
                                                if bPauseNotUnpause then
                                                    if (not(oUnit:IsUnitState('Building')) and not(oUnit:IsUnitState('Repairing')) and not(oUnit.GetWorkProgress and oUnit:GetWorkProgress() > 0)) then
                                                        iCurUnitEnergyUsage = oBP.Economy.BuildRate * 0.01
                                                    else
                                                        if M28UnitInfo.IsUnitValid(oUnit:GetFocusUnit()) then
                                                            oFocusUnitBP = oUnit:GetFocusUnit():GetBlueprint()
                                                            iCurUnitEnergyUsage = oBP.Economy.BuildRate / oFocusUnitBP.Economy.BuildTime * oFocusUnitBP.Economy.BuildCostEnergy * 0.1
                                                            oUnit[refiLastEnergyUsage] = iCurUnitEnergyUsage
                                                        else
                                                            iCurUnitEnergyUsage = oBP.Economy.BuildRate * iEnergyPerBP
                                                        end
                                                    end
                                                else
                                                    iCurUnitEnergyUsage = (oUnit[refiLastEnergyUsage] or oBP.Economy.BuildRate * iEnergyPerBP)
                                                end
                                            end
                                        end
                                    end
                                    --We're working in ticks so adjust energy usage accordingly
                                    iCurUnitEnergyUsage = iCurUnitEnergyUsage * 0.1
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': Estimated energy usage before factoring in unit state=' .. iCurUnitEnergyUsage..'; About to call the function PauseOrUnpauseEnergyUsage on unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bPauseNotUnpause='..tostring(bPauseNotUnpause)..'; iUnitsAdjusted where expected to save energy='..iUnitsAdjusted)
                                    end

                                    if not((iCurUnitEnergyUsage or 0) == 0) then
                                        iUnitsAdjusted = iUnitsAdjusted + 1
                                        if bPauseNotUnpause and EntityCategoryContains(M28UnitInfo.refCategoryEngineer + M28UnitInfo.refCategoryFactory, oUnit.UnitId) then
                                            if not(oUnit:IsUnitState('Upgrading') or oUnit:IsUnitState('Repairing') or oUnit:IsUnitState('Building')) then
                                                iCurUnitEnergyUsage = iCurUnitEnergyUsage * 0.01
                                                if bDebugMessages == true then LOG(sFunctionRef..': Unit state='..M28UnitInfo.GetUnitState(oUnit)..' so will set the amount of energy saved equal to just 1% of the actual value, so it is now '..iCurUnitEnergyUsage) end
                                            end
                                        end
                                    end
                                    M28UnitInfo.PauseOrUnpauseEnergyUsage(oUnit, bPauseNotUnpause)
                                    --Cant move the below into unitinfo as get a crash if unitinfo tries to refernce the table of paused units
                                        --Managed to avoid the crash by making a localised import of M28Economy into the pauseorunpause function; want it in unitinfo as then m28orders can call the same function when clearing an engineer's orders


                                    --[[if bPauseNotUnpause then
                                        table.insert(oBrain[reftPausedUnits], oUnit)
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Added unit to tracker table, size=' .. table.getn(oBrain[reftPausedUnits]))
                                        end
                                    else
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Will remove unit from reftPausedUnits. Size of table before removal=' .. table.getn(oBrain[reftPausedUnits]))
                                        end
                                        for iPausedUnit, oPausedUnit in oBrain[reftPausedUnits] do
                                            if oPausedUnit == oUnit then
                                                table.remove(oBrain[reftPausedUnits], iPausedUnit)
                                            end
                                        end
                                        if bDebugMessages == true then
                                            LOG(sFunctionRef .. ': Size of table after removal =' .. table.getn(oBrain[reftPausedUnits]))
                                        end
                                    end--]]

                                end
                            end
                            if not (bWasUnitPaused) and bPauseNotUnpause then
                                iEnergySavingManaged = iEnergySavingManaged + iCurUnitEnergyUsage
                            elseif bWasUnitPaused and not (bPauseNotUnpause) then
                                iEnergySavingManaged = iEnergySavingManaged - iCurUnitEnergyUsage
                            end
                            if bDebugMessages == true then
                                LOG(sFunctionRef .. ': iEnergySavingManaged=' .. iEnergySavingManaged .. '; iEnergyPerTickSavingNeeded=' .. iEnergyPerTickSavingNeeded .. '; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]))
                            end

                            if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] then
                                if iEnergySavingManaged > iEnergyPerTickSavingNeeded then
                                    if bDebugMessages == true then
                                        LOG(sFunctionRef .. ': Estimate we have saved ' .. iEnergySavingManaged .. ' which is more tahn we wanted so will pause')
                                    end
                                    bAbort = true
                                    break
                                end
                            else
                                if iEnergySavingManaged < iEnergyPerTickSavingNeeded then
                                    bAbort = true
                                    break
                                end
                            end
                        end
                    elseif bDebugMessages == true then
                        LOG(sFunctionRef .. ': We have no units for iCategoryCount=' .. iCategoryCount)
                    end

                    if bPausedUnitsTableIsEmptyForAllBrains and M28Utilities.IsTableEmpty(oBrain[reftPausedUnits]) == false then
                        bPausedUnitsTableIsEmptyForAllBrains = false
                    end

                    if bAbort then
                        break
                    end
                end
                if bAbort then
                    break
                end
            end
            if bDebugMessages == true then
                LOG(sFunctionRef .. 'If we have no paused units then will set us as not having an energy stall; bPausedUnitsTableIsEmptyForAllBrains='..tostring(bPausedUnitsTableIsEmptyForAllBrains)..'; subrefbTeamIsStallingMass ='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass])..'; bPauseNotUnpause='..tostring(bPauseNotUnpause))
            end
            if bPausedUnitsTableIsEmptyForAllBrains or (M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingMass] and not(bPauseNotUnpause) and not(bHaveWeCappedUnpauseAmount)) then
                M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] = false
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': We are no longer stalling energy')
                end
            else
                if bDebugMessages == true then
                    LOG(sFunctionRef .. ': About to check if we wanted to unpause units but havent unpaused anything; iUnitsAdjusted=' .. iUnitsAdjusted .. '; bNoRelevantUnits=' .. tostring(bNoRelevantUnits) .. '; M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]))
                end
                --Backup - sometimes we still have units in the table listed as being paused (e.g. if an engineer changes action to one that isnt listed as needing pausing) - unpause them if we couldnt find via category search
                if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] and not (bPauseNotUnpause) and (iUnitsAdjusted == 0 or bNoRelevantUnits) and M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] >= 0.95 then
                    --Have a decent amount of power, are flagged as stalling energy, but couldnt find any categories to unpause
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': werent able to find any units to unpause with normal approach so will unpause all remaining units for all M28 brains in the team')
                    end
                    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                        local iLoopCountCheck = 0
                        local iMaxLoop = math.max(20, table.getn(oBrain[reftPausedUnits]) + 1)
                        while M28Utilities.IsTableEmpty(oBrain[reftPausedUnits]) == false do
                            iLoopCountCheck = iLoopCountCheck + 1
                            if iLoopCountCheck >= iMaxLoop then
                                M28Utilities.ErrorHandler('Infinite loop likely')
                                break
                            end
                            if M28Utilities.IsTableEmpty(oBrain[reftPausedUnits]) == false then
                                for iUnit, oUnit in oBrain[reftPausedUnits] do
                                    if bDebugMessages == true then
                                        if M28UnitInfo.IsUnitValid(oUnit) then
                                            LOG(sFunctionRef .. ': About to unpause ' .. oUnit.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnit))
                                        else
                                            LOG('Removing iUnit=' .. iUnit .. ' which is no longer valid')
                                        end
                                        LOG('Size of oBrain[reftPausedUnits] before removal=' .. table.getn(oBrain[reftPausedUnits]) .. '; will double check this size')
                                        local iActualSize = 0
                                        for iAltUnit, oAltUnit in oBrain[reftPausedUnits] do
                                            iActualSize = iActualSize + 1
                                        end
                                        LOG('Actual size=' .. iActualSize)
                                    end
                                    if M28UnitInfo.IsUnitValid(oUnit) then
                                        M28UnitInfo.PauseOrUnpauseEnergyUsage(oUnit, false)
                                    end
                                    table.remove(oBrain[reftPausedUnits], iUnit)
                                    break
                                end
                            end
                        end
                    end
                    if bDebugMessages == true then
                        LOG(sFunctionRef .. ': FInished unpausing units')
                    end
                end
            end
        end
        if bDebugMessages == true then
            LOG(sFunctionRef .. ': End of code, M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]=' .. tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) .. '; bPauseNotUnpause=' .. tostring(bPauseNotUnpause) .. '; iUnitsAdjusted=' .. iUnitsAdjusted .. '; Game time=' .. GetGameTimeSeconds() .. '; Energy stored %=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamLowestEnergyPercentStored] .. '; Net energy income=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] .. '; gross energy income=' .. M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy])
        end
        if M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy] then
            M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastEnergyStall] = GetGameTimeSeconds()
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Will now call manage mass stalls if not stalling energy. M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]='..tostring(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy])..'; bChangeRequired='..tostring(bChangeRequired)) end
    if not(M28Team.tTeamData[iTeam][M28Team.subrefbTeamIsStallingEnergy]) and not(bChangeRequired) then
        ForkThread(ManageMassStalls, iTeam)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end