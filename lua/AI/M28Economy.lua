---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 08:37
---

local M28Profiling = import('/mods/M28AI/lua/AI/M28Profiling.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')


--ECONOMY VARIABLES - below 4 are to track values based on base production, ignoring reclaim. Provide per tick values so 10% of per second)
refiGrossEnergyBaseIncome = 'M28EnergyGrossIncome' --against aiBrain
refiNetEnergyBaseIncome = 'M28EnergyNetIncome' --against aiBrain
refiGrossMassBaseIncome = 'M28MassGrossIncome' --against aiBrain
refiNetMassBaseIncome = 'M28MassNetIncome' --against aiBrain

--Against unit variables:
refoBrainRecordedForEconomy = 'M28EconomyBrainRecordedUnit' --Stores the M28 brain that has factored in this unit's mass and energy income

function UpdateGrossIncomeForUnit(oUnit, bDestroyed)
    if oUnit.UnitId == 'xsl0001' then LOG('Are updating for ACU') end
    if oUnit.GetAIBrain and EntityCategoryContains(categories.MASSPRODUCTION + categories.MASSFABRICATION + categories.ENERGYPRODUCTION, oUnit.UnitId) then
        --Does the unit have an M28 aiBrain?
        local aiBrain = oUnit:GetAIBrain()
        if aiBrain.M28AI then
            local bDebugMessages = true if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
            local sFunctionRef = 'UpdateGrossIncomeForUnit'
            M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)

            if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bDestroyed='..tostring(bDestroyed or false)..': Unit aiBrain='..oUnit:GetAIBrain().Nickname..'; Brain recorded for economy='..((oUnit[refoBrainRecordedForEconomy] or {'nil'}).Nickname or 'nil')) end

            if (bDestroyed and oUnit[refoBrainRecordedForEconomy] == aiBrain) or (not(bDestroyed) and not(oUnit[refoBrainRecordedForEconomy] == aiBrain)) then
                local iMassGen
                local iEnergyGen
                if EntityCategoryContains(M28UnitInfo.refCategoryParagon, oUnit.UnitId) then
                    iMassGen = 10000
                    iEnergyGen = 1000000
                else
                    local oBP = oUnit:GetBlueprint()
                    iMassGen = math.max(oBP.Economy.ProductionPerSecondMass or 0) * 0.1
                    iEnergyGen = math.max(oBP.Economy.ProductionPerSecondEnergy or 0) * 0.1
                end
                if bDestroyed then
                    iMassGen = iMassGen * -1
                    iEnergyGen = iEnergyGen * -1
                    oUnit[refoBrainRecordedForEconomy] = nil
                else
                    oUnit[refoBrainRecordedForEconomy] = aiBrain
                end
                aiBrain[refiGrossEnergyBaseIncome] = aiBrain[refiGrossEnergyBaseIncome] + iEnergyGen
                aiBrain[refiNetEnergyBaseIncome] = aiBrain[refiNetEnergyBaseIncome] + iEnergyGen
                aiBrain[refiGrossMassBaseIncome] = aiBrain[refiGrossMassBaseIncome] + iMassGen
                aiBrain[refiNetMassBaseIncome] = aiBrain[refiNetMassBaseIncome] + iMassGen
                if bDebugMessages == true then LOG(sFunctionRef..': Updated gross and net resources for iMassGen='..iMassGen..'; iEnergyGen='..iEnergyGen) end
            end


            M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
        end
    end
end

function RefreshEconomyGrossValues(aiBrain)
    --Updates recorded gross mass and energy for each unit
    local bDebugMessages = true if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshEconomyGrossValues'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)

    local tEconomyUnits = aiBrain:GetListOfUnits(categories.MASSPRODUCTION + categories.MASSFABRICATION + categories.ENERGYPRODUCTION, false, true)
    if bDebugMessages == true then LOG(sFunctionRef..': refreshing gross income for every unit we own, size of tEconomyUnits='..table.getn(tEconomyUnits)) end
    for iUnit, oUnit in tEconomyUnits do
        UpdateGrossIncomeForUnit(oUnit)
    end

end

function RefreshEconomyData(aiBrain)
    local bDebugMessages = true if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshEconomyData'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)
    aiBrain[refiNetEnergyBaseIncome] = math.min(aiBrain[refiGrossEnergyBaseIncome] - aiBrain:GetEconomyRequested('ENERGY'), aiBrain:GetEconomyTrend('ENERGY'))
    aiBrain[refiNetMassBaseIncome] = aiBrain[refiGrossMassBaseIncome] - math.max(aiBrain:GetEconomyRequested('MASS'), -(aiBrain:GetEconomyTrend('MASS') - aiBrain:GetEconomyIncome('MASS')))

    if bDebugMessages == true then LOG(sFunctionRef..': Finished refreshing economy data, time='..GetGameTimeSeconds()..'; Energy gross='..aiBrain[refiGrossEnergyBaseIncome]..'; Energy net='..aiBrain[refiNetEnergyBaseIncome]..'; Mass gross='..aiBrain[refiGrossMassBaseIncome]..'; Mass net='..aiBrain[refiNetMassBaseIncome]) end
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

function EconomyMainLoop(aiBrain)
    local iSlowRefreshCount = 0

    while not(aiBrain.M28IsDefeated) do
        --Slow refresh logic - every 30s update economy values for every unit as redundancy
        if iSlowRefreshCount == 0 then
            ForkThread(RefreshEconomyGrossValues, aiBrain)
        end
        iSlowRefreshCount = iSlowRefreshCount + 1
        if iSlowRefreshCount >= 30 then iSlowRefreshCount = 0 end

        --Frequent refresh logic:
        ForkThread(RefreshEconomyData, aiBrain)
        WaitSeconds(1)
    end
end

function EconomyInitialisation(aiBrain)
    aiBrain[refiGrossEnergyBaseIncome] = 0
    aiBrain[refiNetEnergyBaseIncome] = 0
    aiBrain[refiGrossMassBaseIncome] = 0
    aiBrain[refiNetMassBaseIncome] = 0

    ForkThread(EconomyMainLoop, aiBrain)
end