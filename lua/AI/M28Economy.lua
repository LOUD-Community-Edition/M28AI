---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 08:37
---

local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')

--Variables against aiBrain:
--ECONOMY VARIABLES - below 4 are to track values based on base production, ignoring reclaim. Provide per tick values so 10% of per second)
refiGrossEnergyBaseIncome = 'M28EnergyGrossIncome' --against aiBrain
refiNetEnergyBaseIncome = 'M28EnergyNetIncome' --against aiBrain
refiGrossMassBaseIncome = 'M28MassGrossIncome' --against aiBrain
refiNetMassBaseIncome = 'M28MassNetIncome' --against aiBrain

--Factory tech variables
refiOurHighestFactoryTechLevel = 'M28EOurHighestFactoryTech' --against aiBrain
refiOurHighestAirFactoryTech = 'M28EOurHighestAirFactoryTech' --against aiBrain
refiOurHighestLandFactoryTech = 'M28EOurHighestLandFactoryTech' --against aiBrain
refiOurHighestNavalFactoryTech = 'M28EOurHighestNavalFactoryTech' --against aiBrain

--Against unit variables:
refoBrainRecordedForEconomy = 'M28EconomyBrainRecordedUnit' --Stores the M28 brain that has factored in this unit's mass and energy income


function UpgradeUnit(oUnitToUpgrade, bUpdateUpgradeTracker)
    --Work out the upgrade ID wanted; if bUpdateUpgradeTracker is true then records upgrade against unit's aiBrain
    local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpgradeUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Do we have any HQs of the same factory type of a higher tech level?
    local sUpgradeID = M28UnitInfo.GetUnitUpgradeBlueprint(oUnitToUpgrade, true) --If not a factory or dont recognise the faction then just returns the normal unit ID
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, sUpgradeID='..(sUpgradeID or 'nil')..'; bUpdateUpgradeTracker='..tostring((bUpdateUpgradeTracker or false))) end

    if sUpgradeID and M28UnitInfo.IsUnitValid(oUnitToUpgrade) then
        local aiBrain = oUnitToUpgrade:GetAIBrain()
        if bDebugMessages == true then LOG(sFunctionRef..': About to issue ugprade to unit '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)..'; Current state='..M28UnitInfo.GetUnitState(oUnitToUpgrade)..'; Work progress='..(oUnitToUpgrade:GetWorkProgress() or 'nil')..'; Is unit upgrading='..tostring(oUnitToUpgrade:IsUnitState('Upgrading'))) end

        if not(oUnitToUpgrade:IsUnitState('Upgrading')) then
            local bAddToExistingQueue = true



            --Factory specific - if work progress is <=5% then cancel so can do the upgrade
            if EntityCategoryContains(M28UnitInfo.refCategoryFactory, oUnitToUpgrade.UnitId) then
                if bDebugMessages == true then LOG(sFunctionRef..': Are upgrading a factory '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)..'; work progress='..oUnitToUpgrade:GetWorkProgress()) end
                if oUnitToUpgrade.GetWorkProgress and oUnitToUpgrade:GetWorkProgress() <= 0.05 then
                    --Are we building an engineer or transport?
                    local oUnitThatAreBuilding = oUnitToUpgrade:GetFocusUnit()
                    if not(M28UnitInfo.IsUnitValid(oUnitThatAreBuilding) and EntityCategoryContains(M28UnitInfo.refCategoryTransport + M28UnitInfo.refCategoryEngineer, oUnitThatAreBuilding.UnitId)) then
                        bAddToExistingQueue = false
                        if bDebugMessages == true then LOG(sFunctionRef..': Have barely started with current construction so will cancel so can get upgrade sooner') end
                    end
                end
            end

            --Air factory upgrades - if we are upgrading from T1 to T2 and havent build a transport, and have plateaus, then want to get a transport first
            if EntityCategoryContains(M28UnitInfo.refCategoryAirFactory * categories.TECH1, oUnitToUpgrade.UnitId) and aiBrain[refiOurHighestAirFactoryTech] == 1 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory * categories.TECH1) == 1 then
                M28Map.UpdatePlateausToExpandTo(aiBrain)
                if M28Utilities.IsTableEmpty(aiBrain[M28Map.reftPlateausOfInterest]) == false and M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryTransport) == 0 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if we have already queued up transport for this unit='..tostring(oUnitToUpgrade[refsQueuedTransport] or false)) end
                    if not(oUnitToUpgrade[refsQueuedTransport]) then
                        --Havent built any transports yet so build a T1 transport before we upgrade to T2 air

                        local sTransportID = M28Factory.GetBlueprintsThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryTransport, oUnitToUpgrade)
                        if sTransportID then
                            oUnitToUpgrade[refsQueuedTransport] = true
                            M28Orders.IssueTrackedFactoryBuild(oUnitToUpgrade, sTransportID, false, 'PreUp')
                            if bDebugMessages == true then LOG(sFunctionRef..': Will queue up a transport for factory '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)) end
                        end
                    end
                end
            elseif EntityCategoryContains(M28UnitInfo.refCategoryLandFactory * categories.TECH2 + M28UnitInfo.refCategoryAirFactory * categories.TECH2, oUnitToUpgrade.UnitId) and aiBrain[refiOurHighestFactoryTechLevel] <= 2 and aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer - categories.TECH1) <= 5 then
                --About to go for T3 factory but have hardl yany engineers so queue up an extra one
                local sEngiID = M28Factory.GetBlueprintsThatCanBuildOfCategory(aiBrain, M28UnitInfo.refCategoryEngineer, oUnitToUpgrade)
                if sEngiID then
                    M28Orders.IssueTrackedFactoryBuild(oUnitToUpgrade, sEngiID, false, 'PreUp')
                end
                if bDebugMessages == true then LOG(sFunctionRef..': About to go to T3 on factory '..oUnitToUpgrade.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade)..' but only have '..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryEngineer - categories.TECH1)..' T2 plus engis so will queue up another engi before the upgrade. sEngiID='..(sEngiID or 'nil')) end
            end

            --Issue upgrade
            M28Orders.IssueTrackedUpgrade(oUnitToUpgrade, sUpgradeID, bAddToExistingQueue)
        end

        --Clear any pausing of the unit
        oUnitToUpgrade:SetPaused(false)
        oUnitToUpgrade[M28UnitInfo.refbPaused] = false

        if bUpdateUpgradeTracker then
            M28Team.UpdateUpgradeTrackingOfUnit(oUnitToUpgrade, false, sUpgradeID)
        end

        --T1 mexes - if start upgrading, then flag for TML protection --TODO in a future version (is on todo list)
    else
        M28Utilities.ErrorHandler('Dont have a valid upgrade ID; UnitID=' .. oUnitToUpgrade.UnitId .. M28UnitInfo.GetUnitLifetimeCount(oUnitToUpgrade))
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetBestUnitToUpgrade(toPotentialUnits, bPrioritiseFactoryHQ)
    --Assumes have already checked units are valid/not upgrading and factored in whether safe or not already, so just need to do distance type check
    local iClosestUnitToBase = 100000
    local oClosestUnitToBase
    local iCurModDist
    for iUnit, oUnit in toPotentialUnits do
        iCurModDist = M28Map.GetModDistanceFromStart(oUnit:GetAIBrain(), oUnit:GetPosition(), false)
        if bPrioritiseFactoryHQ and not(EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnit.UnitId)) then iCurModDist = iCurModDist + 1000 end
        if iCurModDist < iClosestUnitToBase then
            iClosestUnitToBase = iCurModDist
            oClosestUnitToBase = oUnit
        end
    end
    return oClosestUnitToBase
end

function UpdateLandZoneM28AllMexByTech(aiBrain, iPlateau, iLandZone, oOptionalUnitThatDied, iOptionalWait)
    local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateLandZoneM28AllMexByTech'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team]
    if iOptionalWait then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(iOptionalWait)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    tLZTeamData[M28Map.subrefMexCountByTech] = {[1]=0,[2]=0,[3]=0} --starting point
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
        local tAllMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        --Update list of units in this LZ in case some of the mexes are dead now
        M28Land.UpdateUnitPositionsAndLandZone(aiBrain, tAllMexes, aiBrain.M28Team, iPlateau, iLandZone, false)

        local tMexesByTech = {}
        local iMexCount = 0
        tMexesByTech[1] = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex * categories.TECH1, tAllMexes)
        tMexesByTech[2] = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex * categories.TECH2, tAllMexes)
        tMexesByTech[3] = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex * categories.TECH3, tAllMexes)
        if bDebugMessages == true and oOptionalUnitThatDied then LOG(sFunctionRef..': oOptionalUnitThatDied='..oOptionalUnitThatDied.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOptionalUnitThatDied)) end

        for iTech = 1, 3 do
            if M28Utilities.IsTableEmpty(tMexesByTech[iTech]) == false then
                for iMex, oCurMex in tMexesByTech[iTech] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Plateau='..iPlateau..'; iLandZone='..iLandZone..'; oCurMex='..oCurMex.UnitId..M28UnitInfo.GetUnitLifetimeCount(oCurMex)..'; Unit state='..M28UnitInfo.GetUnitState(oCurMex)..'; Is unit valid='..tostring(M28UnitInfo.IsUnitValid(oCurMex))..'; Position='..repru(oCurMex:GetPosition())..'; iTech='..iTech..'; iMexCount pre increase='..iMexCount..'; tLZTeamData[M28Map.subrefMexCountByTech] pre increase='..repru(tLZTeamData[M28Map.subrefMexCountByTech])) end
                    if oCurMex:GetAIBrain().M28AI and M28UnitInfo.IsUnitValid(oCurMex) and oCurMex:GetFractionComplete() == 1 and not(oOptionalUnitThatDied == oCurMex) then
                        tLZTeamData[M28Map.subrefMexCountByTech][iTech] = tLZTeamData[M28Map.subrefMexCountByTech][iTech] + 1
                        iMexCount = iMexCount + 1
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished updating mex count, tLZTeamData[M28Map.subrefMexCountByTech]='..repru(tLZTeamData[M28Map.subrefMexCountByTech])) end
        --If have somehow ended up with more mexes than there are locations, then redo the check this time seeing if the units are all valid
        if iMexCount > table.getn( M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]) then
            M28Utilities.ErrorHandler('Somehow we have more mexes than we should, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iMexCount='..iMexCount..'; tLZTeamData[M28Map.subrefMexCountByTech]='..reprs(tLZTeamData[M28Map.subrefMexCountByTech]))
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateLandZoneM28MexByTechCount(oMexJustBuiltOrDied, bJustDied, iOptionalWait)
    local aiBrain = oMexJustBuiltOrDied:GetAIBrain()
    if aiBrain.M28AI then
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oMexJustBuiltOrDied:GetPosition())
        --should be called whenever a mex is created or destroyed in a land zone; ideally call via fork thread so reduced risk of it being called inbetween a mex say upgrading from one to another and being claled before both the creation and destroy events have happened
        if (iLandZone or 0) > 0 then
            if not(iOptionalWait) then
                if bJustDied then
                    UpdateLandZoneM28AllMexByTech(aiBrain, iPlateau, iLandZone, oMexJustBuiltOrDied)
                else
                    UpdateLandZoneM28AllMexByTech(aiBrain, iPlateau, iLandZone, nil)
                end
            else
                if bJustDied then
                    ForkThread(UpdateLandZoneM28AllMexByTech, aiBrain, iPlateau, iLandZone, oMexJustBuiltOrDied, iOptionalWait)
                else
                    ForkThread(UpdateLandZoneM28AllMexByTech, aiBrain, iPlateau, iLandZone, nil, iOptionalWait)
                end
            end
        end
    end
end

function FindAndUpgradeUnitOfCategory(aiBrain, iCategoryWanted)
    --e.g. intended for upgrading factory HQs
    local tUnitsOfCategory = aiBrain:GetListOfUnits(iCategoryWanted, false, true)
    if M28Utilities.IsTableEmpty(tUnitsOfCategory) == false then
        local tUnitsToSearch = {}
        local tUnsafeUnitsOfCategory = {}
        local iCurPlateau, iCurLZ
        for iUnit, oUnit in tUnitsOfCategory do
            if oUnit:GetFractionComplete() == 1 and not(oUnit:IsUnitState('Upgrading')) then
                --Are we in a safe land zone?
                iCurPlateau, iCurLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition())
                if M28Map.tAllPlateaus[iCurPlateau][M28Map.subrefPlateauLandZones][iCurLZ][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
                    table.insert(tUnsafeUnitsOfCategory, oUnit)
                else
                    table.insert(tUnitsToSearch, oUnit)
                end
            end
        end
        if M28Utilities.IsTableEmpty(tUnitsToSearch) then tUnitsToSearch = tUnsafeUnitsOfCategory end
        if M28Utilities.IsTableEmpty(tUnitsToSearch) == false then
            local iCurDist
            local iClosestDist = 100000
            local oClosestUnit
            for iUnit, oUnit in tUnitsToSearch do
                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()])
                if iCurDist < iClosestDist then
                    iClosestDist = iCurDist
                    oClosestUnit = oUnit
                end
            end
            if oClosestUnit then
                UpgradeUnit(aiBrain, oClosestUnit, true) --Will queue up transport or engineer for factories as well as figuring out whether to upgrade a support factory or an HQ
            end
        end
    end
end

function UpdateHighestFactoryTechLevelForBuiltUnit(oUnitJustBuilt)
    local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateHighestFactoryTechLevelForBuiltUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Checking if just built a factory HQ, Have just built unit '..oUnitJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitJustBuilt)..'; Fraction complete='..oUnitJustBuilt:GetFractionComplete()..'; Is it a factory HQ='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnitJustBuilt.UnitId))) end

    if oUnitJustBuilt:GetFractionComplete() == 1 and EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oUnitJustBuilt.UnitId) then
        local iUnitTechLevel = M28UnitInfo.GetUnitTechLevel(oUnitJustBuilt)
        local sFactoryRef
        if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory, oUnitJustBuilt.UnitId) then sFactoryRef = refiOurHighestLandFactoryTech
        elseif EntityCategoryContains(M28UnitInfo.refCategoryAirFactory, oUnitJustBuilt.UnitId) then sFactoryRef = refiOurHighestAirFactory
        elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory, oUnitJustBuilt.UnitId) then sFactoryRef = refiOurHighestNavalFactoryTech
        else M28Utilities.ErrorHandler('Unrecognised factory type')
        end
        local aiBrain = oUnitJustBuilt:GetAIBrain()
        if bDebugMessages == true then LOG(sFunctionRef..': Considering if factory HQ is a higher tech than we already have, sFactoryRef='..sFactoryRef..'; iUnitTechLevel='..iUnitTechLevel..'; aiBrain[sFactoryRef]='..aiBrain[sFactoryRef]) end
        if iUnitTechLevel > aiBrain[sFactoryRef] then
            aiBrain[sFactoryRef] = math.max(aiBrain[sFactoryRef], iUnitTechLevel)
            aiBrain[refiOurHighestFactoryTechLevel] = math.max(iUnitTechLevel, aiBrain[refiOurHighestFactoryTechLevel])
            --Update team details
            M28Team.UpdateTeamHighestAndLowestFactories(aiBrain.M28Team)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateHighestFactoryTechLevelForDestroyedUnit(oUnitJustDestroyed)
    if oUnitJustDestroyed:GetFractionComplete() == 1 and EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories) then
        local aiBrain = oUnitJustDestroyed:GetAIBrain()
        local iUnitTechLevel = M28UnitInfo.GetUnitTechLevel(oUnitJustDestroyed)
        if EntityCategoryContains(M28UnitInfo.refCategoryLandFactory) then
            if iUnitTechLevel >= (aiBrain[refiOurHighestLandFactoryTech] or 0) then
                aiBrain[refiOurHighestLandFactoryTech] = 0
                for iTechLevel = 3, 1, -1 do
                    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory * M28UnitInfo.ConvertTechLevelToCategory(iTechLevel) - categories.SUPPORTFACTORY) > 0 then
                        aiBrain[refiOurHighestLandFactoryTech] = iTechLevel
                        break
                    end
                end
            end
        elseif EntityCategoryContains(M28UnitInfo.refCategoryAirFactory) then sFactoryRef = refiOurHighestAirFactory
            if iUnitTechLevel >= aiBrain[refiOurHighestAirFactoryTech] then
                aiBrain[refiOurHighestAirFactoryTech] = 0
                for iTechLevel = 3, 1, -1 do
                    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory * M28UnitInfo.ConvertTechLevelToCategory(iTechLevel) - categories.SUPPORTFACTORY) > 0 then
                        aiBrain[refiOurHighestAirFactoryTech] = iTechLevel
                        break
                    end
                end
            end
        elseif EntityCategoryContains(M28UnitInfo.refCategoryNavalFactory) then sFactoryRef = refiOurHighestNavalFactoryTech
            if iUnitTechLevel >= aiBrain[refiOurHighestNavalFactoryTech] then
                aiBrain[refiOurHighestNavalFactoryTech] = 0
                for iTechLevel = 3, 1, -1 do
                    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryNavalFactory * M28UnitInfo.ConvertTechLevelToCategory(iTechLevel) - categories.SUPPORTFACTORY) > 0 then
                        aiBrain[refiOurHighestNavalFactoryTech] = iTechLevel
                        break
                    end
                end
            end
        else M28Utilities.ErrorHandler('Unrecognised factory type')
        end

        --Updated highest factory type across all types
        aiBrain[refiOurHighestFactoryTechLevel] = math.max(aiBrain[refiOurHighestLandFactoryTech], aiBrain[refiOurHighestAirFactoryTech], aiBrain[refiOurHighestNavalFactoryTech])

        --Update team details
        M28Team.UpdateTeamHighestAndLowestFactories(aiBrain.M28Team)
    end
end

function UpdateGrossIncomeForUnit(oUnit, bDestroyed)
    --Logs are enabled below

    if oUnit.GetAIBrain and EntityCategoryContains(categories.MASSPRODUCTION + categories.MASSFABRICATION + categories.ENERGYPRODUCTION, oUnit.UnitId) then
        --Does the unit have an M28 aiBrain?
        local aiBrain = oUnit:GetAIBrain()
        if aiBrain.M28AI then
            local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
            local sFunctionRef = 'UpdateGrossIncomeForUnit'
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

            if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..' oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; bDestroyed='..tostring(bDestroyed or false)..': Unit aiBrain='..oUnit:GetAIBrain().Nickname..'; Brain recorded for economy='..((oUnit[refoBrainRecordedForEconomy] or {'nil'}).Nickname or 'nil')..'; Fraction complete='..oUnit:GetFractionComplete()) end
            if oUnit:GetFractionComplete() < 1 then M28Utilities.ErrorHandler('Trying to update income for unit whose fraction isnt complete') end

            if (bDestroyed and oUnit[refoBrainRecordedForEconomy] == aiBrain) or (not(bDestroyed) and not(oUnit[refoBrainRecordedForEconomy] == aiBrain)) then
                local iMassGen
                local iEnergyGen
                if EntityCategoryContains(M28UnitInfo.refCategoryParagon, oUnit.UnitId) then
                    iMassGen = 10000
                    iEnergyGen = 1000000
                else
                    local oBP = oUnit:GetBlueprint()
                    iMassGen = math.max(oBP.Economy.ProductionPerSecondMass or 0) * 0.1
                    iEnergyGen = math.max(oBP.Economy.ProductionPerSecondEnergy or 0) * 0.1
                end
                if bDestroyed then
                    iMassGen = iMassGen * -1
                    iEnergyGen = iEnergyGen * -1
                    oUnit[refoBrainRecordedForEconomy] = nil
                else
                    oUnit[refoBrainRecordedForEconomy] = aiBrain
                end
                aiBrain[refiGrossEnergyBaseIncome] = aiBrain[refiGrossEnergyBaseIncome] + iEnergyGen
                aiBrain[refiNetEnergyBaseIncome] = aiBrain[refiNetEnergyBaseIncome] + iEnergyGen
                aiBrain[refiGrossMassBaseIncome] = aiBrain[refiGrossMassBaseIncome] + iMassGen
                aiBrain[refiNetMassBaseIncome] = aiBrain[refiNetMassBaseIncome] + iMassGen
                if bDebugMessages == true then LOG(sFunctionRef..': Updated gross and net resources for iMassGen='..iMassGen..'; iEnergyGen='..iEnergyGen..'; aiBrain[refiNetMassBaseIncome]='..aiBrain[refiNetMassBaseIncome]..'; aiBrain[refiGrossMassBaseIncome]='..aiBrain[refiGrossMassBaseIncome]) end
            end


            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        end
    end
end

function RefreshEconomyGrossValues(aiBrain)
    --Updates recorded gross mass and energy for each unit
    local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshEconomyGrossValues'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tEconomyUnits = aiBrain:GetListOfUnits(categories.MASSPRODUCTION + categories.MASSFABRICATION + categories.ENERGYPRODUCTION, false, true)
    if bDebugMessages == true then LOG(sFunctionRef..': refreshing gross income for every unit we own time='..GetGameTimeSeconds()..'; size of tEconomyUnits='..table.getn(tEconomyUnits)) end
    for iUnit, oUnit in tEconomyUnits do
        if oUnit:GetFractionComplete() == 1 then
            UpdateGrossIncomeForUnit(oUnit)
        end
    end

end

function RefreshEconomyData(aiBrain)
   local bDebugMessages = true if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshEconomyData'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    aiBrain[refiNetEnergyBaseIncome] = math.min(aiBrain[refiGrossEnergyBaseIncome] - aiBrain:GetEconomyRequested('ENERGY'), aiBrain:GetEconomyTrend('ENERGY'))
    aiBrain[refiNetMassBaseIncome] = math.min(aiBrain[refiGrossMassBaseIncome] - aiBrain:GetEconomyRequested('MASS'), aiBrain:GetEconomyTrend('MASS'))

    if bDebugMessages == true then LOG(sFunctionRef..': Finished refreshing economy data, time='..GetGameTimeSeconds()..'; Energy gross='..aiBrain[refiGrossEnergyBaseIncome]..'; Energy net='..aiBrain[refiNetEnergyBaseIncome]..'; Mass gross='..aiBrain[refiGrossMassBaseIncome]..'; Mass net='..aiBrain[refiNetMassBaseIncome]..'; aiBrain:GetEconomyRequested(\'MASS\')='..aiBrain:GetEconomyRequested('MASS')..'; aiBrain:GetEconomyTrend(\'MASS\')='..aiBrain:GetEconomyTrend('MASS')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function EconomyMainLoop(aiBrain)
    local iSlowRefreshCount = 0

    while not(aiBrain.M28IsDefeated) do
        --Slow refresh logic - every 30s update economy values for every unit as redundancy
        if iSlowRefreshCount == 0 then
            ForkThread(RefreshEconomyGrossValues, aiBrain)
        end
        iSlowRefreshCount = iSlowRefreshCount + 1
        if iSlowRefreshCount >= 30 then iSlowRefreshCount = 0 end

        --Frequent refresh logic:
        ForkThread(RefreshEconomyData, aiBrain)
        WaitSeconds(1)
    end
end

function EconomyInitialisation(aiBrain)
    aiBrain[refiGrossEnergyBaseIncome] = 0
    aiBrain[refiNetEnergyBaseIncome] = 0
    aiBrain[refiGrossMassBaseIncome] = 0
    aiBrain[refiNetMassBaseIncome] = 0

    --Some values are set when creating a team to avoid errors

    ForkThread(EconomyMainLoop, aiBrain)
end