---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 09:03
---



local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Config = import('/mods/M28AI/lua/M28Config.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')


function OnPlayerDefeated(aiBrain)
    M28Utilities.ErrorHandler('To add code')
end

function OnACUKilled(oUnit)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnACUKilled'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        M28Utilities.ErrorHandler('To add code')
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnKilled(oUnitKilled, instigator, type, overkillRatio)
    --WARNING: Doesnt trigger when an ACU is killed
    --Will make sure the OnUnitDeath event is called, i.e. this function should only be used where we only want something to run when we killed something, or an enemy killed something of ours

    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnKilled'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        local refbAlreadyRun = 'M28EventsOnKilledRun'
        if not(oUnitKilled[refbAlreadyRun]) then
            oUnitKilled[refbAlreadyRun] = true
            if bDebugMessages == true then LOG(sFunctionRef..': oUnitKilled='..oUnitKilled.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitKilled)..'; Is unit killed an ACU='..tostring(M28Utilities.IsACU(oUnitKilled))..'; GameTime='..GetGameTimeSeconds()) end
            if oUnitKilled.GetAIBrain then
                OnUnitDeath(oUnitKilled) --Ensure this is run when a unit dies

                --[[local oKillerUnit

                if instigator and not(instigator:BeenDestroyed()) and not(instigator.Dead) then
                    if instigator.Launcher then
                        oKillerUnit = instigator.Launcher
                    elseif instigator.DamageData and not(instigator.unit) and not(instigator.UnitId) then
                        --Can get errors for artillery shells when running IsProjectile
                    elseif IsProjectile(instigator) or IsCollisionBeam(instigator) then
                        if instigator.unit then
                            oKillerUnit = instigator.unit
                        end
                    elseif IsUnit(instigator) then
                        oKillerUnit = instigator
                    end
                end

                if IsUnit(oKillerUnit) then
                    local oKillerBrain = instigator:GetAIBrain()
                    if oKillerBrain.M28AI then
                        --TODO - consider adding in logic e.g. chat messages and tracking
                    end
                end--]]
            elseif bDebugMessages == true then LOG(sFunctionRef..': Unit killed doesnt have a brain')
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnMexDeath(oUnit)
    --Make the mex status available
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnMexDeath'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnPropDestroyed(oProp)
    --Confirmed manually this triggers e.g. if a bomber destroys a rock, and if a tree is reclaimed
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnPropDestroyed'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnYthothaDeath(oUnit)
    --Called when a ythotha (oUnit) is flagged as dying or being killed        
    M28Utilities.ErrorHandler('To add code')
end


function OnUnitDeath(oUnit)
    --NOTE: This is called by the death of any unit of any player, so careful with what commands are given
        --Some callbacks line onkilled will call this as well to make sure it is run (since for some things like when an ACU is killed it doesnt trigger directly)
    if M28Utilities.bM28AIInGame and M28Map.bMapSetupComplete then --No point running on death logic for units at start of the game
        local sFunctionRef = 'OnUnitDeath'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



        if bDebugMessages == true then LOG(sFunctionRef..'Hook successful. oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; GameTime='..GetGameTimeSeconds()) end
        --Is it an ACU?
        if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
            OnACUKilled(oUnit)
        else
            if oUnit.CachePosition then --Redundancy to check not dealing with a unit, not sure this will actually trigger as looks like wreck deaths are picked up by the prop logic above
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Unit killed has a cache position, will draw in blue around it')
                    M28Utilities.DrawLocation(oUnit.CachePosition, nil, 1, 100, nil)
                end
                ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, oUnit.CachePosition, 0)
            else
                if oUnit.GetAIBrain then
                    --------Non-M28 Specific logic------
                    M28Orders.ClearAnyRepairingUnits(oUnit)

                    --Hydro resource location made available again
                    if EntityCategoryContains(M28UnitInfo.refCategoryHydro, oUnit.UnitId) then
                        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroLocations]) == false then
                            for iHydroLocation, tHydroLocation in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroLocations] do
                                if M28Utilities.GetDistanceBetweenPositions(tHydroLocation, oUnit:GetPosition()) <= 2 then
                                    table.insert(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroUnbuiltLocations], tHydroLocation)
                                    break
                                end
                            end
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]) == false then
                            for iMexLocation, tMexLocation in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations] do
                                if M28Utilities.GetDistanceBetweenPositions(tMexLocation, oUnit:GetPosition()) <= 0.9 then
                                    table.insert(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexUnbuiltLocations], tMexLocation)
                                    break
                                end
                            end
                        end
                    --Radar intel coverage update
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryRadar, oUnit.UnitId) then
                        ForkThread(M28Land.UpdateRadarCoverageForDestroyedRadar, oUnit)
                    end
                    --Ythotha deathball avoidance
                    --Note -seraphimunits.lua contains SEnergyBallUnit which looks like it is for when the death ball is spawned; ID is XSL0402; SpawnElectroStorm is in the ythotha script
                    --Sandbox test - have c.36s from ythotha dying to energy ball dying, so want to run away for half of this (18s) plus extra time based on how far away we already were
                    if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental * categories.SERAPHIM, oUnit.UnitId) then
                        OnYthothaDeath(oUnit)
                    end
                    if EntityCategoryContains(categories.STRUCTURE + categories.EXPERIMENTAL, oUnit.UnitId) and (EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) or oUnit:GetFractionComplete() < 1) then
                        M28Engineer.SearchForBuildableLocationsNearDestroyedBuilding(oUnit)
                    end




                    -------M28 specific logic---------
                    --Is the unit owned by M28AI?
                    if oUnit:GetAIBrain().M28AI then
                        --Run unit type specific on death logic where the unit is completed
                        if oUnit:GetFractionComplete() == 1 then
                            M28Economy.UpdateGrossIncomeForUnit(oUnit, true)
                            if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                                M28Engineer.ClearEngineerTracking(oUnit)
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryScathis, oUnit.UnitId) then
                                if M28Utilities.IsTableEmpty(M28Engineer.tAllScathis) == false then
                                    for iScathis, oScathis in M28Engineer.tAllScathis do
                                        if oScathis == oUnit then
                                            table.remove(M28Engineer.tAllScathis, iScathis) --Only doing this once so can get away with using table.remove, otherwise would want to use M28Utilities.ArrayRemove
                                            break
                                        end
                                    end
                                end
                            elseif EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
                                --Check for upgrades
                                --Upgrade tracking (even if have run this already)
                                if bDebugMessages == true then LOG(sFunctionRef..': Will check if upgrade tracking needs updating, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                M28Team.UpdateUpgradeTrackingOfUnit(oUnit, true)
                                if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then M28Economy.UpdateLandZoneM28MexByTechCount(oUnit, true) end
                                M28Economy.UpdateHighestFactoryTechLevelForDestroyedUnit(oUnit) --checks if it was a factory as part of this function
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryMobileLand, oUnit.UnitId) then
                                --If unit was traveling to another land zone, then update that land zone so it no longer things the unit is traveling here
                                M28Land.RemoveUnitFromListOfUnitsTravelingToLandZone(oUnit) --(this will check if it was or not)
                            end
                        end
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnWorkEnd(self, work)
    --Not sure when/if this even triggers - would need to review if plan to use
    --LOG('WOrk end has finished for self='..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self)..'; work reprs='..reprs(work))
end

function OnEnhancementComplete(oUnit, sEnhancement)
    --LOG('Enhancement completed for self='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; sEnhancement='..reprs(sEnhancement))
    M28UnitInfo.UpdateUnitCombatMassRatingForUpgrades(oUnit)
    M28UnitInfo.RecordUnitRange(oUnit) --Refresh the range incase enhancement has increased anything
end

function OnShieldBubbleDamaged(self, instigator)
    
end

function OnDamaged(self, instigator) --This doesnt trigger when a shield bubble is damaged - see OnShieldBubbleDamaged for this
    
end

function OnBombFired(oWeapon, projectile)
    if M28Utilities.bM28AIInGame then        
    end
end

--WARNING: OnWeaponFired and/or OnProjectilfeFired - one of these (probably the latter) resulted in error messages when t1 arti fired, disabled both of them as dont use now

function OnWeaponFired(oWeapon)
    if M28Utilities.bM28AIInGame then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnWeaponFired'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then LOG(sFunctionRef..': Start of code; does the weapon have a valid unit='..tostring(M28UnitInfo.IsUnitValid(oWeapon.unit))..'; Weapon unitID='..(oWeapon.unit.UnitId or 'nil')) end

        local oUnit = oWeapon.unit
        if oUnit and oUnit.GetUnitId and oUnit.GetAIBrain then
            --Update unit last known position/record it
            local oParentBrain = oUnit:GetAIBrain()
            for iTeam, tTeam in M28Team.tTeamData do
                if not(iTeam == oParentBrain.M28Team) then
                    if M28Utilities.IsTableEmpty(tTeam[M28Team.subreftoFriendlyActiveM28Brains]) == false then
                        for iBrain, oBrain in tTeam[M28Team.subreftoFriendlyActiveM28Brains] do
                            M28Team.ConsiderAssigningUnitToZoneForBrain(oBrain, oUnit) --This function includes check of whether this is an M28 brain, and updates last known position
                            break
                        end
                    end
                end
            end

            --M28 owned unit specific logic
            if oUnit:GetAIBrain().M28AI then
                --Shot is blocked logic
                if bDebugMessages == true then LOG(sFunctionRef..': COnsidering if unit shot is blocked Time='..GetGameTimeSeconds()..', range category='..(oWeapon.Blueprint.RangeCategory or 'nil')..'; Is unit a relevant DF category='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategoryNavalSurface * categories.DIRECTFIRE + M28UnitInfo.refCategorySeraphimDestroyer - M28UnitInfo.refCategoryMissileShip, oUnit.UnitId))) end
                if oWeapon.Blueprint.RangeCategory == 'UWRC_DirectFire' and EntityCategoryContains(M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategoryNavalSurface * categories.DIRECTFIRE + M28UnitInfo.refCategorySeraphimDestroyer - M28UnitInfo.refCategoryMissileShip, oUnit.UnitId) then
                    --Get weapon target if it is a DF weapon
                    local oTarget = oWeapon:GetCurrentTarget()
                    if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has just fired a shot. Do we have a valid target for our weapon='..tostring(M28UnitInfo.IsUnitValid(oTarget))..'; time last shot was blocked='..(oUnit[M28UnitInfo.refiTimeOfLastCheck] or 'nil')) end
                    if M28UnitInfo.IsUnitValid(oTarget) then

                        oUnit[M28UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds()
                        oUnit[M28UnitInfo.refbLastShotBlocked] = M28Logic.IsShotBlocked(oUnit, oTarget)
                        if bDebugMessages == true then LOG(sFunctionRef..': oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; Is shot blocked='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked])..'; built in blocking terrain result for low profile='..tostring(oUnit:GetAIBrain():CheckBlockingTerrain(oUnit:GetPosition(), oTarget:GetPosition(), 'Low'))..'; High profile='..tostring(oUnit:GetAIBrain():CheckBlockingTerrain(oUnit:GetPosition(), oTarget:GetPosition(), 'High'))) end

                        if oUnit[M28UnitInfo.refbLastShotBlocked] then
                            --Reset after 20s if we havent fired any more shots at the target
                            --function DelayChangeVariable(oVariableOwner, sVariableName, vVariableValue, iDelayInSeconds, sOptionalOwnerConditionRef, iMustBeLessThanThisTimeValue, iMustBeMoreThanThisTimeValue, vMustNotEqualThisValue)
                            M28Utilities.DelayChangeVariable(oUnit, M28UnitInfo.refbLastShotBlocked, false, 20, M28UnitInfo.refiTimeOfLastCheck, GetGameTimeSeconds() + 0.01)
                        end
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

    end
end

function OnMissileBuilt(self, weapon)
    if M28Utilities.bM28AIInGame then
        
    end
end

--[[
function OnProjectileFired(oWeapon, oMuzzle)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'OnProjectileFired'
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
    if oWeapon.GetBlueprint then
        LOG('OnWeaponFired hook for blueprint='..repru(oWeapon:GetBlueprint()))
    end
    if oWeapon.unit then
        LOG('Have a unit; unit position='..repru(oWeapon.unit:GetPosition()))
    end
end--]]

function OnConstructionStarted(oEngineer, oConstruction, sOrder)
    if M28Utilities.bM28AIInGame then
        --Update land zone queued orders
        if M28Utilities.IsTableEmpty(oEngineer[M28Engineer.reftQueuedBuildings]) == false then
            M28Engineer.RemoveBuildingFromQueuedBuildings(oEngineer, oConstruction)
        end
    end
end

function OnConstructed(oEngineer, oJustBuilt)
    --WARNING: This doesnt seem to trigger for the ACU; it does trigger when untis are constructed by a factory

    --NOTE: This is called every time an engineer stops building a unit whose fractioncomplete is 100%, so can be called multiple times
    if M28Utilities.bM28AIInGame then
        --NonM28 specific - dont set the M28OnConstructionCalled for this, so need to  be careful that any code here will not be run repeatedly
        --LOG('OnConstructed for unit '..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt))
        M28Orders.ClearAnyRepairingUnits(oJustBuilt)

        if EntityCategoryContains(categories.STRUCTURE, oJustBuilt.UnitId) then
            --If a building has just build a building, then make sure all M28 are aware of it (since a player would be)
            if EntityCategoryContains(categories.STRUCTURE, oEngineer.UnitId) then
                local tTeamsUpdated = {}
                for iBrain, oBrain in M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subreftoEnemyBrains] do
                    if oBrain.M28AI and not(tTeamsUpdated[oBrain.M28Team]) then
                        tTeamsUpdated[oBrain.M28Team] = true
                        M28Team.AssignUnitToZoneOrPond(oBrain, oJustBuilt)
                    end
                end
            end

            --If we have just built a radar then update radar logic
            if EntityCategoryContains(M28UnitInfo.refCategoryRadar, oJustBuilt.UnitId) then
                ForkThread(M28Land.UpdateLandZoneIntelForRadar, oJustBuilt)
            end
        end

        --M28 specific
        if oJustBuilt:GetAIBrain().M28AI and not(oJustBuilt.M28OnConstructedCalled) then
            local sFunctionRef = 'OnConstructed'
            local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            oJustBuilt.M28OnConstructedCalled = true
            if bDebugMessages == true then LOG(sFunctionRef..': oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' has just built '..oJustBuilt.UnitId) end

            --Logic based on the unit that was just built:

            --Check build locations for units not built at a factory
            if EntityCategoryContains(categories.STRUCTURE + categories.EXPERIMENTAL, oJustBuilt.UnitId) then
                M28Engineer.CheckIfBuildableLocationsNearPositionStillValid(oJustBuilt:GetAIBrain(), oJustBuilt:GetPosition())
                M28Economy.UpdateHighestFactoryTechLevelForBuiltUnit(oJustBuilt) --includes a check to see if are dealing with a factory HQ
                if EntityCategoryContains(M28UnitInfo.refCategoryMex, oJustBuilt.UnitId) then
                    M28Economy.UpdateLandZoneM28MexByTechCount(oJustBuilt, false, 10)
                    --If have storage owned by M28 on same team by this mex, gift it over
                    --All mexes - on construction check if we have allied M28 mass storage nearby (e.g. we have rebuilt on a mex that they used to have) and if so then have that M28 gift over their mass storage
                    local tMexLocation = oJustBuilt:GetPosition()
                    local rSearchRectangle = M28Utilities.GetRectAroundLocation(tMexLocation, 2.749)
                    local tNearbyUnits = GetUnitsInRect(rSearchRectangle) --at 1.5 end up with storage thats not adjacent being gifted in some cases but not in others; at 1 none of it gets gifted; the mass storage should be exactly 2 from the mex; however even at 2.1, 2.25 and 2.499 had cases where the mex wasnt identified so will try 2.75 since distances can vary/be snapped to the nearest 0.5 I think
                    if bDebugMessages == true then LOG(sFunctionRef..': Storage gifting where built mex - oJustBuilt='..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; owner='..oJustBuilt:GetAIBrain().Nickname..'; is tNearbyUnits empty='..tostring(M28Utilities.IsTableEmpty(tNearbyUnits))) end
                    if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                        local tNearbyStorage = EntityCategoryFilterDown(M28UnitInfo.refCategoryMassStorage, tNearbyUnits)
                        if M28Utilities.IsTableEmpty(tNearbyStorage) == false then
                            for iUnit, oUnit in tNearbyStorage do
                                if bDebugMessages == true then LOG(sFunctionRef..': About to transfer '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from brain '..oUnit:GetAIBrain().Nickname..' to '..oJustBuilt:GetAIBrain().Nickname..'; Dist from unit to tMexLocation='..M28Utilities.GetDistanceBetweenPositions(tMexLocation, oUnit:GetPosition())) end
                                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tMexLocation) <= 2.25 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and gift the storage to the player that built the mex') end
                                    M28Team.TransferUnitsToPlayer({oUnit}, oJustBuilt:GetAIBrain():GetArmyIndex(), false)
                                end
                            end
                        end
                    end
                elseif EntityCategoryContains(M28UnitInfo.refCategoryMassStorage, oJustBuilt.UnitId) then
                    --If just built a mass storage but we dont own the mex it is adjacent to, then gift the storage
                    local rSearchRectangle = M28Utilities.GetRectAroundLocation(oJustBuilt:GetPosition(), 2.749)
                    local tNearbyUnits = GetUnitsInRect(rSearchRectangle) --at 1.5 end up with storage thats not adjacent being gifted in some cases but not in others; at 1 none of it gets gifted; the mass storage should be exactly 2 from the mex; however even at 2.1, 2.25 and 2.499 had cases where the mex wasnt identified so will try 2.75 since distances can vary/be snapped to the nearest 0.5 I think
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Storage gifting where built storage - oJustBuilt='..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; owner='..oJustBuilt:GetAIBrain().Nickname..'; is tNearbyUnits empty='..tostring(M28Utilities.IsTableEmpty(tNearbyUnits)))
                        if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                            for iUnit, oUnit in tNearbyUnits do
                                LOG(sFunctionRef..': iUnit '..iUnit..' in tNearbyUnits='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; owner='..oUnit:GetAIBrain().Nickname)
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                        local tNearbyMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tNearbyUnits)
                        if M28Utilities.IsTableEmpty(tNearbyMexes) == false then
                            local bHaveMexWeOwnNearby = false
                            local oBrainToTransferToIfWeOwnNoMexes
                            for iUnit, oUnit in tNearbyMexes do
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering nearby unit oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname) end
                                if oUnit:GetAIBrain() == oJustBuilt:GetAIBrain() then
                                    bHaveMexWeOwnNearby = true
                                elseif oUnit:GetAIBrain().M28Team == oJustBuilt:GetAIBrain().M28Team then
                                    oBrainToTransferToIfWeOwnNoMexes = oUnit:GetAIBrain()
                                end
                            end
                            if not(bHaveMexWeOwnNearby) and oBrainToTransferToIfWeOwnNoMexes then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will try and gift the storage to the player who owns the mex already there') end
                                M28Team.TransferUnitsToPlayer({oJustBuilt}, oBrainToTransferToIfWeOwnNoMexes:GetArmyIndex(), false)
                            end
                        end
                    end
                elseif EntityCategoryContains(M28UnitInfo.refCategoryEnergyStorage, oJustBuilt.UnitId) then M28Team.TeamEconomyRefresh(oJustBuilt:GetAIBrain().M28Team)
                end
            end

            --Update economy tracking (this function will check if it is an economic unit as part of it)
            M28Economy.UpdateGrossIncomeForUnit(oJustBuilt)
            if EntityCategoryContains(M28UnitInfo.refCategoryScathis, oJustBuilt.UnitId) then
                table.insert(M28Engineer.tAllScathis, oJustBuilt)
            end

            --Logic based on the engineer
            if EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then
                M28ACU.GetACUOrder(oEngineer:GetAIBrain(), oEngineer)
            elseif EntityCategoryContains(M28UnitInfo.refCategoryFactory, oEngineer.UnitId) then
                if bDebugMessages == true then LOG(sFunctionRef..': A factory has just built a unit so will get the next order for the factory') end
                ForkThread(M28Factory.DecideAndBuildUnitForFactory, oEngineer:GetAIBrain(), oEngineer)
            end

            --Logic based on the type of unit built
            if EntityCategoryContains(M28UnitInfo.refCategoryFactory, oJustBuilt.UnitId) then
                if bDebugMessages == true then LOG(sFunctionRef..': A factory has just been built so will get the next order for the factory') end
                ForkThread(M28Factory.DecideAndBuildUnitForFactory, oJustBuilt:GetAIBrain(), oJustBuilt)
                if EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oJustBuilt.UnitId) then
                    oJustBuilt:GetAIBrain()[M28Economy.refiOurHighestFactoryTechLevel] = math.max(M28UnitInfo.GetUnitTechLevel(oJustBuilt), oJustBuilt:GetAIBrain()[M28Economy.refiOurHighestFactoryTechLevel])
                end
            end

            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        elseif not(oJustBuilt:GetAIBrain().M28AI) then
            --If build an M28 unit then will record its plateau and LZ; so for non-M28 AI also want to do this so we have a backup for pathfinding if dont already have something
            if M28Utilities.IsTableEmpty(oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) and not(EntityCategoryContains(categories.AIR, oJustBuilt.UnitId)) then
                local iPlateau, iLandZone = M28Map.GetPathingOverridePlateauAndLandZone(oJustBuilt:GetPosition(), true, oJustBuilt)
                if (iPlateau or 0) > 0 then
                    if not(oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) then oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] = {} end
                    oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][oJustBuilt:GetAIBrain().M28Team] = {iPlateau, iLandZone}
                end
            end

        end
        --Upgrade tracking (even if have run this already)
        if oEngineer:GetAIBrain().M28AI and EntityCategoryContains(categories.STRUCTURE, oEngineer.UnitId) and EntityCategoryContains(categories.STRUCTURE, oJustBuilt.UnitId) then
            M28Team.UpdateUpgradeTrackingOfUnit(oJustBuilt, true)
        end
    end
end

function OnReclaimStarted(oEngineer, oReclaim)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnReclaimStarted'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnReclaimFinished(oEngineer, oReclaim)
    if M28Utilities.bM28AIInGame then
        --Update the segment that the reclaim is at, or the engineer if hte reclaim doesnt have one
        local sFunctionRef = 'OnReclaimFinished'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..': oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' has just finished reclaiming, gametime='..GetGameTimeSeconds()) end
        if oReclaim and oReclaim.CachePosition then
            --LOG('OnReclaimFinished temp log - remove once confirmed this works - about to update reclaim data near location='..repru(oReclaim.CachePosition))
            ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, oReclaim.CachePosition, 0)
        else
            --LOG('OnReclaimFinished alt temp log - couldnt find reclaim position so will use engineer position')
            ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, oEngineer:GetPosition(), 1)
        end

        --Was the engineer reclaiming an area? if so check if still nearby reclaim
        if oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionReclaimArea then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oEngineer:GetPosition(), true, oEngineer)
            if (iLandZone or 0) > 0 then
                local iTeam =  oEngineer:GetAIBrain().M28Team
                local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                M28Engineer.GetEngineerToReclaimNearbyArea(oEngineer, tLZTeamData, iPlateau, iLandZone, M28Conditions.WantToReclaimEnergyNotMass(iTeam, iPlateau, iLandZone), false)
            end
        elseif M28Utilities.IsTableEmpty(oReclaim[M28Engineer.reftUnitsReclaimingUs]) == false then
            local tEngineersToClear = {}
            for iEngineer, oEngineer in oReclaim[M28Engineer.reftUnitsReclaimingUs] do
                if M28UnitInfo.IsUnitValid(oEngineer) then
                    table.insert(tEngineersToClear, oEngineer)
                end
            end
            for iEngineer, oEngineer in tEngineersToClear do
                M28Orders.IssueTrackedClearCommands(oEngineer)
            end
        end

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnCreateWreck(tPosition, iMass, iEnergy)
    --Dont check if M28brains are in game yet as can be called at start of game before we have recorded any aiBrain

    if not(M28Map.bReclaimManagerActive) then
        if GetGameTimeSeconds() >= 20 then return nil
        else
            local iWaitCount = 0
            while not(M28Map.bReclaimManagerActive) do
                WaitTicks(1)
                iWaitCount = iWaitCount + 1
                if iWaitCount >= 20 then M28Utilities.ErrorHandler('Map setup not complete') break end
            end
        end
    end
    if iMass == 113 then LOG('OnCreateWreck: iMass='..iMass..'; tPosition='..repru(tPosition)..'; will record we want to update reclaim at this location') end
    ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, tPosition, 0)
end

function OnTransportLoad(oUnit, oTransport, bone)

end

function OnTransportUnload(oUnit, oTransport, bone)


end

function OnDetectedBy(oUnitDetected, iBrainIndex)
    --Appears to be called when iBrainIndex detects oUnitDetected, triggers for teammate units but not own units?

    --For now used to make sure we have up to date unit info
    if M28Utilities.bM28AIInGame then
        local aiBrain = ArmyBrains[iBrainIndex]
        --LOG('OnDetectedBy: UnitID='..oUnitDetected.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitDetected)..'; tAllAIBrainsByArmyIndex[iBrainIndex] name='..M28Overseer.tAllAIBrainsByArmyIndex[iBrainIndex].Nickname..'; ArmyBrains nickname='..ArmyBrains[iBrainIndex].Nickname..'; Does entity contain navy='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnitDetected.UnitId))..'; aiBrain.M28AI='..tostring((aiBrain.M28AI or false)))
        M28Team.ConsiderAssigningUnitToZoneForBrain(aiBrain, oUnitDetected) --This function includes check of whether this is an M28 brain, and updates last known position
        if aiBrain.M28AI then
            --Update highest enemy ground unti health
            if EntityCategoryContains(M28UnitInfo.refCategoryLandCombat - categories.COMMAND - categories.SUBCOMMANDER, oUnitDetected.UnitId) then
                local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnitDetected)
                local iMaxHealth = oUnitDetected:GetMaxHealth() + iMaxShield
                if iMaxHealth > aiBrain[M28Overseer.refiHighestEnemyGroundUnitHealth] then
                    aiBrain[M28Overseer.refiHighestEnemyGroundUnitHealth] = iMaxHealth
                end
            end
        end
    end
end

function OnCreate(oUnit)
    if M28Utilities.bM28AIInGame and M28UnitInfo.IsUnitValid(oUnit) then
        if not(M28Map.bMapSetupComplete) then --Start of game ACU creation happens before we have setup the map
            while not(M28Map.bMapSetupComplete) do
                WaitTicks(1)
            end
            WaitTicks(1)
            if not(M28UnitInfo.IsUnitValid(oUnit)) then return nil end
        end
        M28Team.ConsiderAssigningUnitToZoneForBrain(oUnit:GetAIBrain(), oUnit) --This function includes check of whether this is an M28 brain

        --All units (not just M28 specific):
        M28UnitInfo.RecordUnitRange(oUnit)
        if M28Config.M28ShowEnemyUnitNames then oUnit:SetCustomName(oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
        --Units with upgrade - update the base threat value
        if EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER, oUnit.UnitId) then M28UnitInfo.UpdateUnitCombatMassRatingForUpgrades(oUnit) end --Will check if unit has enhancements as part of this

        --Hydro resource locations
        if EntityCategoryContains(M28UnitInfo.refCategoryHydro, oUnit.UnitId) then
            --Treat location as no longer having no buildings on it
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
            if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroUnbuiltLocations]) == false then
                --LOG('About to loop through hydro locations; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; reprs='..reprs(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroUnbuiltLocations]))
                for iHydroLocation, tHydroLocation in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroUnbuiltLocations] do
                    if M28Utilities.GetDistanceBetweenPositions(tHydroLocation, oUnit:GetPosition()) <= 2 then
                        table.remove(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroUnbuiltLocations], iHydroLocation)
                        break
                    end
                end
            end
        elseif EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
            --Treat location as no longer having no buildings on it (if we were previously)
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
            if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexUnbuiltLocations]) == false then
                --LOG('About to loop through Mex locations; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; reprs='..reprs(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexUnbuiltLocations]))
                for iMexLocation, tMexLocation in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexUnbuiltLocations] do
                    if M28Utilities.GetDistanceBetweenPositions(tMexLocation, oUnit:GetPosition()) <= 2 then
                        table.remove(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexUnbuiltLocations], iMexLocation)
                        break
                    end
                end
            end
        end

        --M28 specific: Cover units transferred to us or cheated in or presumably that we have captured
        if oUnit:GetAIBrain().M28AI and oUnit:GetFractionComplete() == 1 then
            M28Economy.UpdateHighestFactoryTechLevelForBuiltUnit(oUnit) --this includes a check to see if are dealing with a factory HQ
            M28Economy.UpdateGrossIncomeForUnit(oUnit, false) --This both includes a check of the unit type, and cehcks we havent already recorded
            if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) and not(oUnit.M28OnConstructedCalled) then M28Economy.UpdateLandZoneM28MexByTechCount(oUnit) end
        end
    end
end

function OnCreateBrain(aiBrain, planName, bIsHuman)
    if not(aiBrain['M28BrainSetupRun']) then
        if M28Config.M28RunProfiling then ForkThread(M28Profiler.ProfilerActualTimePerTick) end
        aiBrain['M28BrainSetupRun'] = true

        if bIsHuman == nil then
            if aiBrain.BrainType == "AI" or not(aiBrain.BrainType) or string.find(aiBrain.BrainType, "AI") then bIsHuman = false else bIsHuman = true end
        end

        --Logic to run for all brains
        local iStartPositionX, iStartPositionZ = aiBrain:GetArmyStartPos()
        M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()] = {iStartPositionX, GetSurfaceHeight(iStartPositionX, iStartPositionZ), iStartPositionZ}
        M28Overseer.tAllAIBrainsByArmyIndex[aiBrain:GetArmyIndex()] = aiBrain

        if bIsHuman then
            LOG('Human player brain '..aiBrain.Nickname..' created; Index='..aiBrain:GetArmyIndex()..'; start position='..repru(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()]))
        else
            --Logic to run just for M28AI
            LOG('OnCreateBrain hook for ai with personality '..ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality)

            if ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == 'm28ai' or ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == 'm28aicheat' then
                aiBrain.M28AI = true
                LOG('M28 brain created')

                --Copy of parts of aiBrain OnCreateAI that still want to retain
                aiBrain:CreateBrainShared(planName)
                --aiBrain:InitializeEconomyState()
                aiBrain.BrainType = 'AI'
                local per = ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality
                local cheatPos = string.find(per, 'cheat')
                if cheatPos then

                    local AIUtils = import('/lua/ai/aiutilities.lua')
                    AIUtils.SetupCheat(aiBrain, true)
                    ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality = string.sub(per, 1, cheatPos - 1)
                end

                --M28AIBrainClass.OnCreateAI(aiBrain, planName)
                ForkThread(M28Overseer.M28BrainCreated, aiBrain)
            end
        end
    end
end