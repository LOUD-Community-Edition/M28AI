---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 09:03
---



local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28ACU = import('/mods/M28AI/lua/AI/M28ACU.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Factory = import('/mods/M28AI/lua/AI/M28Factory.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Config = import('/mods/M28AI/lua/M28Config.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local M28Micro = import('/mods/M28AI/lua/AI/M28Micro.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')

refiLastWeaponEvent = 'M28LastWep' --Gametimeseconds that last updated onweapon


function OnPlayerDefeated(aiBrain)
    aiBrain.M28IsDefeated = true

    --Was it an M28AI?
    if aiBrain.M28AI then
        --Give resources to teammates
        local bHaveTeammates = false
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyActiveBrains]) == false then
            for iBrain, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyActiveBrains] do
                if not(oBrain == aiBrain) and not(oBrain.M28IsDefeated) and not(oBrain:IsDefeated()) then
                    bHaveTeammates = true
                    break
                end
            end
        end
        if bHaveTeammates then
            ForkThread(M28Team.GiveAllResourcesToAllies, aiBrain)
        end
    end

    --Update tables tracking the various brains
    ForkThread(M28Team.RefreshActiveBrainListForBrainDeath, aiBrain)
end

function OnACUKilled(oUnit)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnACUKilled'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if bDebugMessages == true then
            local oKilledBrain = oUnit:GetAIBrain()
            if oKilledBrain then
                LOG(sFunctionRef..': ACU '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has just died, and its brain is '..oKilledBrain.Nickname)
            else
                LOG(sFunctionRef..': ACU '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has just died, and it doesnt have a brain')
            end
        end
        if ScenarioInfo.Options.Victory == "demoralization" then
            if oUnit:GetAIBrain() then
                if not(oUnit:GetAIBrain().M28IsDefeated) then
                    OnPlayerDefeated(oUnit:GetAIBrain())
                end
            else
                --Possibility that we have already recorded the unit death, so wait 1 second and then if any brains show as defeated but not M28Defeated then run the function
                ForkThread(M28Team.DelayedPlayerDeathCheck)
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnKilled(oUnitKilled, instigator, type, overkillRatio)
    --WARNING: Doesnt trigger when an ACU is killed
    --Will make sure the OnUnitDeath event is called, i.e. this function should only be used where we only want something to run when we killed something, or an enemy killed something of ours

    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnKilled'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        local refbAlreadyRun = 'M28EventsOnKilledRun'
        if not(oUnitKilled[refbAlreadyRun]) then
            oUnitKilled[refbAlreadyRun] = true
            if bDebugMessages == true then LOG(sFunctionRef..': oUnitKilled='..oUnitKilled.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitKilled)..'; Is unit killed an ACU='..tostring(M28Utilities.IsACU(oUnitKilled))..'; GameTime='..GetGameTimeSeconds()) end
            if oUnitKilled.GetAIBrain then
                OnUnitDeath(oUnitKilled) --Ensure this is run when a unit dies

                --were we killed by something?
                local oKillerUnit

                if instigator and not(instigator:BeenDestroyed()) and not(instigator.Dead) then
                    if instigator.GetLauncher and instigator:GetLauncher() then
                        oKillerUnit = instigator:GetLauncher()
                    elseif instigator.DamageData and not(instigator.unit) and not(instigator.UnitId) then
                        --Can get errors for artillery shells when running IsProjectile
                    elseif IsProjectile(instigator) or IsCollisionBeam(instigator) then
                        if instigator.unit then
                            oKillerUnit = instigator.unit
                        end
                    elseif IsUnit(instigator) then
                        oKillerUnit = instigator
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': Have an instigator, checking if have valid killer unit. Is valid='..tostring(M28UnitInfo.IsUnitValid(oKillerUnit))) end
                    if oKillerUnit and oKillerUnit.GetAIBrain then

                        --Non-M28 specific killer logic:
                        --T2 arti firebase tracking if they get lots of kills:
                        if oUnitKilled:GetAIBrain().M28AI then
                            if EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oKillerUnit.UnitId) then M28Land.ConsiderIfHaveEnemyFirebase(oUnitKilled:GetAIBrain().M28Team, oKillerUnit) end
                        end

                        --M28 specific killer logic
                        local oKillerBrain = instigator:GetAIBrain()
                        if oKillerBrain.M28AI then
                            --TODO - consider adding in logic e.g. chat messages and tracking
                        end
                    end
                end
            elseif bDebugMessages == true then LOG(sFunctionRef..': Unit killed doesnt have a brain')
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnMexDeath(oUnit)
    --Make the mex status available
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnMexDeath'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnPropDestroyed(oProp)
    --Confirmed manually this triggers e.g. if a bomber destroys a rock, and if a tree is reclaimed
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnPropDestroyed'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnYthothaDeath(oUnit)
    --Called when a ythotha (oUnit) is flagged as dying or being killed
    local sFunctionRef = 'OnYthothaDeath'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local refbYthothaDeath = 'M28EventYthothaDeath'

    if not(oUnit[refbYthothaDeath]) then
        oUnit[refbYthothaDeath] = true
        local tNearbyUnits
        if bDebugMessages == true then LOG(sFunctionRef..': Ythotha has just died, will look for nearby units and tell them to run away') end
        local iTimeToRun
        local iSearchRange = 70
        for iBrain, oBrain in M28Overseer.tAllActiveM28Brains do
            tNearbyUnits = oBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand, oUnit:GetPosition(), 50, 'Ally')
            if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                for iFriendlyUnit, oFriendlyUnit in tNearbyUnits do
                    if bDebugMessages == true then LOG(sFunctionRef..': oFriendlyUnit='..oFriendlyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFriendlyUnit)..'; if we own it then will make it run away') end
                    if oFriendlyUnit:GetAIBrain() == oBrain then --Only do this for M28 units
                        if M28UnitInfo.IsUnitValid(oFriendlyUnit, true) then
                            iTimeToRun = math.min(32, math.max(10, 18 + (50 - M28Utilities.GetDistanceBetweenPositions(oFriendlyUnit:GetPosition(), oUnit:GetPosition()) / (oFriendlyUnit:GetBlueprint().Physics.MaxSpeed or 1))))
                            if bDebugMessages == true then LOG(sFunctionRef..': Telling friendly unit '..oFriendlyUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oFriendlyUnit)..' to move away for 18s via moveawayfromtarget order') end
                            ForkThread(M28Micro.MoveAwayFromTargetTemporarily, oFriendlyUnit, iTimeToRun, oUnit:GetPosition())
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function OnUnitDeath(oUnit)
    --NOTE: This is called by the death of any unit of any player, so careful with what commands are given
        --Some callbacks line onkilled will call this as well to make sure it is run (since for some things like when an ACU is killed it doesnt trigger directly)
    if M28Utilities.bM28AIInGame and M28Map.bMapLandSetupComplete then --No point running on death logic for units at start of the game
        local sFunctionRef = 'OnUnitDeath'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



        if bDebugMessages == true then LOG(sFunctionRef..'Hook successful. oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; GameTime='..GetGameTimeSeconds()) end
        --Is it an ACU?
        if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
            OnACUKilled(oUnit)
        else
            if oUnit.CachePosition then --Redundancy to check not dealing with a unit, not sure this will actually trigger as looks like wreck deaths are picked up by the prop logic above
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Unit killed has a cache position, will draw in blue around it')
                    M28Utilities.DrawLocation(oUnit.CachePosition, nil, 1, 100, nil)
                end
                ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, oUnit.CachePosition, 0)
            else
                if oUnit.GetAIBrain then
                    --------Non-M28 Specific logic------

                    --TMD protection logic - refresh land zone TMD entries
                    if oUnit[M28Building.refbUnitWantsMoreTMD] then M28Building.UpdateLZUnitsWantingTMDForUnitDeath(oUnit) end

                    --Big threat global team table update
                    if M28Utilities.IsTableEmpty(oUnit[M28UnitInfo.reftbInArmyIndexBigThreatTable]) == false then
                        M28Team.RemoveUnitFromBigThreatTable(oUnit)
                    end


                    M28Orders.ClearAnyRepairingUnits(oUnit)

                    --Hydro resource location made available again
                    if EntityCategoryContains(M28UnitInfo.refCategoryHydro, oUnit.UnitId) then
                        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroLocations]) == false then
                            for iHydroLocation, tHydroLocation in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroLocations] do
                                if M28Utilities.GetDistanceBetweenPositions(tHydroLocation, oUnit:GetPosition()) <= 2 then
                                    table.insert(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroUnbuiltLocations], tHydroLocation)
                                    break
                                end
                            end
                        end
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
                        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]) == false then
                            for iMexLocation, tMexLocation in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations] do
                                --Prev line - redid at same time as changing approach for removing an unbuilt location to try and be more accurate
                                --if M28Utilities.GetDistanceBetweenPositions(tMexLocation, oUnit:GetPosition()) <= 0.9 then
                                --Revised line:
                                if math.abs(tMexLocation[1] - oUnit:GetPosition()[1]) < 0.9 and math.abs(tMexLocation[3] - oUnit:GetPosition()[3]) < 0.9 then
                                    table.insert(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexUnbuiltLocations], tMexLocation)
                                    break
                                end
                            end
                        end
                        --Radar intel coverage update
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryRadar, oUnit.UnitId) then
                        ForkThread(M28Land.UpdateRadarCoverageForDestroyedRadar, oUnit)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryWall, oUnit.UnitId) and not(oUnit:GetAIBrain().M28AI) then
                        M28Land.TrackWallSegment(oUnit, false)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryFixedT2Arti, oUnit.UnitId) then
                        --For each M28 team with active M28AI consider if we have a firebase
                        M28Land.ConsiderIfAnyEnemyTeamsStillHaveFirebaseOnT2ArtiDeath(oUnit)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryTMD + M28UnitInfo.refCategoryTML, oUnit.UnitId) then
                        if EntityCategoryContains(M28UnitInfo.refCategoryTMD, oUnit.UnitId) then
                            M28Building.TMDDied(oUnit)
                        else
                            M28Building.TMLDied(oUnit)
                        end
                    end
                    --Ythotha deathball avoidance
                    --Note -seraphimunits.lua contains SEnergyBallUnit which looks like it is for when the death ball is spawned; ID is XSL0402; SpawnElectroStorm is in the ythotha script
                    --Sandbox test - have c.36s from ythotha dying to energy ball dying, so want to run away for half of this (18s) plus extra time based on how far away we already were
                    if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental * categories.SERAPHIM, oUnit.UnitId) then
                        OnYthothaDeath(oUnit)
                    end
                    if EntityCategoryContains(categories.STRUCTURE + categories.EXPERIMENTAL, oUnit.UnitId) and (EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) or oUnit:GetFractionComplete() < 1) then
                        M28Engineer.SearchForBuildableLocationsNearDestroyedBuilding(oUnit)
                    end




                    -------M28 specific logic---------
                    --Is the unit owned by M28AI?
                    if oUnit:GetAIBrain().M28AI then
                        --Logic that doesnt require the unit to ahve finished construction:

                        --Fixed shielding
                        if oUnit[M28Building.refbUnitWantsShielding] or oUnit[M28Building.reftoUnitsCoveredByShield] or oUnit[M28Building.reftoShieldsProvidingCoverage] then
                            if oUnit[M28Building.reftoUnitsCoveredByShield] then
                                M28Building.UpdateShieldCoverageOfUnits(oUnit, true)
                            else
                                M28Building.CheckIfUnitWantsFixedShield(oUnit)
                            end
                        end

                        --Run unit type specific on death logic where the unit is completed
                        if oUnit:GetFractionComplete() == 1 then
                            M28Economy.UpdateGrossIncomeForUnit(oUnit, true)
                            if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                                M28Engineer.ClearEngineerTracking(oUnit)
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryScathis, oUnit.UnitId) then
                                if M28Utilities.IsTableEmpty(M28Engineer.tAllScathis) == false then
                                    for iScathis, oScathis in M28Engineer.tAllScathis do
                                        if oScathis == oUnit then
                                            table.remove(M28Engineer.tAllScathis, iScathis) --Only doing this once so can get away with using table.remove, otherwise would want to use M28Utilities.ArrayRemove
                                            break
                                        end
                                    end
                                end
                            elseif EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
                                --Check for upgrades
                                --Upgrade tracking (even if have run this already)
                                if bDebugMessages == true then LOG(sFunctionRef..': Will check if upgrade tracking needs updating, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                                M28Team.UpdateUpgradeTrackingOfUnit(oUnit, true)
                                if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then M28Economy.UpdateLandZoneM28MexByTechCount(oUnit, true) end
                                M28Economy.UpdateHighestFactoryTechLevelForDestroyedUnit(oUnit) --checks if it was a factory as part of this function
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryMobileLand, oUnit.UnitId) then
                                --If unit was traveling to another land zone, then update that land zone so it no longer things the unit is traveling here
                                M28Land.RemoveUnitFromListOfUnitsTravelingToLandZone(oUnit) --(this will check if it was or not)
                            end

                            --Mobile shield update
                            if oUnit[M28Land.refoAssignedMobileShield] then
                                oUnit[M28Land.refoAssignedMobileShield][M28Land.refoMobileShieldTarget] = nil
                            end
                            if oUnit[M28Land.refoMobileShieldTarget] then
                                oUnit[M28Land.refoMobileShieldTarget][M28Land.refoAssignedMobileShield] = nil
                            end
                        end
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnWorkEnd(self, work)
    --Not sure when/if this even triggers - would need to review if plan to use
    --LOG('WOrk end has finished for self='..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self)..'; work reprs='..reprs(work))
end

function OnEnhancementComplete(oUnit, sEnhancement)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'OnEnhancementComplete'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Enhancement completed for self='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; sEnhancement='..reprs(sEnhancement)) end
    M28UnitInfo.UpdateUnitCombatMassRatingForUpgrades(oUnit)
    M28UnitInfo.RecordUnitRange(oUnit) --Refresh the range incase enhancement has increased anything
    if oUnit:GetAIBrain().M28AI then
        if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
            oUnit[M28ACU.refiUpgradeCount] = (oUnit[M28ACU.refiUpgradeCount] or 0) + 1
            M28ACU.GetUpgradePathForACU(oUnit)
        end
        --Remove any upgrade tracking
        M28Team.UpdateUpgradeTrackingOfUnit(oUnit, true, sEnhancement)
    end
    M28UnitInfo.RecordUnitRange(oUnit)
    if bDebugMessages == true then LOG(sFunctionRef..': Unit DF range after updating recorded range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function OnShieldBubbleDamaged(self, instigator)
    
end

function OnDamaged(self, instigator) --This doesnt trigger when a shield bubble is damaged - see OnShieldBubbleDamaged for this
    
end

function OnBombFired(oWeapon, projectile)
    if M28Utilities.bM28AIInGame then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnBombFired'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
        local oUnit = oWeapon.unit
        if oUnit and oUnit.GetUnitId then
            local sUnitID = oUnit.UnitId
            if bDebugMessages == true then LOG(sFunctionRef..': bomber position when firing bomb='..repru(oUnit:GetPosition())) end
            if EntityCategoryContains(M28UnitInfo.refCategoryBomber + M28UnitInfo.refCategoryTorpBomber, sUnitID) then
                --Try to dodge non-experimental bombs
                if not(EntityCategoryContains(categories.EXPERIMENTAL, sUnitID)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and dodge the bomb fired by unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
                    M28Micro.DodgeBomb(oUnit, oWeapon, projectile)
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

--WARNING: OnWeaponFired and/or OnProjectilfeFired - one of these (probably the latter) resulted in error messages when t1 arti fired, disabled both of them as dont use now

function OnWeaponFired(oWeapon)
    if M28Utilities.bM28AIInGame then
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        local sFunctionRef = 'OnWeaponFired'
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..': Start of code; does the weapon have a valid unit='..tostring(M28UnitInfo.IsUnitValid(oWeapon.unit))..'; Weapon unitID='..(oWeapon.unit.UnitId or 'nil')) end

        local oUnit = oWeapon.unit
        if oUnit and oUnit.GetUnitId and oUnit.GetAIBrain then
            if not(oWeapon[refiLastWeaponEvent]) or GetGameTimeSeconds() - (oWeapon[refiLastWeaponEvent] or -1) >= 0.5 then
                oWeapon[refiLastWeaponEvent] = GetGameTimeSeconds()
                --Update unit last known position/record it
                local oParentBrain = oUnit:GetAIBrain()
                for iTeam, tTeam in M28Team.tTeamData do
                    if not(iTeam == oParentBrain.M28Team) then
                        if M28Utilities.IsTableEmpty(tTeam[M28Team.subreftoFriendlyActiveM28Brains]) == false then
                            for iBrain, oBrain in tTeam[M28Team.subreftoFriendlyActiveM28Brains] do
                                M28Team.ConsiderAssigningUnitToZoneForBrain(oBrain, oUnit) --This function includes check of whether this is an M28 brain, and updates last known position
                                break
                            end
                        end
                    end
                end

                --Consider dodging
                if EntityCategoryContains(M28UnitInfo.refCategoryBomber, oUnit.UnitId) and oWeapon.Label == 'GroundMissile' then
                    --Corsairs dont trigger the onbombfired event normally
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Weapon fired by corsair, unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
                        if oWeapon:GetCurrentTarget().GetPosition then LOG(sFunctionRef..': Target of weapon='..repru(oWeapon:GetCurrentTarget():GetPosition())) end
                    end

                    ForkThread(M28Micro.DodgeBomb, oUnit, oWeapon, nil)
                else
                    --Dodge logic for certain other attacks (conditions for this are in considerdodgingshot)
                    if bDebugMessages == true then LOG(sFunctionRef..': Will consider whether we want to dodge the shot') end
                    ForkThread(M28Micro.ConsiderDodgingShot, oUnit, oWeapon)
                end

                --Update overcharge tracking
                if oWeapon.GetBlueprint and oWeapon:GetBlueprint().Overcharge then
                    oUnit[M28UnitInfo.refiTimeOfLastOverchargeShot] = GetGameTimeSeconds()
                    if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and oUnit:GetAIBrain().M28AI then
                        --Get another order immediately rather than waiting (means we dont have to try and queue orders up for ACU logic)
                        M28ACU.GetACUOrder(oUnit:GetAIBrain(), oUnit)
                    end
                end

                --M28 owned unit specific logic
                if oUnit:GetAIBrain().M28AI then
                    --Shot is blocked logic
                    if bDebugMessages == true then LOG(sFunctionRef..': COnsidering if unit shot is blocked Time='..GetGameTimeSeconds()..', range category='..(oWeapon.Blueprint.RangeCategory or 'nil')..'; Is unit a relevant DF category='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategoryNavalSurface * categories.DIRECTFIRE + M28UnitInfo.refCategorySeraphimDestroyer - M28UnitInfo.refCategoryMissileShip, oUnit.UnitId))) end
                    if oWeapon.Blueprint.RangeCategory == 'UWRC_DirectFire' and EntityCategoryContains(M28UnitInfo.refCategoryDFTank + M28UnitInfo.refCategoryNavalSurface * categories.DIRECTFIRE + M28UnitInfo.refCategorySeraphimDestroyer - M28UnitInfo.refCategoryMissileShip, oUnit.UnitId) then
                        --Get weapon target if it is a DF weapon
                        local oTarget = oWeapon:GetCurrentTarget()
                        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' has just fired a shot. Do we have a valid target for our weapon='..tostring(M28UnitInfo.IsUnitValid(oTarget))..'; time last shot was blocked='..(oUnit[M28UnitInfo.refiTimeOfLastCheck] or 'nil')) end
                        if M28UnitInfo.IsUnitValid(oTarget) then

                            oUnit[M28UnitInfo.refiTimeOfLastCheck] = GetGameTimeSeconds()
                            oUnit[M28UnitInfo.refbLastShotBlocked] = M28Logic.IsShotBlocked(oUnit, oTarget)
                            if bDebugMessages == true then LOG(sFunctionRef..': oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; Is shot blocked='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked])..'; built in blocking terrain result for low profile='..tostring(oUnit:GetAIBrain():CheckBlockingTerrain(oUnit:GetPosition(), oTarget:GetPosition(), 'Low'))..'; High profile='..tostring(oUnit:GetAIBrain():CheckBlockingTerrain(oUnit:GetPosition(), oTarget:GetPosition(), 'High'))) end

                            if oUnit[M28UnitInfo.refbLastShotBlocked] then
                                --Reset after 20s if we havent fired any more shots at the target
                                --function DelayChangeVariable(oVariableOwner, sVariableName, vVariableValue, iDelayInSeconds, sOptionalOwnerConditionRef, iMustBeLessThanThisTimeValue, iMustBeMoreThanThisTimeValue, vMustNotEqualThisValue)
                                M28Utilities.DelayChangeVariable(oUnit, M28UnitInfo.refbLastShotBlocked, false, 20, M28UnitInfo.refiTimeOfLastCheck, GetGameTimeSeconds() + 0.01)
                            end
                        end
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

    end
end

function OnMissileBuilt(self, weapon)
    if M28Utilities.bM28AIInGame then
        if self.GetAIBrain and self:GetAIBrain().M28AI then
            local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
            local sFunctionRef = 'OnMissileBuilt'
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


            self[M28Building.refbMissileRecentlyBuilt] = true
            M28Utilities.DelayChangeVariable(self, M28Building.refbMissileRecentlyBuilt, false, 5)


            --Pause if we already have 2 missiles
            if bDebugMessages == true then
                if M28UnitInfo.IsUnitValid(self) then
                    LOG(sFunctionRef..': Have valid unit='..self.UnitId..M28UnitInfo.GetUnitLifetimeCount(self))
                else
                    LOG(sFunctionRef..': self='..reprs(self))
                end
            end

            local iMissiles = 1 --For some reason the count is off by 1, presumably a slight delay between the event being called and the below ammo counts working
            if self.GetTacticalSiloAmmoCount then iMissiles = iMissiles + self:GetTacticalSiloAmmoCount() end
            if bDebugMessages == true then LOG(sFunctionRef..': iMissiles based on tactical silo ammo='..iMissiles) end
            if self.GetNukeSiloAmmoCount then iMissiles = iMissiles + self:GetNukeSiloAmmoCount() end
            if bDebugMessages == true then LOG(sFunctionRef..': iMissiles after Nuke silo ammo='..iMissiles) end
            if iMissiles >= 1 then
                --Stop assisting units (so can reassess if we still want to assist)
                if M28Utilities.IsTableEmpty(self[M28UnitInfo.reftoUnitsAssistingThis]) == false then
                    local tEngineersToStop = {}
                    for iEngineer, oEngineer in self[M28UnitInfo.reftoUnitsAssistingThis] do
                        table.insert(tEngineersToStop, oEngineer)
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to make engineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to stop assisting') end
                    end
                    for iEngineer, oEngineer in tEngineersToStop do
                        M28Orders.IssueTrackedClearCommands(oEngineer)
                        if bDebugMessages == true then LOG(sFunctionRef..': Just sent a clear order to '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' to stop assisting') end
                    end
                end

                --If 2+ missiles then pause, and consider unpausing later
                if iMissiles >= 2 and not(EntityCategoryContains(categories.EXPERIMENTAL, self.UnitId)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have at least 2 missiles so will set paused to true') end
                    self:SetPaused(true)
                    --Recheck every minute
                    ForkThread(M28Building.CheckIfWantToBuildAnotherMissile, self)
                end
            end

            --Start logic to periodically check for targets to fire the missile at (in case there are no targets initially)
            if not(self[M28Building.refbActiveMissileChecker]) and not(EntityCategoryContains(M28UnitInfo.refCategorySMD, self.UnitId)) then
                if bDebugMessages == true then LOG(sFunctionRef..': Calling logic to consider launching a missile') end
                ForkThread(M28Building.ConsiderLaunchingMissile, self, weapon)
            end
        end

    end
end

--[[
function OnProjectileFired(oWeapon, oMuzzle)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'OnProjectileFired'
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
    if oWeapon.GetBlueprint then
        LOG('OnWeaponFired hook for blueprint='..repru(oWeapon:GetBlueprint()))
    end
    if oWeapon.unit then
        LOG('Have a unit; unit position='..repru(oWeapon.unit:GetPosition()))
    end
end--]]

function OnConstructionStarted(oEngineer, oConstruction, sOrder)
    if M28Utilities.bM28AIInGame then
        --Update land zone queued orders
        if M28Utilities.IsTableEmpty(oEngineer[M28Engineer.reftQueuedBuildings]) == false then
            M28Engineer.RemoveBuildingFromQueuedBuildings(oEngineer, oConstruction)
        end

        --Record any mexes so we can repair them if construction gets interrupted
        if oEngineer:GetAIBrain().M28AI then
            --Track experimental construction and other special on construction logic
            local refbConstructionStart = 'M28FirstConstructionStart'
            if oConstruction.GetUnitId and not(oConstruction[refbConstructionStart]) then
                local sFunctionRef = 'OnConstructionStarted'
                local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

                oConstruction[refbConstructionStart] = true
                if EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oConstruction.UnitId) then
                    M28Engineer.RecordPartBuiltMex(oEngineer, oConstruction)
                end

                --Decide if want to shield this construction
                if EntityCategoryContains(M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryExperimentalStructure, oConstruction.UnitId) then
                    M28Building.CheckIfUnitWantsFixedShield(oConstruction, true)
                    --If this is a fixed shield then instead update shield coverage
                    if EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oConstruction.UnitId) then
                        M28Building.UpdateShieldCoverageOfUnits(oConstruction, false)
                    end
                end
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            end
        end
    end
end

function OnConstructed(oEngineer, oJustBuilt)
    --WARNING: This doesnt seem to trigger for the ACU; it does trigger when untis are constructed by a factory

    --NOTE: This is called every time an engineer stops building a unit whose fractioncomplete is 100%, so can be called multiple times
    if M28Utilities.bM28AIInGame then
        --NonM28 specific - dont set the M28OnConstructionCalled for this, so need to  be careful that any code here will not be run repeatedly
        --LOG('OnConstructed for unit '..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt))
        M28Orders.ClearAnyRepairingUnits(oJustBuilt)

        if EntityCategoryContains(categories.STRUCTURE, oJustBuilt.UnitId) then
            --If a building has just build a building, then make sure all M28 are aware of it (since a player would be)
            if EntityCategoryContains(categories.STRUCTURE, oEngineer.UnitId) then
                local tTeamsUpdated = {}
                for iBrain, oBrain in M28Team.tTeamData[oEngineer:GetAIBrain().M28Team][M28Team.subreftoEnemyBrains] do
                    if oBrain.M28AI and not(tTeamsUpdated[oBrain.M28Team]) then
                        tTeamsUpdated[oBrain.M28Team] = true
                        M28Team.AssignUnitToLandZoneOrPond(oBrain, oJustBuilt, false, false, true)
                    end
                end
            end
            --Also update the name
            if M28Config.M28ShowUnitNames then
                local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oJustBuilt:GetPosition(), false)
                local sPlateauAndZoneDesc = ':P='..(iPlateau or 0)..'LZ='..(iLandZone or 0)

                oJustBuilt:SetCustomName(oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..sPlateauAndZoneDesc..': Built')
            end

            --If we have just built a radar then update radar logic
            if EntityCategoryContains(M28UnitInfo.refCategoryRadar, oJustBuilt.UnitId) then
                ForkThread(M28Land.UpdateLandZoneIntelForRadar, oJustBuilt)
            end

            --Track non-M28AI wall segments
            if EntityCategoryContains(M28UnitInfo.refCategoryWall, oJustBuilt.UnitId) and not(oJustBuilt:GetAIBrain().M28AI) then
                M28Land.TrackWallSegment(oJustBuilt, true)
            end
        end

        --M28 specific
        if oJustBuilt:GetAIBrain().M28AI and not(oJustBuilt.M28OnConstructedCalled) then
            local sFunctionRef = 'OnConstructed'
            local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            oJustBuilt.M28OnConstructedCalled = true
            if bDebugMessages == true then LOG(sFunctionRef..': oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' has just built '..oJustBuilt.UnitId) end

            --Logic based on the unit that was just built:

            --Check build locations for units not built at a factory
            if EntityCategoryContains(categories.STRUCTURE + categories.EXPERIMENTAL, oJustBuilt.UnitId) then
                M28Engineer.CheckIfBuildableLocationsNearPositionStillValid(oJustBuilt:GetAIBrain(), oJustBuilt:GetPosition())
                M28Economy.UpdateHighestFactoryTechLevelForBuiltUnit(oJustBuilt) --includes a check to see if are dealing with a factory HQ
                if EntityCategoryContains(M28UnitInfo.refCategoryMex, oJustBuilt.UnitId) then
                    ForkThread(M28Economy.UpdateLandZoneM28MexByTechCount, oJustBuilt, false, 10)
                    --If have storage owned by M28 on same team by this mex, gift it over
                    --All mexes - on construction check if we have allied M28 mass storage nearby (e.g. we have rebuilt on a mex that they used to have) and if so then have that M28 gift over their mass storage
                    local tMexLocation = oJustBuilt:GetPosition()
                    local rSearchRectangle = M28Utilities.GetRectAroundLocation(tMexLocation, 2.749)
                    local tNearbyUnits = GetUnitsInRect(rSearchRectangle) --at 1.5 end up with storage thats not adjacent being gifted in some cases but not in others; at 1 none of it gets gifted; the mass storage should be exactly 2 from the mex; however even at 2.1, 2.25 and 2.499 had cases where the mex wasnt identified so will try 2.75 since distances can vary/be snapped to the nearest 0.5 I think
                    if bDebugMessages == true then LOG(sFunctionRef..': Storage gifting where built mex - oJustBuilt='..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; owner='..oJustBuilt:GetAIBrain().Nickname..'; is tNearbyUnits empty='..tostring(M28Utilities.IsTableEmpty(tNearbyUnits))) end
                    if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                        local tNearbyStorage = EntityCategoryFilterDown(M28UnitInfo.refCategoryMassStorage, tNearbyUnits)
                        if M28Utilities.IsTableEmpty(tNearbyStorage) == false then
                            for iUnit, oUnit in tNearbyStorage do
                                if bDebugMessages == true then LOG(sFunctionRef..': About to transfer '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' from brain '..oUnit:GetAIBrain().Nickname..' to '..oJustBuilt:GetAIBrain().Nickname..'; Dist from unit to tMexLocation='..M28Utilities.GetDistanceBetweenPositions(tMexLocation, oUnit:GetPosition())) end
                                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tMexLocation) <= 2.25 then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will try and gift the storage to the player that built the mex') end
                                    M28Team.TransferUnitsToPlayer({oUnit}, oJustBuilt:GetAIBrain():GetArmyIndex(), false)
                                end
                            end
                        end
                    end
                    --Update part built t1 mex tracking
                    if EntityCategoryContains(M28UnitInfo.refCategoryT1Mex, oJustBuilt.UnitId) then
                        M28Engineer.UpdatePartBuiltListForCompletedMex(oJustBuilt)
                    end
                elseif EntityCategoryContains(M28UnitInfo.refCategoryMassStorage, oJustBuilt.UnitId) then
                    --If just built a mass storage but we dont own the mex it is adjacent to, then gift the storage
                    local rSearchRectangle = M28Utilities.GetRectAroundLocation(oJustBuilt:GetPosition(), 2.749)
                    local tNearbyUnits = GetUnitsInRect(rSearchRectangle) --at 1.5 end up with storage thats not adjacent being gifted in some cases but not in others; at 1 none of it gets gifted; the mass storage should be exactly 2 from the mex; however even at 2.1, 2.25 and 2.499 had cases where the mex wasnt identified so will try 2.75 since distances can vary/be snapped to the nearest 0.5 I think
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Storage gifting where built storage - oJustBuilt='..oJustBuilt.UnitId..M28UnitInfo.GetUnitLifetimeCount(oJustBuilt)..'; owner='..oJustBuilt:GetAIBrain().Nickname..'; is tNearbyUnits empty='..tostring(M28Utilities.IsTableEmpty(tNearbyUnits)))
                        if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                            for iUnit, oUnit in tNearbyUnits do
                                LOG(sFunctionRef..': iUnit '..iUnit..' in tNearbyUnits='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; owner='..oUnit:GetAIBrain().Nickname)
                            end
                        end
                    end
                    if M28Utilities.IsTableEmpty(tNearbyUnits) == false then
                        local tNearbyMexes = EntityCategoryFilterDown(M28UnitInfo.refCategoryMex, tNearbyUnits)
                        if M28Utilities.IsTableEmpty(tNearbyMexes) == false then
                            local bHaveMexWeOwnNearby = false
                            local oBrainToTransferToIfWeOwnNoMexes
                            for iUnit, oUnit in tNearbyMexes do
                                if bDebugMessages == true then LOG(sFunctionRef..': Considering nearby unit oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' owned by '..oUnit:GetAIBrain().Nickname) end
                                if oUnit:GetAIBrain() == oJustBuilt:GetAIBrain() then
                                    bHaveMexWeOwnNearby = true
                                elseif oUnit:GetAIBrain().M28Team == oJustBuilt:GetAIBrain().M28Team then
                                    oBrainToTransferToIfWeOwnNoMexes = oUnit:GetAIBrain()
                                end
                            end
                            if not(bHaveMexWeOwnNearby) and oBrainToTransferToIfWeOwnNoMexes then
                                if bDebugMessages == true then LOG(sFunctionRef..': Will try and gift the storage to the player who owns the mex already there') end
                                M28Team.TransferUnitsToPlayer({oJustBuilt}, oBrainToTransferToIfWeOwnNoMexes:GetArmyIndex(), false)
                            end
                        end
                    end
                elseif EntityCategoryContains(M28UnitInfo.refCategoryEnergyStorage, oJustBuilt.UnitId) then
                    M28Team.TeamEconomyRefresh(oJustBuilt:GetAIBrain().M28Team)
                    M28Team.ConsiderGiftingStorageToTeammate(oJustBuilt)
                end
            elseif EntityCategoryContains(M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryIndirectT3, oJustBuilt.UnitId) then
                if not(M28Team.tTeamData[oJustBuilt:GetAIBrain().M28Team][M28Team.refbBuiltLotsOfT3Combat]) then
                    if M28Conditions.GetTeamLifetimeBuildCount(oJustBuilt:GetAIBrain().M28Team, M28UnitInfo.refCategoryLandCombat * categories.TECH3 + M28UnitInfo.refCategoryIndirectT3) >= 30 then
                        M28Team.tTeamData[oJustBuilt:GetAIBrain().M28Team][M28Team.refbBuiltLotsOfT3Combat] = true
                    end
                end
            end

            --Update economy tracking (this function will check if it is an economic unit as part of it)
            M28Economy.UpdateGrossIncomeForUnit(oJustBuilt)
            if EntityCategoryContains(M28UnitInfo.refCategoryScathis, oJustBuilt.UnitId) then
                table.insert(M28Engineer.tAllScathis, oJustBuilt)
            end

            --Logic based on the engineer
            if EntityCategoryContains(categories.COMMAND, oEngineer.UnitId) then
                M28ACU.GetACUOrder(oEngineer:GetAIBrain(), oEngineer)
            elseif EntityCategoryContains(M28UnitInfo.refCategoryFactory, oEngineer.UnitId) then
                if bDebugMessages == true then LOG(sFunctionRef..': A factory has just built a unit so will get the next order for the factory') end
                ForkThread(M28Factory.DecideAndBuildUnitForFactory, oEngineer:GetAIBrain(), oEngineer)
            end

            --Logic based on the type of unit built
            if EntityCategoryContains(M28UnitInfo.refCategoryFactory, oJustBuilt.UnitId) then
                if bDebugMessages == true then LOG(sFunctionRef..': A factory has just been built so will get the next order for the factory') end
                ForkThread(M28Factory.DecideAndBuildUnitForFactory, oJustBuilt:GetAIBrain(), oJustBuilt)
                if EntityCategoryContains(M28UnitInfo.refCategoryAllHQFactories, oJustBuilt.UnitId) then
                    oJustBuilt:GetAIBrain()[M28Economy.refiOurHighestFactoryTechLevel] = math.max(M28UnitInfo.GetUnitTechLevel(oJustBuilt), oJustBuilt:GetAIBrain()[M28Economy.refiOurHighestFactoryTechLevel])
                end
            end

            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        elseif not(oJustBuilt:GetAIBrain().M28AI) then
            --If build an M28 unit then will record its plateau and LZ; so for non-M28 AI also want to do this so we have a backup for pathfinding if dont already have something
            if M28Utilities.IsTableEmpty(oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) and not(EntityCategoryContains(categories.AIR, oJustBuilt.UnitId)) then
                local iPlateau, iLandZone = M28Map.GetPathingOverridePlateauAndLandZone(oJustBuilt:GetPosition(), true, oJustBuilt)
                if not(oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) then oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] = {} end
                oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][oJustBuilt:GetAIBrain().M28Team] = {iPlateau, iLandZone}
                --[[if (iPlateau or 0) > 0 then
                    if not(oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) then oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] = {} end
                    oJustBuilt[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][oJustBuilt:GetAIBrain().M28Team] = {iPlateau, iLandZone}
                end--]]
            end

        end
        --Upgrade tracking (even if have run this already)
        if oEngineer.GetAIBrain and oEngineer:GetAIBrain().M28AI and EntityCategoryContains(categories.STRUCTURE, oEngineer.UnitId) and EntityCategoryContains(categories.STRUCTURE, oJustBuilt.UnitId) then
            M28Team.UpdateUpgradeTrackingOfUnit(oJustBuilt, true)
        end
    end
end

function OnReclaimStarted(oEngineer, oReclaim)
    if M28Utilities.bM28AIInGame then
        local sFunctionRef = 'OnReclaimStarted'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnReclaimFinished(oEngineer, oReclaim)
    if M28Utilities.bM28AIInGame then
        --Update the segment that the reclaim is at, or the engineer if hte reclaim doesnt have one
        local sFunctionRef = 'OnReclaimFinished'
        local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

        if bDebugMessages == true then LOG(sFunctionRef..': oEngineer '..oEngineer.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEngineer)..' has just finished reclaiming, gametime='..GetGameTimeSeconds()) end
        if oReclaim and oReclaim.CachePosition then
            --LOG('OnReclaimFinished temp log - remove once confirmed this works - about to update reclaim data near location='..repru(oReclaim.CachePosition))
            ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, oReclaim.CachePosition, 0)
        else
            --LOG('OnReclaimFinished alt temp log - couldnt find reclaim position so will use engineer position')
            ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, oEngineer:GetPosition(), 1)
        end

        --Was the engineer reclaiming an area? if so check if still nearby reclaim
        if oEngineer[M28Engineer.refiAssignedAction] == M28Engineer.refActionReclaimArea then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oEngineer:GetPosition(), true, oEngineer)
            if (iLandZone or 0) > 0 then
                local iTeam =  oEngineer:GetAIBrain().M28Team
                local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
                M28Engineer.GetEngineerToReclaimNearbyArea(oEngineer, tLZTeamData, iPlateau, iLandZone, M28Conditions.WantToReclaimEnergyNotMass(iTeam, iPlateau, iLandZone), false)
            end
        elseif M28Utilities.IsTableEmpty(oReclaim[M28Engineer.reftUnitsReclaimingUs]) == false then
            local tEngineersToClear = {}
            for iEngineer, oEngineer in oReclaim[M28Engineer.reftUnitsReclaimingUs] do
                if M28UnitInfo.IsUnitValid(oEngineer) then
                    table.insert(tEngineersToClear, oEngineer)
                end
            end
            for iEngineer, oEngineer in tEngineersToClear do
                M28Orders.IssueTrackedClearCommands(oEngineer)
            end
        end

        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function OnCreateWreck(tPosition, iMass, iEnergy)
    --Dont check if M28brains are in game yet as can be called at start of game before we have recorded any aiBrain

    if not(M28Map.bReclaimManagerActive) then
        if GetGameTimeSeconds() >= 20 then return nil
        else
            local iWaitCount = 0
            while not(M28Map.bReclaimManagerActive) do
                WaitTicks(1)
                iWaitCount = iWaitCount + 1
                if iWaitCount >= 20 then M28Utilities.ErrorHandler('Map setup not complete') break end
            end
        end
    end
    --[[if iMass >= 35 then
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tPosition)
        local iReclaimSegmentX, iReclaimSegmentZ = M28Map.GetReclaimSegmentsFromLocation(tPosition)
        LOG('OnCreateWreck: Time='..GetGameTimeSeconds()..'; iMass='..iMass..'; tPosition='..repru(tPosition)..'; will record we want to update reclaim at this location, iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; iReclaimSegmentX='..iReclaimSegmentX..'; iReclaimSegmentZ='..iReclaimSegmentZ)
    end--]]
    ForkThread(M28Map.RecordThatWeWantToUpdateReclaimAtLocation, tPosition, 0)
end

function OnTransportLoad(oUnit, oTransport, bone)

end

function OnTransportUnload(oUnit, oTransport, bone)


end

function OnDetectedBy(oUnitDetected, iBrainIndex)
    --Appears to be called when iBrainIndex detects oUnitDetected, triggers for teammate units but not own units?

    --For now used to make sure we have up to date unit info
    if M28Utilities.bM28AIInGame then
        local aiBrain = ArmyBrains[iBrainIndex]
        --LOG('OnDetectedBy: UnitID='..oUnitDetected.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitDetected)..'; tAllAIBrainsByArmyIndex[iBrainIndex] name='..M28Overseer.tAllAIBrainsByArmyIndex[iBrainIndex].Nickname..'; ArmyBrains nickname='..ArmyBrains[iBrainIndex].Nickname..'; Does entity contain navy='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy, oUnitDetected.UnitId))..'; aiBrain.M28AI='..tostring((aiBrain.M28AI or false)))
        M28Team.ConsiderAssigningUnitToZoneForBrain(aiBrain, oUnitDetected) --This function includes check of whether this is an M28 brain, and updates last known position
        if aiBrain.M28AI then
            --Update highest enemy ground unti health
            if EntityCategoryContains(M28UnitInfo.refCategoryLandCombat - categories.COMMAND - categories.SUBCOMMANDER, oUnitDetected.UnitId) then
                local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnitDetected)
                local iMaxHealth = oUnitDetected:GetMaxHealth() + iMaxShield
                if iMaxHealth > M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyHighestMobileLandHealth] then
                    M28Team.tTeamData[aiBrain.M28Team][M28Team.refiEnemyHighestMobileLandHealth] = iMaxHealth
                end
            end
        end
    end
end

function OnCreate(oUnit)
    if M28Utilities.bM28AIInGame and M28UnitInfo.IsUnitValid(oUnit) then
        if not(M28Map.bMapLandSetupComplete) then --Start of game ACU creation happens before we have setup the map
            while not(M28Map.bMapLandSetupComplete) do
                WaitTicks(1)
            end
            WaitTicks(1)
            if not(M28UnitInfo.IsUnitValid(oUnit)) then return nil end
        end
        M28Team.ConsiderAssigningUnitToZoneForBrain(oUnit:GetAIBrain(), oUnit) --This function includes check of whether this is an M28 brain

        --All units (not just M28 specific):
        M28UnitInfo.RecordUnitRange(oUnit)
        if M28Config.M28ShowEnemyUnitNames then oUnit:SetCustomName(oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)) end
        --Units with upgrade - update the base threat value
        if EntityCategoryContains(categories.COMMAND + categories.SUBCOMMANDER, oUnit.UnitId) then M28UnitInfo.UpdateUnitCombatMassRatingForUpgrades(oUnit) end --Will check if unit has enhancements as part of this

        --Hydro resource locations
        if EntityCategoryContains(M28UnitInfo.refCategoryHydro, oUnit.UnitId) then
            --Treat location as no longer having no buildings on it
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
            if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroUnbuiltLocations]) == false then
                --LOG('About to loop through hydro locations; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; reprs='..reprs(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroUnbuiltLocations]))
                for iHydroLocation, tHydroLocation in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroUnbuiltLocations] do
                    if M28Utilities.GetDistanceBetweenPositions(tHydroLocation, oUnit:GetPosition()) <= 2 then
                        table.remove(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroUnbuiltLocations], iHydroLocation)
                        break
                    end
                end
            end
        elseif EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) then
            --Treat location as no longer having no buildings on it (if we were previously)
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
            if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexUnbuiltLocations]) == false then
                LOG('About to loop through Mex locations; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; reprs='..reprs(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexUnbuiltLocations]))
                for iMexLocation, tMexLocation in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexUnbuiltLocations] do
                    --Old code commented out below caused issues on maps like sludge:
                    --if M28Utilities.GetDistanceBetweenPositions(tMexLocation, oUnit:GetPosition()) <= 2 then
                    --Replaced with the following:
                    if math.abs(tMexLocation[1] - oUnit:GetPosition()[1]) < 1 and math.abs(tMexLocation[3] - oUnit:GetPosition()[3]) < 1 then
                        table.remove(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexUnbuiltLocations], iMexLocation)
                        break
                    end
                end
            end
        end

        --M28 specific: Cover units transferred to us or cheated in or presumably that we have captured
        if oUnit:GetAIBrain().M28AI and oUnit:GetFractionComplete() == 1 then
            M28Economy.UpdateHighestFactoryTechLevelForBuiltUnit(oUnit) --this includes a check to see if are dealing with a factory HQ
            M28Economy.UpdateGrossIncomeForUnit(oUnit, false) --This both includes a check of the unit type, and cehcks we havent already recorded
            if EntityCategoryContains(M28UnitInfo.refCategoryMex, oUnit.UnitId) and not(oUnit.M28OnConstructedCalled) then ForkThread(M28Economy.UpdateLandZoneM28MexByTechCount, oUnit) end
        end
    end
end

function OnCreateBrain(aiBrain, planName, bIsHuman)
    if not(aiBrain['M28BrainSetupRun']) then
        if M28Config.M28RunProfiling then ForkThread(M28Profiler.ProfilerActualTimePerTick) end
        aiBrain['M28BrainSetupRun'] = true

        if bIsHuman == nil then
            if aiBrain.BrainType == "AI" or not(aiBrain.BrainType) or string.find(aiBrain.BrainType, "AI") then bIsHuman = false else bIsHuman = true end
        end

        --Logic to run for all brains
        local iStartPositionX, iStartPositionZ = aiBrain:GetArmyStartPos()
        M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()] = {iStartPositionX, GetSurfaceHeight(iStartPositionX, iStartPositionZ), iStartPositionZ}
        M28Overseer.tAllAIBrainsByArmyIndex[aiBrain:GetArmyIndex()] = aiBrain

        if bIsHuman then
            LOG('Human player brain '..aiBrain.Nickname..' created; Index='..aiBrain:GetArmyIndex()..'; start position='..repru(M28Map.PlayerStartPoints[aiBrain:GetArmyIndex()]))
        else
            --Logic to run just for M28AI
            LOG('OnCreateBrain hook for ai with personality '..ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality)

            if ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == 'm28ai' or ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality == 'm28aicheat' then
                aiBrain.M28AI = true
                LOG('M28 brain created')

                --Copy of parts of aiBrain OnCreateAI that still want to retain
                aiBrain:CreateBrainShared(planName)
                --aiBrain:InitializeEconomyState()
                aiBrain.BrainType = 'AI'
                local per = ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality
                local cheatPos = string.find(per, 'cheat')
                if cheatPos then

                    local AIUtils = import('/lua/ai/aiutilities.lua')
                    AIUtils.SetupCheat(aiBrain, true)
                    ScenarioInfo.ArmySetup[aiBrain.Name].AIPersonality = string.sub(per, 1, cheatPos - 1)
                end

                --M28AIBrainClass.OnCreateAI(aiBrain, planName)
                ForkThread(M28Overseer.M28BrainCreated, aiBrain)
            end
        end
    end
end