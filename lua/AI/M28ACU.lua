---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 02/12/2022 08:29
---
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Micro = import('/mods/M28AI/lua/AI/M28Micro.lua')

--ACU specific variables against the ACU
refbDoingInitialBuildOrder = 'M28ACUInitialBO'
reftPreferredUpgrades = 'M28ACUPreferredUpgrades' --table of the enhancement IDs in the order that we want to get them (which is updated to remove any upgrades we already have as and when we get them)
refiUpgradeCount = 'M28ACUUpgradeCount' --Number of upgrades the ACU has
refiTimeLastWantedToRun = 'M28ACUTimeLastWantedToRun' --gametimeseconds that last wanted to run

function ACUBuildUnit(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearchForAdjacencyAndUnderConstruction, iMaxAreaToSearchForBuildLocation, iOptionalAdjacencyCategory, iOptionalCategoryBuiltUnitCanBuild)
    local sFunctionRef = 'ACUBuildUnit'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Do we have a nearby unit of the type we want to build under construction?
    local tNearbyUnitsOfCategoryToBuild = aiBrain:GetUnitsAroundPoint(iCategoryToBuild, oACU:GetPosition(), iMaxAreaToSearchForAdjacencyAndUnderConstruction, 'Ally')
    local oNearestPartComplete

    if M28Utilities.IsTableEmpty(tNearbyUnitsOfCategoryToBuild) == false then
        local iClosestUnit = 10000
        local iCurDist
        for _, oUnit in tNearbyUnitsOfCategoryToBuild do
            if oUnit:GetFractionComplete() < 1 then
                iCurDist = M28Utilities.GetTravelDistanceBetweenPositions(oUnit:GetPosition(), oACU:GetPosition(), M28Map.refPathingTypeLand)
                if iCurDist < iClosestUnit then
                    oNearestPartComplete = oUnit
                    iClosestUnit = iCurDist
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Is tNearbyUnitsOfCategoryToBuild empty='..tostring(tNearbyUnitsOfCategoryToBuild)..'; Is oNearestPartComplete valid='..tostring(M28UnitInfo.IsUnitValid(oNearestPartComplete))) end
    if oNearestPartComplete then
        if bDebugMessages == true then LOG(sFunctionRef..': Will assist part complete building='..oNearestPartComplete.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestPartComplete)) end
        M28Orders.IssueTrackedGuard(oACU, oNearestPartComplete, false)
    else
        --No nearby under construction factory, so build one
        --GetBlueprintAndLocationToBuild(aiBrain, oEngineer, iCategoryToBuild, iMaxAreaToSearch, iCatToBuildBy,         tAlternativePositionToLookFrom, bLookForQueuedBuildings, oUnitToBuildBy, iOptionalCategoryForStructureToBuild, bBuildCheapestStructure)
        local sBlueprint, tBuildLocation = M28Engineer.GetBlueprintAndLocationToBuild(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearchForAdjacencyAndUnderConstruction, iOptionalAdjacencyCategory, nil,                           false,                      nil,         iOptionalCategoryBuiltUnitCanBuild, nil)
        if not(tBuildLocation) then sBlueprint, tBuildLocation = M28Engineer.GetBlueprintAndLocationToBuild(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearchForBuildLocation, nil, nil,                           false,                      nil,         iOptionalCategoryBuiltUnitCanBuild, nil) end
        if bDebugMessages == true then
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oACU:GetPosition(), true, oACU)
            LOG(sFunctionRef..': Blueprint to build='..(sBlueprint or 'nil')..'; tBuildLocation='..repru(tBuildLocation)..'; ACU plateau and land zone based on cur position='..iPlateau..'; iLandZone='..(iLandZone or 'nil')..'; iMaxAreaToSearchForBuildLocation='..(iMaxAreaToSearchForBuildLocation or 'nil')..'; was iOptionalAdjacencyCategory nil='..tostring(iOptionalAdjacencyCategory == nil))
        end
        if sBlueprint and tBuildLocation then
            --Move to the target and then build on it
            local tMoveTarget = M28Engineer.GetLocationToMoveForConstruction(oACU, tBuildLocation, sBlueprint)
            if tMoveTarget then
                --IssueTrackedMoveAndBuild(oUnit, tBuildLocation, sOrderBlueprint, tMoveTarget, iDistanceToReorderMoveTarget, bAddToExistingQueue)
                M28Orders.IssueTrackedMoveAndBuild(oACU, tBuildLocation, sBlueprint, tMoveTarget, 2, false)
            else
                M28Orders.IssueTrackedBuild(oACU, tBuildLocation, sBlueprint, false)
            end
        else
            M28Orders.UpdateRecordedOrders(oACU)
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ACUActionBuildFactory(aiBrain, oACU)
    local sFunctionRef = 'ACUActionBuildFactory'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iMaxAreaToSearch = 35
    local iCategoryToBuild = M28UnitInfo.refCategoryLandFactory
    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryFactory) >= 2 and iCategoryToBuild == M28UnitInfo.refCategoryLandFactory then
        iMaxAreaToSearch = 20
    end
    ACUBuildUnit(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearch, iMaxAreaToSearch * 2, M28UnitInfo.refCategoryMex, M28UnitInfo.refCategoryEngineer)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ACUActionAssistHydro(aiBrain, oACU)
    --If have hydro under construction then assist the hydro if it's within build range; if not under construciton or out of build range then move towards it
    local sFunctionRef = 'ACUActionAssistHydro'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Redundancy - make sure we have hydros in this LZ:
    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oACU:GetPosition(), true, oACU)
    if bDebugMessages == true then LOG(sFunctionRef..': Do we have hydro loations in iPlateau '..iPlateau..'; iLZ='..iLandZone..': Table empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroLocations]))) end
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroLocations]) == false then
        local tNearestHydro
        local iNearestHydro = 10000
        local iCurDist
        local iBuildRange = oACU:GetBlueprint().Economy.MaxBuildDistance
        local iMinRangeToAssist = iBuildRange + 10
        for iHydro, tHydro in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroLocations] do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tHydro, oACU:GetPosition())
            if iCurDist < iNearestHydro then iNearestHydro = iCurDist tNearestHydro = tHydro end
        end
        --If we are in range of a hydro then assist it (or wait until construction is started)
        if bDebugMessages == true then LOG(sFunctionRef..': Checking if have hydro near enough to consider mvoing to and assisting, iNearestHydro='..iNearestHydro..'; iMinRangeToAssist='..iMinRangeToAssist) end
        if iNearestHydro < iMinRangeToAssist then
            local tUnderConstructionHydro = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryHydro, tNearestHydro, 5, 'Ally')
            local oUnderConstructionHydro
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of hydros around nearest hydro point empty='..tostring(M28Utilities.IsTableEmpty(tUnderConstructionHydro))) end
            if M28Utilities.IsTableEmpty(tUnderConstructionHydro) == false then
                for iHydro, oHydro in tUnderConstructionHydro do
                    if oHydro:GetFractionComplete() < 1 then
                        oUnderConstructionHydro = oHydro
                        break
                    end
                end
            end
            if oUnderConstructionHydro then
                M28Orders.IssueTrackedRepair(oACU, oUnderConstructionHydro, false, 'RH')
            else
                oACU['M28BOHydroWait'] = ( oACU['M28BOHydroWait'] or 0) + 1
                if  oACU['M28BOHydroWait'] >= 20 then
                    ACUActionBuildPower(aiBrain, oACU)
                else
                    --Stay where we are as maybe we are waiting for an engi to start construction
                    M28Orders.IssueTrackedMove(oACU, oACU:GetPosition(), 3, false, 'W4C')
                end
            end
        else
            --Move to be near hydro
            local tLocationNearHydro = M28Engineer.GetLocationToMoveForConstruction(oACU, tNearestHydro, 'ueb1102', -0.5, false)
            if tLocationNearHydro then
                M28Orders.IssueTrackedMove(oACU, tLocationNearHydro, 0.5, false, 'M2NH')
            else
                M28Orders.IssueTrackedMove(oACU, tNearestHydro, 0.5, false, 'M2H')
            end
        end
    else
        M28Utilities.ErrorHandler('Trying to buidl hydro when none nearby')
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ACUActionBuildPower(aiBrain, oACU)
    local sFunctionRef = 'ACUActionBuildPower'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCategoryToBuild = M28UnitInfo.refCategoryPower
    local iMaxAreaToSearch = 16
    local iOptionalAdjacencyCategory
    if aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryAirFactory) > 0 then iOptionalAdjacencyCategory = M28UnitInfo.refCategoryAirFactory
    elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] <= 11 then iOptionalAdjacencyCategory = M28UnitInfo.refCategoryLandFactory
    end
    if bDebugMessages == true then LOG(sFunctionRef..': About to tell ACU to build power; is optional adjacency category nil='..tostring(iOptionalAdjacencyCategory == nil)) end
    ACUBuildUnit(aiBrain, oACU, iCategoryToBuild, iMaxAreaToSearch, iMaxAreaToSearch * 3, iOptionalAdjacencyCategory, nil)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ACUActionBuildMex(aiBrain, oACU, iAreaToSearchOverride)
    local sFunctionRef = 'ACUActionBuildMex'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local iMaxAreaToSearch = iAreaToSearchOverride
    --Increase search range if still doing initial build order, as this suggests we have mexes in our initial land zone that we havent built on yet
    if not(iMaxAreaToSearch) then
        if oACU[refbDoingInitialBuildOrder] then
            if aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 12 then iMaxAreaToSearch = 50
            elseif aiBrain[M28Economy.refiGrossMassBaseIncome] < 6 then iMaxAreaToSearch = 30
            end
        else
            iMaxAreaToSearch = 20
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': About to tell ACU to build a mex, iMaxAreaToSearch='..iMaxAreaToSearch) end
    ACUBuildUnit(aiBrain, oACU, M28UnitInfo.refCategoryMex, iMaxAreaToSearch, iMaxAreaToSearch * 2, nil, nil)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetACUEarlyGameOrders(aiBrain, oACU)
    local sFunctionRef = 'GetACUEarlyGameOrders'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Are we already building something?
    if bDebugMessages == true then LOG(sFunctionRef..': ACU unit state='..M28UnitInfo.GetUnitState(oACU)) end
    if not(oACU:IsUnitState('Building')) then
        local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oACU:GetPosition(), true, oACU)


        --Do we want to build a mex, hydro or factory?
        if bDebugMessages == true then LOG(sFunctionRef..': Current land factories='..aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory)..'; Gross energy income='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; Gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]) end
        local iMinEnergyPerTickWanted = 14 --i.e. 6 T1 PGens given ACU gives 2 E
        local iCurLandFactories = aiBrain:GetCurrentUnits(M28UnitInfo.refCategoryLandFactory)
        if iCurLandFactories == 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': Want ACU to build land factory') end
            ACUActionBuildFactory(aiBrain, oACU)
        elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] <= iMinEnergyPerTickWanted then

            --Do we want to build a hydro (so get mexes first then hydro) or build pgen?

            if bDebugMessages == true then LOG(sFunctionRef..': Will adjust build order depending on if have hydro nearby. Is table of land zone hydros empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroLocations]))) end
            if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroLocations]) then
                --Per discord gameplay and training pinned build order for going land facs with no hydro:
                --ACU:      Landfac - 2 PG - 2 Mex - 1 PG - 2 Mex - 3 PG - Landfac - PG - Landfac
                if bDebugMessages == true then LOG(sFunctionRef..': No hydro locations so will build power or mex depending on income') end
                if aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 6 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Want to build initial PGens') end
                    ACUActionBuildPower(aiBrain, oACU)
                else
                    local iMexInLandZone = 0
                    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]) == false then iMexInLandZone = table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]) end
                    if bDebugMessages == true then LOG(sFunctionRef..': Deciding on ACU action for where no hydro nearby, gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; Gross energy income='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]..'; iMexInLandZone='..iMexInLandZone..'; iMinEnergyPerTickWanted='..iMinEnergyPerTickWanted..'; iCurLandFactories='..iCurLandFactories) end
                    if aiBrain[M28Economy.refiGrossMassBaseIncome] < math.min(2, iMexInLandZone) * 0.2 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want at least 2 mexes') end
                        ACUActionBuildMex(aiBrain, oACU)

                    elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 8 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want at least 4 PGens') end
                        ACUActionBuildPower(aiBrain, oACU)
                    elseif aiBrain[M28Economy.refiGrossMassBaseIncome] < math.min(4, iMexInLandZone) * 0.2 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want up to 4 mexes') end
                        ACUActionBuildMex(aiBrain, oACU)
                    elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] < iMinEnergyPerTickWanted then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want basic level of power') end
                        ACUActionBuildPower(aiBrain, oACU)
                    elseif iCurLandFactories < 2 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want 2 land factories') end
                        ACUActionBuildFactory(aiBrain, oACU)
                    elseif aiBrain[M28Economy.refiGrossMassBaseIncome] < iMexInLandZone * 0.2 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Want to build on every mex in land zone') end
                        ACUActionBuildMex(aiBrain, oACU)
                    else
                        --No more actions so abort initial BO
                        oACU[refbDoingInitialBuildOrder] = false
                    end
                end

                --Redundancy if failed to get orer from the above
                if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) and oACU[refbDoingInitialBuildOrder] then
                    --No hydro nearby - try building power; then try building mex; then cancel initial build order
                    ACUActionBuildMex(aiBrain, oACU)
                    if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) then
                        ACUActionBuildPower(aiBrain, oACU)
                        if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) then
                            oACU[refbDoingInitialBuildOrder] = false
                        end
                    end
                end
            else --Have a hydro so get more mexes initially
                --Max mex to build
                local iMexInLandZone = 0
                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]) == false then iMexInLandZone = table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]) end
                if bDebugMessages == true then LOG(sFunctionRef..': Hydro is nearby, Gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; iMexInLandZone='..iMexInLandZone..'; Gross base energy income='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]) end
                if aiBrain[M28Economy.refiGrossMassBaseIncome] < math.min(4, iMexInLandZone) * 0.2 then
                    if bDebugMessages == true then LOG(sFunctionRef..': We ahve mexes in land zone and we havent built on all of them so will build a mex') end
                    ACUActionBuildMex(aiBrain, oACU)
                elseif aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 10 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Will try to assist a hydro nearby') end
                    ACUActionAssistHydro(aiBrain, oACU)
                else
                    --Have base level of power suggesting already have hydro
                    if bDebugMessages == true then LOG(sFunctionRef..': Want more power to reach a base level') end
                    ACUActionBuildPower(aiBrain, oACU)
                end

                --Redundancy if fail to get order from above
                if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) and oACU[refbDoingInitialBuildOrder] then
                    --Is it just that we want to assist a hydro and engineers havent started one yet? If so then check if we have an engineer assigned to build one, and check the game time
                    if GetGameTimeSeconds() <= 180 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] < 10 and M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZHydroLocations]) == false then
                        ACUActionAssistHydro(aiBrain, oACU)
                        if bDebugMessages == true then LOG(sFunctionRef..': Assuming we are waiting for an engi to start on building a hydro, or we have no nearby mexes to our ACU') end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Failed to get order from above so will resort to backup logic') end
                        --No hydro nearby - try building power; then try building mex; then cancel initial build order
                        ACUActionBuildMex(aiBrain, oACU)
                        if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) then
                            ACUActionAssistHydro(aiBrain, oACU)
                            if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) then
                                ACUActionBuildPower(aiBrain, oACU)
                                if M28Utilities.IsTableEmpty(oACU[M28Orders.reftiLastOrders]) then
                                    oACU[refbDoingInitialBuildOrder] = false
                                end
                            end
                        end
                    end
                end
            end
        else
            --Have initial power and mexes built, get second factory now
            if iCurLandFactories < 2 then
                ACUActionBuildFactory(aiBrain, oACU)
            else
                local iMexInLandZone = 0
                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]) == false then iMexInLandZone = table.getn(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexLocations]) end
                if aiBrain[M28Economy.refiGrossMassBaseIncome] < iMexInLandZone * 0.2 then
                    ACUActionBuildMex(aiBrain, oACU)
                else
                    --Finish the initial BO
                    oACU[refbDoingInitialBuildOrder] = false
                end
            end
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': Are building so wont give any new orders') end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetUpgradePathForACU(oACU)
    --Records the order of upgrades we will want for the ACU
    local sFunctionRef = 'GetUpgradePathForACU'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if EntityCategoryContains(categories.UEF, oACU.UnitId) then
        oACU[reftPreferredUpgrades] = {'HeavyAntiMatterCannon', 'DamageStabilization', 'Shield'}
    elseif EntityCategoryContains(categories.AEON, oACU.UnitId) then
        oACU[reftPreferredUpgrades] = {'CrysalisBeam', 'HeatSink', 'Shield'}
    elseif EntityCategoryContains(categories.CYBRAN, oACU.UnitId) then
        oACU[reftPreferredUpgrades] = {'CoolingUpgrade', 'StealthGenerator'}
    elseif EntityCategoryContains(categories.SERAPHIM, oACU.UnitId) then
        oACU[reftPreferredUpgrades] = {'RateOfFire', 'AdvancedEngineering'}
    end

    --Check all of these are options (in case a mod has changed them)
    if M28Utilities.IsTableEmpty(oACU[reftPreferredUpgrades]) == false then
        local oBP = oACU:GetBlueprint()
        for iUpgradeWanted, sUpgradeWanted in oACU[reftPreferredUpgrades] do
            if M28Utilities.IsTableEmpty(oBP.Enhancements[sUpgradeWanted]) then
                oACU[reftPreferredUpgrades] = {}
                break
            end
        end
    end
    if M28Utilities.IsTableEmpty(oACU[reftPreferredUpgrades]) then
        --Find the cheapest upgrade that boosts either rate of fire or range
        oACU[reftPreferredUpgrades] = {}
        local iLowestMassCost = 1000000
        local sLowestUpgrade
        for sUpgrade, tUpgrade in oACU:GetBlueprint().Enhancements do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering sUpgrade='..sUpgrade..'; tUpgrade='..reprs(tUpgrade)) end
            if tUpgrade.NewMaxRadius or tUpgrade.NewRateOfFire then
                if tUpgrade.BuildCostMass < iLowestMassCost and not(tUpgrade.Prerequisite) then
                    sLowestUpgrade = sUpgrade
                    iLowestMassCost = tUpgrade.BuildCostMass
                    if bDebugMessages == true then LOG(sFunctionRef..': Have a new preferred upgrade '..sUpgrade..'; iLowestMassCost='..iLowestMassCost) end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished considering the cheapest gun improving upgrade, sLowestUpgrade='..(sLowestUpgrade or 'nil')) end
        if sLowestUpgrade then oACU[reftPreferredUpgrades] = {sLowestUpgrade} end
    end

    --Remove any upgrades that we already have
    if M28Utilities.IsTableEmpty(oACU[reftPreferredUpgrades]) == false then
        local iRevisedIndex = 1
        local iTableSize = table.getn(oACU[reftPreferredUpgrades])

        for iOrigIndex=1, iTableSize do
            if oACU[reftPreferredUpgrades][iOrigIndex] then
                if not(oACU:HasEnhancement(oACU[reftPreferredUpgrades][iOrigIndex])) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                    --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                    if (iOrigIndex ~= iRevisedIndex) then
                        oACU[reftPreferredUpgrades][iRevisedIndex] = oACU[reftPreferredUpgrades][iOrigIndex];
                        oACU[reftPreferredUpgrades][iOrigIndex] = nil;
                    end
                    iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                else
                    oACU[reftPreferredUpgrades][iOrigIndex] = nil;
                end
            end
        end
    end
end

function GetACUUpgradeWanted(oACU)
    --Returns nil if cantr find anything
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetACUUpgradeWanted'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local sUpgradeWanted

    --If we were to get an upgrade, what upgrade would it be?
    if not(oACU[reftPreferredUpgrades]) then
        GetUpgradePathForACU(oACU)
    end
    local iTeam = oACU:GetAIBrain().M28Team
    if M28Utilities.IsTableEmpty(oACU[reftPreferredUpgrades]) == false and not(M28Conditions.HaveLowPower(iTeam)) then

        local sPotentialUpgrade = oACU[reftPreferredUpgrades][1]
        if sPotentialUpgrade then
            local tEnhancement = oACU:GetBlueprint().Enhancements[sPotentialUpgrade]
            --Do we have the eco to support the upgrade?
            if bDebugMessages == true then LOG(sFunctionRef..': Considering sPotentialUpgrade='..sPotentialUpgrade..'; for ACU '..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' for brain '..oACU:GetAIBrain().Nickname..'; tEnhancement='..reprs(tEnhancement)) end
            local iBuildRate = oACU:GetBlueprint().Economy.BuildRate
            local iMassCostPerTick = 0.1 * tEnhancement.BuildCostMass / (tEnhancement.BuildTime / iBuildRate)
            local iEnergyCostPerTick = 0.1 * tEnhancement.BuildCostEnergy / (tEnhancement.BuildTime / iBuildRate)
            --Do we have enough gross energy?
            local iActiveACUUpgrades = 0
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingACUs]) == false then iActiveACUUpgrades = table.getn(M28Team.tTeamData[iTeam][M28Team.subreftTeamUpgradingACUs]) end
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we have enough resources to get this upgrade, M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy]..'; Gross mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass]..'; Net energy='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy]..'; Net mass='..M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass]..'; Other active upgrades='..iActiveACUUpgrades..'; Is safe to get upgrade='..tostring(M28Conditions.SafeToUpgradeUnit(oACU))..'; iEnergyCostPerTick='..iEnergyCostPerTick..'; iMassCostPerTick='..iMassCostPerTick) end
            if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 45 * iActiveACUUpgrades + iEnergyCostPerTick * 1.35 then
                --Do we have enough gross mass?
                if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 2.5 * iActiveACUUpgrades * iMassCostPerTick * 2 then
                    --Do we have enough net energy?
                    if (M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossEnergy] >= 100 * iActiveACUUpgrades + iEnergyCostPerTick * 2 and M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= 5) or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetEnergy] >= iEnergyCostPerTick * 0.4 then
                        --Do we have enoguh net mass?
                        if M28Team.tTeamData[iTeam][M28Team.subrefiTeamGrossMass] >= 3.5 * iActiveACUUpgrades * iMassCostPerTick * 3 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamNetMass] >= iMassCostPerTick * 0.4 or M28Team.tTeamData[iTeam][M28Team.subrefiTeamMassStored] >= tEnhancement.BuildCostMass * 0.5 then
                            sUpgradeWanted = sPotentialUpgrade
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return sUpgradeWanted
end

function DoesACUWantToRun(iPlateau, iLandZone, tLZData, tLZTeamData, oACU)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DoesACUWantToRun'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Dont run if in core base
    if bDebugMessages == true then LOG(sFunctionRef..': Is ACU in core base='..tostring(tLZData[M28Map.subrefLZTCoreBase])..' iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; oACU='..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)) end
    if tLZData[M28Map.subrefLZTCoreBase] then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return false
    else
        --Run if on low health or shield
        local iACUThreat = (M28UnitInfo.GetCombatThreatRating({ oACU}, false) or 0)
        if bDebugMessages == true then LOG(sFunctionRef..': iACUThreat='..iACUThreat..'; LZ enemy combat total='..tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal]) end
        if iACUThreat <= 500 or (iACUThreat <= 600 and tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal] >= 80) then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        else
            local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oACU, true)
            if bDebugMessages == true then LOG(sFunctionRef..'; iCurSHield='..iCurShield..'; iMaxShield='..iMaxShield) end
            if iMaxShield > 0 and iCurShield <= (iMaxShield * 0.1) then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return true
            else
                local iHealthPercent = M28UnitInfo.GetUnitHealthPercent(oACU)
                if bDebugMessages == true then LOG(sFunctionRef..': iHealthPercent='..iHealthPercent) end
                if iHealthPercent <= 0.6 or (iHealthPercent <= 0.75 and tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal] >= 80) then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    return true
                else
                    local iEnemyNearbyThreat = (tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal] or 0)
                    local iTeam = oACU:GetAIBrain().M28Team
                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                        for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                            if bDebugMessages == true then LOG(sFunctionRef..': Adding threat for iAdjLZ='..iAdjLZ..' with threat '..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTThreatEnemyCombatTotal]) end
                            iEnemyNearbyThreat = iEnemyNearbyThreat + M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTThreatEnemyCombatTotal]
                        end
                    end
                    if bDebugMessages == true then LOG(sFunctionRef..': iEnemyNearbyThreat='..iEnemyNearbyThreat) end
                    --Run if enemy has a really large threat (regardless of if we think we can beat it)
                    if iEnemyNearbyThreat > math.min(iACUThreat * 2, 3500) then
                        return true
                    else
                        --Run if we dont have enough threat in this LZ to easily beat enemy threat in all adjacent LZs
                        if iACUThreat * 0.5 + (tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] or 0) < iEnemyNearbyThreat or (iACUThreat + tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] < iEnemyNearbyThreat) then
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return true
                        else
                            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                            return false
                        end
                    end
                end
            end
        end
    end
end

function GiveOverchargeOrderIfRelevant(tLZData, tLZTeamData, oACU)
    --Are there enemies in this LZ or adjacent, and do we have the energy to overcharge?
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GiveOverchargeOrderIfRelevant'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; DO we have enemies in this or adjacent LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])..'; Can we use overcharge='..tostring(M28Conditions.CanUnitUseOvercharge(oACU:GetAIBrain(), oACU))) end

    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ]) and M28Conditions.CanUnitUseOvercharge(oACU:GetAIBrain(), oACU) then
        local oUnitToOvercharge = M28Micro.GetOverchargeTarget(tLZData, oACU:GetAIBrain(), oACU)
        if bDebugMessages == true then LOG(sFunctionRef..': Do we have a valid OC target='..tostring(M28UnitInfo.IsUnitValid(oUnitToOvercharge))) end
        if oUnitToOvercharge then
            M28Orders.IssueTrackedOvercharge(oACU, oUnitToOvercharge, false, 'OC', true)
            if bDebugMessages == true then LOG(sFunctionRef..': Have just told ACU '..oACU.UnitId..M28UnitInfo.GetUnitLifetimeCount(oACU)..' owned by '..oACU:GetAIBrain().Nickname..' to overcharge '..oUnitToOvercharge.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnitToOvercharge)) end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function AttackNearestEnemyWithACU(iPlateau, iLandZone, tLZData, tLZTeamData, oACU)
    --Attack move to the nearest enemy if we arent in range of it or retreat if we are in range of it
    local oEnemyToTarget
    local iCurDist
    local iClosestDist = 100000
    local tUnitsToTarget

    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) == false then
        tUnitsToTarget = tLZTeamData[M28Map.reftoNearestDFEnemies]
    elseif M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZTEnemyUnits]) == false then
        tUnitsToTarget = tLZData[M28Map.subrefLZTEnemyUnits]
    else
        tUnitsToTarget = oACU:GetAIBrain():GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure, oACU:GetPosition(), 60, 'Enemy')
    end
    if M28Utilities.IsTableEmpty(tUnitsToTarget) == false then
        for iUnit, oUnit in tUnitsToTarget do
            if M28UnitInfo.IsUnitValid(oUnit) then
                iCurDist = M28Utilities.GetDistanceBetweenPositions(oACU:GetPosition(), oUnit:GetPosition())
                if iCurDist < iClosestDist then
                    iClosestDist = iCurDist
                    oEnemyToTarget = oUnit
                end
            end
        end
        if oEnemyToTarget then
            if oACU[M28UnitInfo.refbLastShotBlocked] then
                --Shot blocked, but we must think we can win the fight or we would be running, so move towards enemy
                M28Orders.IssueTrackedMove(oACU, oEnemyToTarget:GetPosition(), 5, false, 'ACUBl', false)
            elseif iClosestDist + 1.5 <= oACU[M28UnitInfo.refiDFRange]  then
                --Retreat temporarily
                local tRallyPoint = M28Land.GetNearestRallyPoint(tLZData, oACU:GetAIBrain().M28Team, iPlateau, iLandZone, 2)
                M28Orders.IssueTrackedMove(oACU, tRallyPoint, 6, false, 'ACUKit', false)
            else
                --Attack-move towards enemy
                M28Orders.IssueTrackedAggressiveMove(oACU, oEnemyToTarget:GetPosition(), 5, false, 'ACUAM', false)
            end
        end
    end

    if oEnemyToTarget then return true else return false end
end

function ConsiderBuildingMex(tLZData, tLZTeamData, oACU)
    --Do we have unclaimed mexes in the LZ? If so then build a mex on them.  However first check we dont alreayd have engineers trying to do this

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderBuildingMex'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Do we have any unbuilt locations for this LZ - is table empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZMexUnbuiltLocations]))..'; Is table of part built mexes empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]))) end

    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZMexUnbuiltLocations]) == false or M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subreftoPartBuiltMexes]) == false then
        local bHaveEngineersAssignedAlready = false
        local tEngisInLZ = EntityCategoryFilterDown(M28UnitInfo.refCategoryEngineer, tLZTeamData[M28Map.subrefLZTAlliedUnits])

        if M28Utilities.IsTableEmpty(tEngisInLZ) == false then
            for iEngi, oEngi in tEngisInLZ do
                if oEngi[M28Engineer.refiAssignedAction] == M28Engineer.refActionBuildMex or oEngi[M28Engineer.refiAssignedAction] == M28Engineer.refActionCompletePartBuiltMex then
                    bHaveEngineersAssignedAlready = true
                    break
                end
            end
        end
        if not(bHaveEngineersAssignedAlready) then
            ACUActionBuildMex(oACU:GetAIBrain(), oACU, 60)
            local tLastOrder = oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]]
            if tLastOrder and (tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueBuild or tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueRepair) then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                return true
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function ConsiderNearbyReclaim(iPlateau, iLandZone, tLZData, tLZTeamData, oACU)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderNearbyReclaim'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iTotalReclaimWanted
    local iIndividualReclaimThreshold
    if oACU[refiUpgradeCount] > 0 then
        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] or not(M28Conditions.TeamHasLowMass(oACU:GetAIBrain().M28Team)) then
            iTotalReclaimWanted = 200
            iIndividualReclaimThreshold = 24
        else
            iTotalReclaimWanted = 80
            iIndividualReclaimThreshold = 15
        end
        if oACU[refiUpgradeCount] >= 2 and (oACU[refiUpgradeCount] >= 3 or not(EntityCategoryContains(categories.AEON, oACU.UnitId))) then
            iTotalReclaimWanted = iTotalReclaimWanted * 1.5
        end
    else
        if M28Conditions.TeamHasLowMass(oACU:GetAIBrain().M28Team) then
            iTotalReclaimWanted = 25
            iIndividualReclaimThreshold = 10
        else
            iTotalReclaimWanted = 30
            iIndividualReclaimThreshold = 12
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': LZ reclaim mass='..tLZData[M28Map.subrefLZTotalMassReclaim]..'; Team mass % stored='..M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.subrefiTeamLowestMassPercentStored]..'; iTotalReclaimWanted='..iTotalReclaimWanted..'; iIndividualReclaimThreshold='..iIndividualReclaimThreshold) end
    if tLZData[M28Map.subrefLZTotalMassReclaim] >= iTotalReclaimWanted and M28Team.tTeamData[oACU:GetAIBrain().M28Team][M28Team.subrefiTeamLowestMassPercentStored] <= 0.6 then
        --If any reclaim of iIndividualReclaimThreshold+ value then get ACU to reclaim
        M28Engineer.GetEngineerToReclaimNearbyArea(oACU, tLZTeamData, iPlateau, iLandZone, false, false, iIndividualReclaimThreshold)
        if bDebugMessages == true then LOG(sFunctionRef..': ACU last order after checking for reclaim in area='..reprs(oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]])) end
        local tLastOrder = oACU[M28Orders.reftiLastOrders][oACU[M28Orders.refiOrderCount]]
        if tLastOrder and tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueReclaim then
            if bDebugMessages == true then LOG(sFunctionRef..': ACU has a reclaim order so will stop') end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            return true
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return false
end

function MoveToOtherLandZone(iPlateau, tLZData, oACU)
    --COnsiders the land zone we want to support with the ACU - get the LZ within 175 travel distance that has the greatest value, wants DF support, and has less than 800 enemy threat in it
    local iLZToMoveTo
    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZPathingToOtherLandZones]) == false then
        local iAdjLZ
        local iHighestValueAmount = 0
        local iTeam = oACU:GetAIBrain().M28Team
        for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
            iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
            if tPathingDetails[M28Map.subrefLZTravelDist] < 175 then
                if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport] then
                    if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTValue] > iHighestValueAmount then
                        iHighestValueAmount = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTValue]
                        iLZToMoveTo = iAdjLZ
                    end
                end
            else
                break
            end
        end
        if not(iLZToMoveTo) then
            --Are there any LZs nearby with unclaimed mexes or enemy ground units?
            for iPathingRef, tPathingDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                iAdjLZ = tPathingDetails[M28Map.subrefLZNumber]
                if tPathingDetails[M28Map.subrefLZTravelDist] < 200 then
                    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTEnemyUnits]) == false or M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZMexUnbuiltLocations]) == false then
                        iLZToMoveTo = iAdjLZ

                    end
                else
                    break
                end
            end
        end
        if iLZToMoveTo then
            M28Orders.IssueTrackedMove(oACU, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZToMoveTo][M28Map.subrefLZMidpoint], 6, false, 'ACMLZ'..iLZToMoveTo, false)
        end
    end

    if iLZToMoveTo then return true else return false end
end

function GetACUOrder(aiBrain, oACU)
    --Early game - do we want to build factory/power?
    local sFunctionRef = 'GetACUOrder'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oACU:GetPosition(), true, oACU)
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][aiBrain.M28Team]
    --Refresh ACU last orders as some functions will check last order to decide if it was given an order
    M28Orders.UpdateRecordedOrders(oACU)


    if bDebugMessages == true then LOG(sFunctionRef..': Near start of code, time='..GetGameTimeSeconds()..'; oACU[refbDoingInitialBuildOrder]='..tostring(oACU[refbDoingInitialBuildOrder])..'; ACU unit state='..M28UnitInfo.GetUnitState(oACU)..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end

    --Is the ACU busy with something?
    if oACU:IsUnitState('Upgrading') then
        --Do nothing
        if bDebugMessages == true then LOG(sFunctionRef..': ACU is upgrading') end
    elseif GiveOverchargeOrderIfRelevant(tLZData, tLZTeamData, oACU) then
        --when an overcharge shot is fired it triggers this code to run again so no need to queue things up afterwards
        if bDebugMessages == true then LOG(sFunctionRef..': Have just givne overcharge order') end
    elseif oACU[M28UnitInfo.refbSpecialMicroActive] then
        --Do nothing
        if bDebugMessages == true then LOG(sFunctionRef..': ACU has special micro active') end
    --Are there enemies in the same LZ as the ACU? If so then consider action for these
    else
        if DoesACUWantToRun(iPlateau, iLandZone, tLZData, tLZTeamData, oACU) then
            oACU[refiTimeLastWantedToRun] = GetGameTimeSeconds()
            --Retreat
            local tRallyPoint = M28Land.GetNearestRallyPoint(tLZData, oACU:GetAIBrain().M28Team, iPlateau, iLandZone, 2)
            M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'Run')
        else
            --Are there enemies in this LZ? If so then attack them
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemy units for this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTEnemyUnits]))) end
            if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTEnemyUnits]) == false and AttackNearestEnemyWithACU(iPlateau, iLandZone, tLZData, tLZTeamData, oACU) then
                --(Do nothing further - will ahve given the order)
            else
                if oACU[refbDoingInitialBuildOrder] then
                    GetACUEarlyGameOrders(aiBrain, oACU)

                    --Have we finished our initial build order? (even if we stil lahve some early game orders)
                    if bDebugMessages == true then LOG(sFunctionRef..': Checking if have finished initial build order, Economy stored mass='..aiBrain:GetEconomyStored('MASS')..'; Gross mass income='..aiBrain[M28Economy.refiGrossMassBaseIncome]..'; Gross energy income='..aiBrain[M28Economy.refiGrossEnergyBaseIncome]) end
                    if not(oACU:IsUnitState('Building')) and aiBrain:GetEconomyStored('MASS') == 0 and aiBrain[M28Economy.refiGrossMassBaseIncome] >= 0.3 and aiBrain[M28Economy.refiGrossEnergyBaseIncome] >= 15 then
                        bDoingInitialBuildOrder = false
                    end
                else
                    --If we are reclaiming or building then dont do anything
                    if bDebugMessages == true then LOG(sFunctionRef..': Arent doing initial build order and dont want to run, ACU unit state='..M28UnitInfo.GetUnitState(oACU)..'; Brain mass stored%='..aiBrain:GetEconomyStoredRatio('MASS')) end
                    if not(oACU:IsUnitState('Building')) and not(oACU:IsUnitState('Repairing')) and (not(oACU:IsUnitState('Reclaiming')) or aiBrain:GetEconomyStoredRatio('MASS') >= 0.8) then
                        --Do we want to get an upgrade?
                        local sUpgradeToGet = GetACUUpgradeWanted(oACU)
                        if bDebugMessages == true then LOG(sFunctionRef..': Do we have an upgrade we want to get? sUpgradeToGet='..(sUpgradeToGet or 'nil')) end
                        if sUpgradeToGet then
                            --Are we safe to get the upgrade here? if not then retreat
                            if M28Conditions.SafeToUpgradeUnit(oACU) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Safe to get upgrade so will proceed with upgrading ACU') end
                                M28Orders.IssueTrackedEnhancement(oACU, sUpgradeToGet, false, 'ACUUp')
                            else
                                --Retreat
                                local tRallyPoint = M28Land.GetNearestRallyPoint(tLZData, oACU:GetAIBrain().M28Team, iPlateau, iLandZone, 2)
                                if bDebugMessages == true then LOG(sFunctionRef..': Not safe to get upgrade so want to retreat until it is. tRallyPoint='..repru(tRallyPoint)..'; ACU position='..repru(oACU:GetPosition())) end
                                M28Orders.IssueTrackedMove(oACU, tRallyPoint, 5, false, 'R4U')
                            end
                        else
                            --We dont want an upgrade, and have no enemies in this LZ, but there might be enemies nearby (e.g. in an adjacent land zone); there might also be mexes to build or reclaim to get in this LZ - decide on what we want to do
                            --Does the LZ have uncalimed mexes?
                            if not(ConsiderBuildingMex(tLZData, tLZTeamData, oACU)) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Dont want to build mex, will cehck if want to get reclaim') end
                                if not(ConsiderNearbyReclaim(iPlateau, iLandZone, tLZData, tLZTeamData, oACU)) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Dont want to get reclaim, will see if want to attack adjacent enemies; are there adjacent enemies='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
                                    if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and AttackNearestEnemyWithACU(iPlateau, iLandZone, tLZData, tLZTeamData, oACU) then
                                        --Do nothing - will have given the order
                                    else
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will consider moving to another land zone as nothing to do in this one') end
                                        if not(MoveToOtherLandZone(iPlateau, tLZData, oACU)) then
                                            --Backup - assist nearest factory
                                            if bDebugMessages == true then LOG(sFunctionRef..': ACU no longer doing iniitial BO; Will give backup assist factory order if not building or guarding, ACU unit state='..M28UnitInfo.GetUnitState(oACU)) end
                                            if not(oACU:IsUnitState('Building')) and not(oACU:IsUnitState('Guarding')) then
                                                local oNearestFactory = M28Utilities.GetNearestUnit(aiBrain:GetListOfUnits(M28UnitInfo.refCategoryFactory, false, true), oACU:GetPosition(), true, M28Map.refPathingTypeAmphibious)
                                                if M28UnitInfo.IsUnitValid(oNearestFactory) then
                                                    M28Orders.IssueTrackedGuard(oACU, oNearestFactory, false)
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageACU(aiBrain)
    local sFunctionRef = 'ManageACU'
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --First get our ACU
    local oACU
    while not(oACU) do
        local tOurACU = aiBrain:GetListOfUnits(categories.COMMAND, false, true)
        if M28Utilities.IsTableEmpty(tOurACU) == false then
            for _, oUnit in tOurACU do
                oACU = oUnit
                break
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Looking for ACU that we own, is oACU valid='..tostring(M28UnitInfo.IsUnitValid(oACU))) end
        if oACU then
            oACU[refbDoingInitialBuildOrder] = true
            break
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    --Wait until ok for us to give orders
    while (GetGameTimeSeconds() <= 4.5) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end

    --Make sure ACU is recorded
    M28Team.AssignUnitToLandZoneOrPond(aiBrain, oACU)

    while M28UnitInfo.IsUnitValid(oACU) do
        GetACUOrder(aiBrain, oACU)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    end
end