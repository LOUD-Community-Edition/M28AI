---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 09/12/2022 07:49
---
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Economy = import('/mods/M28AI/lua/AI/M28Economy.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Air = import('/mods/M28AI/lua/AI/M28Air.lua')

--Global
tLZRefreshCountByTeam = {}
--Land zone subteam data - see M28Map for main variables; threat specific values are included here

--Varaibles against specific units
reftiPlateauAndLZToMoveTo = 'M28LandPlatAndLZToMoveTo' --If tell a unit to mvoe to a LZ then will update this with the plateau and land zone wanted
refiCurrentAssignmentValue = 'M28LandAssignedValue' --when a combat unit is given an order for a land zone, the value of that land zone should be recorded
refiCurrentAssignmentPlateauAndLZ = 'M28LandAssignedPlatLZ' --returns {iPlateau, iLandZone} that the units orders have been coordinated by
refiTimeOfLastAssignment = 'M28LandLastAssignmenttime' --returns gametimeseconds that the unit was last assigned to the available units of a land zone
reftiRadarPlateauAndLandZonesCoveredByTeam = 'M28LandRadarLZs' --Returns talbes of {iPlateau, iLandZone} that the radar is providing the best radar coverage of

function UpdateIfLandZoneWantsSupport(tLZTeamData, iPlateau, iLandZone, iTeam, bWantDFSupport, bWantIndirectSupport)
    tLZTeamData[M28Map.subrefbLZWantsSupport] = (bWantDFSupport or bWantIndirectSupport)
    tLZTeamData[M28Map.subrefbLZWantsDFSupport] = bWantDFSupport
    tLZTeamData[M28Map.subrefbLZWantsIndirectSupport] = bWantIndirectSupport
    if not(M28Team.tTeamData[iTeam][M28Team.subrefiLandZonesWantingSupportByPlateau][iPlateau]) then
        M28Team.tTeamData[iTeam][M28Team.subrefiLandZonesWantingSupportByPlateau][iPlateau] = {}
    end
    M28Team.tTeamData[iTeam][M28Team.subrefiLandZonesWantingSupportByPlateau][iPlateau][iLandZone] = tLZTeamData[M28Map.subrefbLZWantsSupport]
end


function GetUnitPlateauAndLandZoneOverride(oUnit)
    --Return true if have changed something
    local iPossiblePlateau
    local iPossibleLZ
    local iBestPlateau
    local iBestLZ
    if M28Utilities.IsTableEmpty(oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]) == false then
        for iTeam, tTeamPlateauAndLZ in oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam] do
            if iTeam == oUnit:GetAIBrain().M28Team then
                iBestPlateau = tTeamPlateauAndLZ[1]
                iBestLZ = tTeamPlateauAndLZ[2]
                break
            else
                iPossiblePlateau = tTeamPlateauAndLZ[1]
                iPossibleLZ = tTeamPlateauAndLZ[2]
            end
        end
        if iBestPlateau then
            M28Map.AddLocationToPlateauExceptions(oUnit:GetPosition(), iBestPlateau, iBestLZ)
            return true
        elseif iPossiblePlateau then

            M28Map.AddLocationToPlateauExceptions(oUnit:GetPosition(), iPossiblePlateau, iPossibleLZ)
            return true
        end
    else
        --If we look in a 2x2 box around the unit can we find a valid plateau?
        local iDistAdjust = math.max(2, M28Map.iLandZoneSegmentSize)
        local tLocationAdjust = {{-iDistAdjust,0}, {-iDistAdjust, -iDistAdjust}, {-iDistAdjust, iDistAdjust}, {0, -iDistAdjust}, {0, iDistAdjust}, {iDistAdjust, -iDistAdjust}, {iDistAdjust, 0}, {iDistAdjust,iDistAdjust}}
        local tBasePosition = oUnit:GetPosition()
        for iEntry, tAdjustXZ in tLocationAdjust do
            --LOG('Considering tBasePosition='..repru(tBasePosition)..'; tAdjustXZ='..repru(tAdjustXZ))
            iPossiblePlateau, iPossibleLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition({ tBasePosition[1] + tAdjustXZ[1], tBasePosition[2], tBasePosition[3] + tAdjustXZ[2] })
            if (iPossiblePlateau or 0) > 0 then
                --LOG('Found a plateau override for oUnit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' at position '..repru(oUnit:GetPosition())..' and tAdjustXZ='..repru(tAdjustXZ))
                M28Map.AddLocationToPlateauExceptions(oUnit:GetPosition(), iPossiblePlateau, iPossibleLZ)
                break
            end
        end
    end
end

function ConsiderAddingPlateauOverrideForUnit(oUnit)
    --If unit doesnt show as having a plateau, it isnt attached, and it is on land then have its current position assigned  to the most recent plateau
    --Note - other places will also call override, this isnt the only function
    --returns true if has added an override
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderAddingPlateauOverrideForUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bMadeChange = false
    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit state='..M28UnitInfo.GetUnitState(oUnit)..'; Unit position='..repru(oUnit:GetPosition())..'; Map height='..M28Map.iMapWaterHeight) end
    if oUnit.IsUnitState and not(oUnit:IsUnitState('Attached')) and oUnit:GetPosition()[2] > M28Map.iMapWaterHeight then
        local iCurPlateau = NavUtils.GetLabel(M28Map.refPathingTypeAmphibious, oUnit:GetPosition())
        if bDebugMessages == true then LOG(sFunctionRef..': Unit plateau from NavUtils='..(iCurPlateau or 'nil')) end
        if (iCurPlateau or 0) <= 0 then
            bMadeChange = GetUnitPlateauAndLandZoneOverride(oUnit)
        else
            --Have a valid plateau but for some reason dont have a land zone?
            local iSegmentX, iSegmentZ = M28Map.GetPathingSegmentFromPosition(oUnit:GetPosition())
            if bDebugMessages == true then LOG(sFunctionRef..': iSegmentX-Z='..iSegmentX..'-'..iSegmentZ..'; tLandZoneBySegment[iSegmentX][iSegmentZ]='..(M28Map.tLandZoneBySegment[iSegmentX][iSegmentZ] or 'nil')) end
            if not(M28Map.tLandZoneBySegment[iSegmentX][iSegmentZ]) then
                bMadeChange = GetUnitPlateauAndLandZoneOverride(oUnit)
                if bDebugMessages == true then LOG(sFunctionRef..': bMadeChange after checking unit plateau and LZ override='..tostring(bMadeChange)) end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bMadeChange
end

function RemoveUnitFromListOfUnitsTravelingToLandZone(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RemoveUnitFromListOfUnitsTravelingToLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[reftiPlateauAndLZToMoveTo]='..repru(oUnit[reftiPlateauAndLZToMoveTo])) end
    if oUnit[reftiPlateauAndLZToMoveTo] then
        local sUnitTableRef
        if EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oUnit.UnitId) then
            sUnitTableRef = M28Map.subrefLZTScoutsTravelingHere
        else
            M28Utilities.ErrorHandler('Need to add code for this unit category')
        end
        if sUnitTableRef then
            local iTargetPlateau = oUnit[reftiPlateauAndLZToMoveTo][1]
            local iTargetLandZone = oUnit[reftiPlateauAndLZToMoveTo][2]
            local tTravelingUnits = M28Map.tAllPlateaus[iTargetPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team][sUnitTableRef]
            if M28Utilities.IsTableEmpty(tTravelingUnits) == false then
                for iTravelUnit, oTravelUnit in tTravelingUnits do
                    if oTravelUnit == oUnit then
                        table.remove(tTravelingUnits, iTravelUnit)
                        break
                    end
                end
            end
        end
        oUnit[reftiPlateauAndLZToMoveTo] = nil
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetUnitToTravelToLandZone(oUnit, iTargetPlateau, iTargetLandZone, subrefLZTScoutsTravelingHere)
    --Intended for non-engineer units (engineers are handled separately)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetUnitToTravelToLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    oUnit[reftiPlateauAndLZToMoveTo] = {iTargetPlateau, iTargetLandZone}
    local tLZData = M28Map.tAllPlateaus[iTargetPlateau][M28Map.subrefPlateauLandZones][iTargetLandZone]
    local tTeamData = tLZData[M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
    if not(tTeamData[subrefLZTScoutsTravelingHere]) then tTeamData[subrefLZTScoutsTravelingHere] = {} end
    table.insert(tTeamData[subrefLZTScoutsTravelingHere], oUnit)
    if bDebugMessages == true then LOG(sFunctionRef..': About to tell unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to go to iTargetPlateau='..iTargetPlateau..'; iTargetLandZone='..iTargetLandZone..'; midpoint of LZ='..repru(tLZData[M28Map.subrefLZMidpoint])) end
    M28Orders.IssueTrackedMove(oUnit, tLZData[M28Map.subrefLZMidpoint], 6, false, 'TLZ'..iTargetLandZone)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateUnitPositionsAndLandZone(aiBrain, tUnits, iTeam, iRecordedPlateau, iRecordedLandZone, bUseLastKnownPosition, bAreAirUnits)
    --Based on RemoveEntriesFromArrayAndAddToNewTableBasedOnCondition, but more complex as dont always want to add unit to a table


    local iRevisedIndex = 1
    local iTableSize = table.getn(tUnits)
    local iActualPlateau, iActualLandZone
    local UpdateUnitLastKnownPosition = M28Team.UpdateUnitLastKnownPosition
    --if iRecordedPlateau == 12 and iRecordedLandZone == 9 then LOG('Start of code, reprs of tUnits='..reprs(tUnits)) end
    for iOrigIndex=1, iTableSize do
        if not(tUnits[iOrigIndex]) or tUnits[iOrigIndex].Dead then
            --Remove the entry
            tUnits[iOrigIndex] = nil
        else
            --Unit still valid, does it have the right plateau and land zone?
            if bUseLastKnownPosition then
                UpdateUnitLastKnownPosition(aiBrain, tUnits[iOrigIndex], false)
                iActualPlateau, iActualLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tUnits[iOrigIndex][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], true, tUnits[iOrigIndex])
            else
                --Allied unit so can use actual position
                --LOG('Updating unit position, iOrigIndex='..iOrigIndex..'; reprs='..reprs(tUnits[iOrigIndex]))
                iActualPlateau, iActualLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tUnits[iOrigIndex]:GetPosition(), true, tUnits[iOrigIndex])
            end
            if not(iActualPlateau > 0) then
                if not(bAreAirUnits) and not(tUnits[iOrigIndex]:IsUnitState('Attached')) then
                    iActualPlateau = iRecordedPlateau
                    iActualLandZone = iRecordedLandZone
                    --Add location to table of pathing exceptions
                    if bUseLastKnownPosition then
                        M28Map.AddLocationToPlateauExceptions(tUnits[iOrigIndex][M28UnitInfo.reftLastKnownPositionByTeam][iTeam], iRecordedPlateau, iRecordedLandZone)
                    else
                        M28Map.AddLocationToPlateauExceptions(tUnits[iOrigIndex]:GetPosition(), iRecordedPlateau, iRecordedLandZone)
                    end
                end
            end

            --Is the plateau and zone correct?
            if iRecordedPlateau == iActualPlateau and iRecordedLandZone == iActualLandZone then
                --No change needed for unit
                if (iOrigIndex ~= iRevisedIndex) then
                    tUnits[iRevisedIndex] = tUnits[iOrigIndex]
                    tUnits[iOrigIndex] = nil
                end
                iRevisedIndex = iRevisedIndex + 1
            else
                local oUnitToAdd = tUnits[iOrigIndex]
                --Want to remove the entry from this table, but then add it to the correct table
                oUnitToAdd[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam] = nil --Done here so we dont try and go through this table again when removing later on
                if iActualPlateau > 0 and iActualLandZone > 0 then
                    --AddUnitToLandZoneForBrain(aiBrain,        oUnit,      iPlateau,       iLandZone,      bIsEnemyAirUnit)
                    M28Team.AddUnitToLandZoneForBrain(aiBrain, oUnitToAdd, iActualPlateau, iActualLandZone, bAreAirUnits)
                else
                    if bAreAirUnits then
                        --Add unit to table of air units without a plateau
                        M28Air.RecordEnemyAirUnitWithNoZone(iTeam, oUnitToAdd)
                    else
                        --Not sure where to record unit so call main logic
                        M28Team.AssignUnitToZoneOrPond(aiBrain, oUnitToAdd, true)
                    end
                end
                tUnits[iOrigIndex] = nil
            end
        end
    end
    --if iRecordedPlateau == 12 and iRecordedLandZone == 9 then LOG('End of code, iRevisedIndex='..iRevisedIndex..'; reprs of tUnits='..reprs(tUnits)) end
end

function RecordAirThreatForLandZone(tLZTeamData, iTeam, iPlateau, iLandZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAirThreatForLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    tLZTeamData[M28Map.refiLZEnemyAirToGroundThreat] = M28UnitInfo.GetAirThreatLevel(tLZTeamData[M28Map.reftLZEnemyAirUnits], true, false, false, true, false, false)
    tLZTeamData[M28Map.refiLZEnemyAirOtherThreat] = M28UnitInfo.GetAirThreatLevel(tLZTeamData[M28Map.reftLZEnemyAirUnits], true, true, false, false, true, true)

    if bDebugMessages == true then LOG(sFunctionRef..': Finished updating enemy air threat values for iTeam '..iTeam..' iPlateau '..iPlateau..'; iLandZOne '..iLandZone..'; AirToGround threat='.. tLZTeamData[M28Map.refiLZEnemyAirToGroundThreat]..'; Other air threat='..tLZTeamData[M28Map.refiLZEnemyAirOtherThreat]..'; Is table of enemy air units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]))) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordGroundThreatForLandZone(tLZTeamData, iTeam, iPlateau, iLandZone)
    --Records the different types of threat for the land zone

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordGroundThreatForLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Track team total threat - first remove the previous entry, then add in the new entry
    M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] - tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
    M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] - tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]
    M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] - tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]


    --if iLandZone == 12 then bDebugMessages = true end


    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for iTeam='..iTeam..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTEnemyUnits]))) end
    --local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam]
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTEnemyUnits]) then
        tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] = 0
        tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] = 0
        tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] = false
    else
        local tMobileUnits = EntityCategoryFilterDown(categories.MOBILE, tLZTeamData[M28Map.subrefLZTEnemyUnits])
        local tStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tLZTeamData[M28Map.subrefLZTEnemyUnits])
        local bHaveDangerousEnemies = false
        tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal] = M28UnitInfo.GetCombatThreatRating(tLZTeamData[M28Map.subrefLZTEnemyUnits], true)
        tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] = M28UnitInfo.GetCombatThreatRating(tStructures, true, false, true)
        tLZTeamData[M28Map.subrefLZThreatEnemyGroundAA] = M28UnitInfo.GetAirThreatLevel(tLZTeamData[M28Map.subrefLZTEnemyUnits], true, false, true, false, false, false)
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange] = nil
        if bDebugMessages == true then LOG(sFunctionRef..': Plateau '..iPlateau..' LZ '..iLandZone..' has enemy units, Enemy combat total='..tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal]) end
        local iCurThreat
        if M28Utilities.IsTableEmpty(tMobileUnits) == false then
            for iUnit, oUnit in tMobileUnits do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Combat threat rating='..M28UnitInfo.GetCombatThreatRating({ oUnit }, true)) end
                if oUnit[M28UnitInfo.refiDFRange] > 0 or oUnit[M28UnitInfo.refiIndirectRange] then
                    iCurThreat = M28UnitInfo.GetCombatThreatRating({ oUnit }, true)
                    if iCurThreat > 0 then
                        if oUnit[M28UnitInfo.refiDFRange] > 0 then
                            if not(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) then tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] = {} end
                            tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange][oUnit[M28UnitInfo.refiDFRange]] = (tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange][oUnit[M28UnitInfo.refiDFRange]] or 0) + iCurThreat
                            if not(bHaveDangerousEnemies) and iCurThreat > 10 then bHaveDangerousEnemies = true end
                        end
                        if oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                            if not(tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange]) then tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange] = {} end
                            tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange][oUnit[M28UnitInfo.refiIndirectRange]] = (tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange][oUnit[M28UnitInfo.refiIndirectRange]] or 0) + iCurThreat
                        end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tStructures) == false then
            for iUnit, oUnit in tStructures do
                if oUnit[M28UnitInfo.refiDFRange] > 0 then
                    iCurThreat = M28UnitInfo.GetCombatThreatRating({ oUnit }, true)
                    if iCurThreat > 0 then
                        if not(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) then tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] = {} end
                        tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange][oUnit[M28UnitInfo.refiDFRange]] = (tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange][oUnit[M28UnitInfo.refiDFRange]] or 0) + iCurThreat
                        if not(bHaveDangerousEnemies) and iCurThreat > 10 then bHaveDangerousEnemies = true end
                    end
                end
            end
        end
        tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ] = bHaveDangerousEnemies
    end


    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) then
        tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatAllyStructureIndirect] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] = 0
    else
        local tMobileUnits = EntityCategoryFilterDown(categories.MOBILE, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        local tStructures = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tLZTeamData[M28Map.subrefLZTAlliedUnits])
        tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] = M28UnitInfo.GetCombatThreatRating(tLZTeamData[M28Map.subrefLZTAlliedUnits], false)
        tLZTeamData[M28Map.subrefLZThreatAllyStructureIndirect] = M28UnitInfo.GetCombatThreatRating(tStructures, false, false, true)
        tLZTeamData[M28Map.subrefLZThreatAllyGroundAA] = M28UnitInfo.GetAirThreatLevel(tLZTeamData[M28Map.subrefLZTAlliedUnits], false, false, true, false, false, false)
        tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] = nil
        tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] = nil
        local iCurThreat
        if M28Utilities.IsTableEmpty(tMobileUnits) == false then
            for iUnit, oUnit in tMobileUnits do
                if oUnit[M28UnitInfo.refiDFRange] > 0 or oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                    iCurThreat = M28UnitInfo.GetCombatThreatRating({ oUnit }, false)
                    if iCurThreat > 0 then
                        if oUnit[M28UnitInfo.refiDFRange] > 0 then
                            if not(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) then tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] = {} end
                            tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange][oUnit[M28UnitInfo.refiDFRange]] = (tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange][oUnit[M28UnitInfo.refiDFRange]] or 0) + iCurThreat
                        end
                        if oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                            if not(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange]) then tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] = {} end
                            tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange][oUnit[M28UnitInfo.refiIndirectRange]] = (tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange][oUnit[M28UnitInfo.refiIndirectRange]] or 0) + iCurThreat
                        end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tStructures) == false then
            for iUnit, oUnit in tStructures do
                if oUnit[M28UnitInfo.refiDFRange] > 0 then
                    iCurThreat = M28UnitInfo.GetCombatThreatRating({ oUnit }, true)
                    if iCurThreat > 0 then
                        if not(tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange]) then tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange] = {} end
                        tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange][oUnit[M28UnitInfo.refiDFRange]] = (tLZTeamData[M28Map.subrefLZThreatAllyStructureDFByRange][oUnit[M28UnitInfo.refiDFRange]] or 0) + iCurThreat
                    end
                end
            end
        end
        --Update total DF and indirect threat
        tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] = 0
        tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] = 0
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] = tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] + iThreat
            end
        end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] do
                tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] = tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal] + iThreat
            end
        end

        M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] + tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal]
        M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] + tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectTotal]
        M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] + tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]

    end
    local bNearbyEnemies = false

    if bDebugMessages == true then LOG(sFunctionRef..': Considering if enemy units in this or adjacent LZ, is table of enemy units for this LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTEnemyUnits]))..'; Adjacent LZs='..repru(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]))) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTEnemyUnits]) == false then
        bNearbyEnemies = true
    else
        --, iPlateau, iLandZone
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones] do
                --NEED to flag as nearby enemies if any enemy units in the LZ, or else can cause problems where we try to attack a unit in an adjacent land zone, and then think there is no such unit due to this flag if it is only based on combat threat
                if bDebugMessages == true then LOG(sFunctionRef..': Enemy combat threat for adjacent LZ iAdjLZ='..iAdjLZ..'; threat='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTThreatEnemyCombatTotal]) end
                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTEnemyUnits]) == false then
                    bNearbyEnemies = true
                    break
                end
            end
        end
    end

    --Calculate core DF and indirect wanted just for this LZ:
    if bNearbyEnemies then
        local iEnemyStructureThreat = 0
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
                iEnemyStructureThreat = iEnemyStructureThreat + iThreat
            end
        end
        tLZTeamData[M28Map.subrefLZIndirectThreatWanted] = iEnemyStructureThreat * 2 + tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] * 2
        tLZTeamData[M28Map.subrefLZDFThreatWanted] = math.max(200, tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal] * 2)
    else
        tLZTeamData[M28Map.subrefLZDFThreatWanted] = 0
        tLZTeamData[M28Map.subrefLZIndirectThreatWanted] = 0
    end

    --If we have no friendly combat units and enemy has combat threat, then request less MAA, or none if we have no non-MAA/scout units
    if bDebugMessages == true then LOG(sFunctionRef..': Setting the MAA level wanted for iLandZone='..iLandZone..'; tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal]='..tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal]..'; tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]='..tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]..'; tLZTeamData[M28Map.refiLZEnemyAirToGroundThreat]='..tLZTeamData[M28Map.refiLZEnemyAirToGroundThreat]..'; tLZTeamData[M28Map.refiLZEnemyAirOtherThreat]='..tLZTeamData[M28Map.refiLZEnemyAirOtherThreat]..'; Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]))) end
    if tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal] < 11 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] >= math.min(1500, tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal] * 0.9) or tLZTeamData[M28Map.subrefLZTCoreBase] then
        tLZTeamData[M28Map.subrefLZMAAThreatWanted] = math.max(tLZTeamData[M28Map.refiLZEnemyAirToGroundThreat] * 0.65 + tLZTeamData[M28Map.refiLZEnemyAirOtherThreat] * 0.15, tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] * 0.1)
    elseif M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
        local bHaveAlliedNonMAAOrScout = false
        local bHaveAlliedMAA = false
        for iUnit, oUnit in tLZTeamData[M28Map.subrefLZTAlliedUnits] do
            if EntityCategoryContains(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryMAA - M28UnitInfo.refCategoryLandScout, oUnit.UnitId) then
                bHaveAlliedNonMAAOrScout = true
                break
            elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId) then
                bHaveAlliedMAA = true
            end
        end -- M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryMAA - M28UnitInfo.refCategoryLandScout, subrefLZTAlliedUnits
        if bDebugMessages == true then LOG(sFunctionRef..': bHaveAlliedMAA='..tostring(bHaveAlliedMAA)..'; bHaveAlliedNonMAAOrScout='..tostring(bHaveAlliedNonMAAOrScout)) end
        if bHaveAlliedNonMAAOrScout or (bHaveAlliedMAA and tLZTeamData[M28Map.refiLZEnemyAirToGroundThreat] > 0) then
            --SIgnificantly less MAA for dealing with non-air to ground threats
            tLZTeamData[M28Map.subrefLZMAAThreatWanted] = math.max(tLZTeamData[M28Map.refiLZEnemyAirToGroundThreat] * 0.65, tLZTeamData[M28Map.refiLZEnemyAirOtherThreat] * 0.05, tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] * 0.1)
        else
            tLZTeamData[M28Map.subrefLZMAAThreatWanted] = 0
        end
    else
        tLZTeamData[M28Map.subrefLZMAAThreatWanted] = 0
    end


    if bDebugMessages == true then LOG(sFunctionRef..': End of code, tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]='..repru(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange])..'; bNearbyEnemies='..tostring(bNearbyEnemies)) end
    tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] = bNearbyEnemies
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RunFromEnemy(oUnitToRun, oEnemy, iTeam, iPlateau, iDistanceToRun)
    local iAngleFromEnemy = M28Utilities.GetAngleFromAToB(oUnitToRun:GetPosition(), oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) - 180
    if iAngleFromEnemy < 0 then iAngleFromEnemy = iAngleFromEnemy + 360 end
    local tPotentialRunPosition = M28Utilities.MoveInDirection(oUnitToRun:GetPosition(), iAngleFromEnemy, iDistanceToRun, true, false)
    --If target not in same plateau then try moving further away by 5 and 10; if still not in same plateau then move back to start position
    local iCurPlateau, iCurLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tPotentialRunPosition)
    local iAlternativeCount = 0
    while not(iCurPlateau == iPlateau) do
        iAlternativeCount = iAlternativeCount + 1
        if iAlternativeCount >= 3 then
            --Go to start instead
            tPotentialRunPosition = M28Map.PlayerStartPoints[oUnitToRun:GetAIBrain():GetArmyIndex()]
            break
        else
            iDistanceToRun = iDistanceToRun + 4
            tPotentialRunPosition = M28Utilities.MoveInDirection(oUnitToRun:GetPosition(), iAngleFromEnemy, iDistanceToRun, true, false)
            iCurPlateau, iCurLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tPotentialRunPosition)
        end
    end

    M28Orders.IssueTrackedMove(oUnitToRun, tPotentialRunPosition, math.min(8, iDistanceToRun * 0.25), false, 'RunE'..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy))
end

function ManageLandZoneScouts(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tScouts, bLandZoneContainsNonScouts)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageLandZoneScouts'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    tLZTeamData[M28Map.refbWantLandScout] = false
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want a land scout for iPlateau '..iPlateau..'; iLandZone='..iLandZone..'; bLandZoneContainsNonScouts='..tostring(bLandZoneContainsNonScouts or false)..'; Enemy combat threat='..tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal]..'; Is table of land scouts traveling here empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTScoutsTravelingHere]))..'; Is table of scouts currently in this LZ empty='..tostring(M28Utilities.IsTableEmpty(tScouts))) end
    if (bLandZoneContainsNonScouts or tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal] <= 2) and (tLZData[M28Map.subrefLZMexCount] > 0 or tLZData[M28Map.subrefLZTotalSegmentCount] > 30) and M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTScoutsTravelingHere]) then
        --Want a land scout for htis land zone, unless we already have one traveling here; if we have available land scouts then will change this flag back to false
        tLZTeamData[M28Map.refbWantLandScout] = true
        if bDebugMessages == true then LOG(sFunctionRef..': We want to get a scout for this LZ') end
    end

    --Do we have any land scouts that are available? if so then assign to an adjacent land zone if the adjacent zone wants scouts
    if M28Utilities.IsTableEmpty(tScouts) == false then
        local tAvailableScouts = {}
        local bCheckForEnemies = false
        local tEnemyUnitTablesToConsider = {}
        --Check for neemies if there are any in this or adjacent land zone
        if tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal] > 0 then
            table.insert(tEnemyUnitTablesToConsider, tLZTeamData[M28Map.subrefLZTEnemyUnits])
        end
        if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
            for _, iAdjLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones] do
                if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTThreatEnemyCombatTotal] > 0 then
                    table.insert(tEnemyUnitTablesToConsider, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTEnemyUnits])
                end
            end
        end
        if M28Utilities.IsTableEmpty(tEnemyUnitTablesToConsider) == false then bCheckForEnemies = true end

        local oEnemyToRunFrom
        local oPrevEnemyToRunFrom
        local iRunThreshold = 15 --If get this close to being in range of an enemy should try to run
        if bDebugMessages == true then LOG(sFunctionRef..': About to consider orders for scouts in this LZ, size of tScouts='..table.getn(tScouts)..'; bCheckForEnemies='..tostring(bCheckForEnemies)..'; Enemy combat total='..tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal]) end
        for iScout, oScout in tScouts do
            if bCheckForEnemies then
                oEnemyToRunFrom = nil
                if oPrevEnemyToRunFrom and M28Utilities.GetDistanceBetweenPositions(oPrevEnemyToRunFrom[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) - oPrevEnemyToRunFrom[M28UnitInfo.refiDFRange] <= iRunThreshold then
                    --Run from same enemy
                    oEnemyToRunFrom = oPrevEnemyToRunFrom
                else
                    for iUnitTable, tUnitTable in tEnemyUnitTablesToConsider do
                        for iUnit, oUnit in tUnitTable do
                            if bDebugMessages == true then LOG(sFunctionRef..': Looking for enemy to run from, considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit DF range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Unit position='..repru(oUnit:GetPosition())..'; Unit last known position='..repru(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Dist between last known position and scout='..M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition())..'; Unit range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; iRunThreshold='..iRunThreshold..'; Is distance within run threshold='..tostring(M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) - (oUnit[M28UnitInfo.refiDFRange] or 0) <= iRunThreshold)) end
                            if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and not(oUnit == oPrevEnemyToRunFrom) then
                                if M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) - oUnit[M28UnitInfo.refiDFRange] <= iRunThreshold then
                                    oEnemyToRunFrom = oUnit
                                    break
                                end
                            end
                        end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Do we have a valid enemy unit to run from='..tostring(M28UnitInfo.IsUnitValid(oEnemyToRunFrom))..'; ENemy ID if any='..(oEnemyToRunFrom.UnitId or 'nil')) end
            if oEnemyToRunFrom then
                if bDebugMessages == true then LOG(sFunctionRef..': Want scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..' to run from oEnemyToRunFrom '..oEnemyToRunFrom.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToRunFrom)) end
                oPrevEnemyToRunFrom = oEnemyToRunFrom
                RunFromEnemy(oScout, oEnemyToRunFrom, iTeam, iPlateau, 16)

                tLZTeamData[M28Map.refbWantLandScout] = false
            else
                if bDebugMessages == true then LOG(sFunctionRef..': No nearby enemy to run from, Considering if scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..' is available; reftiPlateauAndLZToMoveTo='..repru(oScout[reftiPlateauAndLZToMoveTo])) end
                if oScout[reftiPlateauAndLZToMoveTo] then
                    --Make scout available if its target LZ is this LZ
                    if oScout[reftiPlateauAndLZToMoveTo][2] == iLandZone and oScout[reftiPlateauAndLZToMoveTo][1] == iPlateau then
                        --Clear this unit from list of traveling units, but dont make it available as want a slight delay, so want it to be available on the next cycle
                        if bDebugMessages == true then LOG(sFunctionRef..': Scout is traveling to this land zone and is here so will clear the trackers so next cycle it is shown as available') end
                        RemoveUnitFromListOfUnitsTravelingToLandZone(oScout)
                        tLZTeamData[M28Map.refbWantLandScout] = false
                    else
                        --Scout should be traveling to another land zone - if it has no orders then refresh them
                        if bDebugMessages == true then LOG(sFunctionRef..': Scout should travel to another land zone so order it to travel there') end
                        M28Orders.IssueTrackedMove(oScout, M28Map.tAllPlateaus[oScout[reftiPlateauAndLZToMoveTo][1]][M28Map.subrefPlateauLandZones][oScout[reftiPlateauAndLZToMoveTo][2]][M28Map.subrefLZMidpoint], 6, false, 'TLZ'..oScout[reftiPlateauAndLZToMoveTo][2])
                    end
                else
                    --Scout has no nearby enemies to run from, and isnt traveling to a plateau, so it should be available for use
                    table.insert(tAvailableScouts, oScout)
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Is available scout table empty='..tostring(M28Utilities.IsTableEmpty(tAvailableScouts))) end

        if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
            --First assign any available scouts to adjacent land zones wanting scouts
            if bDebugMessages == true then LOG(sFunctionRef..': Will first allocate scouts to any adjacent land zones that want a scout. Is table of adj zones empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]))) end
            if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
                for _, iAdjLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Consideri niAdjLZ='..iAdjLZ..'; Does this LZ want land scout='..tostring(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.refbWantLandScout] or false)..'; Is table of traveling scouts here empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTScoutsTravelingHere]))) end
                    if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.refbWantLandScout] then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will send land scout '..tAvailableScouts[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tAvailableScouts[1])..' to go to adjacent land zone '..iAdjLZ..' in plateau '..iPlateau) end


                        GetUnitToTravelToLandZone(tAvailableScouts[1], iPlateau, iAdjLZ, M28Map.subrefLZTScoutsTravelingHere)
                        M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.refbWantLandScout] = false
                        table.remove(tAvailableScouts, 1)
                        if M28Utilities.IsTableEmpty(tAvailableScouts) then break end
                    end
                end

            end
            if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
                tLZTeamData[M28Map.refbWantLandScout] = false
                --If we are here then we still have available land scouts; if we have ap atrol path then patrol; if we have a mex then go here, if we have an adjcent zone go here, otherwise move randomly if we have no orders
                for iScout, oScout in tAvailableScouts do
                    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subreftPatrolPath]) == false then
                        --Patrol the land zone
                        M28Orders.PatrolPath(oScout, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subreftPatrolPath], false, 'SP')
                    else
                        --Do nothing if scout is moving as maybe it landed on a segment just out of the zone it shoudl have been in
                        if not(oScout:IsUnitState('Moving')) then
                            M28Orders.UpdateRecordedOrders(oScout)
                            if (oScout[M28Orders.refiOrderCount] or 0) == 0 then
                                --Want ot get somewhere to move to as a backup
                                if tLZData[M28Map.subrefLZMexCount] > 0 then
                                    M28Orders.IssueTrackedMove(oScout, tLZData[M28Map.subrefLZMidpoint], 5, false, 'BackupMid')
                                else
                                    --Do we have an adjacent LZ? If so move here
                                    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
                                        GetUnitToTravelToLandZone(tAvailableScouts[1], iPlateau, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones][1], M28Map.subrefLZTScoutsTravelingHere)
                                    else
                                        --No adjacent LZs, and no mexes in this LZ, so just move randomly
                                        M28Orders.IssueTrackedMove(oScout, M28Utilities.MoveInDirection(oScout:GetPosition(), math.random(1, 360), math.random(10, 30), true, false), 5, false, 'BackupRnd')
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateBestEnemyRangesForThisLandZone(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateBestEnemyRangesForThisLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Update best range values for enemies and allies
    local iEnemyBestMobileDFRange = 0
    local iEnemyBestStructureDFRange = 0
    local iEnemyBestMobileIndirectRange = 0

    --First get range for this land zone
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]) == false then
        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] do
            if iThreat > 20 then iEnemyBestMobileDFRange = math.max(iRange, iEnemyBestMobileDFRange) end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange]='..repru(tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange])..'; iEnemyBestMobileDFRange='..iEnemyBestMobileDFRange) end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange]) == false then
        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyStructureDFByRange] do
            if iThreat > 20 then iEnemyBestStructureDFRange = math.max(iRange, iEnemyBestStructureDFRange) end
        end
    end
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange]) == false then
        for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange] do
            if iThreat > 20 then iEnemyBestMobileIndirectRange = math.max(iRange, iEnemyBestMobileIndirectRange) end
        end
    end
    tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange] = iEnemyBestMobileDFRange
    tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] = iEnemyBestStructureDFRange
    tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange] = iEnemyBestMobileIndirectRange
    if bDebugMessages == true then LOG(sFunctionRef..': End of code for iLandZone '..iLandZone..'; tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]='..tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordClosestAdjacentEnemiesAndGetBestEnemyRange(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordClosestAdjacentEnemiesAndGetBestEnemyRange'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    tLZTeamData[M28Map.reftoNearestDFEnemies] = {}
    local iEnemyBestMobileDFRange = 0
    local iEnemyBestStructureDFRange = 0
    local iEnemyBestMobileIndirectRange = 0
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iTeam='..iTeam..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Enemies in this or adjacent LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end
    if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
        local tNearestCombatEnemies = {}
        iEnemyBestMobileDFRange = tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]
        iEnemyBestStructureDFRange = tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange]
        iEnemyBestMobileIndirectRange = tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange]

        --Adjust the ranges to factor in adjacent land zones
        local iLowestDistUntilInRange = 10000
        local oLowestDFDistUntilInRange
        local tMidpoint = tLZData[M28Map.subrefLZMidpoint]
        local iCurDistUntilInRange
        if bDebugMessages == true then LOG(sFunctionRef..': Best mobile DF range for this zone only='..tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]..'; Mobile structure range='..tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange]..'; Mobile indirect='..tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange]..'; Is table of adjacent LZs empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]))) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for iEntry, iAdjLandZone in tLZData[M28Map.subrefLZAdjacentLandZones] do
                iLowestDistUntilInRange = 10000
                oLowestDFDistUntilInRange = nil
                local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLandZone][M28Map.subrefLZTeamData][iTeam]

                iEnemyBestMobileDFRange = math.max(iEnemyBestMobileDFRange, tAltLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange])
                iEnemyBestStructureDFRange = math.max(iEnemyBestMobileDFRange, tAltLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange])
                iEnemyBestMobileIndirectRange = math.max(iEnemyBestMobileIndirectRange, tAltLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange])
                if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent LZ '..iAdjLandZone..'; Enemy mobile DF for this LZ='..tAltLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange]..'; Mobile structure range='..tAltLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange]..'; Mobile indirect='..tAltLZTeamData[M28Map.subrefLZThreatEnemyBestMobileIndirectRange]) end
                if M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subrefLZTEnemyUnits]) == false and tAltLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal] >= 10 then
                    for iUnit, oUnit in tAltLZTeamData[M28Map.subrefLZTEnemyUnits] do
                        if oUnit[M28UnitInfo.refiDFRange] > 0 and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - categories.SERAPHIM, oUnit.UnitId)) then
                            iCurDistUntilInRange = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], tMidpoint) - oUnit[M28UnitInfo.refiDFRange]
                            if iCurDistUntilInRange < iLowestDistUntilInRange then
                                oLowestDFDistUntilInRange = oUnit
                                iLowestDistUntilInRange = iCurDistUntilInRange
                            end
                        end
                    end
                end
                if oLowestDFDistUntilInRange  then
                    table.insert(tLZTeamData[M28Map.reftoNearestDFEnemies], oLowestDFDistUntilInRange)
                end
            end
        end

        --Add all units from this zone into reftoNearestDFEnemies
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTEnemyUnits]) == false and tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal] then
            for iUnit, oUnit in tLZTeamData[M28Map.subrefLZTEnemyUnits] do
                if oUnit[M28UnitInfo.refiDFRange] > 0 and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - categories.SERAPHIM, oUnit.UnitId)) then
                    table.insert(tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit)
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iEnemyBestMobileDFRange='..iEnemyBestMobileDFRange..'; iEnemyBestStructureDFRange='..iEnemyBestStructureDFRange..'; iEnemyBestMobileIndirectRange='..iEnemyBestMobileIndirectRange) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iEnemyBestMobileDFRange, iEnemyBestStructureDFRange, iEnemyBestMobileIndirectRange
end

function ReviseTargetLZIfFarAway(tLZData, iTeam, iPlateau, iStartLandZone, iTargetLandZone, iMaxLZTowardsRally)
    --If we want to move to a rally point but it is more than iMaxLZTowardsRally land zones away, then go to the iMaxLZTowardsRally'th entry
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReviseTargetLZIfFarAway'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iNewTargetLZ = iTargetLandZone
    if not(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]) then
        M28Map.ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iPlateau, iStartLandZone, iTargetLandZone, tLZData[M28Map.subrefLZMidpoint])
    end
    if iMaxLZTowardsRally and tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone] then
        if bDebugMessages == true then LOG(sFunctionRef..': WIll consider changing to the '..iMaxLZTowardsRally..' entry along the path; repru of the path='..repru(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath])..'; Position in the path='..tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]) end
        --Change closest LZ to run to to be 2 along the path from cur LZ to the target LZ
        for iEntry, iLZPointInPath in tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath] do
            if iEntry >= iMaxLZTowardsRally then
                if bDebugMessages == true then LOG(sFunctionRef..': Were going to move to iTargetLandZone='..iTargetLandZone..' from LZ'..iStartLandZone..' but it is at least iMaxLZTowardsRally='..iMaxLZTowardsRally..' LZ away so will move to iEntry LZ which is '..iLZPointInPath..'; Total paht size='..table.getn(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iTargetLandZone]][M28Map.subrefLZPath])) end
                iNewTargetLZ = iLZPointInPath
                break
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iNewTargetLZ
end

function GetNearestRallyPoint(tLZData, iTeam, iPlateau, iLandZone, iMaxLZTowardsRally)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetNearestRallyPoint'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau]) == false then
        local iCurDist
        local iClosestDist = 100000
        local iClosestLZ
        for iEntry, iAltLZ in M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau] do
            if iAltLZ == iLandZone then
                iClosestLZ = iAltLZ
                break
            else
                iCurDist = M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iAltLZ)  --M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAltLZ][M28Map.subrefLZMidpoint], tLZData[M28Map.subrefLZMidpoint])
            end
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                iClosestLZ = iAltLZ
            end
        end
        if iClosestLZ == iLandZone then
            --Do nothing - wont find a closer one
        else
            --Do we have a path to this rally point from the current land zone? If so move 2 along the path
            if not(tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZ]) then
                M28Utilities.ErrorHandler('Dont have pathing recorded for iClosetsLZ='..iClosestLZ..'; iPlateau='..iPlateau..'; iBaesLZ='..iLandZone)
                M28Map.ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iPlateau, iLandZone, iClosestLZ, tLZData[M28Map.subrefLZMidpoint])
            end
            if iMaxLZTowardsRally and tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZ] then
                if bDebugMessages == true then LOG(sFunctionRef..': WIll consider changing to the '..iMaxLZTowardsRally..' entry along the path; repru of the path='..repru(tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZ]][M28Map.subrefLZPath])..'; Position in the path='..tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZ]) end
                --Change closest LZ to run to to be 2 along the path from cur LZ to the target LZ
                for iEntry, iLZPointInPath in tLZData[M28Map.subrefLZPathingToOtherLandZones][tLZData[M28Map.subrefLZPathingToOtherLZEntryRef][iClosestLZ]][M28Map.subrefLZPath] do
                    if iEntry >= iMaxLZTowardsRally then
                        iClosestLZ = iLZPointInPath
                        break
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iMaxLZTowardsRally='..(iMaxLZTowardsRally or 'nil')..'; iClosestLZ='..iClosestLZ) end
        return {M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZ][M28Map.subrefLZMidpoint][1], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZ][M28Map.subrefLZMidpoint][2], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iClosestLZ][M28Map.subrefLZMidpoint][3]}
    else
        M28Utilities.ErrorHandler('No rally point for P'..(iPlateau or 'nil')..' LZ'..(iLandZone or 'nil')..'; will return current midpoint')
        return {tLZData[M28Map.subrefLZMidpoint][1], tLZData[M28Map.subrefLZMidpoint][2], tLZData[M28Map.subrefLZMidpoint][3]}
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshRallyPoints(iTeam)
    --For now just has core bases as rally points, may adjust htis in the future
    M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau] = {}
    for iPlateau, tPlateauSubtable in M28Map.tAllPlateaus do
        M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau] = {}
        for iLandZone, tLandZoneInfo in tPlateauSubtable[M28Map.subrefPlateauLandZones] do
            if tLandZoneInfo[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTCoreBase] then
                table.insert(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau], iLandZone)
            end
        end
    end
end

function SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, iLZToSupport)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SendMAAToSupportLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tAltLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZToSupport]
    local tAltTeamLZData = tAltLZData[M28Map.subrefLZTeamData][iTeam]
    local tDistToTargetByRef = {}
    local tTargetPosition = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZToSupport][M28Map.subrefLZMidpoint]
    if not(tAltTeamLZData[M28Map.subrefLZMAAThreatWanted]) or not(tAltTeamLZData[M28Map.subrefLZThreatAllyGroundAA]) then
        M28Utilities.ErrorHandler('Have nil MAA or AllyGroundAA threat for iLZToSupport='..(iLZToSupport or 'nil')..'; see log for more info')
        LOG(sFunctionRef..': MAA iTeam='..(iTeam or 'nil')..'; iPlateau='..(iPlateau or 'nil')..'; iLZToSupport='..(iLZToSupport or 'nil')..'; tAltTeamLZData[M28Map.subrefLZMAAThreatWanted]='..(tAltTeamLZData[M28Map.subrefLZMAAThreatWanted] or 'nil')..'; tAltTeamLZData[M28Map.subrefLZThreatAllyGroundAA]='..(tAltTeamLZData[M28Map.subrefLZThreatAllyGroundAA] or 'nil')..'; reprs of teamLZData='..reprs(tAltTeamLZData))
    else
        local iMAAThreatWanted = tAltTeamLZData[M28Map.subrefLZMAAThreatWanted] - tAltTeamLZData[M28Map.subrefLZThreatAllyGroundAA]

        for iUnit, oUnit in tMAAToAdvance do
            tDistToTargetByRef[iUnit] = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetPosition)
        end
        local tbRemovedMAAReferencesByRef = {}
        for iUnitRef, iDistance in M28Utilities.SortTableByValue(tDistToTargetByRef, false) do
            M28Orders.IssueTrackedMove(tMAAToAdvance[iUnitRef], tTargetPosition, 10, false, 'MVELZ'..iLZToSupport)
            iMAAThreatWanted = iMAAThreatWanted - M28UnitInfo.GetAirThreatLevel({ tMAAToAdvance[iUnitRef] }, false, false, true, false, false, false)
            tbRemovedMAAReferencesByRef[iUnitRef] = true
            if iMAAThreatWanted < 0 then break end
        end
        if M28Utilities.IsTableEmpty(tbRemovedMAAReferencesByRef) == false then
            --Remove any MAA that have given orders from tMAAToAdvance:
            local iRevisedIndex = 1
            local iTableSize = table.getn(tMAAToAdvance)

            for iOrigIndex=1, iTableSize do
                if tMAAToAdvance[iOrigIndex] then
                    if not(tbRemovedMAAReferencesByRef[iOrigIndex]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                        --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                        if (iOrigIndex ~= iRevisedIndex) then
                            tMAAToAdvance[iRevisedIndex] = tMAAToAdvance[iOrigIndex];
                            tMAAToAdvance[iOrigIndex] = nil;
                        end
                        iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                    else
                        tMAAToAdvance[iOrigIndex] = nil;
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageMAAInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableMAA)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMAAInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local tRallyPoint = GetNearestRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2) --Get a LZ up to 3 land zones away to retreat to (i.e. will pick rally point and then move 2 towards it)

    --First split the MAA into those that need to run (due to being in range of DF units) and those that can advance
    local tMAAToAdvance = {}
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies]) then
        --No DF enemies so treat all MAA as being available
        tMAAToAdvance = tAvailableMAA
    else
        for iUnit, oUnit in tAvailableMAA do
            --Run if within 14 of being in range of enemy direct fire
            if M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 14, iTeam, true) then
                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'Run'..iLandZone)
            else
                table.insert(tMAAToAdvance, oUnit)
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of tMAAToAdvance empty='..tostring(M28Utilities.IsTableEmpty(tMAAToAdvance))) end


    --If enemy has air units in this zone then send the MAA to advance units towards it, but avoid enemy land units
    if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Number of MAA units to advance='..table.getn(tMAAToAdvance)..'; Is table of enemy air units for this LZ '..iLandZone..' empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]))) end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) == false then
            --Move towards the nearest enemy air unit to the LZ midpoint
            local oNearestEnemyToMidpoint
            local iClosestDist = 100000
            local iCurDist
            --Get closest enemy air unit
            for iUnit, oUnit in tLZTeamData[M28Map.reftLZEnemyAirUnits] do
                iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefLZMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                if iCurDist < iClosestDist then
                    iClosestDist = iCurDist
                    oNearestEnemyToMidpoint = oUnit
                end
            end

            --Move towards the air unit
            local tOrderPosition = oNearestEnemyToMidpoint:GetPosition()
            if bDebugMessages == true then LOG(sFunctionRef..': Will order every MAA to move to oNearestEnemyToMidpoint='..oNearestEnemyToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToMidpoint)..' at position '..repru(oNearestEnemyToMidpoint:GetPosition())) end

            for iUnit, oUnit in tMAAToAdvance do
                M28Orders.IssueTrackedMove(oUnit, tOrderPosition, 7, false, 'MNA')
            end

        else

            if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                --Cycle through each land zone in order of distance from us, and assign MAA there until have no MAA left to assign, or no more LZs
                for iEntry, tPathDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering each LZ that needs MAA support based on closest to us, cur entry=LZ'..tPathDetails[M28Map.subrefLZNumber]..'; MAA threat wanted='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZMAAThreatWanted]..'; GroundAA have already='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZThreatAllyGroundAA]..'; Enemy air to ground threat='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.refiLZEnemyAirToGroundThreat]..'; Air othre threat='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.refiLZEnemyAirOtherThreat]..'; Is table of enemy air empty for this alt LZ='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.reftLZEnemyAirUnits]))) end
                    if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZMAAThreatWanted] > M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZThreatAllyGroundAA] then
                        SendMAAToSupportLandZone(tMAAToAdvance, iPlateau, iTeam, tPathDetails[M28Map.subrefLZNumber])
                        if M28Utilities.IsTableEmpty(tMAAToAdvance) then
                            break
                        end
                    end
                end
            end
            --Do we have any MAA remaining after sending MAA to any LZ wanting support?
            if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                local iMAALZToSupport
                local iHighestAirValue = 0
                local iHighestAirLZ
                local iCurAirValue
                for iEntry, tPathDetails in tLZData[M28Map.subrefLZPathingToOtherLandZones] do
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering which adjacent LZ has the biggest air threat for leftover MAA, cur entry=LZ'..tPathDetails[M28Map.subrefLZNumber]..'; MAA threat wanted='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZMAAThreatWanted]..'; GroundAA have already='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZThreatAllyGroundAA]..'; Enemy air to ground threat='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.refiLZEnemyAirToGroundThreat]..'; Air othre threat='..M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.refiLZEnemyAirOtherThreat]..'; Is table of enemy air empty for this alt LZ='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.reftLZEnemyAirUnits]))..' iHighestAirValue so far='..iHighestAirValue) end
                    if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZMAAThreatWanted] > M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZThreatAllyGroundAA] then
                        iCurAirValue = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZMAAThreatWanted] * 0.01 + M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.refiLZEnemyAirToGroundThreat] + M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][tPathDetails[M28Map.subrefLZNumber]][M28Map.subrefLZTeamData][iTeam][M28Map.refiLZEnemyAirOtherThreat] * 0.1
                        if iCurAirValue > iHighestAirValue then
                            iHighestAirValue = iCurAirValue
                            iHighestAirLZ = tPathDetails[M28Map.subrefLZNumber]
                        end
                    end
                end
                iMAALZToSupport = iHighestAirLZ


                if bDebugMessages == true then LOG(sFunctionRef..': Do any adjacent zones want support? iMAALZToSupport='..(iMAALZToSupport or 'nil')) end
                if iMAALZToSupport then
                    local tTargetPosition = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iMAALZToSupport][M28Map.subrefLZMidpoint]
                    for iUnit, oUnit in tMAAToAdvance do
                        M28Orders.IssueTrackedMove(oUnit, tTargetPosition, 10, false, 'MVBLZ'..iMAALZToSupport)
                    end
                else
                    --Go to rally point instead
                    for iUnit, oUnit in tMAAToAdvance do
                        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 10, false, 'BRtr'..iLandZone)
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageCombatUnitsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableCombatUnits, iFriendlyBestMobileDFRange, iFriendlyBestMobileIndirectRange, bWantIndirectReinforcements, tUnavailableUnitsInThisLZ)
    --Handles logic for main combat units (direct and indirect fire mobile units) that are noted as available to the land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageCombatUnitsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    if bDebugMessages == true then LOG(sFunctionRef..': start of code, iTeam='..iTeam..'; iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Is table of available combat units empty='..tostring(M28Utilities.IsTableEmpty(tAvailableCombatUnits))..'; iFriendlyBestMobileDFRange='..iFriendlyBestMobileDFRange..'; iFriendlyBestMobileIndirectRange='..iFriendlyBestMobileIndirectRange..'; Are there enemy units in this or adjacent LZ='..tostring(tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ])) end

    local bWantDFReinforcements = false

    --First record the range of enemy units, and which units in adjacent zones are nearest to us:
    UpdateBestEnemyRangesForThisLandZone(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    local iEnemyBestMobileDFRange, iEnemyBestStructureDFRange, iEnemyBestMobileIndirectRange = RecordClosestAdjacentEnemiesAndGetBestEnemyRange(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
    local tRallyPoint = GetNearestRallyPoint(tLZData, iTeam, iPlateau, iLandZone, 2) --Get a LZ up to 3 land zones away to retreat to (i.e. will pick rally point and then move 2 towards it)
    local iIndirectRunFigureNormal = 10
    local iIndirectRunFigureDeployedAdjust = 15
    local iIndirectDistanceInsideRangeThreshold

    --If enemy has units in this or adjacent LZ, then decide what to do
    if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] then
        local bEnemyHasNoDFUnits = M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestDFEnemies])
        local oNearestEnemyToMidpoint
        local iClosestDist = 100000
        local iCurDist
        local iEnemyBestDFRange = math.max(iEnemyBestMobileDFRange, iEnemyBestStructureDFRange)
        for iUnit, oUnit in tLZTeamData[M28Map.subrefLZTEnemyUnits] do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefLZMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oNearestEnemyToMidpoint = oUnit
            end
        end
        if not(oNearestEnemyToMidpoint) then
            for _, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTEnemyUnits]) == false then
                    for iUnit, oUnit in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTEnemyUnits] do
                        iCurDist = M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefLZMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                        if iCurDist < iClosestDist then
                            iClosestDist = iCurDist
                            oNearestEnemyToMidpoint = oUnit
                        end
                    end
                end
            end
            if not(oNearestEnemyToMidpoint) then M28Utilities.ErrorHandler('LZ has flagged it has enemies here or in adjacent LZ but couldnt find any; iPlateau='..iPlateau..'; LZ='..iLandZone) end
        end

        --Do we have shot blocked on non-skirmisher units, no indirect fire units, and have signficantly more threat than the enemy? If so then move instead of attakc-moving when attacking
        local bMoveBlockedNotAttackMove = false
        if (iFriendlyBestMobileIndirectRange == 0 or tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] > tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal] * 5) and tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal] > tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal] * 2 then
            bMoveBlockedNotAttackMove = true
        end


        if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if should move blocked units, bMoveBlockedNotAttackMove='..tostring(bMoveBlockedNotAttackMove)..'; iFriendlyBestMobileIndirectRange='..iFriendlyBestMobileIndirectRange..';  tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal]='..tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal]..'; tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]='..tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]..'; iFriendlyBestMobileDFRange='..iFriendlyBestMobileDFRange..'; Enemy best DF range='..iEnemyBestDFRange..'; iFriendlyBestMobileIndirectRange='..iFriendlyBestMobileIndirectRange..'; iEnemyBestStructureDFRange='..iEnemyBestStructureDFRange..'; Enemy structure threat indirect='..tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect]..'; bEnemyHasNoDFUnits='..tostring(bEnemyHasNoDFUnits)) end

        --SCENARIO 1 - We outrange enemy DF units (mobile and fix)
        if iFriendlyBestMobileDFRange > iEnemyBestDFRange or (iFriendlyBestMobileIndirectRange > iEnemyBestDFRange and (iEnemyBestStructureDFRange > 0 or tLZTeamData[M28Map.subrefLZThreatEnemyStructureIndirect] > 0)) then
            local tOutrangedCombatUnits = {}
            local tUnitsToSupport = {}
            local bAttackWithOutrangedDFUnits = false
            if tLZTeamData[M28Map.subrefLZTCoreBase] then bAttackWithOutrangedDFUnits = true
            elseif tLZTeamData[M28Map.subrefLZThreatAllyMobileDFTotal] > tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal] then bAttackWithOutrangedDFUnits = true
            end

            local bUpdateNearestUnit = false
            local bCheckIfNearestUnitVisible = false
            if M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToMidpoint:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) >= 10 then bCheckIfNearestUnitVisible = true end

            for iUnit, oUnit in tAvailableCombatUnits do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit for scenario 1, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Close to enemy unit or enemy has no DF units='..tostring(bEnemyHasNoDFUnits or M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiDFRange], iTeam, false))..'; Was last shot blocked='..tostring(oUnit[M28UnitInfo.refbLastShotBlocked] or false)) end

                if oUnit[M28UnitInfo.refiDFRange] > iEnemyBestDFRange then
                    table.insert(tUnitsToSupport, oUnit)
                    --Consider kiting logic unless want to use shot blocked override logic
                    if bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId)) then
                        M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'BlckM'..iLandZone)
                        --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                        if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                    else

                        --Are we in range of any enemy?
                        if bEnemyHasNoDFUnits or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], oUnit[M28UnitInfo.refiDFRange], iTeam, false)) then
                            if bDebugMessages == true then LOG(sFunctionRef..': Not in range of enemy yet, and we outrange enemy; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..oUnit[M28UnitInfo.refiDFRange]..'; oNearestEnemyToMidpoint='..oNearestEnemyToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToMidpoint)..'; oNearestEnemyToMidpoint DF range='..(oNearestEnemyToMidpoint[M28UnitInfo.refiDFRange] or 'nil')..'; Distance to the nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; Enemy unit actual position='..repru(oNearestEnemyToMidpoint:GetPosition())..'; Enemy last recorded position='..repru(oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Our unit position='..repru(oUnit:GetPosition())..'; LZ midpoint position='..repru(tLZData[M28Map.subrefLZMidpoint])) end
                            --Not in range yet, so attack move to the nearest enemy
                            M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit[M28UnitInfo.refiDFRange] * 0.5, false, 'KAMve'..iLandZone)
                        else
                            --Enemy has DF units and they are already in our range so retreat
                            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'KRetr'..iLandZone)
                            --If enemy is able to shoot us then get DF support
                            if not(bAttackWithOutrangedDFUnits) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], 4, iTeam, true) then
                                bAttackWithOutrangedDFUnits = true
                            end
                            --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                            if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                        end
                    end
                else
                    if oUnit[M28UnitInfo.refiDFRange] > 0 then
                        --We dont outrange the enemy, but we do have other units that do
                        table.insert(tOutrangedCombatUnits, oUnit)
                    elseif oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                        if oUnit[M28UnitInfo.refiIndirectRange] > iEnemyBestDFRange then
                            iIndirectDistanceInsideRangeThreshold = iIndirectRunFigureNormal
                            if oUnit[M28UnitInfo.refbWeaponUnpacks] then iIndirectDistanceInsideRangeThreshold = iIndirectDistanceInsideRangeThreshold + iIndirectRunFigureDeployedAdjust end

                            table.insert(tUnitsToSupport, oUnit)

                            if bDebugMessages == true then
                                LOG(sFunctionRef..': Have Indirect unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that doesnt outrange the enemy, WIll list every unit in the nearest DF enemies and their distance to us; our position='..repru(oUnit:GetPosition()))
                                for iEnemy, oEnemy in tLZTeamData[M28Map.reftoNearestDFEnemies] do
                                    LOG(sFunctionRef..': oEnemy '..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..' is '..M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), oUnit:GetPosition())..'; distance based on last known position='..M28Utilities.GetDistanceBetweenPositions(oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; oEnemy DF range='..(oEnemy[M28UnitInfo.refiDFRange] or 'nil')..'; Enemy Indirect range='..(oEnemy[M28UnitInfo.refiIndirectRange] or 'nil'))
                                end
                            end
                            if not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], math.max(oUnit[M28UnitInfo.refiIndirectRange] - iIndirectDistanceInsideRangeThreshold, math.min(iEnemyBestDFRange + 10, oUnit[M28UnitInfo.refiIndirectRange] - 2)), iTeam, false)) then
                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(15, iIndirectDistanceInsideRangeThreshold), false, 'IKAMve'..iLandZone)
                            else
                                --Retreat temporarily from enemy units
                                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'IKRetr'..iLandZone)
                                --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                            end
                        else
                            --Treat the same as outranged DF units
                            table.insert(tOutrangedCombatUnits, oUnit)
                        end
                    else
                        M28Utilities.ErrorHandler('Have a unit without DF or indirect range, so will retreat with it')
                        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'UnkRetr'..iLandZone)
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tOutrangedCombatUnits) == false then
                if bAttackWithOutrangedDFUnits then
                    for iUnit, oUnit in tOutrangedCombatUnits do
                        if bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId)) then
                            M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'OBlckM'..iLandZone)
                            --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                            if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                        else
                            M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], (oUnit[M28UnitInfo.refiDFRange] or oUnit[M28UnitInfo.refiIndirectRange]) * 0.5, false, 'SRDFA'..iLandZone)
                        end
                    end
                else
                    if M28Utilities.IsTableEmpty(tUnitsToSupport) == false then
                        --Short range DF units can stay back and provide support - stay inbetween our long range DF units and the rally point
                        local iCurDist
                        local iClosestDist
                        local oClosestUnit
                        for iSRUnit, oSRUnit in tOutrangedCombatUnits do
                            iClosestDist = 100000
                            for iLRUnit, oLRUnit in tUnitsToSupport do
                                iCurDist = M28Utilities.GetRoughDistanceBetweenPositions(oSRUnit:GetPosition(), oLRUnit:GetPosition())
                                if iCurDist < iClosestDist then
                                    iClosestDist = iCurDist
                                    oClosestUnit = oLRUnit
                                end
                            end
                            M28Orders.IssueTrackedMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), tRallyPoint), 5, true, false), 5, false, 'SRSup'..iLandZone)
                        end
                    else
                        M28Utilities.ErrorHandler('We somehow think we outrange the enemy with DF units, but have no DF units with a long range')
                    end
                end
            end

            if tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal] * 1.5 > M28UnitInfo.GetCombatThreatRating(tAvailableCombatUnits, false, true) then
                bWantDFReinforcements = true
            end

            if bUpdateNearestUnit then
                local aiBrain
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                    aiBrain = oBrain
                    break
                end
                M28Team.UpdateUnitLastKnownPosition(aiBrain, oNearestEnemyToMidpoint, true)
            end
        else
            --SCENARIO 2 - we dont outrange enemy with DF, but have slightly more threat than them
            local bAttackWithEverything = false
            if tLZTeamData[M28Map.subrefLZTCoreBase] then bAttackWithEverything = true end
            local tOurDFAndT1ArtiUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandCombat, tAvailableCombatUnits)
            if M28Utilities.IsTableEmpty(tOurDFAndT1ArtiUnits) == false then
                local iOurCombatThreat = M28UnitInfo.GetCombatThreatRating(tOurDFAndT1ArtiUnits, false)
                if M28Utilities.IsTableEmpty(tUnavailableUnitsInThisLZ) == false then
                    if bDebugMessages == true then LOG(sFunctionRef..'; Combat threat before including unavailable units='..iOurCombatThreat..'; Threat of unavailable units in this LZ='..M28UnitInfo.GetCombatThreatRating(tUnavailableUnitsInThisLZ, false)) end
                    iOurCombatThreat = iOurCombatThreat + M28UnitInfo.GetCombatThreatRating(tUnavailableUnitsInThisLZ, false)
                end

                --Check the threat of our available combat units vs threat of enemy combat units
                local iEnemyCombatThreat = tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal]
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    local tNearbyAdjacentEnemies = {}

                    for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        local iAdjacentDistThreshold = 0
                        local iCurDist
                        for iUnit, oUnit in tOurDFAndT1ArtiUnits do
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefLZMidpoint])
                            if iCurDist > iAdjacentDistThreshold then iAdjacentDistThreshold = iCurDist end
                        end
                        iAdjacentDistThreshold = iAdjacentDistThreshold + 10
                        --Only include units in the threat calculation if they are close enough to this LZ
                        if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTThreatEnemyCombatTotal] > 10 then
                            local tPotentialEnemyUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryLandCombat + M28UnitInfo.refCategoryPD, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTEnemyUnits])
                            if M28Utilities.IsTableEmpty(tPotentialEnemyUnits) == false then
                                for iUnit, oUnit in tPotentialEnemyUnits do
                                    if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefLZMidpoint]) - math.max((oUnit[M28UnitInfo.refiDFRange] or 0), (oUnit[M28UnitInfo.refiIndirectRange] or 0)) <= iAdjacentDistThreshold then
                                        table.insert(tNearbyAdjacentEnemies, oUnit)
                                    end
                                end
                            end
                        end
                    end
                    iEnemyCombatThreat = iEnemyCombatThreat + M28UnitInfo.GetCombatThreatRating(tNearbyAdjacentEnemies, false)
                end
                if not(bAttackWithEverything) and iOurCombatThreat > iEnemyCombatThreat * 1.4 or (iOurCombatThreat > iEnemyCombatThreat and tLZTeamData[M28Map.subrefLZTValue] > iOurCombatThreat * 0.5) or (tLZTeamData[M28Map.subrefLZTCoreBase] and iOurCombatThreat > iEnemyCombatThreat * 0.8) then
                    bAttackWithEverything = true
                end
                if iOurCombatThreat < iEnemyCombatThreat * 1.4 then
                    bWantDFReinforcements = true
                end
                if bDebugMessages == true then LOG(sFunctionRef..': We dont outrange enemy, considering if we have much more threat than them, iEnemyCombatThreat='..iEnemyCombatThreat..'; iOurCombatThreat='..iOurCombatThreat..'; bWantDFReinforcements='..tostring(bWantDFReinforcements)..'; bAttackWithEverything='..tostring(bAttackWithEverything)) end
            else
                bWantDFReinforcements = true
                bAttackWithEverything = false
            end

            if bDebugMessages == true then LOG(sFunctionRef..': Dont outrange enemy, bAttackWithEverything='..tostring(bAttackWithEverything)) end
            local bUpdateNearestUnit = false
            local bCheckIfNearestUnitVisible = false
            if M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToMidpoint:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) >= 10 then bCheckIfNearestUnitVisible = true end

            if bAttackWithEverything then
                for iUnit, oUnit in tAvailableCombatUnits do
                    if oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                        if oUnit[M28UnitInfo.refiIndirectRange] > iEnemyBestDFRange then
                            iIndirectDistanceInsideRangeThreshold = iIndirectRunFigureNormal
                            if oUnit[M28UnitInfo.refbWeaponUnpacks] then iIndirectDistanceInsideRangeThreshold = iIndirectDistanceInsideRangeThreshold + iIndirectRunFigureDeployedAdjust end

                            if not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tLZTeamData[M28Map.reftoNearestDFEnemies], math.max(oUnit[M28UnitInfo.refiIndirectRange] - iIndirectDistanceInsideRangeThreshold, math.min(iEnemyBestDFRange + 10, oUnit[M28UnitInfo.refiIndirectRange] - 2)), iTeam, false)) then
                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(15, iIndirectDistanceInsideRangeThreshold), false, 'I2KAMve'..iLandZone)
                            else
                                --Retreat temporarily from enemy units
                                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'I2KRetr'..iLandZone)
                                --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                            end
                        else
                            --Treat the same as outranged DF units
                            M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'I2AWE'..iLandZone)
                        end
                    else
                        if bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] and not(EntityCategoryContains(M28UnitInfo.refCategorySkirmisher, oUnit.UnitId)) then
                            M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'BAWE'..iLandZone)
                            --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                            if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                        else
                            M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'AWE'..iLandZone)
                        end
                    end
                end
            else
                --Enemy outranges us and we dont ahve enough threat / high enough priority location to defend so want to retreat
                for iUnit, oUnit in tAvailableCombatUnits do
                    --Only retreat units from this LZ
                    if oUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam][iTeam][2] == iLandZone then
                        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'GenRetr'..iLandZone)
                    end
                end
            end

            if bUpdateNearestUnit then
                local aiBrain
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                    aiBrain = oBrain
                    break
                end
                M28Team.UpdateUnitLastKnownPosition(aiBrain, oNearestEnemyToMidpoint, true)
            end
        end
    else
        --Split units available to reinforce into DF and indirect fire units
        local tDFUnits = {}
        local tIndirectUnits = {}
        for iUnit, oUnit in tAvailableCombatUnits do
            if oUnit[M28UnitInfo.refiDFRange] > 0 then
                table.insert(tDFUnits, oUnit)
            elseif oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                table.insert(tIndirectUnits, oUnit)
            else
                M28Utilities.ErrorHandler('Combat unit with no DF or indirect range')
            end
        end
        --Do we have adjacent zones wanting reinforcements?
        local iIndirectLZToSupport
        local iDFLZToSupport
        --if M28Utilities.IsTableEmpty(tDFUnits) then iDFLZToSupport = -1 end --set to -1 so not nil so we can ignore checking the threat for indirect/direct respectively
        --(dont set the DFLZ to -1 yet, as we want to support a zone wanting DF units iwth indirect if we have spare indirect
        if M28Utilities.IsTableEmpty(tIndirectUnits) then iIndirectLZToSupport = -1 end


        if bDebugMessages == true then LOG(sFunctionRef..': Dont have any enemy units in this LZ, so will consider supporting other land zones, is tDFUnits empty='..tostring(M28Utilities.IsTableEmpty(tDFUnits))..'; Is adjacent LZ empty='..tostring(M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]))) end
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                if not(iIndirectLZToSupport) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsIndirectSupport] then
                    iIndirectLZToSupport = iAdjLZ
                    if iDFLZToSupport or M28Utilities.IsTableEmpty(tDFUnits) then break end
                end
                if not(iDFLZToSupport) and (M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport]) then
                    if bDebugMessages == true then LOG(sFunctionRef..': iAdjLZ '..iAdjLZ..' wants DF support so will support here') end
                    iDFLZToSupport = iAdjLZ
                    if  iIndirectLZToSupport then break end
                end
            end
        end
        if iIndirectLZToSupport and not(iDFLZToSupport) and M28Utilities.IsTableEmpty(tDFUnits) then iDFLZToSupport = -1 end

        if not(iIndirectLZToSupport) or not(iDFLZToSupport) then
            --Are there any further away LZs on this plateau that want support?
            local iClosestLZDFDist = 100000
            local iCurDist
            local iClosestLZIndirectDist = 100000
            local iClosestDFLZRef
            local iClosestIndirectLZRef
            if M28Team.tTeamData[iTeam][M28Team.subrefiLandZonesWantingSupportByPlateau][iPlateau] then
                for iOtherLZ, bWantsSupport in M28Team.tTeamData[iTeam][M28Team.subrefiLandZonesWantingSupportByPlateau][iPlateau] do
                    if bWantsSupport then
                        if not(iDFLZToSupport) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsDFSupport] then
                            iCurDist = (M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iOtherLZ) or 100000) --M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefLZMidpoint], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZMidpoint])
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want to support iOtherLZ '..iOtherLZ..'; iCurDist='..iCurDist..'; iClosestLZDFDist='..iClosestLZDFDist..'; straight line dist from our start='..M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZTeamData][iTeam][M28Map.reftClosestFriendlyBase], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZMidpoint])) end
                            if iCurDist < iClosestLZDFDist then
                                iClosestLZDFDist = iCurDist
                                iClosestDFLZRef = iOtherLZ
                            end
                            if not(iIndirectLZToSupport) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsIndirectSupport] then
                                if iCurDist < iClosestLZIndirectDist then
                                    iClosestLZIndirectDist = iCurDist
                                    iClosestIndirectLZRef = iOtherLZ
                                end
                            end
                        elseif not(iIndirectLZToSupport) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsIndirectSupport] then
                            iCurDist = M28Map.GetTravelDistanceBetweenLandZones(iPlateau, iLandZone, iOtherLZ) --M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefLZMidpoint], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iOtherLZ][M28Map.subrefLZMidpoint])
                            if iCurDist < iClosestLZIndirectDist then
                                iClosestLZIndirectDist = iCurDist
                                iClosestIndirectLZRef = iOtherLZ
                            end
                        end
                    end
                end
            end
            if not(iDFLZToSupport) then iDFLZToSupport = iClosestDFLZRef end
            if not(iIndirectLZToSupport) then
                iIndirectLZToSupport = iClosestIndirectLZRef
                if not(iIndirectLZToSupport) then
                    iIndirectLZToSupport = iDFLZToSupport
                end
            end
        end


        if iDFLZToSupport > 0 then
            if bDebugMessages == true then LOG(sFunctionRef..': Want to support LZ '..iDFLZToSupport..'; Will adjust DF to get via point if it is far away') end
            iDFLZToSupport = ReviseTargetLZIfFarAway(tLZData, iTeam, iPlateau, iLandZone, iDFLZToSupport, 2)

            for iUnit, oUnit in tDFUnits do
                M28Orders.IssueTrackedMove(oUnit, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iDFLZToSupport][M28Map.subrefLZMidpoint], 6, false, 'DFMovLZ'..iDFLZToSupport..';'..iLandZone)
            end
            tDFUnits = nil
        end
        if iIndirectLZToSupport > 0 then
            iIndirectLZToSupport = ReviseTargetLZIfFarAway(tLZData, iTeam, iPlateau, iLandZone, iIndirectLZToSupport, 2)
            for iUnit, oUnit in tIndirectUnits do
                M28Orders.IssueTrackedMove(oUnit, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iIndirectLZToSupport][M28Map.subrefLZMidpoint], 6, false, 'IFMovLZ'..iIndirectLZToSupport..';'..iLandZone)
            end
            tIndirectUnits = nil
        end
        if M28Utilities.IsTableEmpty(tDFUnits) == false then
            for iUnit, oUnit in tDFUnits do
                M28Orders.IssueTrackedMove(oUnit, tLZTeamData[M28Map.reftClosestEnemyBase], 6, false, 'MTDEnB'..iLandZone)
            end
        end
        if M28Utilities.IsTableEmpty(tIndirectUnits) == false then
            for iUnit, oUnit in tIndirectUnits do
                M28Orders.IssueTrackedAggressiveMove(oUnit, tLZTeamData[M28Map.reftClosestEnemyBase], 10, false, 'MTIEnB'..iLandZone)
            end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': End of code for iLandZOne '..iLandZone..', bWantDFReinforcements='..tostring(bWantDFReinforcements)..'; bWantIndirectReinforcements='..tostring(bWantIndirectReinforcements)) end
    UpdateIfLandZoneWantsSupport(tLZTeamData, iPlateau, iLandZone, iTeam, bWantDFReinforcements, bWantIndirectReinforcements)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageSpecificLandZone(aiBrain, iTeam, iPlateau, iLandZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageSpecificLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    --Record enemy threat
    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]
    if bDebugMessages == true then LOG(sFunctionRef..': About to update threat for iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; iTeam='..iTeam..'; Is LZData empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData))) end
    RecordGroundThreatForLandZone(tLZTeamData, iTeam, iPlateau, iLandZone)
    RecordAirThreatForLandZone(tLZTeamData, iTeam, iPlateau, iLandZone)

    tLZTeamData[M28Map.subrefLZTAlliedCombatUnits] = {}
    tLZTeamData[M28Map.subrefLZAlliedMAA] = {}

    local tEngineers, tScouts
    local bLandZoneOrAdjHasUnitsWantingScout = false
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]))) end
    local bUpdateEnemyDataHere = true --Will handle this logic in logic for managing land zone units if htis is false
    if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
        --Decide on what to do with units in this LZ
        tEngineers = {}
        tScouts = {}
        local tAvailableCombatUnits = {}
        local tUnavailableUnitsInThisLZ = {}
        local tTempOtherUnits = {}
        local tAvailableMAA = {}
        local iCurLZValue = tLZTeamData[M28Map.subrefLZTValue]

        local iOurBestDFRange = 0
        local iOurBestIndirectRange = 0
        local bIncludeUnit

        for iUnit, oUnit in tLZTeamData[M28Map.subrefLZTAlliedUnits] do
            if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                table.insert(tEngineers, oUnit)
                bLandZoneOrAdjHasUnitsWantingScout = true
            elseif EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                --Do nothing
                bLandZoneOrAdjHasUnitsWantingScout = true
            elseif EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oUnit.UnitId) then
                table.insert(tScouts, oUnit)
            elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA + M28UnitInfo.refCategoryMobileLand - categories.COMMAND - M28UnitInfo.refCategoryRASSACU, oUnit.UnitId) then
                --Tanks, skirmishers, and indirect fire units - handled by main combat unit manager
                bIncludeUnit = false
                bLandZoneOrAdjHasUnitsWantingScout = true
                --Is the unit available for use by this land zone?
                if oUnit:GetFractionComplete() == 1 then
                    --Is the unit's priority lower than this?
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering if have available combat unit, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[refiCurrentAssignmentValue]='..(oUnit[refiCurrentAssignmentValue] or 'nil')..'; oUnit[refiCurrentAssignmentPlateauAndLZ]='..repru(oUnit[refiCurrentAssignmentPlateauAndLZ])) end
                    if (oUnit[refiCurrentAssignmentValue] or 0) < iCurLZValue or (oUnit[refiCurrentAssignmentPlateauAndLZ][1] == iPlateau and (oUnit[refiCurrentAssignmentPlateauAndLZ][2] == iLandZone or (GetGameTimeSeconds() - (oUnit[refiTimeOfLastAssignment] or 0) >= 5))) then
                        if EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId) then
                            table.insert(tAvailableMAA, oUnit)
                            bIncludeUnit =  true
                        elseif ((oUnit[M28UnitInfo.refiDFRange] or 0) > 0 or (oUnit[M28UnitInfo.refiIndirectRange] or 0) > 0) then
                            table.insert(tAvailableCombatUnits, oUnit)
                            table.insert(tLZTeamData[M28Map.subrefLZTAlliedCombatUnits], oUnit)
                            if oUnit[M28UnitInfo.refiDFRange] > iOurBestDFRange then iOurBestDFRange = oUnit[M28UnitInfo.refiDFRange] end
                            if oUnit[M28UnitInfo.refiIndirectRange] > iOurBestIndirectRange then iOurBestIndirectRange = oUnit[M28UnitInfo.refiIndirectRange] end
                            bIncludeUnit = true
                        end
                        if bIncludeUnit then
                            oUnit[refiCurrentAssignmentValue] = iCurLZValue
                            oUnit[refiCurrentAssignmentPlateauAndLZ] = {iPlateau, iLandZone}
                            oUnit[refiTimeOfLastAssignment] = GetGameTimeSeconds()
                        end
                    else
                        table.insert(tUnavailableUnitsInThisLZ, oUnit)
                    end
                end
            elseif EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                --ACU logic - handled via M28ACU file, as amy not want to kite with it
            elseif EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
                --Structure logic - handled separately e.g. via M28Factory for factories
            else
                table.insert(tTempOtherUnits, oUnit)
                LOG('Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to table of temp other units - need to add logic to handle such a unit')
                bLandZoneOrAdjHasUnitsWantingScout = true
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of engineers empty='..tostring(M28Utilities.IsTableEmpty(tEngineers))..'; Is table of combat units just for this zone empty='..tostring(M28Utilities.IsTableEmpty(tAvailableCombatUnits))) end

        local iCurDFThreat = 0
        local iCurIndirectThreat = 0
        local iCurMAAThreat = tLZTeamData[M28Map.subrefLZThreatAllyGroundAA]
        local iMinIndirectRangeNeededForThreat = tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] + 1
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileIndirectByRange] do
                if iRange >= iMinIndirectRangeNeededForThreat then
                    iCurIndirectThreat = iCurIndirectThreat + iThreat
                end
            end
        end
        if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange]) == false then
            for iRange, iThreat in tLZTeamData[M28Map.subrefLZThreatAllyMobileDFByRange] do
                iCurDFThreat = iCurDFThreat + iThreat
            end
        end


        local bConsiderAdjacentDF = false
        local bConsiderAdjacentIndirect = false
        local bConsiderAdjacentMAA = false
        if iCurIndirectThreat < tLZTeamData[M28Map.subrefLZIndirectThreatWanted] then bConsiderAdjacentIndirect = true end
        if iCurDFThreat < tLZTeamData[M28Map.subrefLZDFThreatWanted] then bConsiderAdjacentDF = true end
        if iCurMAAThreat < tLZTeamData[M28Map.subrefLZMAAThreatWanted] then bConsiderAdjacentMAA = true end




        --Add adjacent combat units if the land zone is lower priority than us
        local iCurUnitThreat
        if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false and (bConsiderAdjacentIndirect or bConsiderAdjacentDF) then
            for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                local tAltLZTeam = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; Base LZ='..iLandZone..'; iAdjLZ='..iAdjLZ..'; LZTValue='..repru(tAltLZTeam[M28Map.subrefLZTValue])..'; Is table of allied combat units empty='..tostring(M28Utilities.IsTableEmpty(tAltLZTeam[M28Map.subrefLZTAlliedCombatUnits]))) end
                if not(bLandZoneOrAdjHasUnitsWantingScout) and M28Utilities.IsTableEmpty(tAltLZTeam[M28Map.subrefLZTAlliedCombatUnits]) == false then bLandZoneOrAdjHasUnitsWantingScout = true end
                if tAltLZTeam[M28Map.subrefLZTValue] < iCurLZValue and M28Utilities.IsTableEmpty(tAltLZTeam[M28Map.subrefLZTAlliedCombatUnits]) == false then
                    for iUnit, oUnit in tAltLZTeam[M28Map.subrefLZTAlliedCombatUnits] do
                        if not(oUnit.Dead) and ((oUnit[refiCurrentAssignmentValue] or 0) < iCurLZValue or (oUnit[refiCurrentAssignmentPlateauAndLZ][1] == iPlateau and oUnit[refiCurrentAssignmentPlateauAndLZ][2] == iAdjLZ)) then
                            --Combat unit related
                            if (bConsiderAdjacentDF and oUnit[M28UnitInfo.refiDFRange] > 0) or (bConsiderAdjacentIndirect and oUnit[M28UnitInfo.refiIndirectRange] > 0) then
                                table.insert(tAvailableCombatUnits, oUnit)
                                oUnit[refiCurrentAssignmentValue] = iCurLZValue
                                oUnit[refiCurrentAssignmentPlateauAndLZ] = {iPlateau, iLandZone}
                                oUnit[refiTimeOfLastAssignment] = GetGameTimeSeconds()
                                iCurUnitThreat = nil
                                if oUnit[M28UnitInfo.refiDFRange] > 0 then
                                    if oUnit[M28UnitInfo.refiDFRange] > iOurBestDFRange then iOurBestDFRange = oUnit[M28UnitInfo.refiDFRange] end
                                    iCurUnitThreat = M28UnitInfo.GetCombatThreatRating({ oUnit })
                                    iCurDFThreat = iCurDFThreat + iCurUnitThreat
                                    if iCurDFThreat > tLZTeamData[M28Map.subrefLZDFThreatWanted] then
                                        bConsiderAdjacentDF = false
                                        if not(bConsiderAdjacentIndirect) and not(bConsiderAdjacentMAA) then break end
                                    end
                                end
                                if oUnit[M28UnitInfo.refiIndirectRange] > 0 then
                                    if oUnit[M28UnitInfo.refiIndirectRange] > iOurBestIndirectRange then iOurBestIndirectRange = oUnit[M28UnitInfo.refiIndirectRange] end
                                    if oUnit[M28UnitInfo.refiIndirectRange] > iMinIndirectRangeNeededForThreat then
                                        if not(iCurUnitThreat) then iCurUnitThreat = M28UnitInfo.GetCombatThreatRating({ oUnit }) end
                                        iCurIndirectThreat = iCurIndirectThreat + iCurUnitThreat
                                        if iCurIndirectThreat > tLZTeamData[M28Map.subrefLZIndirectThreatWanted] then
                                            bConsiderAdjacentIndirect = false
                                            if not(bConsiderAdjacentDF) and not(bConsiderAdjacentMAA) then break end
                                        end
                                    end
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId) then
                                table.insert(tAvailableMAA, oUnit)
                                oUnit[refiCurrentAssignmentValue] = iCurLZValue
                                oUnit[refiCurrentAssignmentPlateauAndLZ] = {iPlateau, iLandZone}
                                oUnit[refiTimeOfLastAssignment] = GetGameTimeSeconds()
                                iCurUnitThreat = M28UnitInfo.GetAirThreatLevel({ oUnit }, false, false, true)
                                iCurMAAThreat = iCurMAAThreat + iCurUnitThreat
                                if iCurMAAThreat > tLZTeamData[M28Map.subrefLZMAAThreatWanted] then
                                    bConsiderAdjacentMAA = false
                                    if not(bConsiderAdjacentIndirect) and not(bConsiderAdjacentDF) then break end
                                end
                            end
                        end
                    end
                    if not(bConsiderAdjacentDF) and not(bConsiderAdjacentIndirect) and not(bConsiderAdjacentMAA) then break end
                end
            end
        end

        if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then
            ManageCombatUnitsInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableCombatUnits, iOurBestDFRange, iOurBestIndirectRange, bConsiderAdjacentIndirect, tUnavailableUnitsInThisLZ)
            bUpdateEnemyDataHere = false
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of MAA empty='..tostring(M28Utilities.IsTableEmpty(tAvailableMAA))..'; Is table of entity filtered dow nto MAA empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryMAA, tLZTeamData[M28Map.subrefLZTAlliedUnits])))) end
        if M28Utilities.IsTableEmpty(tAvailableMAA) == false then
            ManageMAAInLandZone(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tAvailableMAA)
        end

        if M28Utilities.IsTableEmpty(tTempOtherUnits) == false then
            M28Utilities.ErrorHandler('To add logic to handle non engineers in a LZ')
        end

    end
    --Update enemy ranges for this LZ and decide if this LZ still wants support, if we havent run our main combat management logic
    if bUpdateEnemyDataHere then
        UpdateBestEnemyRangesForThisLandZone(tLZData, tLZTeamData, iPlateau, iTeam)
        RecordClosestAdjacentEnemiesAndGetBestEnemyRange(tLZData, tLZTeamData, iPlateau, iLandZone, iTeam)
        if tLZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentLZ] and tLZTeamData[M28Map.subrefLZTValue] >= 200 then
            local bWantDFSupport = false
            local bWantIndirectSupport = false
            if tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange] > 0 then bWantIndirectSupport = true end
            if not(bWantIndirectSupport) or tLZTeamData[M28Map.subrefLZThreatEnemyMobileDFByRange] > 0 or tLZTeamData[M28Map.subrefLZThreatEnemyMobileIndirectByRange] > 0 then bWantDFSupport = true end
            UpdateIfLandZoneWantsSupport(tLZTeamData, iPlateau, iLandZone, iTeam, bWantDFSupport, bWantIndirectSupport)
        else
            UpdateIfLandZoneWantsSupport(tLZTeamData, iPlateau, iLandZone, iTeam, false, false)
        end
    end
    --Handle engineers and even if no engineers still decide what engineers we would want for hte LZ
    M28Engineer.ConsiderLandZoneEngineerAssignment(tLZTeamData, iTeam, iPlateau, iLandZone, tEngineers) --Should update the land zone engineer requirements, even if tEngineers itself is empty

    ManageLandZoneScouts(tLZData, tLZTeamData, iTeam, iPlateau, iLandZone, tScouts, bLandZoneOrAdjHasUnitsWantingScout)


    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Is unbuild locations empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZMexUnbuiltLocations]))) end

    --Update BP wanted for adjacent zones - will just have a flag in the engineer assignment that sets subrefLZTbWantBP to true/false so commented out the below
    --[[tLZTeamData[M28Map.subrefLZTAdjacentBPByTechWanted] = {[1]=0, [2]=0,[3]=0}
    tLZTeamData[M28Map.subrefLZTbWantBP] = false
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[M28Map.iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
        for _, iAdjLZ in M28Map.tAllPlateaus[M28Map.iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZAdjacentLandZones] do
            for iTech = 1, 3, 1 do
                tLZTeamData[M28Map.subrefLZTAdjacentBPByTechWanted] = math.max(tLZTeamData[M28Map.subrefLZTAdjacentBPByTechWanted][iTech], (M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTBuildPowerByTechWanted][iTech] or 0))
            end
        end
    end
    for iTech = 1, 3, 1 do
        if tLZTeamData[M28Map.subrefLZTAdjacentBPByTechWanted][iTech] > 0 or tLZTeamData[M28Map.subrefLZTAdjacentBPByTechWanted][iTech] > 0 then
            tLZTeamData[M28Map.subrefLZTbWantBP] = true
        end
    end--]]
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AssignValuesToLandZones(iTeam)
    --Periodically cycles through every land zone and refreshes the unit details
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignValuesToLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local aiBrain = GetFirstActiveBrain(iTeam)

    if bDebugMessages == true then
        LOG(sFunctionRef..': About to start the main loop for assigning values to land zones provided we have friendly M28 brains in the team '..iTeam..'; is table empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))..'; will list out the plateau and LZ for each member of the team')
        local iStartPlateau, iStartLZ
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            iStartPlateau, iStartLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
            LOG(sFunctionRef..': Brain '..oBrain.Nickname..' has start position '..repru(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])..' with iStartPlateau='..(iStartPlateau or 'nil')..' and iStartLZ='..(iStartLZ or 'nil'))
        end
    end
    local iCurValue
    local tFriendlyNonPDBuildings
    local bAdjacentToCoreFactory
    while M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false do

        local tiPlateauAndLZWithFriendlyStartPosition = {}
        local iBaseCategory
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iBrain='..iBrain..'; oBrain='..oBrain.Nickname..'; Army index='..oBrain:GetArmyIndex()..'; Player start point='..repru(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])..'; Plateau and LZ='..iPlateau..'-'..iLandZone) end
            if not(tiPlateauAndLZWithFriendlyStartPosition[iPlateau]) then tiPlateauAndLZWithFriendlyStartPosition[iPlateau] = {} end
            tiPlateauAndLZWithFriendlyStartPosition[iPlateau][iLandZone] = true
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording the friendly start positions for each brain, tiPlateauAndLZWithFriendlyStartPosition='..repru(tiPlateauAndLZWithFriendlyStartPosition)) end
        if M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 3 then iBaseCategory = categories.TECH3 * M28UnitInfo.refCategoryFactory
        elseif M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] >= 2 then iBaseCategory = M28UnitInfo.refCategoryFactory - categories.TECH1
        else iBaseCategory = M28UnitInfo.refCategoryFactory
        end

        for iPlateau, tPlateauData in M28Map.tAllPlateaus do
            if M28Utilities.IsTableEmpty(tPlateauData[M28Map.subrefPlateauLandZones]) == false then
                --tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
                for iLandZone, tLandZoneData in tPlateauData[M28Map.subrefPlateauLandZones] do
                    if bDebugMessages == true then LOG(sFunctionRef..': About to refresh value of iPlateau='..iPlateau..'; iLandZone='..iLandZone..' for team '..iTeam) end
                    --Decide on value of the land zone ignoring distance:
                    --Treat each mex position as being worth 250 mass, value reclaim at 25% of the total value, and reflect the value of all non-PD in the area
                    iCurValue = tLandZoneData[M28Map.subrefLZMexCount] * 250 + (tLandZoneData[M28Map.subrefLZReclaimMass] or 0) * 0.25
                    if M28Utilities.IsTableEmpty(tLandZoneData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTAlliedUnits]) == false then
                        tFriendlyNonPDBuildings = EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure - M28UnitInfo.refCategoryPD, tLandZoneData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTAlliedUnits])
                        iCurValue = iCurValue + M28UnitInfo.GetCombatThreatRating(tFriendlyNonPDBuildings, false, true)
                    end

                    --Record the value
                    tLandZoneData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTValue] = iCurValue

                    tLandZoneData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTCoreBase] = nil
                    --Is this a core base land zone?
                    if tiPlateauAndLZWithFriendlyStartPosition[iPlateau][iLandZone] then
                        tLandZoneData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTCoreBase] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Core LZ='..iLandZone..'; All adjacent zones='..repru(tLandZoneData[M28Map.subrefLZAdjacentLandZones])) end
                    elseif M28Utilities.IsTableEmpty(tLandZoneData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTAlliedUnits]) == false then
                        --Are we adjacent to a core factoroy?  If so then check if we also have a factory of our highest tech level in this zone, and if so treat it as a core base zone
                        bAdjacentToCoreFactory = false
                        if M28Utilities.IsTableEmpty(tLandZoneData[M28Map.subrefLZAdjacentLandZones]) == false then
                            for iEntry, iAdjLZ in tLandZoneData[M28Map.subrefLZAdjacentLandZones] do
                                if tPlateauData[M28Map.subrefPlateauLandZones][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTCoreBase] then
                                    bAdjacentToCoreFactory = true
                                    break
                                end
                            end
                            if bAdjacentToCoreFactory and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(iBaseCategory, tLandZoneData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTAlliedUnits])) == false then
                                tLandZoneData[M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTCoreBase] = true
                            end
                        end

                    end

                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitTicks(1)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageAllLandZones(aiBrain, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageAllLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iLastRefreshCount = (tLZRefreshCountByTeam[iTeam] or 1)
    local iCurRefreshCount = 0
    local iTicksToSpreadOver = 10
    local iRefreshThreshold = math.max(2, math.ceil(iLastRefreshCount * 0.95 / iTicksToSpreadOver))
    local iCurCycleRefreshCount = 0
    local iCurTicksWaited = 0

    local function WantToKeepUnitInTable(tArray, iEntry)
        if tArray[iEntry].Dead then
            return false
        else return true
        end
    end

    if bDebugMessages == true then
        LOG(sFunctionRef..': Start of code, Time='..GetGameTimeSeconds()..'; If have an ACU will list its plateau and land zone')
        local tOurACU = aiBrain:GetListOfUnits(categories.COMMAND, false, true)
        if M28Utilities.IsTableEmpty(tOurACU) == false then
            local iACUPlateau, iACULZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tOurACU[1]:GetPosition(), true, tOurACU[1])
            LOG(sFunctionRef..': ACU is at plateau '..iACUPlateau..'; LZ='..iACULZ)
        end
        LOG(sFunctionRef..': Is plateau 12 LZ 2 empty of allies for team 2='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[12][M28Map.subrefPlateauLandZones][2][M28Map.subrefLZTeamData][2][M28Map.subrefLZTAlliedUnits])))
    end

    if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastRallyPointRefresh] or -100) >= 10 then
        RefreshRallyPoints(iTeam)
    end



    --Cycle through land zones
    for iPlateau, tPlateauData in M28Map.tAllPlateaus do
        if M28Utilities.IsTableEmpty(tPlateauData[M28Map.subrefPlateauLandZones]) == false then
            if bDebugMessages == true then
                LOG(sFunctionRef..': About to cycle through every land zone in plateau '..iPlateau..'; subrefLandZoneCount='..tPlateauData[M28Map.subrefLandZoneCount])
                LOG(sFunctionRef..': Is plateau 12 LZ 2 empty of allies for team 2='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[12][M28Map.subrefPlateauLandZones][2][M28Map.subrefLZTeamData][2][M28Map.subrefLZTAlliedUnits])))
            end
            for iLandZone, tLandZoneDataByTeam in tPlateauData[M28Map.subrefPlateauLandZones] do
                local tLZTeamData = tLandZoneDataByTeam[M28Map.subrefLZTeamData][iTeam]
                if bDebugMessages == true then
                    LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Is table of enemey units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTEnemyUnits]))..'; Is table of friendly units empty='..tostring(M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits])))
                    if iPlateau == 12 and iLandZone == 2 then LOG(sFunctionRef..': Will do reprs of tLZTeamData='..reprs(tLZTeamData)..'; reprs of same table via full ref='..reprs(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][iTeam])..'; Is table empty for team '..aiBrain.M28Team..' doing full ref='..tostring(M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZTAlliedUnits]))) end
                end
                --First check all units in here are alive
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTEnemyUnits]) == false then
                    iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                    UpdateUnitPositionsAndLandZone(aiBrain, tLZTeamData[M28Map.subrefLZTEnemyUnits], iTeam, iPlateau, iLandZone, true)
                end
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftLZEnemyAirUnits]) == false then
                    iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                    UpdateUnitPositionsAndLandZone(aiBrain, tLZTeamData[M28Map.reftLZEnemyAirUnits], iTeam, iPlateau, iLandZone, true, true)
                end
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) == false then
                    iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                    UpdateUnitPositionsAndLandZone(aiBrain, tLZTeamData[M28Map.subrefLZTAlliedUnits], iTeam, iPlateau, iLandZone, false)
                end

                ManageSpecificLandZone(aiBrain, iTeam, iPlateau, iLandZone)
                iCurCycleRefreshCount = iCurCycleRefreshCount + 1

                if iCurCycleRefreshCount >= iRefreshThreshold then
                    iCurRefreshCount = iCurRefreshCount + iCurCycleRefreshCount
                    iCurCycleRefreshCount = 0
                    if iCurTicksWaited < iTicksToSpreadOver then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                        iCurTicksWaited = iCurTicksWaited + 1
                    end
                end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Warning - no land zones found for plateau '..iPlateau) end
        end
    end
    iCurRefreshCount = iCurRefreshCount + iCurCycleRefreshCount
    tLZRefreshCountByTeam[iTeam] = iCurRefreshCount

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetFirstActiveBrain(iTeam)
    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
        if not(oBrain.M28IsDefeated) then
            return oBrain
        end
    end
end

function LandZoneOverseer(iTeam)
    --Periodically cycles through every land zone and refreshes the unit details
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'LandZoneOverseer'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local aiBrain = GetFirstActiveBrain(iTeam)

    if bDebugMessages == true then LOG(sFunctionRef..': About to start the main loop for land zones provided we have friendly M28 brains in the team '..iTeam..'; is table empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        ForkThread(AssignValuesToLandZones, iTeam)
    end

    while M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false do
        if bDebugMessages == true then LOG(sFunctionRef..': Will call logic to refresh every unit in a land zone') end
        ForkThread(ManageAllLandZones, aiBrain, iTeam)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if aiBrain.M28IsDefeated and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
            aiBrain = GetFirstActiveBrain(iTeam)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': About to restart the loop for team '..iTeam..'; aiBrain referred to='..(aiBrain.Nickname or 'nil')..'; Is table of active m28 brains='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetLandZoneToRunTo(iTeam, iPlateau, iCurLandZone, sPathing, tOptionalStartPosition, tOptionalEnemyPositionToRunFrom)
    --Returns cur LZ if no LZ to run to, otherwise returns the land zone we think is best to run to from iCurLandZone
    --tOptionalStartPosition - if nil then will use midpoint of iCurLandZone
    --tOptionalEnemyPositionToRunFrom - if this is specified, then will pick al ocation based on angle from the start position to the location vs the start position angle to the enemy position to run to (so we run in the opposite direction to the enemy position if the opposite direction LZ is safe)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetLandZoneToRunTo'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': iTeam='..iTeam..'; iPlateau='..iPlateau..'; iCurLandZone='..iCurLandZone..'; sPathing='..sPathing..'; tOptionalStartPosition='..repru(tOptionalStartPosition)..'; tOptionalEnemyPositionToRunFrom='..repru(tOptionalEnemyPositionToRunFrom)) end

    local tLZShortlist = {}
    --See if we have any adjacent LZs with no enemy combat units in them - if so, then run here
    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefLZAdjacentLandZones]) == false then
        for _, iAdjacentLZ in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefLZAdjacentLandZones] do
            if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjacentLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTThreatEnemyCombatTotal] == 0 then
                table.insert(tLZShortlist, iAdjacentLZ)
            end
        end
    end
    if M28Utilities.IsTableEmpty(tLZShortlist) then
        --Add each team start point on the same plateau
        local iPotentialPlateau, iPotentialLZ
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            iPotentialPlateau, iPotentialLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
            if iPotentialPlateau == iPlateau and not(iPotentialLZ == iCurLandZone) then
                table.insert(tLZShortlist, iPotentialLZ)
            end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Getting LZ to run to from, iTeam='..iTeam..'; iPlateau='..iPlateau..'; iCurLandZone='..iCurLandZone..'; sPathing='..sPathing..'; tLZShortlist='..repru(tLZShortlist)) end
    if M28Utilities.IsTableEmpty(tLZShortlist) then
        --Nowhere to run to
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return iCurLandZone
    else
        local tStartPoint = (tOptionalStartPosition or M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iCurLandZone][M28Map.subrefLZMidpoint])
        local iPreferredLZRef
        if tOptionalEnemyPositionToRunFrom then
            --Go to the angle furthest in angle away from the nearest enemy
            local iAngleToEnemy = M28Utilities.GetAngleFromAToB(tStartPoint, tOptionalEnemyPositionToRunFrom)
            local iCurAngleDif
            local iHighestAngleDif = 0
            for _, iPossibleLZ in tLZShortlist do
                iCurAngleDif = M28Utilities.GetAngleDifference(iAngleToEnemy, M28Utilities.GetAngleFromAToB(tStartPoint, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleLZ][M28Map.subrefLZMidpoint]))
                if iCurAngleDif > iHighestAngleDif then
                    iHighestAngleDif = iCurAngleDif
                    iPreferredLZRef = iPossibleLZ
                end
            end
        else
            --dont have angle to nearest enemy so just pick the closest land zone

            local iClosestLZDistance = 100000
            local iClosestLZRef
            local iCurDist
            for _, iPossibleLZ in tLZShortlist do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering distance from tStartPoint to iPossibleLZ '..(iPossibleLZ or 'nil')..'; Midpoint of that LZ='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleLZ][M28Map.subrefLZMidpoint])..'; iCurDist='..(M28Utilities.GetTravelDistanceBetweenPositions(tStartPoint, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleLZ][M28Map.subrefLZMidpoint], sPathing) or 'nil')) end
                iCurDist = M28Utilities.GetTravelDistanceBetweenPositions(tStartPoint, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleLZ][M28Map.subrefLZMidpoint], sPathing)
                --Backup - if the built in pathfinding doesnt htink we can path there (e.g. we are by a cliff) then use straight line distance
                if not(iCurDist) then iCurDist = M28Utilities.GetDistanceBetweenPositions(tStartPoint, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleLZ][M28Map.subrefLZMidpoint]) + 30 end

                if iCurDist < iClosestLZDistance then
                    iClosestLZDistance = iCurDist
                    iPreferredLZRef = iPossibleLZ
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return iPreferredLZRef
    end
end

function IsLandZonePathSafe(iPlateau, tLZData, iTeam, iPathingRef)
    --More performant version of IsItSafeToPathBetweenLandZones, to check if safe to path from the tLZData land zone to the tAltLZ land zone, based on iPathingRef for tLZData
    for _, iLandZoneRef in tLZData[M28Map.subrefLZPathingToOtherLandZones][iPathingRef][M28Map.subrefLZPath] do
        --Are there any units in this LZ that are dangerous?
        if M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZoneRef][iTeam][M28Map.subrefbDangerousEnemiesInThisLZ] then
            return false
        end
    end
    return true
end

--Below code should function but when used for engineers took way too long so redid using IsLandZonePathSafe - look to make use of the varaibles recorded for this to come up with a more performant approach to the below if want the below functionality
--[[function IsItSafeToPathBetweenLandZones(iTeam, iPlateau, iStartLandZone, iEndLandZone, sPathing)
    --Returns true if no enemy threats in any of the land zones that will path through (doesnt consider adjacent zones for performance reasons)
        --Only combat threats should be considered
        --WARNING - Very intensive function, use sparingly - in most cases referring to subrefLZPathingToOtherLandZones is better which will record 3 layers of adjacency to the current zone (more for core LZs)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsItSafeToPathBetweenLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tFullPath, iPathSize, iDistance = NavUtils.PathTo((sPathing or 'Land'), M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iStartLandZone][M28Map.subrefLZMidpoint], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iEndLandZone][M28Map.subrefLZMidpoint], nil)
    if M28Utilities.IsTableEmpty(tFullPath) == false then
        local tLZConsidered = {}
        local iCurPlateau, iCurLZ
        for iPath, tPath in tFullPath do
            iCurPlateau, iCurLZ = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tPath)
            if iCurPlateau and iCurLZ then
                if not(tLZConsidered[iCurLZ]) then
                    tLZConsidered[iCurLZ] = true
                    --Are there any units in this LZ that are dangerous?
                    if M28Utilities.IsTableEmpty(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iCurLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTEnemyUnits]) == false then
                        for iUnit, oUnit in M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iCurLZ][M28Map.subrefLZTeamData][iTeam][M28Map.subrefLZTEnemyUnits] do
                            if ((oUnit[M28UnitInfo.refiDFRange] or 0) > 0 or (oUnit[M28UnitInfo.refiIndirectRange] or 0) > 0) and not(EntityCategoryContains(M28UnitInfo.refCategoryLandScout - categories.SERAPHIM, oUnit.UnitId)) then
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                return false
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return true
end--]]

function DrawReclaimSegmentsInLandZone(iPlateau, iLandZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DrawReclaimSegmentsInLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone]
    local rCurRect
    if bDebugMessages == true then LOG(sFunctionRef..': About to draw reclaim segnemtns for iPlateau '..iPlateau..' iLandZone '..iLandZone..'; Table of reclaim segments='..repru(tLZData[M28Map.subrefLZReclaimSegments])) end

    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZReclaimSegments]) == false then
        for iCount, tSegmentXZ in tLZData[M28Map.subrefLZReclaimSegments] do
            rCurRect = M28Utilities.GetRectAroundLocation(M28Map.tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][M28Map.refReclaimSegmentMidpoint], M28Map.iReclaimSegmentSizeX * 0.5)
            M28Utilities.DrawRectangle(rCurRect)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)

end

function UpdateRadarCoverageForDestroyedRadar(oRadar)
    if M28Utilities.IsTableEmpty(oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam]) == false then
        for iTeam, tRadarData in oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam] do
            --local aiBrain = oRadar:GetAIBrain()
            --local iTeam = aiBrain.M28Team
            if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
                local aiBrain
                for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                    aiBrain = oBrain
                    break
                end
                for iEntry, tiPlateauAndLZ in tRadarData do
                    local tLZData = M28Map.tAllPlateaus[tiPlateauAndLZ[1]][M28Map.subrefPlateauLandZones][tiPlateauAndLZ[2]]
                    if tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar] == oRadar then
                        tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar] = nil
                        tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] = 0
                        local tNearbyRadar = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryRadar, tLZData[M28Map.subrefLZMidpoint], 600, 'Ally')
                        local iCurIntelRange
                        local iBestIntelRange = 0
                        local oBestRadar
                        if M28Utilities.IsTableEmpty(tNearbyRadar) == false then
                            for iUnit, oUnit in tNearbyRadar do
                                iCurIntelRange = (oUnit:GetBlueprint().Intel.RadarRadius or 0) - M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tLZData[M28Map.subrefLZMidpoint])
                                if iCurIntelRange > iBestIntelRange then
                                    iBestIntelRange = iCurIntelRange
                                    oBestRadar = oUnit
                                end
                            end
                        end
                        if oBestRadar then
                            tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar] = oBestRadar
                            tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] = iBestIntelRange
                            if not(oBestRadar[reftiRadarPlateauAndLandZonesCoveredByTeam]) then oBestRadar[reftiRadarPlateauAndLandZonesCoveredByTeam] = {} end
                            if not(oBestRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam]) then oBestRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam] = {} end
                            table.insert(oBestRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam], {tiPlateauAndLZ[1], tiPlateauAndLZ[2]})
                        end
                    end
                end
            end
        end
    end
end

function UpdateLandZoneIntelForRadar(oRadar)
    --If just built radar then want to update all land zones for the team to indicate the intel coverage
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateLandZoneIntelForRadar'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iTeam = oRadar:GetAIBrain().M28Team
    if bDebugMessages == true then LOG(sFunctionRef..': Just built radar '..oRadar.UnitId..M28UnitInfo.GetUnitLifetimeCount(oRadar)..' owned by '..oRadar:GetAIBrain().Nickname..' with M28Team '..iTeam..'; is the table of active m28 brains for this team empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        if not(oRadar['M28UpdatedIntel']) then
            oRadar['M28UpdatedIntel'] = true
            local iIntelRange = (oRadar:GetBlueprint().Intel.RadarRadius or 0)
            local iCurIntelRange
            if bDebugMessages == true then LOG(sFunctionRef..': Radar intel range='..iIntelRange) end
            if iIntelRange > 0 then
                for iPlateau, tPlateauSubtable in M28Map.tAllPlateaus do
                    for iLandZone, tLZData in tPlateauSubtable[M28Map.subrefPlateauLandZones] do
                        if tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] < iIntelRange then
                            iCurIntelRange = iIntelRange - M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefLZMidpoint], oRadar:GetPosition())
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateau '..iPlateau..' Land zone '..iLandZone..'; iCurIntelRange factoring in distance='..iCurIntelRange..'; Distance='..M28Utilities.GetDistanceBetweenPositions(tLZData[M28Map.subrefLZMidpoint], oRadar:GetPosition())..'; LZ current radar coverage='..tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage]) end
                            if iCurIntelRange > tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] then
                                --First remove this plateau and LZ from the existing radar if there was one
                                if M28UnitInfo.IsUnitValid(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar]) then
                                    if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar][reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam]) == false then
                                        for iEntry, tiPlateauAndLZ in tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar][reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam] do
                                            if tiPlateauAndLZ[1] == iPlateau and tiPlateauAndLZ[2] == iLandZone then
                                                table.remove(tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar][reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam], iEntry)
                                                break
                                            end
                                        end
                                    end
                                end
                                tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage] = iCurIntelRange
                                tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refoBestRadar] = oRadar
                                if not(oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam]) then oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam] = {} end
                                if not(oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam]) then oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam] = {} end
                                table.insert(oRadar[reftiRadarPlateauAndLandZonesCoveredByTeam][iTeam], {iPlateau, iLandZone})
                                if bDebugMessages == true then LOG(sFunctionRef..': Finished udpating for the new intel range, tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage]='..tLZData[M28Map.subrefLZTeamData][iTeam][M28Map.refiRadarCoverage]) end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end