---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 18/01/2023 06:57
---
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local XZDist = import('/lua/utilities.lua').XZDistanceTwoVectors

function MoveAwayFromTargetTemporarily(oUnit, iTimeToRun, tPositionToRunFrom)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MoveAwayFromTargetTemporarily'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local bMoveInStages = false --set to true later if hardly have any time to run, but in reality this functionality isn't expected to be used in most cases, left in since took a while to get it to work to a basic level, but turns out it's probably better to just move in a straight line rather than trying multiple move orders


    local tUnitPosition = oUnit:GetPosition()
    local oBP = oUnit:GetBlueprint()
    local iUnitSpeed = oBP.Physics.MaxSpeed
    local iDistanceToMove = (iTimeToRun + 1) * iUnitSpeed
    --local tRevisedPositionToRunFrom

    local iCurFacingDirection = M28UnitInfo.GetUnitFacingAngle(oUnit)
    local iAngleFromUnitToBomb
    if tUnitPosition[1] == tPositionToRunFrom[1] and tUnitPosition[3] == tPositionToRunFrom[3] then
        iAngleFromUnitToBomb = iCurFacingDirection - 180
        if iAngleFromUnitToBomb < 0 then iAngleFromUnitToBomb = iAngleFromUnitToBomb + 360 end
    else
        iAngleFromUnitToBomb = M28Utilities.GetAngleFromAToB(oUnit:GetPosition(), tPositionToRunFrom)
    end

    local iAngleAdjFactor
    local iFacingAngleWanted = iAngleFromUnitToBomb + 180
    if iFacingAngleWanted >= 360 then iFacingAngleWanted = iFacingAngleWanted - 360 end

    local iTurnRate = (oBP.Physics.TurnRate or 90)
    local iTimeToTurn = math.abs(iFacingAngleWanted - iCurFacingDirection) / iTurnRate
    local iDistToBomb = M28Utilities.GetDistanceBetweenPositions(tPositionToRunFrom, oUnit:GetPosition())
    if iDistToBomb * 2 / iUnitSpeed <= iTimeToTurn then
        iFacingAngleWanted = iCurFacingDirection
        iDistanceToMove = iDistanceToMove + iDistToBomb
    end
    if iTimeToTurn > iTimeToRun then bMoveInStages = true end

    local tTempLocationToMove

    if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop for move commands for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTimeToRun='..iTimeToRun..'; iCurFacingDirection='..iCurFacingDirection..'; iAngleFromUnitToBomb='..iAngleFromUnitToBomb..'; iFacingAngleWanted='..iFacingAngleWanted..'; tUnitStartPosition='..repru(oUnit:GetPosition())..'; tPositionToRunFrom='..repru(tPositionToRunFrom)) end
    M28Orders.IssueTrackedClearCommands(oUnit)
    TrackTemporaryUnitMicro(oUnit, iTimeToRun)
    tTempLocationToMove = oUnit:GetPosition()
    local iDistanceAlreadyMoved = 0


    --Turn around while moving away if we're not facing the right direction:
    if bMoveInStages then
        local iInitialAngleAdj = 30
        local iAngleMaxSingleAdj = 45
        local iTempDistanceAwayToMove = 3
        local iDistanceIncreasePerCycle = 1.5
        local iDistanceIncreaseCompoundFactor = 1.5
        local iLoopCount = 0

        if math.abs(iCurFacingDirection - iFacingAngleWanted) > (iAngleMaxSingleAdj + iInitialAngleAdj) then
            local iTempAngleDirectionToMove = iCurFacingDirection

            if iCurFacingDirection - iFacingAngleWanted > 0 then
                if iCurFacingDirection - iFacingAngleWanted > 180 then iAngleAdjFactor = 1 --Clockwise
                else iAngleAdjFactor = -1 --AntiClockwise
                end

            elseif iCurFacingDirection - iFacingAngleWanted < -180 then iAngleAdjFactor = -1
            else iAngleAdjFactor = 1
            end --Clockwise



            while iLoopCount < 6 do
                iLoopCount = iLoopCount + 1

                iTempAngleDirectionToMove = iCurFacingDirection + (iInitialAngleAdj + iLoopCount * iAngleMaxSingleAdj) * iAngleAdjFactor
                if iTempAngleDirectionToMove > 360 then iTempAngleDirectionToMove = iTempAngleDirectionToMove - 360
                elseif iTempAngleDirectionToMove < 0 then iTempAngleDirectionToMove = iTempAngleDirectionToMove + 360
                end

                if bDebugMessages == true then LOG(sFunctionRef..': iLoopCount='..iLoopCount..'; iTempAngleDirectionToMove='..iTempAngleDirectionToMove..'; iInitialAngleAdj='..iInitialAngleAdj..'; iAngleAdjFactor='..iAngleAdjFactor..'; iCurFacingDirection='..iCurFacingDirection..'; iFacingAngleWanted='..iFacingAngleWanted) end


                iTempDistanceAwayToMove = iTempDistanceAwayToMove + iDistanceIncreasePerCycle * iDistanceIncreasePerCycle * (iDistanceIncreaseCompoundFactor ^ iLoopCount - 1)
                tTempLocationToMove = M28Utilities.MoveInDirection(oUnit:GetPosition(), iTempAngleDirectionToMove, iTempDistanceAwayToMove)
                M28Orders.IssueTrackedMove(oUnit, tTempLocationToMove, 0.25, true, 'TempMA', true)
                if bDebugMessages == true then LOG(sFunctionRef..': Just issued move order to tTempLocationToMove='..repru(tTempLocationToMove)..'; iTempAngleDirectionToMove='..iTempAngleDirectionToMove) end
                if math.abs(iTempAngleDirectionToMove - iFacingAngleWanted) <= iAngleMaxSingleAdj then break
                elseif math.abs(iTempAngleDirectionToMove - iFacingAngleWanted) > 360 then
                    M28Utilities.ErrorHandler('Something has gone wrong with dodge micro, will stop trying to turn around')
                    break
                end
            end
            iDistanceAlreadyMoved = M28Utilities.GetDistanceBetweenPositions(tTempLocationToMove, tPositionToRunFrom)
        end
    end

    --Should now be facing close to the right direction, so move further in this direction

    local tNewTargetIgnoringGrouping = M28Utilities.MoveInDirection(oUnit:GetPosition(), iFacingAngleWanted, math.max(1, iDistanceToMove - iDistanceAlreadyMoved))
    if bDebugMessages == true then LOG(sFunctionRef..': Finished trying to face the right direction, tNewTargetIgnoringGrouping='..repru(tNewTargetIgnoringGrouping)..'; tUnitPosition='..repru(tUnitPosition)..'; iDistanceToMove='..iDistanceToMove..'; iDistanceAlreadyMoved='..iDistanceAlreadyMoved) end

    local tNewTargetInSameGroup = M28Map.GetPositionAtOrNearTargetInPathingGroup(tUnitPosition, tNewTargetIgnoringGrouping, 0, 0, oUnit, true, false)
    if tNewTargetInSameGroup then
        if bDebugMessages == true then LOG(sFunctionRef..': Starting bomber dodge for unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; tNewTargetInSameGroup='..repru(tNewTargetInSameGroup)) end

        M28Orders.IssueTrackedMove(oUnit, tNewTargetInSameGroup, 0.25, true, 'TempMA', true)
        TrackTemporaryUnitMicro(oUnit, iTimeToRun)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetBombTarget(weapon, projectile)
    --based on CalcBallisticAcceleration

    --Copy of CalcBallisticAcceleration core part of calculation to determine bomb target; ignores multiple bombs
    local acc = 4.75
    if projectile and projectile.GetLauncher then
        local launcher = projectile:GetLauncher()
        if launcher then
            -- Get projectile position and velocity
            -- velocity needs to multiplied by 10 due to being returned /tick instead of /s
            local proj = {pos=projectile:GetPosition(), vel=VMult(Vector(launcher:GetVelocity()), 10)}
            local entity = launcher:GetTargetEntity()

            local target
            if entity and IsUnit(entity) then
                -- target is a entity
                target = {pos=entity:GetPosition(), vel=VMult(Vector(entity:GetVelocity()), 10)}
            else
                -- target is something else i.e. attack ground
                target = {pos=weapon:GetCurrentTargetPos(), vel=Vector(0, 0, 0)}
            end

            -- calculate flat(exclude y-axis) distance and velocity between projectile and target
            if M28Utilities.IsTableEmpty(target) == false and M28Utilities.IsTableEmpty(proj.pos) == false and target.pos and target.vel and proj.pos and target.pos then
                local dist = {pos=XZDist(proj.pos, target.pos), vel=XZDist(proj.vel, target.vel)}

                -- how many seconds until the bomb hits the target in xz-space
                local time = dist.pos / dist.vel
                if time == 0 then return acc end

                -- find out where the target will be at that point in time (it could be moving)
                target.tpos = {target.pos[1] + time * target.vel[1], 0, target.pos[3] + time * target.vel[3]}
                -- what is the height at that future position
                target.tpos[2] = GetSurfaceHeight(target.tpos[1], target.tpos[3])
                return target.tpos
            end
        end
    elseif not(projectile) and weapon.GetCurrentTarget then
        if weapon:GetCurrentTarget().GetPosition then return weapon:GetCurrentTarget():GetPosition() end
    end
    return nil
end

function DodgeBomb(oBomber, oWeapon, projectile)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DodgeBombsFiredByUnit'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tBombTarget = GetBombTarget(oWeapon, projectile)
    if tBombTarget then
        local iBombSize = 2.5
        if oWeapon.GetBlueprint then iBombSize = math.max(iBombSize, (oWeapon:GetBlueprint().DamageRadius or iBombSize)) end
        local iTimeToRun = 1.75 --T1
        if iBombSize > 2.5 then iTimeToRun = math.min(2.6, iTimeToRun + (iBombSize - 2.5) * 0.5) end
        if EntityCategoryContains(categories.TECH2, oBomber.UnitId) then
            iBombSize = 3
            iTimeToRun = 1.95
            if iBombSize > 3 then iTimeToRun = math.min(2.6, iTimeToRun + (iBombSize - 3) * 0.5) end
        elseif EntityCategoryContains(categories.TECH3, oBomber.UnitId) then
            iTimeToRun = 2.5
        end --Some t2 bombers do damage in a spread (cybran, uef)
        --local iTimeToRun = math.min(7, iBombSize + 1)
        local iRadiusSize = iBombSize + 1

        local iBomberArmyIndex = oBomber:GetAIBrain():GetArmyIndex()

        if bDebugMessages == true then
            LOG(sFunctionRef..': oBomber='..oBomber.UnitId..M28UnitInfo.GetUnitLifetimeCount(oBomber)..'; Bomber position='..repru(oBomber:GetPosition())..'; tBombTarget='..repru(tBombTarget)..'; Dist between position and target='..M28Utilities.GetDistanceBetweenPositions(oBomber:GetPosition(), tBombTarget)..'; Angle='..M28Utilities.GetAngleFromAToB(oBomber:GetPosition(), tBombTarget)..'; Bomber facing direction='..M28UnitInfo.GetUnitFacingAngle(oBomber)..'; will draw bomb target in black')
            M28Utilities.DrawLocation(tBombTarget, 3, 20)
        end --black ring around target

        local tAllUnitsInArea = GetUnitsInRect(Rect(tBombTarget[1]-iRadiusSize, tBombTarget[3]-iRadiusSize, tBombTarget[1]+iRadiusSize, tBombTarget[3]+iRadiusSize))
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of units in rectangle around bomb radius empty='..tostring(M28Utilities.IsTableEmpty(tAllUnitsInArea))) end
        if M28Utilities.IsTableEmpty(tAllUnitsInArea) == false then
            local tMobileLandInArea = EntityCategoryFilterDown(M28UnitInfo.refCategoryMobileLand - categories.EXPERIMENTAL, tAllUnitsInArea)
            if bDebugMessages == true then LOG(sFunctionRef..': Is table of mobile land units in rectangle around bomb radius empty='..tostring(M28Utilities.IsTableEmpty(tMobileLandInArea))) end
            if M28Utilities.IsTableEmpty(tMobileLandInArea) == false then
                local oCurBrain
                for iUnit, oUnit in tMobileLandInArea do
                    if not(oUnit.Dead) and oUnit.GetUnitId and oUnit.GetPosition and oUnit.GetAIBrain then
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Does unit already have micro active='..tostring((oUnit[M28UnitInfo.refbSpecialMicroActive] or false))..'; iTimeToRun='..iTimeToRun) end
                        oCurBrain = oUnit:GetAIBrain()
                        if oCurBrain.M28AI and not(oCurBrain.M28IsDefeated) and not(oCurBrain:IsDefeated()) and IsEnemy(oCurBrain:GetArmyIndex(), iBomberArmyIndex) then
                            --ACU specific
                            if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                                local aiBrain = oCurBrain
                                --If ACU is upgrading might not want to cancel
                                local bDontTryAndDodge = false
                                if oUnit:IsUnitState('Upgrading') then
                                    --Are we facing a T1 bomb?
                                    if EntityCategoryContains(categories.TECH1, oBomber.UnitId) then
                                        bDontTryAndDodge = true
                                    else
                                        --Facing T2+ bomb, so greater risk if we dont try and dodge; dont dodge if are almost complete
                                        if oUnit:GetWorkProgress() >= 0.9 then
                                            bDontTryAndDodge = true
                                        else
                                            --Is it a T2 bomber, and there arent many bombers nearby?
                                            if EntityCategoryContains(categories.TECH2, oBomber.UnitId) then
                                                local tNearbyBombers = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryBomber + M28UnitInfo.refCategoryGunship - categories.TECH1, oUnit:GetPosition(), 100, 'Enemy')
                                                if M28Utilities.IsTableEmpty(tNearbyBombers) == true then
                                                    bDontTryAndDodge = true
                                                else
                                                    local iEnemyBomberCount = 0
                                                    for iEnemy, oEnemy in tNearbyBombers do
                                                        if M28UnitInfo.IsUnitValid(oEnemy) then
                                                            iEnemyBomberCount = iEnemyBomberCount + 1
                                                            if iEnemyBomberCount >= 4 then break end
                                                        end
                                                    end
                                                    if iEnemyBomberCount < 4 then bDontTryAndDodge = true end
                                                end
                                            end
                                        end
                                    end
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': bDontTryAndDodge after checking if upgrading='..tostring(bDontTryAndDodge)) end
                                if not(bDontTryAndDodge) then
                                    --Is there a significant enemy land threat and we are against a T1 bomber?
                                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                                    if iLandZone > 0 and EntityCategoryContains(categories.TECH1, oBomber.UnitId) and M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][aiBrain.M28Team][M28Map.subrefLZTThreatEnemyCombatTotal] * 1.2 > math.min(300, M28UnitInfo.GetCombatThreatRating({ oUnit }, false, false, false, false, false, false, false)) then
                                        bDontTryAndDodge = true
                                    end
                                end

                                if not(bDontTryAndDodge) then
                                    if oUnit[M28UnitInfo.refbSpecialMicroActive] then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will move in a circle as micro is already active') end
                                        MoveInCircleTemporarily(oUnit, iTimeToRun)
                                    else
                                        if bDebugMessages == true then LOG(sFunctionRef..': Will move away from bomb target temporarily') end
                                        MoveAwayFromTargetTemporarily(oUnit, iTimeToRun, tBombTarget)
                                        oUnit[M28UnitInfo.refiGameTimeMicroStarted] = GetGameTimeSeconds()
                                    end
                                end

                            else
                                --Are we a mobile shield that isn't on the same team as the bomber? If so, then dont worry about dodging
                                if not(EntityCategoryContains(M28UnitInfo.refCategoryMobileLandShield, oUnit.UnitId)) or (oUnit.MyShield:GetHealth() == 0 or not(oUnit.MyShield.Enabled) or oUnit.MyShield.DepletedByEnergy) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': about to call moveawayfromtargettemporarily') end
                                    MoveAwayFromTargetTemporarily(oUnit, iTimeToRun, tBombTarget)
                                    oUnit[M28UnitInfo.refiGameTimeMicroStarted] = GetGameTimeSeconds()
                                end
                            end
                        end
                    end
                end
            end
        end
    else
        if bDebugMessages == true then LOG(sFunctionRef..': tBombTarget is nil') end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderDodgingShot(oUnit, oWeapon)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderDodgingShot'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --if EntityCategoryContains(categories.TECH2, oUnit.UnitId) then bDebugMessages = true end
    if bDebugMessages == true then
        LOG(sFunctionRef..': Just fired, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit))
        if oWeapon.GetCurrentTarget then
            LOG(sFunctionRef..': Is current target valid='..tostring(M28UnitInfo.IsUnitValid(oWeapon:GetCurrentTarget()))..'; Weapon category='..oWeapon.Blueprint.WeaponCategory)
            if not(M28UnitInfo.IsUnitValid(oWeapon:GetCurrentTarget())) then
                LOG(sFunctionRef..': Invalid target, will do reprs of it:'..reprs(oWeapon:GetCurrentTarget())..' will also draw black square around the weapon target position which is '..repru(oWeapon:GetCurrentTargetPos()))
                M28Utilities.DrawLocation(oWeapon:GetCurrentTargetPos(), nil, 3, 200)
            else
                LOG(sFunctionRef..': Valid target='..oWeapon:GetCurrentTarget().UnitId..M28UnitInfo.GetUnitLifetimeCount(oWeapon:GetCurrentTarget()))
            end
        else
            LOG(sFunctionRef..': Dont have a current target for this weapon')
        end
    end
    --Direct fire, t1 mobile arti, t2 mobile missile launchers, and experimental land
    if oWeapon.GetCurrentTarget and (oWeapon.Blueprint.WeaponCategory == 'Direct Fire' or oWeapon.Blueprint.WeaponCategory == 'Direct Fire Naval' or oWeapon.Blueprint.WeaponCategory == 'Direct Fire Experimental' or (oWeapon.Blueprint.WeaponCategory == 'Artillery' and EntityCategoryContains(categories.TECH1, oUnit.UnitId)) or (oWeapon.Blueprint.WeaponCategory == 'Missile' and oWeapon.Blueprint.MaxRadius <= 80)) or (oWeapon.Blueprint.WeaponCategory == 'Indirect Fire' and oWeapon.Blueprint.MuzzleVelocity <= 25) then
        if bDebugMessages == true then LOG(sFunctionRef..': Have a valid weapon category, will see if have targets to consider dodging') end
        local oWeaponTarget = oWeapon:GetCurrentTarget()
        local bConsiderUnitsInArea = false
        if not(M28UnitInfo.IsUnitValid(oWeaponTarget)) or EntityCategoryContains(categories.NAVAL * categories.MOBILE, oWeaponTarget.UnitId) then bConsiderUnitsInArea = true end

        local tUnitsToConsiderDodgeFor = {}
        function ConsiderAddingUnitToTable(oCurUnit, bIncludeBusyUnits)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering if we should add oCurUnit='..oCurUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oCurUnit)..'; Brain='..oCurUnit:GetAIBrain().Nickname..'; Unit state='..M28UnitInfo.GetUnitState(oCurUnit)..'; Special micro active='..tostring(oCurUnit[M28UnitInfo.refbSpecialMicroActive] or false)) end
            if oCurUnit:GetAIBrain().M28AI and (bIncludeBusyUnits or (not(oCurUnit:IsUnitState('Upgrading')) and not(oCurUnit[M28UnitInfo.refbSpecialMicroActive]))) then
                if EntityCategoryContains(categories.AIR + categories.STRUCTURE, oCurUnit.UnitId) then
                    --Do nothing
                elseif EntityCategoryContains(categories.MOBILE, oCurUnit.UnitId) then
                    if oCurUnit:GetFractionComplete() == 1 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Added unit to table of units to consider dodging for') end
                        table.insert(tUnitsToConsiderDodgeFor, oCurUnit)
                    end
                end
            end
        end
        local bIncludeBusyUnits = false
        if oWeapon.Blueprint.Damage >= 5000 then bIncludeBusyUnits = true end
        if not(bConsiderUnitsInArea) then
            --Is it a unit with a shield?
            if EntityCategoryContains(categories.SHIELD, oWeaponTarget.UnitId) then
                local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oWeaponTarget, true)
                if (iCurShield or 0) <= (iMaxShield or 0) * 0.2 then
                    ConsiderAddingUnitToTable(oWeaponTarget, bIncludeBusyUnits)
                end
            else
                ConsiderAddingUnitToTable(oWeaponTarget, bIncludeBusyUnits)
            end

        else
            --Does the weapon have an aoe?
            if (oWeapon.Blueprint.DamageRadius or 0) > 0.1 then
                --Get all units in area
                local tWeaponTarget = oWeapon:GetCurrentTargetPos()
                if M28Utilities.IsTableEmpty(tWeaponTarget) == false then
                    local iRadiusSize = math.min(3, math.max(oWeapon.Blueprint.DamageRadius, 1))
                    local tAllUnitsInArea = GetUnitsInRect(Rect(tWeaponTarget[1]-iRadiusSize, tWeaponTarget[3]-iRadiusSize, tWeaponTarget[1]+iRadiusSize, tWeaponTarget[3]+iRadiusSize))
                    if M28Utilities.IsTableEmpty(tAllUnitsInArea) == false then
                        --Do we have shield units in the area with at least 20% shield? Will assume shield covers all the units
                        local tShieldsInArea = EntityCategoryFilterDown(categories.SHIELD, tAllUnitsInArea)
                        local bUnderMobileShield = false
                        if M28Utilities.IsTableEmpty(tShieldsInArea) == false then
                            local iCurShield, iMaxShield
                            for iShield, oShield in tShieldsInArea do
                                iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oShield, true)
                                if bDebugMessages == true then LOG(sFunctionRef..': oCurUnit='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..'; iCurShield='..iCurShield..'; iMaxShield='..iMaxShield) end
                                if (iCurShield or 0) > (iMaxShield or 0) * 0.2 then
                                    bUnderMobileShield = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Unit has at least 20% shield remaining so wont dodge') end
                                    break
                                end
                            end
                        end
                        if not(bUnderMobileShield) then
                            for iNearbyUnit, oNearbyUnit in tAllUnitsInArea do
                                ConsiderAddingUnitToTable(oNearbyUnit, bIncludeBusyUnits)
                            end
                        end
                    end
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of units to consider dodging empty='..tostring(M28Utilities.IsTableEmpty(tUnitsToConsiderDodgeFor))..'; Weapon damage='..oWeapon.Blueprint.Damage) end
        if M28Utilities.IsTableEmpty(tUnitsToConsiderDodgeFor) == false then
            --Calculate time to impact
            local iDistToTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oWeapon:GetCurrentTargetPos())
            local iMaxTimeToRun = 3
            if oWeapon.Blueprint.WeaponCategory == 'Artillery' then
                iDistToTarget = iDistToTarget + 15
                iMaxTimeToRun = 0.8
            elseif oWeapon.Blueprint.WeaponCategory == 'Missile' then
                iDistToTarget = iDistToTarget + 10
                iMaxTimeToRun = 0.8
            end
            local iShotSpeed = oWeapon.Blueprint.MuzzleVelocity
            local iTimeUntilImpact = iDistToTarget / iShotSpeed
            local bCancelDodge = false
            if bDebugMessages == true then LOG(sFunctionRef..': Dist to target='..iDistToTarget..'; Shot speed='..iShotSpeed..'; iTimeUntilImpact='..iTimeUntilImpact) end
            if iTimeUntilImpact > 0.8 then
                for iTarget, oTarget in tUnitsToConsiderDodgeFor do
                    bCancelDodge = false
                    if bDebugMessages == true then LOG(sFunctionRef..': oTarget='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; Weapon damage='..oWeapon.Blueprint.Damage..'; Target health='..oTarget:GetHealth()) end
                    --Does the shot do enough damage that we want to try and doge it?
                    if oWeapon.Blueprint.Damage / oTarget:GetHealth() >= 0.01 then
                        --Do we think we can dodge the shot?
                        --If we are a large unit then only dodge if will be a while for the shot to hit
                        local oBP = oTarget:GetBlueprint()
                        local iAverageSize = (oBP.SizeX + oBP.SizeZ) * 0.5
                        if bDebugMessages == true then LOG(sFunctionRef..': iAverageSize='..iAverageSize..'; Is unit underwater='..tostring(M28UnitInfo.IsUnitUnderwater(oUnit))..'; Unit speed='..oBP.Physics.MaxSpeed) end
                        if iTimeUntilImpact > math.min(2.5, 0.4 + iAverageSize * 1.5 / oBP.Physics.MaxSpeed) and (iTimeUntilImpact >= 2 or not(EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId))) then
                            --Are we not underwater?
                            if not(M28UnitInfo.IsUnitUnderwater(oUnit)) then
                                --If dealing with an ACU then drastically reduce the dodge time so we can overcharge if we havent recently and have enemies in range and enough power
                                if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) and M28Conditions.CanUnitUseOvercharge(oUnit:GetAIBrain(), oUnit) and (GetGameTimeSeconds() - (oUnit[M28UnitInfo.refiTimeOfLastOverchargeShot] or 0)) > 5 then
                                    local iPlateau, iLandZone = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oUnit:GetPosition(), true, oUnit)
                                    local tLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLandZone][M28Map.subrefLZTeamData][oUnit:GetAIBrain().M28Team]
                                    if tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal] >= 200 then
                                        if bDebugMessages == true then LOG(sFunctionRef..': Reducing dodge time drastically as have ACU that can overcharge enemies in range but it also wants to dodge a shot; will cancel if damage is very low that are dodging. oWeapon.Blueprint.Damage='..oWeapon.Blueprint.Damage) end
                                        if oWeapon.Blueprint.Damage <= 100 then
                                            bCancelDodge = true
                                        else
                                            iMaxTimeToRun = math.min(0.7, iMaxTimeToRun)
                                        end
                                    end
                                elseif EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) then
                                    --If we are a GC, Monkey or Ythotha that has an enemy experimental nearby but not in range, then cancel dodging as want to get in range to be able to  fire
                                    iMaxTimeToRun = math.min(2.5, iMaxTimeToRun)
                                end

                                if not(bCancelDodge) then
                                    if bDebugMessages == true then LOG(sFunctionRef..': Will try to dodge shot. iTimeUntilImpact='..iTimeUntilImpact..'; iMaxTimeToRun='..iMaxTimeToRun) end
                                    DodgeShot(oTarget, oUnit, oWeapon, math.min(iTimeUntilImpact, iMaxTimeToRun))
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DodgeShot(oTarget, oWeapon, oAttacker, iTimeToDodge)
    --Should have already checked oTarget is a valid unit that has a chance of dodging the shot in time before claling this
    --Gets unit to move at a slightly different angle to its current facing direction for iTimeToDodge
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DodgeShot'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    M28Orders.UpdateRecordedOrders(oTarget)
    local tCurDestination
    local bAttackMove = false
    if oTarget[M28Orders.refiOrderCount] > 0 then
        local tLastOrder = oTarget[M28Orders.reftiLastOrders][oTarget[M28Orders.refiOrderCount]]
        tCurDestination = tLastOrder[M28Orders.subreftOrderPosition]
        if tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAttack or tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAggressiveMove or tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueAggressiveFormMove then
            bAttackMove = true
        end
    end

    local iCurFacingAngle = M28UnitInfo.GetUnitFacingAngle(oTarget)
    local iAngleToDestination
    if tCurDestination then iAngleToDestination = M28Utilities.GetAngleFromAToB(oTarget:GetPosition(), tCurDestination)
    else
        iAngleToDestination = iCurFacingAngle
        tCurDestination = oTarget:GetPosition()
    end

    local oBP = oTarget:GetBlueprint()
    local iSpeed = oBP.Physics.MaxSpeed
    local iDistanceToRun = iTimeToDodge * iSpeed
    local iUnitSize = oBP.SizeX + oBP.SizeZ
    local iAngleAdjust = math.max(15, oBP.Physics.TurnRate * 0.3)
    if iUnitSize >= 2 then
        if iUnitSize >= 4 then iAngleAdjust = iAngleAdjust * 2.5
        else iAngleAdjust = iAngleAdjust * 1.75
        end
        if EntityCategoryContains(M28UnitInfo.refCategoryLandExperimental, oTarget.UnitId) then
            iAngleAdjust = math.min(iAngleAdjust, 30)
        end
    end
    if M28Utilities.GetAngleDifference(iCurFacingAngle + iAngleAdjust, iAngleToDestination) > M28Utilities.GetAngleDifference(iCurFacingAngle - iAngleAdjust, iAngleToDestination) then
        iAngleAdjust = iAngleAdjust * -1
    end

    local tTempDestination = M28Utilities.MoveInDirection(oTarget:GetPosition(), iCurFacingAngle + iAngleAdjust, iDistanceToRun, true, false)
    if bDebugMessages == true then LOG(sFunctionRef..': oTarget (ie unit that is dodging)='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; clearing current orders which have a possible destination of '..repru(tCurDestination)..'; and giving an order to move to '..repru(tTempDestination)..'; Dist from our position to temp position='..M28Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), tTempDestination)..'; iAngleAdjust='..iAngleAdjust..'; Unit size='..iUnitSize) end
    M28Orders.IssueTrackedClearCommands(oTarget)
    TrackTemporaryUnitMicro(oTarget, iTimeToDodge)
    M28Orders.IssueTrackedMove(oTarget, tTempDestination, 0.25, false, 'MiDod1', true)
    --Also send an order to go to the destination that we had before
    if bAttackMove then
        M28Orders.IssueTrackedAttackMove(oTarget, tCurDestination, 0.25, true, 'MiDod2', true)
    else
        M28Orders.IssueTrackedMove(oTarget, tCurDestination, 0.25, true, 'MiDod3', true)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function TrackTemporaryUnitMicro(oUnit, iTimeActiveFor, sAdditionalTrackingVar)
    --Where we are doing all actions upfront can call this to enable micro and then turn the flag off after set period of time
    --Note that air logic currently doesnt make use of this

    oUnit[M28UnitInfo.refbSpecialMicroActive] = true
    oUnit[M28UnitInfo.refiGameTimeMicroStarted] = GetGameTimeSeconds()
    oUnit[M28UnitInfo.refiGameTimeToResetMicroActive] = GetGameTimeSeconds() + iTimeActiveFor

    M28Utilities.DelayChangeVariable(oUnit, M28UnitInfo.refbSpecialMicroActive, false, iTimeActiveFor - 0.01)

    if sAdditionalTrackingVar then
        oUnit[sAdditionalTrackingVar] = true
        M28Utilities.DelayChangeVariable(oUnit, sAdditionalTrackingVar, false, iTimeActiveFor - 0.01)
    end
end

function ForkedMoveInCircle(oUnit, iTimeToRun, bDontTreatAsMicroAction, bDontClearCommandsFirst, iCircleSizeOverride, iTickWaitOverride)
    --More intensive version of MoveAwayFromTargetTemporarily, intended e.g. for ACUs
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ForkedMoveInCircle'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local refbActiveCircleMicro = 'M28MicroActiveCircleMicro'

    if bDebugMessages == true then LOG(sFunctionRef..': GameTime='..GetGameTimeSeconds()..'; Unit has active circle micro='..tostring(oUnit[refbActiveCircleMicro] or false)) end
    if not(oUnit[refbActiveCircleMicro]) then

        --KEY CONFIG SETTINGS: (these will work sometimes but not always against an aeon strat)
        local iInitialAngleAdj = 15
        local iInitialDistanceAdj = -1
        local iDistanceAwayToMove = (iCircleSizeOverride or 2)
        local iAngleMaxSingleAdj = 45
        local iTicksBetweenOrders = (iTickWaitOverride or 4)

        if iDistanceAwayToMove > oUnit:GetBlueprint().Physics.MaxSpeed * 1.5 then
            iAngleMaxSingleAdj = math.max(25, iAngleMaxSingleAdj * 2.5 / iDistanceAwayToMove)
        end



        local iStartTime = GetGameTimeSeconds()
        oUnit[M28UnitInfo.refiGameTimeMicroStarted] = iStartTime
        local iLoopCount = 0
        local iMaxLoop = iTimeToRun * 10 + 1
        --Distance from point A to point B will be much less than distanceaway to move, since that is the distance from the centre (radius) rather than the distance between 1 points on the circle edge; for simplicity will assume that distance is 0.25 of the distance from the centre
        if bDontTreatAsMicroAction then iMaxLoop = math.ceil(iTimeToRun / (iDistanceAwayToMove / oUnit:GetBlueprint().Physics.MaxSpeed)) * 4 end
        local tUnitStartPosition = oUnit:GetPosition()

        local iCurFacingDirection = M28UnitInfo.GetUnitFacingAngle(oUnit)
        local iAngleAdjFactor = 1

        local tTempLocationToMove

        local bRecentMicro = false
        local iRecentMicroThreshold = 1
        local iGameTime = GetGameTimeSeconds()
        if oUnit[M28UnitInfo.refbSpecialMicroActive] and iGameTime - oUnit[M28UnitInfo.refiGameTimeMicroStarted] < iRecentMicroThreshold then bRecentMicro = true end
        if bDebugMessages == true then LOG(sFunctionRef..': About to start main loop for move commands for unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTimeToRun='..iTimeToRun..'; iStartTime='..iStartTime..'; iCurFacingDirection='..iCurFacingDirection..'; tUnitStartPosition='..repru(tUnitStartPosition)..'; bRecentMicro='..tostring((bRecentMicro or false))..'; bDontClearCommandsFirst='..tostring(bDontClearCommandsFirst or false)..'; oUnit[M28UnitInfo.refbSpecialMicroActive]='..tostring(oUnit[M28UnitInfo.refbSpecialMicroActive])..'; oUnit[M28UnitInfo.refiGameTimeMicroStarted]='..(oUnit[M28UnitInfo.refiGameTimeMicroStarted] or 'nil')..'; GameTime='..iGameTime..'; Dif='..iGameTime-(oUnit[M28UnitInfo.refiGameTimeMicroStarted] or 0)..'; bDontTreatAsMicroAction='..tostring((bDontTreatAsMicroAction or false))) end
        if bRecentMicro == false and not(bDontClearCommandsFirst) then
            M28Orders.IssueTrackedClearCommands(oUnit)
            if bDebugMessages == true then LOG(sFunctionRef..': Issued clear commands order to the unit') end
        end
        if not(bDontTreatAsMicroAction) then
            TrackTemporaryUnitMicro(oUnit, iTimeToRun, refbActiveCircleMicro)
            if bDebugMessages == true then LOG(sFunctionRef..': Will temporarily track the unit micro. iTimeToRun='..(iTimeToRun or 'nil')) end
        end

        local iTempAngleDirectionToMove = iCurFacingDirection + iInitialAngleAdj * iAngleAdjFactor
        local iTempDistanceAwayToMove
        local bTimeToStop = false
        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; refbSpecialMicroActive='..tostring((oUnit[M28UnitInfo.refbSpecialMicroActive] or false))..'; iMaxLoop='..iMaxLoop) end
        while bTimeToStop == false do
            iLoopCount = iLoopCount + 1
            if iLoopCount > iMaxLoop then break
            elseif M28UnitInfo.IsUnitValid(oUnit) == false then break end --No longer give error message as may be calling this for intel scouts now

            iTempAngleDirectionToMove = iTempAngleDirectionToMove + iAngleMaxSingleAdj * iAngleAdjFactor
            if iTempAngleDirectionToMove > 360 then iTempAngleDirectionToMove = iTempAngleDirectionToMove - 360 end
            --end
            iTempDistanceAwayToMove = iDistanceAwayToMove
            if iLoopCount == 1 then iTempDistanceAwayToMove = iDistanceAwayToMove + iInitialDistanceAdj end
            tTempLocationToMove = M28Utilities.MoveInDirection(tUnitStartPosition, iTempAngleDirectionToMove, iTempDistanceAwayToMove)
            M28Orders.IssueTrackedMove(oUnit, tTempLocationToMove, 0.25, true, 'MiCirc1', true)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(iTicksBetweenOrders)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            if not(bDontTreatAsMicroAction) and not((oUnit[M28UnitInfo.refiGameTimeMicroStarted] == iStartTime and GetGameTimeSeconds() - iStartTime < iTimeToRun)) then bTimeToStop = true end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MoveInCircleTemporarily(oUnit, iTimeToRun, bDontTreatAsMicroAction, bDontClearCommandsFirst, iCircleSizeOverride, iTickWaitOverride)
    ForkThread(ForkedMoveInCircle, oUnit, iTimeToRun, bDontTreatAsMicroAction, bDontClearCommandsFirst, iCircleSizeOverride, iTickWaitOverride)
end