---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 07/12/2022 19:50
---
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Building = import('/mods/M28AI/lua/AI/M28Building.lua')


refiNearestEnemyIndex = 'M28NearestEnemyIndex'


function GetNearestEnemyIndex(aiBrain)
    --Returns the army index of the nearest enemy brain, or nil if there is none
    local oNearestBrain = M28Overseer.GetNearestEnemyBrain(aiBrain)
    if oNearestBrain then return oNearestBrain:GetArmyIndex() else return nil end
end

function GetDirectFireWeaponPosition(oFiringUnit)
    --Returns position of oFiringUnit's first DF weapon; nil if oFiringUnit doesnt have a DF weapon; Unit position if no weapon bone
    --for ACU, returns this for the overcharge weapon
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetDirectFireWeaponPosition'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local oBPFiringUnit = oFiringUnit:GetBlueprint()
    local tShotStartPosition
    if EntityCategoryContains(categories.DIRECTFIRE + M28UnitInfo.refCategoryFatboy, oBPFiringUnit.BlueprintId) == true then
        local bIsACU = EntityCategoryContains(categories.COMMAND, oBPFiringUnit.BlueprintId)

        local sFiringBone
        if bDebugMessages == true then LOG(sFunctionRef..': Have a DF unit, working out where shot coming from') end
        --Work out where the shot is coming from:
        local bIsFatboy = EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oFiringUnit)
        for iCurWeapon, oWeapon in oBPFiringUnit.Weapon do
            if oWeapon.RangeCategory and (oWeapon.RangeCategory == 'UWRC_DirectFire' or (bIsFatboy and oWeapon.RangeCategory == 'UWRC_IndirectFire')) then
                if bDebugMessages == true then LOG(sFunctionRef..': Have a weapon with range category') end
                if oWeapon.RackBones then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have a weapon with RackBones') end
                    for _, oRackBone in oWeapon.RackBones do
                        if bDebugMessages == true then LOG(sFunctionRef..' Cur oRackBone='..repru(oRackBone)) end
                        if oRackBone.MuzzleBones then
                            sFiringBone = oRackBone.MuzzleBones[1]
                            if bDebugMessages == true then LOG(sFunctionRef..': Found muzzlebone='..sFiringBone) end
                            break
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Cant locate muzzle bone') end
                        end
                    end
                    if sFiringBone then
                        if bIsACU == false then break
                        else
                            --ACU - make sure we have an overcharge weapon (to avoid e.g. cybran laser weapon)
                            if oWeapon.OverChargeWeapon then
                                break
                            end
                        end
                    end
                end
            end
        end
        if sFiringBone then
            tShotStartPosition = oFiringUnit:GetPosition(sFiringBone)
        else
            tShotStartPosition = oFiringUnit:GetPosition()
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tShotStartPosition
end

function IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, iAOE, bReturnDistanceThatBlocked)
    --If iAOE is specified then will end once reach the iAOE range
    --(aiBrain included as argument as want to retry CheckBlockingTerrain in the future)
    --bReturnDistanceThatBlocked - if true then returns either distance at which shot is blocked, or the distance+1 between the start and end position

    --Angle (looking only at vertical dif) from shot start to shot end, theta: Tan Theta = Opp/Adj, so Theta = tan-1 Opp/Adj
    --Once have this angle, then the height if move vertically to the target is: Sin theta = opp / hyp
    --Opp is the height dif; adj is the distance between start and end (referred to below as iFlatDistance)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsLineBlocked'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local bShotIsBlocked = false
    local iFlatDistance = M28Utilities.GetDistanceBetweenPositions(tShotStartPosition, tShotEndPosition)
    local tTerrainPositionAtPoint = {}
    local bStartHigherThanEnd = false
    if tShotStartPosition[2] > tShotEndPosition[2] then bStartHigherThanEnd = true end
    if iFlatDistance > 1 then
        local iAngleInRadians = math.atan(math.abs((tShotEndPosition[2] - tShotStartPosition[2])) / iFlatDistance)
        local iShotHeightAtPoint
        if bDebugMessages == true then LOG(sFunctionRef..': About to check if at any point on path shot will be lower than terrain; iAngle='..M28Utilities.ConvertAngleToRadians(iAngleInRadians)..'; startshot height='..tShotStartPosition[2]..'; target height='..tShotEndPosition[2]..'; iFlatDistance='..iFlatDistance) end
        local iEndPoint = math.max(1, math.floor(iFlatDistance - (iAOE or 0)))
        for iPointToTarget = 1, iEndPoint do
            --math.min(math.floor(iFlatDistance), math.max(math.floor(iStartDistance or 1),1)), math.floor(iFlatDistance) do
            --MoveTowardsTarget(tStartPos, tTargetPos, iDistanceToTravel, iAngle)
            tTerrainPositionAtPoint = M28Utilities.MoveInDirection(tShotStartPosition, M28Utilities.GetAngleFromAToB(tShotStartPosition, tShotEndPosition), iPointToTarget, false, false)
            if bDebugMessages == true then LOG(sFunctionRef..': iPointToTarget='..iPointToTarget..'; tTerrainPositionAtPoint='..repru(tTerrainPositionAtPoint)) end
            if bStartHigherThanEnd then iShotHeightAtPoint = tShotStartPosition[2] - math.sin(iAngleInRadians) * iPointToTarget
            else iShotHeightAtPoint = tShotStartPosition[2] + math.sin(iAngleInRadians) * iPointToTarget
            end
            if iShotHeightAtPoint <= tTerrainPositionAtPoint[2] then
                if not(iPointToTarget == iEndPoint and iShotHeightAtPoint == tTerrainPositionAtPoint[2]) then
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Shot blocked at this position; iPointToTarget='..iPointToTarget..'; iShotHeightAtPoint='..iShotHeightAtPoint..'; tTerrainPositionAtPoint='..tTerrainPositionAtPoint[2])
                        M28Utilities.DrawLocation(tTerrainPositionAtPoint, 5, 10)
                    end
                    bShotIsBlocked = true
                    if bReturnDistanceThatBlocked then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return iPointToTarget
                    end

                    break
                elseif bDebugMessages == true then LOG(sFunctionRef..': Are at end point and terrain height is identical, so will assume we will actually reach the target')
                end
            else
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Shot not blocked at this position, will draw in blue; iPointToTarget='..(iPointToTarget or 'nil')..'; iShotHeightAtPoint='..(iShotHeightAtPoint or 'nil')..'; tTerrainPositionAtPoint='..(tTerrainPositionAtPoint[2] or 'nil')..'; iAngle='..M28Utilities.ConvertAngleToRadians(iAngleInRadians)..'; iPointToTarget='..(iPointToTarget or 'nil')..'; tShotStartPosition[2]='..(tShotStartPosition[2] or 'nil'))
                    M28Utilities.DrawLocation(tTerrainPositionAtPoint, 1, 20)
                end
            end
        end
    else bShotIsBlocked = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bReturnDistanceThatBlocked and not(bShotIsBlocked) then return M28Utilities.GetDistanceBetweenPositions(tShotStartPosition, tShotEndPosition) + 1
    else
        return bShotIsBlocked
    end
end

function IsShotBlocked(oFiringUnit, oTargetUnit)
    --Returns true or false depending on if oFiringUnit can hit oTargetUnit in a straight line
    --intended for direct fire units only
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsShotBlocked'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local bShotIsBlocked = false
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
    local tShotStartPosition = GetDirectFireWeaponPosition(oFiringUnit)
    if tShotStartPosition then
        if bDebugMessages == true then LOG(sFunctionRef..': tShotStartPosition='..repru(tShotStartPosition)) end
        if tShotStartPosition[2] <= 0 then bShotIsBlocked = true
        else
            local tShotEndPosition = {}
            local oBPTargetUnit = oTargetUnit:GetBlueprint()
            local iLowestHeight = 1000
            local iHighestHeight = -1000
            local sLowestBone, sHighestBone
            local tTargetUnitDefaultPosition = oTargetUnit:GetPosition()
            --Work out where the shot is targetting - not all units will have a bone specified in the AI section, in which case just get the unit position
            if oBPTargetUnit.AI and oBPTargetUnit.AI.TargetBones then
                if bDebugMessages == true then LOG(sFunctionRef..': Have targetbones in the targetunit blueprint; repr='..repru(oBPTargetUnit.AI.TargetBones)) end
                --Is the target higher or lower than the shooter? If higher, want the lowest target bone; if lower, want the highest target bone
                for iBone, sBone in oBPTargetUnit.AI.TargetBones do
                    if oTargetUnit:IsValidBone(sBone) == true then
                        tShotEndPosition = oTargetUnit:GetPosition(sBone)
                        if bDebugMessages == true then LOG(sFunctionRef..' Getting position for sBone='..sBone..'; position='..repru(tShotEndPosition)) end
                        if tShotEndPosition[2] < iLowestHeight then
                            iLowestHeight = tShotEndPosition[2]
                            sLowestBone = sBone
                        end
                        if tShotEndPosition[2] > iHighestHeight then
                            iHighestHeight = tShotEndPosition[2]
                            sHighestBone = sBone
                        end
                    end
                end
                --Try alternative approach:
                if sHighestBone == nil and oTargetUnit.GetBoneCount then
                    local iBoneCount = oTargetUnit:GetBoneCount()
                    local sBone
                    if iBoneCount > 0 then
                        for iCurBone = 0, iBoneCount - 1 do
                            sBone = oTargetUnit:GetBoneName(iCurBone)
                            if sBone then
                                if oTargetUnit:IsValidBone(sBone) == true then
                                    tShotEndPosition = oTargetUnit:GetPosition(sBone)
                                    if bDebugMessages == true then LOG(sFunctionRef..' Getting position for sBone='..sBone..'; position='..repru(tShotEndPosition)) end
                                    if tShotEndPosition[2] < iLowestHeight then
                                        iLowestHeight = tShotEndPosition[2]
                                        sLowestBone = sBone
                                    end
                                    if tShotEndPosition[2] > iHighestHeight then
                                        iHighestHeight = tShotEndPosition[2]
                                        sHighestBone = sBone
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if sHighestBone == nil then
                tShotEndPosition = tTargetUnitDefaultPosition
                if bDebugMessages == true then LOG(sFunctionRef..': Couldnt find a bone to target for target unit, so using its position instaed='..repru(tShotEndPosition)) end
            else
                if tTargetUnitDefaultPosition[2] > tShotStartPosition[2] then
                    tShotEndPosition = oTargetUnit:GetPosition(sLowestBone)
                else
                    tShotEndPosition = oTargetUnit:GetPosition(sHighestBone)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': HighestBone='..sHighestBone..'; lowest bone='..sLowestBone..'; tShotEndPosition='..repru(tShotEndPosition)) end
            end
            --Have the shot end and start positions; Now check that not firing at underwater target
            if tShotEndPosition[2] < GetSurfaceHeight(tShotEndPosition[1], tShotEndPosition[3]) then
                bShotIsBlocked = true
            else
                --Have the shot end and start positions; now want to move along a line between the two and work out if terrain will block the shot
                if bDebugMessages == true then LOG(sFunctionRef..': About to see if line is blocked. tShotStartPosition='..repru(tShotStartPosition)..'; tShotEndPosition='..repru(tShotEndPosition)..'; Terrain height at start='..GetTerrainHeight(tShotStartPosition[1], tShotStartPosition[3])..'; Terrain height at end='..GetTerrainHeight(tShotEndPosition[1], tShotEndPosition[3])) end
                bShotIsBlocked = IsLineBlocked(oFiringUnit:GetAIBrain(), tShotStartPosition, tShotEndPosition)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bShotIsBlocked
end

function IsTargetUnderShield(aiBrain, oTarget, iIgnoreShieldsWithLessThanThisHealth, bReturnShieldHealthInstead, bIgnoreMobileShields, bTreatPartCompleteAsComplete, bCumulativeShieldHealth)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsTargetUnderShield'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Determines if target is under a shield
    --bCumulativeShieldHealth - if true, then will treat as being under a shield if all shields combined have health of at least iIgnoreShieldsWithLessThanThisHealth

    if M28UnitInfo.IsUnitValid(oTarget) and oTarget.GetHealth then
        if bDebugMessages == true and EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oTarget.UnitId) then
            if oTarget.MyShield.GetHealth then
                LOG(sFunctionRef..': oTarget is a shield='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; Shield ratio='..oTarget:GetShieldRatio(false)..'; Shield ratio true='..oTarget:GetShieldRatio(true)..'; Shield health='..oTarget.MyShield:GetHealth()..'; SHield max health='..oTarget.MyShield:GetMaxHealth()..'; Active consumption='..tostring(oTarget.ActiveConsumption)..'; reprs of shield='..reprs(oTarget.MyShield))
            else
                LOG(sFunctionRef..': oTarget is a shield but it doesnt have a .GetHealth property. target='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'reprs of shield='..reprs(oTarget.MyShield))
            end
        end
        if iIgnoreShieldsWithLessThanThisHealth == nil then iIgnoreShieldsWithLessThanThisHealth = 0 end
        local bUnderShield = false
        local iShieldSearchRange = 46 --T3 sera shield is 46; bulwark is 120; will go with sera t3 for now; if changing here then also change reference in getmaxstrikedamage
        --Is the target an enemy?
        local oTBrain = oTarget:GetAIBrain()
        local bEnemy
        if oTBrain == aiBrain then
            bEnemy = false
        else
            local iOurArmyIndex = aiBrain:GetArmyIndex()
            local iTargetArmyIndex = oTBrain:GetArmyIndex()
            if iOurArmyIndex and iTargetArmyIndex then
                bEnemy = IsEnemy(iOurArmyIndex, iTargetArmyIndex)
            else bEnemy = true
            end
        end
        local sSearchType = 'Ally'
        if bEnemy then sSearchType = 'Enemy' end
        local tTargetPos = oTarget:GetPosition()
        local iShieldCategory = M28UnitInfo.refCategoryMobileLandShield + M28UnitInfo.refCategoryFixedShield
        if bIgnoreMobileShields then iShieldCategory = M28UnitInfo.refCategoryFixedShield end
        local tNearbyShields = aiBrain:GetUnitsAroundPoint(iShieldCategory, tTargetPos, iShieldSearchRange, sSearchType)
        if bDebugMessages == true then LOG(sFunctionRef..': Searching for shields around '..repru(tTargetPos)..'; iShieldSearchRange='..iShieldSearchRange..'; sSearchType='..sSearchType) end
        local iShieldCurHealth, iShieldMaxHealth
        local iTotalShieldCurHealth = 0
        local iTotalShieldMaxHealth = 0
        local iMinFractionComplete = 0.95

        local iShieldSizeAdjust = 2 --i.e. if want to be prudent about whether can hit an enemy should be positive, if prudent about whether an ally is protected want a negative value
        if not(bEnemy) then iShieldSizeAdjust = -1 end

        if bTreatPartCompleteAsComplete then iMinFractionComplete = 0 end
        if M28Utilities.IsTableEmpty(tNearbyShields) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Size of tNearbyShields='..table.getn(tNearbyShields)) end
            local oCurUnitBP, iCurShieldRadius, iCurDistanceFromTarget
            for iUnit, oUnit in tNearbyShields do
                if not(oUnit.Dead) and oUnit:GetFractionComplete() >= iMinFractionComplete then
                    oCurUnitBP = oUnit:GetBlueprint()
                    iCurShieldRadius = 0
                    if oCurUnitBP.Defense and oCurUnitBP.Defense.Shield then
                        if bDebugMessages == true then LOG(sFunctionRef..': Target has a shield, will check its shield size and how close that is to the target') end
                        iCurShieldRadius = oCurUnitBP.Defense.Shield.ShieldSize * 0.5
                        if iCurShieldRadius > 0 then
                            iCurDistanceFromTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetPos)
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurDistance to shield='..iCurDistanceFromTarget..'; iCurShieldRadius='..iCurShieldRadius..'; shield position='..repru(oUnit:GetPosition())..'; target position='..repru(tTargetPos)) end
                            if iCurDistanceFromTarget <= (iCurShieldRadius + iShieldSizeAdjust) then --if dont increase by anything then half of unit might be under shield which means bombs cant hit it
                                if bDebugMessages == true then LOG(sFunctionRef..': Shield is large enough to cover target, will check its health') end
                                iShieldCurHealth, iShieldMaxHealth = M28UnitInfo.GetCurrentAndMaximumShield(oUnit)
                                iTotalShieldCurHealth = iTotalShieldCurHealth + iShieldCurHealth
                                iTotalShieldMaxHealth = iTotalShieldMaxHealth + iShieldMaxHealth
                                if bTreatPartCompleteAsComplete or (oUnit:GetFractionComplete() >= 0.95 and oUnit:GetFractionComplete() < 1) then iShieldCurHealth = iShieldMaxHealth end
                                if bDebugMessages == true then LOG(sFunctionRef..': iShieldCurHealth='..iShieldCurHealth..'; iIgnoreShieldsWithLessThanThisHealth='..iIgnoreShieldsWithLessThanThisHealth) end
                                if (not(bCumulativeShieldHealth) and iShieldCurHealth >= iIgnoreShieldsWithLessThanThisHealth) or (bCumulativeShieldHealth and iTotalShieldCurHealth >= iIgnoreShieldsWithLessThanThisHealth) then
                                    bUnderShield = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Shield health more than threshold so unit is under a shield') end
                                    if not(bReturnShieldHealthInstead) then break end
                                end
                            end
                        elseif bDebugMessages == true then LOG(sFunctionRef..': Shield radius isnt >0')
                        end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Blueprint doesnt have a shield value; UnitID='..oUnit.UnitId) end
                    end
                elseif bDebugMessages == true then LOG(sFunctionRef..': Unit is dead')
                end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': tNearbyShields is empty') end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        if bReturnShieldHealthInstead then
            return iTotalShieldCurHealth, iTotalShieldMaxHealth
        else return bUnderShield
        end
    end
end

function GetDamageFromOvercharge(aiBrain, oTargetUnit, iAOE, iDamage, bTargetWalls)
    --Originally copied from the 'getdamagefrombomb' function, but adjusted since OC doesnt deal full damage to ACU or structures
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetDamageFromOvercharge'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iTotalDamage = 0

    local tEnemiesInRange
    if bTargetWalls then tEnemiesInRange =  aiBrain:GetUnitsAroundPoint(categories.WALL + M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryAllNavy, oTargetUnit:GetPosition(), iAOE, 'Enemy')
    else tEnemiesInRange = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryAllNavy, oTargetUnit:GetPosition(), iAOE, 'Enemy')
    end

    local oCurBP
    local iMassFactor
    local iCurHealth, iMaxHealth, iCurShield, iMaxShield
    local iActualDamage
    local iKillsExpected = 0
    local iUnitsHit = 0 --E.g. if targeting walls then this means we target the most walls assuming no nearby other units
    if bDebugMessages == true then LOG(sFunctionRef..': About to loop through all enemies in range; iDamage='..iDamage..'; iAOE='..iAOE..'; Base target unit='..oTargetUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTargetUnit)..'; position='..repru(oTargetUnit:GetPosition())) end

    if M28Utilities.IsTableEmpty(tEnemiesInRange) == false then
        for iUnit, oUnit in tEnemiesInRange do
            if oUnit.GetBlueprint then
                oCurBP = oUnit:GetBlueprint()
                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; dist to postiion='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oTargetUnit:GetPosition())) end
                --Is the unit within range of the aoe?
                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oTargetUnit:GetPosition()) <= iAOE then
                    --Is the unit shielded by a non-mobile shield (mobile shields should take full damage I think)
                    --IsTargetUnderShield(aiBrain, oTarget, iIgnoreShieldsWithLessThanThisHealth, bReturnShieldHealthInstead, bIgnoreMobileShields, bTreatPartCompleteAsComplete)
                    if not(IsTargetUnderShield(aiBrain, oUnit, 800, false, true, false)) then
                        iActualDamage = iDamage
                        if EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
                            iActualDamage = 800
                        elseif EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                            iActualDamage = 400
                        end

                        iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit)
                        iCurHealth = iCurShield + oUnit:GetHealth()
                        iMaxHealth = iMaxShield + oUnit:GetMaxHealth()
                        --Set base mass value based on health
                        if iDamage >= iMaxHealth or iDamage >= math.min(iCurHealth * 3, iCurHealth + 1000) then
                            iMassFactor = 1
                            iKillsExpected = iKillsExpected + 1
                            --Was the unit almost dead already?
                            if (iCurShield + iCurHealth) <= iMaxHealth * 0.4 then iMassFactor = math.max(0.25, (iCurShield + iCurHealth) / iMaxHealth) end
                        else
                            --Still some value in damaging a unit (as might get a second strike), but far less than killing it
                            iMassFactor = 0.4
                            if EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) then iMassFactor = 0.5 end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iMassFactor after considering if will kill it='..iMassFactor..'; Unit max health='..iMaxHealth..'; CurHealth='..iCurHealth) end
                        --Is the target mobile and within 1 of the AOE edge? If so then reduce to 25% as it might move out of the wayif
                        if oUnit:GetFractionComplete() == 1 and EntityCategoryContains(categories.MOBILE, oUnit.UnitId) and iAOE - 0.5 < M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oTargetUnit:GetPosition()) then iMassFactor = iMassFactor * 0.25 end
                        iTotalDamage = iTotalDamage + oCurBP.Economy.BuildCostMass * oUnit:GetFractionComplete() * iMassFactor
                        if bDebugMessages == true then LOG(sFunctionRef..': Finished considering the unit; iTotalDamage='..iTotalDamage..'; oCurBP.Economy.BuildCostMass='..oCurBP.Economy.BuildCostMass..'; oUnit:GetFractionComplete()='..oUnit:GetFractionComplete()..'; iMassFactor after considering if unit is mobile='..iMassFactor) end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished going through units in the aoe, iTotalDamage in mass='..iTotalDamage..'; iAOE='..iAOE..'; iDamage='..iDamage) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iTotalDamage, iKillsExpected
end


function GetDamageFromBomb(aiBrain, tBaseLocation, iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor)
    --Below is largely a copy of M27 logic
    --iFriendlyUnitDamageReductionFactor - optional, assumed to be 0 if not specified; will reduce the damage from the bomb by any friendly units in the aoe
    --iFriendlyUnitAOEFactor - e.g. if 2, then will search for friendly units in 2x the aoe
    --bCumulativeShieldHealthCheck - if true, then will treat a unit as unshielded if its cumulative shield health check is below the damage
    --iOptionalSizeAdjust - Defaults to 1, % of value to assign to a normal (mex sized) target; if this isn't 1 then will adjust values accordingly, with T3 power given a value of 1, larger buildings given a greater value, and T1 PD sized buildings given half of iOptionalSizeAdjust
    --iOptionalModIfNeedMultipleShots - Defaults to 0.1; % of value to assign if we wont kill the target with a single shot (experimentals will always give at least 0.5 value)
    --bT3ArtiShotReduction - if true then will reduce value of targets where we have fired lots of shots at them
    --iOptionalShieldReductionFactor - if shields exceed iDamage, then this will be used in place of 0 (the default), i.e. what % of the mass damage should be used if the shield means 0 damage will be dealt

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetDamageFromBomb'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local bIgnoreT3ArtiShotReduction = not(bT3ArtiShotReduction or false)

    local iTotalDamage = 0
    local tEnemiesInRange = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryAllNavy + M28UnitInfo.refCategoryAllAir * categories.EXPERIMENTAL, tBaseLocation, iAOE + 4, 'Enemy')
    local oCurBP
    local iMassFactor
    local iCurHealth, iMaxHealth, iCurShield, iMaxShield
    local tFriendlyUnits
    local iSizeAdjustFactor = iOptionalSizeAdjust or 1
    local iDifBetweenSize8And2 = 0

    local tiSizeAdjustFactors
    local iFactorIfWontKill = iOptionalModIfNeedMultipleShots or 0.1
    if not(iSizeAdjustFactor == 1) then
        iDifBetweenSize8And2 = iSizeAdjustFactor - 1
        --Key values are 1, 2 (Mex), 6 (T2 pgen), 8 (T3 PGen), 10 (rapidfire arti); could potentially go up to 20 (czar)
        tiSizeAdjustFactors = {[1] = 2, [2] = 1, [3] = 0.9, [4] = 0.75, [5] = 0.6, [6] = 0.5, [7] = 0.3, [8] = 0, [9] = -0.1, [10] = -0.25}

    end

    function GetBuildingSizeFactor(sBlueprint)
        if iSizeAdjustFactor == 1 then
            return 1
        else
            local tSize = M28UnitInfo.GetBuildingSize(sBlueprint)
            local iCurSize = math.floor(tSize[1], tSize[2])
            if bDebugMessages == true then LOG(sFunctionRef..': iCurSize='..iCurSize..'; tiSizeAdjustFactors[iCurSize]='..(tiSizeAdjustFactors[iCurSize] or 'nil')..'; expected factor='..1 + (tiSizeAdjustFactors[iCurSize] or -0.35) * iDifBetweenSize8And2) end

            return 1 + (tiSizeAdjustFactors[iCurSize] or -0.35) * iDifBetweenSize8And2
        end
    end

    if iFriendlyUnitDamageReductionFactor then
        --Reduce damage dealt based on nearby friendly units

        tFriendlyUnits = aiBrain:GetUnitsAroundPoint(categories.ALLUNITS - categories.BENIGN - M28UnitInfo.refCategorySatellite, tBaseLocation, iAOE * (iFriendlyUnitAOEFactor or 1), 'Ally')
        if M28Utilities.IsTableEmpty(tFriendlyUnits) == false then
            for iUnit, oUnit in tFriendlyUnits do
                if oUnit.GetBlueprint and not(oUnit.Dead) then
                    if EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                        if ScenarioInfo.Options.Victory == "demoralization" then
                            iTotalDamage = iTotalDamage - 100000
                        else
                            iTotalDamage = iTotalDamage - 15000 * iFriendlyUnitDamageReductionFactor
                        end
                    else
                        iTotalDamage = iTotalDamage - oUnit:GetBlueprint().Economy.BuildCostMass * oUnit:GetFractionComplete() * iFriendlyUnitDamageReductionFactor
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of enemies in range empty='..tostring(M28Utilities.IsTableEmpty(tEnemiesInRange))) end
    if M28Utilities.IsTableEmpty(tEnemiesInRange) == false then
        local iShieldThreshold = math.max(iDamage * 0.9, iDamage - 500)
        local iCurDist
        local iMobileDamageDistThreshold = iAOE * 0.75
        local iMobileDamageFactorWithinThreshold
        local iMobileDamageFactorOutsideThreshold = 0.2
        local iMobileDamageNotMovingWithinThreshold
        local iMobileDamageFactorOutsideThresholdMoving
        if iMobileValueOverrideFactorWithin75Percent then
            iMobileDamageFactorWithinThreshold = math.max(iMobileDamageFactorOutsideThreshold, iMobileValueOverrideFactorWithin75Percent)
        else
            if iAOE >= 3.5 then iMobileDamageFactorWithinThreshold = iMobileDamageFactorOutsideThreshold * 1.25
            else
                iMobileDamageFactorWithinThreshold = iMobileDamageFactorOutsideThreshold
            end
        end
        iMobileDamageNotMovingWithinThreshold = math.min(iMobileDamageFactorWithinThreshold + 0.1, iMobileDamageFactorWithinThreshold * 1.5, 1)
        iMobileDamageFactorWithinThreshold = math.max(iMobileDamageFactorWithinThreshold - 0.1, iMobileDamageFactorWithinThreshold * 0.5) --value for if we are moving
        iMobileDamageFactorOutsideThresholdMoving = math.max(iMobileDamageFactorOutsideThreshold - 0.1, iMobileDamageFactorOutsideThreshold * 0.5)

        for iUnit, oUnit in tEnemiesInRange do
            if oUnit.GetBlueprint and not(oUnit.Dead) and oUnit:GetFractionComplete() == 1 or not(EntityCategoryContains(categories.AIR * categories.MOBILE, oUnit.UnitId)) then
                iMassFactor = 1
                oCurBP = oUnit:GetBlueprint()
                --Is the unit within range of the aoe?
                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBaseLocation)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Distance to base location='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBaseLocation)..'; iAOE='..iAOE) end
                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tBaseLocation) <= iAOE then
                    --Is the unit shielded by more than 90% of our damage?
                    --IsTargetUnderShield(aiBrain, oTarget, iIgnoreShieldsWithLessThanThisHealth, bReturnShieldHealthInstead, bIgnoreMobileShields, bTreatPartCompleteAsComplete, bCumulativeShieldHealth)
                    if IsTargetUnderShield(aiBrain, oUnit, iShieldThreshold, false, false, nil, bCumulativeShieldHealthCheck) then iMassFactor = (iOptionalShieldReductionFactor or 0) end
                    if bDebugMessages == true then LOG(sFunctionRef..': Mass factor after considering if under shield='..iMassFactor) end
                    if iMassFactor > 0 then
                        iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit)
                        iCurHealth = iCurShield + oUnit:GetHealth()
                        iMaxHealth = iMaxShield + oUnit:GetMaxHealth()
                        --Set base mass value based on health
                        if not(iFactorIfWontKill == 1) then
                            if iDamage >= iMaxHealth or iDamage >= math.min(iCurHealth * 3, iCurHealth + 1000) then
                                --Do nothing - stick with default mass factor of 1
                            else
                                --Still some value in damaging a unit (as might get a second strike), but far less than killing it

                                if EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) then
                                    iMassFactor = iMassFactor * math.max(0.5, iFactorIfWontKill)
                                else
                                    iMassFactor = iMassFactor * iFactorIfWontKill
                                end
                            end
                        end
                        --Adjust for building size if specified (e.g. useful for if firing from unit with randomness factor)
                        iMassFactor = iMassFactor * GetBuildingSizeFactor(oUnit.UnitId)
                        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iMassFactor after considering if will kill it and how large it is='..iMassFactor..'; iFactorIfWontKill='..iFactorIfWontKill..'; Building size factor='..GetBuildingSizeFactor(oUnit.UnitId)) end
                        --Is the target mobile and not under construction? Then reduce to 20% as unit might dodge or not be there when bomb lands
                        if oUnit:GetFractionComplete() == 1 then
                            if EntityCategoryContains(categories.MOBILE, oUnit.UnitId) then
                                if iCurDist <= iMobileDamageDistThreshold then
                                    if oUnit:IsUnitState('Moving') then
                                        iMassFactor = iMassFactor * iMobileDamageFactorWithinThreshold
                                    else
                                        iMassFactor = iMassFactor * iMobileDamageNotMovingWithinThreshold
                                    end
                                else
                                    if oUnit:IsUnitState('Moving') then
                                        iMassFactor = iMassFactor * iMobileDamageFactorOutsideThresholdMoving
                                    else
                                        iMassFactor = iMassFactor * iMobileDamageFactorOutsideThreshold
                                    end
                                end
                                --Is it a mex that will be killed outright and/or a volatile structure? Then increase the value of killing it
                            elseif iMassFactor >= 1 and EntityCategoryContains(categories.MASSEXTRACTION + categories.VOLATILE, oUnit.UnitId) then iMassFactor = iMassFactor * 2
                            end
                        end
                        if bT3ArtiShotReduction then
                            if (oUnit[refiT3ArtiShotCount] >= iT3ArtiShotThreshold) then
                                iMassFactor = iMassFactor * 0.1
                            elseif (oUnit[refiT3ArtiLifetimeShotCount] or 0) >= iT3ArtiShotLifetimeThreshold then
                                iMassFactor = iMassFactor * math.max(0.1, 0.4 * oUnit[refiT3ArtiLifetimeShotCount] / iT3ArtiShotLifetimeThreshold)
                            end
                        end
                        iTotalDamage = iTotalDamage + oCurBP.Economy.BuildCostMass * oUnit:GetFractionComplete() * iMassFactor
                        --Increase further for SML and SMD that might have a missile
                        if EntityCategoryContains(M28UnitInfo.refCategorySML - M28UnitInfo.refCategoryBattleship, oUnit.UnitId) then
                            if oUnit:GetFractionComplete() == 1 then
                                iTotalDamage = iTotalDamage + 12000 * math.min(iMassFactor, 1)
                            end
                        elseif EntityCategoryContains(M28UnitInfo.refCategorySMD, oUnit.UnitId) then
                            if oUnit:GetFractionComplete() == 1 then
                                iTotalDamage = iTotalDamage + 3600 * math.min(iMassFactor, 1)
                                --Also increase if we have a nuke launcher more than 35% complete

                                function HaveSML(oBrain)
                                    local tFriendlyNukes = aiBrain:GetListOfUnits(M28UnitInfo.refCategorySML, false, true)
                                    if M28Utilities.IsTableEmpty(tFriendlyNukes) == false then
                                        for iUnit, oUnit in tFriendlyNukes do
                                            if oUnit:GetFractionComplete() == 1 then
                                                if oUnit:GetWorkProgress() >= 0.35 then
                                                    return true
                                                elseif oUnit.GetNukeSiloAmmoCount and oUnit:GetNukeSiloAmmoCount() >= 1 then
                                                    return true
                                                end
                                            end
                                        end
                                    end
                                    return false
                                end
                                local bHaveFriendlySMLNearlyLoaded = false
                                if not(bHaveFriendlySMLNearlyLoaded) then
                                    for iBrain, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyActiveM28Brains] do
                                        if not(oBrain == aiBrain) then
                                            if HaveSML(oBrain) then
                                                bHaveFriendlySMLNearlyLoaded = true
                                                break
                                            end
                                        end
                                    end
                                end
                                if bHaveFriendlySMLNearlyLoaded then
                                    iTotalDamage = iTotalDamage + 10000
                                end
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Finished considering the unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iTotalDamage='..iTotalDamage..'; oCurBP.Economy.BuildCostMass='..oCurBP.Economy.BuildCostMass..'; oUnit:GetFractionComplete()='..oUnit:GetFractionComplete()..'; iMassFactor after considering if unit is mobile='..iMassFactor..'; distance between unit and target='..M28Utilities.GetDistanceBetweenPositions(tBaseLocation, oUnit:GetPosition())) end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished going through units in the aoe, iTotalDamage in mass='..iTotalDamage..'; tBaseLocation='..repru(tBaseLocation)..'; iAOE='..iAOE..'; iDamage='..iDamage) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iTotalDamage
end

function GetBestAOETarget(aiBrain, tBaseLocation, iAOE, iDamage, bOptionalCheckForSMD, tSMLLocationForSMDCheck, iOptionalTimeSMDNeedsToHaveBeenBuiltFor, iSMDRangeAdjust, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, iOptionalMaxDistanceCheckOptions, iMobileValueOverrideFactorWithin75Percent, iOptionalShieldReductionFactor)
    --Calcualtes the most damaging location for an aoe target; also returns the damage dealt
    --if bOptionalCheckForSMD is true then will ignore targest that are near an SMD
    --iOptionalMaxDistanceCheckOptions - can use to limit hte nubmer of distance options that will choose
    --iFriendlyUnitAOEFactor - e.g. if 2, then will search for friendly units in 2x the aoe
    --iOptionalShieldReductionFactor - instead of igivng shielded targets 0 value this assigns this % of value
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetBestAOETarget'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': About to find the best target for bomb, tBaseLocation='..repru(tBaseLocation)..'; iAOE='..(iAOE or 'nil')..'; iDamage='..(iDamage or 'nil')) end

    local tBestTarget = {tBaseLocation[1], tBaseLocation[2], tBaseLocation[3]}
    --GetDamageFromBomb(aiBrain, tBaseLocation, iAOE, iDamage)
    --GetDamageFromBomb(aiBrain, tBaseLocation, iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor)
    local iCurTargetDamage = GetDamageFromBomb(aiBrain, tBaseLocation, iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, nil, nil, nil, iMobileValueOverrideFactorWithin75Percent, nil, iOptionalShieldReductionFactor)
    local iMaxTargetDamage = iCurTargetDamage
    local iMaxDistanceChecks = math.min(4, math.ceil(iAOE / 2))
    if iOptionalMaxDistanceCheckOptions then iMaxDistanceChecks = math.min(iOptionalMaxDistanceCheckOptions, iMaxDistanceChecks) end
    local iDistanceFromBase = 0
    local tPossibleTarget
    if bOptionalCheckForSMD and M28Building.IsSMDBlockingTarget(aiBrain, tBaseLocation, tSMLLocationForSMDCheck, (iOptionalTimeSMDNeedsToHaveBeenBuiltFor or 200), iSMDRangeAdjust) then iMaxTargetDamage = math.min(4000, iMaxTargetDamage) end

    for iCurDistanceCheck = iMaxDistanceChecks, 1, -1 do
        iDistanceFromBase = iAOE / iCurDistanceCheck
        for iAngle = 0, 360, 45 do
            tPossibleTarget = M28Utilities.MoveInDirection(tBaseLocation, iAngle, iDistanceFromBase)
            --GetDamageFromBomb(aiBrain, tBaseLocation, iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, bCumulativeShieldHealthCheck, iOptionalSizeAdjust, iOptionalModIfNeedMultipleShots, iMobileValueOverrideFactorWithin75Percent, bT3ArtiShotReduction, iOptionalShieldReductionFactor)
            iCurTargetDamage = GetDamageFromBomb(aiBrain, tPossibleTarget, iAOE, iDamage, iFriendlyUnitDamageReductionFactor, iFriendlyUnitAOEFactor, nil, nil, nil, iMobileValueOverrideFactorWithin75Percent, nil, iOptionalShieldReductionFactor)
            if iCurTargetDamage > iMaxTargetDamage then
                if bOptionalCheckForSMD and M28Building.IsSMDBlockingTarget(aiBrain, tPossibleTarget, tSMLLocationForSMDCheck, (iOptionalTimeSMDNeedsToHaveBeenBuiltFor or 200), iSMDRangeAdjust) then iCurTargetDamage = math.min(4000, iCurTargetDamage) end
                if iCurTargetDamage > iMaxTargetDamage then
                    tBestTarget = tPossibleTarget
                    iMaxTargetDamage = iCurTargetDamage
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished checking every angle for iDistanceFromBase='..iDistanceFromBase..'; iMaxTargetDamage='..iMaxTargetDamage..'; tBestTarget='..repru(tBestTarget)) end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef..': Best target for bomb='..repru(tBestTarget)..'; iMaxTargetDamage='..iMaxTargetDamage)
        M28Utilities.DrawLocation(tBestTarget)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tBestTarget, iMaxTargetDamage
end