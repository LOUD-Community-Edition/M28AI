---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 07/12/2022 19:50
---
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')


refiNearestEnemyIndex = 'M28NearestEnemyIndex'


function GetNearestEnemyIndex(aiBrain)
    --Returns the army index of the nearest enemy brain, or nil if there is none
    local oNearestBrain = M28Overseer.GetNearestEnemyBrain(aiBrain)
    if oNearestBrain then return oNearestBrain:GetArmyIndex() else return nil end
end

function GetDirectFireWeaponPosition(oFiringUnit)
    --Returns position of oFiringUnit's first DF weapon; nil if oFiringUnit doesnt have a DF weapon; Unit position if no weapon bone
    --for ACU, returns this for the overcharge weapon
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetDirectFireWeaponPosition'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local oBPFiringUnit = oFiringUnit:GetBlueprint()
    local tShotStartPosition
    if EntityCategoryContains(categories.DIRECTFIRE + M28UnitInfo.refCategoryFatboy, oBPFiringUnit.BlueprintId) == true then
        local bIsACU = EntityCategoryContains(categories.COMMAND, oBPFiringUnit.BlueprintId)

        local sFiringBone
        if bDebugMessages == true then LOG(sFunctionRef..': Have a DF unit, working out where shot coming from') end
        --Work out where the shot is coming from:
        local bIsFatboy = EntityCategoryContains(M28UnitInfo.refCategoryFatboy, oFiringUnit)
        for iCurWeapon, oWeapon in oBPFiringUnit.Weapon do
            if oWeapon.RangeCategory and (oWeapon.RangeCategory == 'UWRC_DirectFire' or (bIsFatboy and oWeapon.RangeCategory == 'UWRC_IndirectFire')) then
                if bDebugMessages == true then LOG(sFunctionRef..': Have a weapon with range category') end
                if oWeapon.RackBones then
                    if bDebugMessages == true then LOG(sFunctionRef..': Have a weapon with RackBones') end
                    for _, oRackBone in oWeapon.RackBones do
                        if bDebugMessages == true then LOG(sFunctionRef..' Cur oRackBone='..repru(oRackBone)) end
                        if oRackBone.MuzzleBones then
                            sFiringBone = oRackBone.MuzzleBones[1]
                            if bDebugMessages == true then LOG(sFunctionRef..': Found muzzlebone='..sFiringBone) end
                            break
                        else
                            if bDebugMessages == true then LOG(sFunctionRef..': Cant locate muzzle bone') end
                        end
                    end
                    if sFiringBone then
                        if bIsACU == false then break
                        else
                            --ACU - make sure we have an overcharge weapon (to avoid e.g. cybran laser weapon)
                            if oWeapon.OverChargeWeapon then
                                break
                            end
                        end
                    end
                end
            end
        end
        if sFiringBone then
            tShotStartPosition = oFiringUnit:GetPosition(sFiringBone)
        else
            tShotStartPosition = oFiringUnit:GetPosition()
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tShotStartPosition
end

function IsLineBlocked(aiBrain, tShotStartPosition, tShotEndPosition, iAOE, bReturnDistanceThatBlocked)
    --If iAOE is specified then will end once reach the iAOE range
    --(aiBrain included as argument as want to retry CheckBlockingTerrain in the future)
    --bReturnDistanceThatBlocked - if true then returns either distance at which shot is blocked, or the distance+1 between the start and end position

    --Angle (looking only at vertical dif) from shot start to shot end, theta: Tan Theta = Opp/Adj, so Theta = tan-1 Opp/Adj
    --Once have this angle, then the height if move vertically to the target is: Sin theta = opp / hyp
    --Opp is the height dif; adj is the distance between start and end (referred to below as iFlatDistance)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsLineBlocked'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local bShotIsBlocked = false
    local iFlatDistance = M28Utilities.GetDistanceBetweenPositions(tShotStartPosition, tShotEndPosition)
    local tTerrainPositionAtPoint = {}
    local bStartHigherThanEnd = false
    if tShotStartPosition[2] > tShotEndPosition[2] then bStartHigherThanEnd = true end
    if iFlatDistance > 1 then
        local iAngleInRadians = math.atan(math.abs((tShotEndPosition[2] - tShotStartPosition[2])) / iFlatDistance)
        local iShotHeightAtPoint
        if bDebugMessages == true then LOG(sFunctionRef..': About to check if at any point on path shot will be lower than terrain; iAngle='..M28Utilities.ConvertAngleToRadians(iAngleInRadians)..'; startshot height='..tShotStartPosition[2]..'; target height='..tShotEndPosition[2]..'; iFlatDistance='..iFlatDistance) end
        local iEndPoint = math.max(1, math.floor(iFlatDistance - (iAOE or 0)))
        for iPointToTarget = 1, iEndPoint do
            --math.min(math.floor(iFlatDistance), math.max(math.floor(iStartDistance or 1),1)), math.floor(iFlatDistance) do
            --MoveTowardsTarget(tStartPos, tTargetPos, iDistanceToTravel, iAngle)
            tTerrainPositionAtPoint = M28Utilities.MoveInDirection(tShotStartPosition, M28Utilities.GetAngleFromAToB(tShotStartPosition, tShotEndPosition), iPointToTarget, false, false)
            if bDebugMessages == true then LOG(sFunctionRef..': iPointToTarget='..iPointToTarget..'; tTerrainPositionAtPoint='..repru(tTerrainPositionAtPoint)) end
            if bStartHigherThanEnd then iShotHeightAtPoint = tShotStartPosition[2] - math.sin(iAngleInRadians) * iPointToTarget
            else iShotHeightAtPoint = tShotStartPosition[2] + math.sin(iAngleInRadians) * iPointToTarget
            end
            if iShotHeightAtPoint <= tTerrainPositionAtPoint[2] then
                if not(iPointToTarget == iEndPoint and iShotHeightAtPoint == tTerrainPositionAtPoint[2]) then
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Shot blocked at this position; iPointToTarget='..iPointToTarget..'; iShotHeightAtPoint='..iShotHeightAtPoint..'; tTerrainPositionAtPoint='..tTerrainPositionAtPoint[2])
                        M28Utilities.DrawLocation(tTerrainPositionAtPoint, 5, 10)
                    end
                    bShotIsBlocked = true
                    if bReturnDistanceThatBlocked then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        return iPointToTarget
                    end

                    break
                elseif bDebugMessages == true then LOG(sFunctionRef..': Are at end point and terrain height is identical, so will assume we will actually reach the target')
                end
            else
                if bDebugMessages == true then
                    LOG(sFunctionRef..': Shot not blocked at this position, will draw in blue; iPointToTarget='..(iPointToTarget or 'nil')..'; iShotHeightAtPoint='..(iShotHeightAtPoint or 'nil')..'; tTerrainPositionAtPoint='..(tTerrainPositionAtPoint[2] or 'nil')..'; iAngle='..M28Utilities.ConvertAngleToRadians(iAngleInRadians)..'; iPointToTarget='..(iPointToTarget or 'nil')..'; tShotStartPosition[2]='..(tShotStartPosition[2] or 'nil'))
                    M28Utilities.DrawLocation(tTerrainPositionAtPoint, 1, 20)
                end
            end
        end
    else bShotIsBlocked = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bReturnDistanceThatBlocked and not(bShotIsBlocked) then return M28Utilities.GetDistanceBetweenPositions(tShotStartPosition, tShotEndPosition) + 1
    else
        return bShotIsBlocked
    end
end

function IsShotBlocked(oFiringUnit, oTargetUnit)
    --Returns true or false depending on if oFiringUnit can hit oTargetUnit in a straight line
    --intended for direct fire units only
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsShotBlocked'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local bShotIsBlocked = false
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code') end
    local tShotStartPosition = GetDirectFireWeaponPosition(oFiringUnit)
    if tShotStartPosition then
        if bDebugMessages == true then LOG(sFunctionRef..': tShotStartPosition='..repru(tShotStartPosition)) end
        if tShotStartPosition[2] <= 0 then bShotIsBlocked = true
        else
            local tShotEndPosition = {}
            local oBPTargetUnit = oTargetUnit:GetBlueprint()
            local iLowestHeight = 1000
            local iHighestHeight = -1000
            local sLowestBone, sHighestBone
            local tTargetUnitDefaultPosition = oTargetUnit:GetPosition()
            --Work out where the shot is targetting - not all units will have a bone specified in the AI section, in which case just get the unit position
            if oBPTargetUnit.AI and oBPTargetUnit.AI.TargetBones then
                if bDebugMessages == true then LOG(sFunctionRef..': Have targetbones in the targetunit blueprint; repr='..repru(oBPTargetUnit.AI.TargetBones)) end
                --Is the target higher or lower than the shooter? If higher, want the lowest target bone; if lower, want the highest target bone
                for iBone, sBone in oBPTargetUnit.AI.TargetBones do
                    if oTargetUnit:IsValidBone(sBone) == true then
                        tShotEndPosition = oTargetUnit:GetPosition(sBone)
                        if bDebugMessages == true then LOG(sFunctionRef..' Getting position for sBone='..sBone..'; position='..repru(tShotEndPosition)) end
                        if tShotEndPosition[2] < iLowestHeight then
                            iLowestHeight = tShotEndPosition[2]
                            sLowestBone = sBone
                        end
                        if tShotEndPosition[2] > iHighestHeight then
                            iHighestHeight = tShotEndPosition[2]
                            sHighestBone = sBone
                        end
                    end
                end
                --Try alternative approach:
                if sHighestBone == nil and oTargetUnit.GetBoneCount then
                    local iBoneCount = oTargetUnit:GetBoneCount()
                    local sBone
                    if iBoneCount > 0 then
                        for iCurBone = 0, iBoneCount - 1 do
                            sBone = oTargetUnit:GetBoneName(iCurBone)
                            if sBone then
                                if oTargetUnit:IsValidBone(sBone) == true then
                                    tShotEndPosition = oTargetUnit:GetPosition(sBone)
                                    if bDebugMessages == true then LOG(sFunctionRef..' Getting position for sBone='..sBone..'; position='..repru(tShotEndPosition)) end
                                    if tShotEndPosition[2] < iLowestHeight then
                                        iLowestHeight = tShotEndPosition[2]
                                        sLowestBone = sBone
                                    end
                                    if tShotEndPosition[2] > iHighestHeight then
                                        iHighestHeight = tShotEndPosition[2]
                                        sHighestBone = sBone
                                    end
                                end
                            end
                        end
                    end
                end
            end
            if sHighestBone == nil then
                tShotEndPosition = tTargetUnitDefaultPosition
                if bDebugMessages == true then LOG(sFunctionRef..': Couldnt find a bone to target for target unit, so using its position instaed='..repru(tShotEndPosition)) end
            else
                if tTargetUnitDefaultPosition[2] > tShotStartPosition[2] then
                    tShotEndPosition = oTargetUnit:GetPosition(sLowestBone)
                else
                    tShotEndPosition = oTargetUnit:GetPosition(sHighestBone)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': HighestBone='..sHighestBone..'; lowest bone='..sLowestBone..'; tShotEndPosition='..repru(tShotEndPosition)) end
            end
            --Have the shot end and start positions; Now check that not firing at underwater target
            if tShotEndPosition[2] < GetSurfaceHeight(tShotEndPosition[1], tShotEndPosition[3]) then
                bShotIsBlocked = true
            else
                --Have the shot end and start positions; now want to move along a line between the two and work out if terrain will block the shot
                if bDebugMessages == true then LOG(sFunctionRef..': About to see if line is blocked. tShotStartPosition='..repru(tShotStartPosition)..'; tShotEndPosition='..repru(tShotEndPosition)..'; Terrain height at start='..GetTerrainHeight(tShotStartPosition[1], tShotStartPosition[3])..'; Terrain height at end='..GetTerrainHeight(tShotEndPosition[1], tShotEndPosition[3])) end
                bShotIsBlocked = IsLineBlocked(oFiringUnit:GetAIBrain(), tShotStartPosition, tShotEndPosition)
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return bShotIsBlocked
end

function IsTargetUnderShield(aiBrain, oTarget, iIgnoreShieldsWithLessThanThisHealth, bReturnShieldHealthInstead, bIgnoreMobileShields, bTreatPartCompleteAsComplete, bCumulativeShieldHealth)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'IsTargetUnderShield'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --Determines if target is under a shield
    --bCumulativeShieldHealth - if true, then will treat as being under a shield if all shields combined have health of at least iIgnoreShieldsWithLessThanThisHealth
    --if oTarget.UnitId == 'urb4206' then bDebugMessages = true end
    if M28UnitInfo.IsUnitValid(oTarget) and oTarget.GetHealth then
        if bDebugMessages == true and EntityCategoryContains(M28UnitInfo.refCategoryFixedShield, oTarget.UnitId) then
            if oTarget.MyShield.GetHealth then
                LOG(sFunctionRef..': oTarget is a shield='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'; Shield ratio='..oTarget:GetShieldRatio(false)..'; Shield ratio true='..oTarget:GetShieldRatio(true)..'; Shield health='..oTarget.MyShield:GetHealth()..'; SHield max health='..oTarget.MyShield:GetMaxHealth()..'; Active consumption='..tostring(oTarget.ActiveConsumption)..'; reprs of shield='..reprs(oTarget.MyShield))
            else
                LOG(sFunctionRef..': oTarget is a shield but it doesnt have a .GetHealth property. target='..oTarget.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTarget)..'reprs of shield='..reprs(oTarget.MyShield))
            end
        end
        if iIgnoreShieldsWithLessThanThisHealth == nil then iIgnoreShieldsWithLessThanThisHealth = 0 end
        local bUnderShield = false
        local iShieldSearchRange = 46 --T3 sera shield is 46; bulwark is 120; will go with sera t3 for now; if changing here then also change reference in getmaxstrikedamage
        --Is the target an enemy?
        local oTBrain = oTarget:GetAIBrain()
        local bEnemy
        if oTBrain == aiBrain then
            bEnemy = false
        else
            local iOurArmyIndex = aiBrain:GetArmyIndex()
            local iTargetArmyIndex = oTBrain:GetArmyIndex()
            if iOurArmyIndex and iTargetArmyIndex then
                bEnemy = IsEnemy(iOurArmyIndex, iTargetArmyIndex)
            else bEnemy = true
            end
        end
        local sSearchType = 'Ally'
        if bEnemy then sSearchType = 'Enemy' end
        local tTargetPos = oTarget:GetPosition()
        local iShieldCategory = M28UnitInfo.refCategoryMobileLandShield + M28UnitInfo.refCategoryFixedShield
        if bIgnoreMobileShields then iShieldCategory = M28UnitInfo.refCategoryFixedShield end
        local tNearbyShields = aiBrain:GetUnitsAroundPoint(iShieldCategory, tTargetPos, iShieldSearchRange, sSearchType)
        if bDebugMessages == true then LOG(sFunctionRef..': Searching for shields around '..repru(tTargetPos)..'; iShieldSearchRange='..iShieldSearchRange..'; sSearchType='..sSearchType) end
        local iShieldCurHealth, iShieldMaxHealth
        local iTotalShieldCurHealth = 0
        local iTotalShieldMaxHealth = 0
        local iMinFractionComplete = 0.95

        local iShieldSizeAdjust = 2 --i.e. if want to be prudent about whether can hit an enemy should be positive, if prudent about whether an ally is protected want a negative value
        if not(bEnemy) then iShieldSizeAdjust = -1 end

        if bTreatPartCompleteAsComplete then iMinFractionComplete = 0 end
        if M28Utilities.IsTableEmpty(tNearbyShields) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Size of tNearbyShields='..table.getn(tNearbyShields)) end
            local oCurUnitBP, iCurShieldRadius, iCurDistanceFromTarget
            for iUnit, oUnit in tNearbyShields do
                if not(oUnit.Dead) and oUnit:GetFractionComplete() >= iMinFractionComplete then
                    oCurUnitBP = oUnit:GetBlueprint()
                    iCurShieldRadius = 0
                    if oCurUnitBP.Defense and oCurUnitBP.Defense.Shield then
                        if bDebugMessages == true then LOG(sFunctionRef..': Target has a shield, will check its shield size and how close that is to the target') end
                        iCurShieldRadius = oCurUnitBP.Defense.Shield.ShieldSize * 0.5
                        if iCurShieldRadius > 0 then
                            iCurDistanceFromTarget = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetPos)
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurDistance to shield='..iCurDistanceFromTarget..'; iCurShieldRadius='..iCurShieldRadius..'; shield position='..repru(oUnit:GetPosition())..'; target position='..repru(tTargetPos)) end
                            if iCurDistanceFromTarget <= (iCurShieldRadius + iShieldSizeAdjust) then --if dont increase by anything then half of unit might be under shield which means bombs cant hit it
                                if bDebugMessages == true then LOG(sFunctionRef..': Shield is large enough to cover target, will check its health') end
                                iShieldCurHealth, iShieldMaxHealth = M28UnitInfo.GetCurrentAndMaximumShield(oUnit)
                                iTotalShieldCurHealth = iTotalShieldCurHealth + iShieldCurHealth
                                iTotalShieldMaxHealth = iTotalShieldMaxHealth + iShieldMaxHealth
                                if bTreatPartCompleteAsComplete or (oUnit:GetFractionComplete() >= 0.95 and oUnit:GetFractionComplete() < 1) then iShieldCurHealth = iShieldMaxHealth end
                                if bDebugMessages == true then LOG(sFunctionRef..': iShieldCurHealth='..iShieldCurHealth..'; iIgnoreShieldsWithLessThanThisHealth='..iIgnoreShieldsWithLessThanThisHealth) end
                                if (not(bCumulativeShieldHealth) and iShieldCurHealth >= iIgnoreShieldsWithLessThanThisHealth) or (bCumulativeShieldHealth and iTotalShieldCurHealth >= iIgnoreShieldsWithLessThanThisHealth) then
                                    bUnderShield = true
                                    if bDebugMessages == true then LOG(sFunctionRef..': Shield health more than threshold so unit is under a shield') end
                                    if not(bReturnShieldHealthInstead) then break end
                                end
                            end
                        elseif bDebugMessages == true then LOG(sFunctionRef..': Shield radius isnt >0')
                        end
                    else
                        if bDebugMessages == true then LOG(sFunctionRef..': Blueprint doesnt have a shield value; UnitID='..oUnit.UnitId) end
                    end
                elseif bDebugMessages == true then LOG(sFunctionRef..': Unit is dead')
                end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': tNearbyShields is empty') end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        if bReturnShieldHealthInstead then
            return iTotalShieldCurHealth, iTotalShieldMaxHealth
        else return bUnderShield
        end
    end
end

function GetDamageFromOvercharge(aiBrain, oTargetUnit, iAOE, iDamage, bTargetWalls)
    --Originally copied from the 'getdamagefrombomb' function, but adjusted since OC doesnt deal full damage to ACU or structures
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetDamageFromOvercharge'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iTotalDamage = 0

    local tEnemiesInRange
    if bTargetWalls then tEnemiesInRange =  aiBrain:GetUnitsAroundPoint(categories.WALL + M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryAllNavy, oTargetUnit:GetPosition(), iAOE, 'Enemy')
    else tEnemiesInRange = aiBrain:GetUnitsAroundPoint(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryAllNavy, oTargetUnit:GetPosition(), iAOE, 'Enemy')
    end

    local oCurBP
    local iMassFactor
    local iCurHealth, iMaxHealth, iCurShield, iMaxShield
    local iActualDamage
    local iKillsExpected = 0
    local iUnitsHit = 0 --E.g. if targeting walls then this means we target the most walls assuming no nearby other units
    if bDebugMessages == true then LOG(sFunctionRef..': About to loop through all enemies in range; iDamage='..iDamage..'; iAOE='..iAOE..'; Base target unit='..oTargetUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oTargetUnit)..'; position='..repru(oTargetUnit:GetPosition())) end

    if M28Utilities.IsTableEmpty(tEnemiesInRange) == false then
        for iUnit, oUnit in tEnemiesInRange do
            if oUnit.GetBlueprint then
                oCurBP = oUnit:GetBlueprint()
                if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; dist to postiion='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oTargetUnit:GetPosition())) end
                --Is the unit within range of the aoe?
                if M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oTargetUnit:GetPosition()) <= iAOE then
                    --Is the unit shielded by a non-mobile shield (mobile shields should take full damage I think)
                    --IsTargetUnderShield(aiBrain, oTarget, iIgnoreShieldsWithLessThanThisHealth, bReturnShieldHealthInstead, bIgnoreMobileShields, bTreatPartCompleteAsComplete)
                    if not(IsTargetUnderShield(aiBrain, oUnit, 800, false, true, false)) then
                        iActualDamage = iDamage
                        if EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
                            iActualDamage = 800
                        elseif EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                            iActualDamage = 400
                        end

                        iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit)
                        iCurHealth = iCurShield + oUnit:GetHealth()
                        iMaxHealth = iMaxShield + oUnit:GetMaxHealth()
                        --Set base mass value based on health
                        if iDamage >= iMaxHealth or iDamage >= math.min(iCurHealth * 3, iCurHealth + 1000) then
                            iMassFactor = 1
                            iKillsExpected = iKillsExpected + 1
                            --Was the unit almost dead already?
                            if (iCurShield + iCurHealth) <= iMaxHealth * 0.4 then iMassFactor = math.max(0.25, (iCurShield + iCurHealth) / iMaxHealth) end
                        else
                            --Still some value in damaging a unit (as might get a second strike), but far less than killing it
                            iMassFactor = 0.4
                            if EntityCategoryContains(categories.EXPERIMENTAL, oUnit.UnitId) then iMassFactor = 0.5 end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iMassFactor after considering if will kill it='..iMassFactor..'; Unit max health='..iMaxHealth..'; CurHealth='..iCurHealth) end
                        --Is the target mobile and within 1 of the AOE edge? If so then reduce to 25% as it might move out of the wayif
                        if oUnit:GetFractionComplete() == 1 and EntityCategoryContains(categories.MOBILE, oUnit.UnitId) and iAOE - 0.5 < M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oTargetUnit:GetPosition()) then iMassFactor = iMassFactor * 0.25 end
                        iTotalDamage = iTotalDamage + oCurBP.Economy.BuildCostMass * oUnit:GetFractionComplete() * iMassFactor
                        if bDebugMessages == true then LOG(sFunctionRef..': Finished considering the unit; iTotalDamage='..iTotalDamage..'; oCurBP.Economy.BuildCostMass='..oCurBP.Economy.BuildCostMass..'; oUnit:GetFractionComplete()='..oUnit:GetFractionComplete()..'; iMassFactor after considering if unit is mobile='..iMassFactor) end
                    end
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished going through units in the aoe, iTotalDamage in mass='..iTotalDamage..'; iAOE='..iAOE..'; iDamage='..iDamage) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iTotalDamage, iKillsExpected
end