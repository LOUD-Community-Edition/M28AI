---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 04/03/2023 08:22
---

local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local M28Map = import('/mods/M28AI/lua/AI/M28Map.lua')
local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28Orders = import('/mods/M28AI/lua/AI/M28Orders.lua')
local M28Engineer = import('/mods/M28AI/lua/AI/M28Engineer.lua')
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local NavUtils = import("/lua/sim/navutils.lua")

--Unit variables
refiTimeOfLastWZAssignment = 'M28WZLastAssignmentTime' --GameTimeSeconds
refiCurrentWZAssignmentValue = 'M28WZAssignmentVal' --Value of current assignment
refiCurrentAssignmentWaterZone = 'M28WZCurAssign'
reftiRadarWaterZonesCoveredByTeam = 'M28RadarWZCovered' --against radar, [x] is the team number, returns table of water zones it provides the best intel for
refiWZToMoveTo = 'M28WZToMoveTo' --e.g. aginast scouts

--aiBrian variables
refiPriorityPondRef = 'M28PriorityPondRef' --against aibrain, returns the pond ref (naval segment group) that we think is most important to that aibrain (only recorded for M27 brains)
reftiPondThreatToUs = 'M28PondThreatToUs' --against aiBrain, [x] is the pond ref (naval segment group), returns the 'mex value' of that pond when considering mexes within 40% of our base (mod distance).  Only recorded for ponds where we have identified a naval yard build location
reftiPondValueToUs = 'M28PondValueToUs' --against aiBrain, [x] is the pond ref (naval segment group), returns the expected value of the pond if we have naval control of it (so ignores distance reductions that are used to decide if we want to build navy there in the first place)
refbEnemyNavyPreventingBuildingNavy = 'M28PondEnemyNavyNearBuildLocation' --against aibrain, true if enemy has navy near to the build location

--Global variables
tWZRefreshCountByTeam = {}

function GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetNearestWaterRallyPoint'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()..'; iPond='..(iPond or 'nil')..'; iWaterZone='..(iWaterZone or 'nil')..'; iTeam='..(iTeam or 'nil')..'; Is table of rally points by pond for this pond empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond]))) end
    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond]) == false then
        local iCurDist
        local iClosestDist = 100000
        local iClosestWZRef

        for iEntry, iAltWZ in M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond] do
            if bDebugMessages == true then LOG(sFunctionRef..': Looking for rally point for iPond '..iPond..'; iWaterZone '..iWaterZone..'; Considering iAltWZ='..iAltWZ) end
            if iAltWZ == iWaterZone then
                iClosestWZRef = iAltWZ
                break
            else
                local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAltWZ]
                if tAltWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZbCoreBase] then
                    iCurDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefWZMidpoint], tAltWZData[M28Map.subrefWZMidpoint])
                    if iCurDist < iClosestDist then
                        iClosestDist = iCurDist
                        iClosestWZRef = iAltWZ
                    end
                end
            end
        end
        if not(iClosestWZRef) then iClosestWZRef = iWaterZone end
        --Land zone will consider moving 2 towards the rally ponit land zone; have left this out for water zones for now but could add in if it becomes an issue

        --Water zone specific - if we have a naval fac in this water zone, then choose that as the retreat point
        local tRallyWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iClosestWZRef]
        local tRallyWZTeamData = tRallyWZData[M28Map.subrefWZTeamData][iTeam]

        if M28Utilities.IsTableEmpty(tRallyWZTeamData[M28Map.subrefWZTAlliedUnits]) == false then
            local tFriendlyFactories = EntityCategoryFilterDown(M28UnitInfo.refCategoryAllHQFactories,     tRallyWZTeamData[M28Map.subrefWZTAlliedUnits])
            if M28Utilities.IsTableEmpty(tFriendlyFactories) == false then
                return M28Utilities.MoveInDirection(tFriendlyFactories[1]:GetPosition(), M28Utilities.GetAngleFromAToB(tFriendlyFactories[1]:GetPosition(), tRallyWZData[M28Map.subrefWZMidpoint]), 8, true, false)
            end
        end

        return {tRallyWZData[M28Map.subrefWZMidpoint][1], tRallyWZData[M28Map.subrefWZMidpoint][2], tRallyWZData[M28Map.subrefWZMidpoint][3]}
    else
        M28Utilities.ErrorHandler('No rally point for Pond '..(iPond or 'nil')..' WZ'..(iWaterZone or 'nil')..'; will return current midpoint')
        return {tWZData[M28Map.subrefWZMidpoint][1], tWZData[M28Map.subrefWZMidpoint][2], tWZData[M28Map.subrefWZMidpoint][3]}
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshWaterRallyPoints(iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RefreshWaterRallyPoints'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time '..GetGameTimeSeconds()) end
    M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond] = {}
    for iPond, tPondSubtable in M28Map.tPondDetails do
        M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond] = {}
        for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do
            if tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZbCoreBase] then
                table.insert(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond], iWaterZone)
                if bDebugMessages == true then LOG(sFunctionRef..': Added iWaterZone='..(iWaterZone or 'nil')..' as a water zone rally for pond '..iPond..' based on core base flag') end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Considering pond '..iPond..'; Is table of water zone rally points by pond empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond]))) end
        if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond]) then
            --Dont have any core WZ, so need to pick the WZ whose midpoint is closest to a base - filter to just the water zones that are adjacent to a LZ
            local iCurDistToRallyLZ
            local iClosestDistToRallyLZ = 100000
            local iClosestWZRef
            local iPlateau
            for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do
                iPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tWZData[M28Map.subrefWZMidpoint])
                if iPlateau then break end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Will see if nearby land zone rally points to any water zones, iPlateau='..(iPlateau or 'nil')..'; Is table of rally point land zones for this plateau empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau]))) end
            if iPlateau and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau]) == false then
                for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do
                    --Does the WZ have adjacent LZ?
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iWaterZone='..iWaterZone..'; Is the table of adjacent land zones empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]))) end
                    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
                        --Search rally points for this plateau and get the closest
                        for iEntry, iAltLZ in M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointLandZonesByPlateau][iPlateau] do
                            iCurDistToRallyLZ = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefWZMidpoint], M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAltLZ][M28Map.subrefLZMidpoint])
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurDistToRallyLZ='..iCurDistToRallyLZ..'; iClosestDistToRallyLZ='..iClosestDistToRallyLZ) end
                            if iCurDistToRallyLZ < iClosestDistToRallyLZ then
                                iClosestDistToRallyLZ = iCurDistToRallyLZ
                                iClosestWZRef = iWaterZone
                            end
                        end
                    end
                end
                if iClosestWZRef then
                    table.insert(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][iPond], iClosestWZRef)
                    if bDebugMessages == true then LOG(sFunctionRef..': Added iClosestWZRef='..(iClosestWZRef or 'nil')..' as a water zone rally') end
                end
            end
        end
    end
    if bDebugMessages == true then
        LOG(sFunctionRef..': End of code, repru of rally points by pond for team '..iTeam..'='..repru(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond]))
        LOG(sFunctionRef..': Is table empty for pond 5='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][5]))..'; repru for pond 5='..repru(M28Team.tTeamData[iTeam][M28Team.subrefiRallyPointWaterZonesByPond][5]))
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateUnitPositionsAndWaterZone(aiBrain, tUnits, iTeam, iRecordedWaterZone, bUseLastKnownPosition, bAreAirUnits, tWZTeamData)
    --Similar to UpdateUnitPositionsAndLandZone

    local iRevisedIndex = 1
    local iTableSize = table.getn(tUnits)
    local iActualWaterZone
    local iUnitSegmentX, iUnitSegmentZ
    local UpdateUnitLastKnownPosition = M28Team.UpdateUnitLastKnownPosition
    local bUseActualPositionIfEnemy = false
    if tWZTeamData[M28Map.refiRadarCoverage] >= 100 then bUseActualPositionIfEnemy = true end

    for iOrigIndex=1, iTableSize do
        if not(tUnits[iOrigIndex]) or tUnits[iOrigIndex].Dead then
            --Remove the entry
            tUnits[iOrigIndex] = nil
        else
            --Unit still valid, does it have the right water zone?
            if bUseLastKnownPosition then
                UpdateUnitLastKnownPosition(aiBrain, tUnits[iOrigIndex], bUseActualPositionIfEnemy, true)
                iUnitSegmentX, iUnitSegmentZ = M28Map.GetPathingSegmentFromPosition(tUnits[iOrigIndex][M28UnitInfo.reftLastKnownPositionByTeam][aiBrain.M28Team])
            else
                --Allied unit so can use actual position
                iUnitSegmentX, iUnitSegmentZ = M28Map.GetPathingSegmentFromPosition(tUnits[iOrigIndex]:GetPosition())
            end
            iActualWaterZone = M28Map.tWaterZoneBySegment[iUnitSegmentX][iUnitSegmentZ]

            --Is the water zone correct?
            if iActualWaterZone == iRecordedWaterZone then
                --No change needed for unit
                if (iOrigIndex ~= iRevisedIndex) then
                    tUnits[iRevisedIndex] = tUnits[iOrigIndex]
                    tUnits[iOrigIndex] = nil
                end
                iRevisedIndex = iRevisedIndex + 1
            else
                local oUnitToAdd = tUnits[iOrigIndex]
                oUnitToAdd[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] = nil
                if iActualWaterZone > 0 then
                    --AddUnitToWaterZoneForBrain(aiBrain,        oUnit,      iWaterZone,      bIsEnemyAirUnit)
                    M28Team.AddUnitToWaterZoneForBrain(aiBrain, oUnitToAdd, iActualWaterZone, bAreAirUnits)
                else
                    --[[if bAreAirUnits then
                        --Add unit to table of air units without a plateau
                        M28Air.RecordEnemyAirUnitWithNoZone(iTeam, oUnitToAdd)
                    else--]]
                        --Not sure where to record unit so call main logic
                        M28Team.AssignUnitToLandZoneOrPond(aiBrain, oUnitToAdd, true)
                    --end
                end

                tUnits[iOrigIndex] = nil
            end
        end
    end
end

function UpdateIfWaterZoneWantsSupport(tWZTeamData, bWantCombatSupport)
    tWZTeamData[M28Map.subrefbWZWantsSupport] = bWantCombatSupport
end

function GetUnitToTravelToWaterZone(oUnit, iTargetPond, iTargetWaterZone, subrefWZTUnitTypeTravelingHere)
    --Intended for non-engineer units (engineers are handled separately)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetUnitToTravelToLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    oUnit[refiWZToMoveTo] = iTargetWaterZone
    local tWZData = M28Map.tPondDetails[iTargetPond][M28Map.subrefPondWaterZones][iTargetWaterZone]
    local tTeamData = tWZData[M28Map.subrefWZTeamData][oUnit:GetAIBrain().M28Team]
    if not(tTeamData[subrefWZTUnitTypeTravelingHere]) then tTeamData[subrefWZTUnitTypeTravelingHere] = {} end
    table.insert(tTeamData[subrefWZTUnitTypeTravelingHere], oUnit)
    if bDebugMessages == true then LOG(sFunctionRef..': About to tell unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to go to iTargetPond='..iTargetPond..'; iTargetWaterZone='..iTargetWaterZone..'; midpoint of WZ='..repru(tWZData[M28Map.subrefWZMidpoint])) end
    M28Orders.IssueTrackedMove(oUnit, tWZData[M28Map.subrefWZMidpoint], 6, false, 'NTWZ'..iTargetWaterZone)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RemoveUnitFromListOfUnitsTravelingToWaterZone(oUnit)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RemoveUnitFromListOfUnitsTravelingToWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Considering unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[refiWZToMoveTo]='..repru(oUnit[refiWZToMoveTo])) end
    if oUnit[refiWZToMoveTo] then
        local sUnitTableRef
        if EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oUnit.UnitId) then
            sUnitTableRef = M28Map.subrefWZTScoutsTravelingHere
        else
            M28Utilities.ErrorHandler('Need to add code for this unit category')
        end
        if sUnitTableRef then

            local iTargetWaterZone = oUnit[refiWZToMoveTo]
            local iTargetPond = M28Map.tiPondByWaterZone[iTargetWaterZone]
            local tTravelingUnits = M28Map.tPondDetails[iTargetPond][M28Map.subrefPondWaterZones][iTargetWaterZone][M28Map.subrefWZTeamData][oUnit:GetAIBrain().M28Team][sUnitTableRef]
            if M28Utilities.IsTableEmpty(tTravelingUnits) == false then
                for iTravelUnit, oTravelUnit in tTravelingUnits do
                    if oTravelUnit == oUnit then
                        table.remove(tTravelingUnits, iTravelUnit)
                        break
                    end
                end
            end
        end
        oUnit[refiWZToMoveTo] = nil
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


function ManageAllWaterZones(aiBrain, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageAllWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iLastRefreshCount = (tWZRefreshCountByTeam[iTeam] or 1)
    local iCurRefreshCount = 0
    local iTicksToSpreadOver = 10
    local iRefreshThreshold = math.max(2, math.ceil(iLastRefreshCount * 0.95 / iTicksToSpreadOver))
    local iCurCycleRefreshCount = 0
    local iCurTicksWaited = 0

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, Time='..GetGameTimeSeconds()) end

    if GetGameTimeSeconds() - (M28Team.tTeamData[iTeam][M28Team.refiTimeOfLastRallyPointRefresh] or -100) >= 10 then
        RefreshWaterRallyPoints(iTeam)
    end

    --Cycle through water zones
    for iPond, tPondSubtable in M28Map.tPondDetails do
        if M28Utilities.IsTableEmpty(tPondSubtable[M28Map.subrefPondWaterZones]) == false then
            for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do
                local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': iPond='..iPond..'; iWaterZone='..iWaterZone..'; Is table of enemey units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]))..'; Is table of friendly units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefWZTAlliedUnits]))) end
                --First check all units in here are alive
                if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
                    iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                    UpdateUnitPositionsAndWaterZone(aiBrain, tWZTeamData[M28Map.subrefTEnemyUnits], iTeam, iWaterZone, true, false, tWZTeamData)
                end
                if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftWZEnemyAirUnits]) == false then
                    iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                    UpdateUnitPositionsAndWaterZone(aiBrain, tWZTeamData[M28Map.reftWZEnemyAirUnits], iTeam, iWaterZone, true, true, tWZTeamData)
                end
                if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefWZTAlliedUnits]) == false then
                    iCurCycleRefreshCount = iCurCycleRefreshCount + 1
                    UpdateUnitPositionsAndWaterZone(aiBrain, tWZTeamData[M28Map.subrefWZTAlliedUnits], iTeam, iWaterZone, false, false, tWZTeamData)
                end

                ManageSpecificWaterZone(aiBrain, iTeam, iPond, iWaterZone)
                iCurCycleRefreshCount = iCurCycleRefreshCount + 1

                if iCurCycleRefreshCount >= iRefreshThreshold then
                    iCurRefreshCount = iCurRefreshCount + iCurCycleRefreshCount
                    iCurCycleRefreshCount = 0
                    if iCurTicksWaited < iTicksToSpreadOver then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                        iCurTicksWaited = iCurTicksWaited + 1
                    end
                end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Warning - no water zones found for pond '..iPond) end
        end
    end
    iCurRefreshCount = iCurRefreshCount + iCurCycleRefreshCount
    tWZRefreshCountByTeam[iTeam] = iCurRefreshCount

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordAirThreatForWaterZone(tWZTeamData, iTeam, iPond, iWaterZone)
    --NOTE: M28Navy uses similar logic for RecordAirThreatForWaterZone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAirThreatForWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                                                                    --GetAirThreatLevel(tUnits,                             bEnemyUnits, bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat)
    tWZTeamData[M28Map.refiEnemyAirToGroundThreat] = M28UnitInfo.GetAirThreatLevel(tWZTeamData[M28Map.reftWZEnemyAirUnits], true,         false,          false,               true,                  false,              true)
    tWZTeamData[M28Map.refiEnemyAirOtherThreat] = M28UnitInfo.GetAirThreatLevel(tWZTeamData[M28Map.reftWZEnemyAirUnits],      true,       true,           false,              false,                  true,               false)

    if bDebugMessages == true then LOG(sFunctionRef..': Finished updating enemy air threat values for iTeam '..iTeam..' iPond '..iPond..'; iWaterZOne '..iWaterZone..'; AirToGround threat='.. tWZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; Other air threat='..tWZTeamData[M28Map.refiEnemyAirOtherThreat]..'; Is table of enemy air units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftWZEnemyAirUnits]))) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordGroundThreatForWaterZone(tWZTeamData, iTeam, iPond, iWaterZone)
    --Records the different types of threat for the water zone

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordGroundThreatForWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    --Track team total threat - first remove the previous entry, then add in the new entry
    --M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedDFThreat] - tWZTeamData[M28Map.subrefWZThreatAllyMobileDFTotal]
    --M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedIndirectThreat] - tWZTeamData[M28Map.subrefWZThreatAllyMobileIndirectTotal]
    --M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] = M28Team.tTeamData[iTeam][M28Team.subrefiAlliedGroundAAThreat] - tWZTeamData[M28Map.subrefWZThreatAlliedAA]

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code time='..GetGameTimeSeconds()..' for iTeam='..iTeam..'; iPond='..iPond..'; iWaterZone='..iWaterZone..'; Is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]))) end

    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) then
        tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] = 0
        tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] = 0
        tWZTeamData[M28Map.subrefWZThreatEnemySurface] = 0
        tWZTeamData[M28Map.subrefWZThreatEnemyAA] = 0
        tWZTeamData[M28Map.subrefWZBestEnemyDFRange] = 0
        tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] = 0
    else
                                                            --function GetCombatThreatRating(tUnits,                            bEnemyUnits, bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly, bBlueprintThreat)
        tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] = M28UnitInfo.GetCombatThreatRating(tWZTeamData[M28Map.subrefTEnemyUnits], true, false, false, true, false)
        tWZTeamData[M28Map.subrefWZThreatEnemySubmersible] = M28UnitInfo.GetCombatThreatRating(tWZTeamData[M28Map.subrefTEnemyUnits], true,     false,          false,                      false,          false,       true)
        tWZTeamData[M28Map.subrefWZThreatEnemySurface] = M28UnitInfo.GetCombatThreatRating(tWZTeamData[M28Map.subrefTEnemyUnits], true, false, false, false, true, false)
        --GetAirThreatLevel(tUnits, bEnemyUnits, bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat)
        tWZTeamData[M28Map.subrefWZThreatEnemyAA] = M28UnitInfo.GetAirThreatLevel(tWZTeamData[M28Map.subrefTEnemyUnits], true, false, true, false, false, false, false)

        for iUnit, oUnit in tWZTeamData[M28Map.subrefTEnemyUnits] do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Combat threat rating='..M28UnitInfo.GetCombatThreatRating({ oUnit }, true)) end
            --Simplification to approach taken for land zone logic - will ignore threat (since only relevant for aeon land scout)
            if oUnit[M28UnitInfo.refiDFRange] >  tWZTeamData[M28Map.subrefWZBestEnemyDFRange] then  tWZTeamData[M28Map.subrefWZBestEnemyDFRange] = oUnit[M28UnitInfo.refiDFRange] end
            if oUnit[M28UnitInfo.refiAntiNavyRange] >  tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] then  tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange] = oUnit[M28UnitInfo.refiAntiNavyRange] end
        end
    end
    tWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal] = tWZTeamData[M28Map.subrefWZThreatEnemySurface] + tWZTeamData[M28Map.subrefWZThreatEnemySubmersible]

    --Record allied unit data
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefWZTAlliedUnits]) then
        tWZTeamData[M28Map.subrefWZThreatAlliedAntiNavy] = 0
        tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] = 0
        tWZTeamData[M28Map.subrefWZThreatAlliedSurface] = 0
        tWZTeamData[M28Map.subrefWZThreatAlliedAA] = 0
        tWZTeamData[M28Map.subrefWZBestAlliedDFRange] = 0
        tWZTeamData[M28Map.subrefWZBestAlliedSubmersibleRange] = 0
    else
        --function GetCombatThreatRating(tUnits, bEnemyUnits, bJustGetMassValue, bIndirectFireThreatOnly, bAntiNavyOnly, bAddAntiNavy, bSubmersibleOnly, bLongRangeThreatOnly, bBlueprintThreat)
        tWZTeamData[M28Map.subrefWZThreatAlliedAntiNavy] = M28UnitInfo.GetCombatThreatRating(tWZTeamData[M28Map.subrefWZTAlliedUnits], true, false, false, true, false)
        tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] = M28UnitInfo.GetCombatThreatRating(tWZTeamData[M28Map.subrefWZTAlliedUnits], true, false, false, false, false, true)
        tWZTeamData[M28Map.subrefWZThreatAlliedSurface] = M28UnitInfo.GetCombatThreatRating(tWZTeamData[M28Map.subrefWZTAlliedUnits], true, false, false, false, true, false)
        --GetAirThreatLevel(tUnits, bAlliedUnits, bIncludeAirToAir, bIncludeGroundToAir, bIncludeAirToGround, bIncludeNonCombatAir, bIncludeAirTorpedo, bBlueprintThreat)
        tWZTeamData[M28Map.subrefWZThreatAlliedAA] = M28UnitInfo.GetAirThreatLevel(tWZTeamData[M28Map.subrefWZTAlliedUnits], true, false, true, false, false, false, false)

        for iUnit, oUnit in tWZTeamData[M28Map.subrefWZTAlliedUnits] do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering Allied unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; DF range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; Combat threat rating='..M28UnitInfo.GetCombatThreatRating({ oUnit }, true)) end
            --Simplification to approach taken for land zone logic - will ignore threat (since only relevant for aeon land scout)
            if oUnit[M28UnitInfo.refiDFRange] >  tWZTeamData[M28Map.subrefWZBestAlliedDFRange] then  tWZTeamData[M28Map.subrefWZBestAlliedDFRange] = oUnit[M28UnitInfo.refiDFRange] end
            if oUnit[M28UnitInfo.refiAntiNavyRange] >  tWZTeamData[M28Map.subrefWZBestAlliedSubmersibleRange] and EntityCategoryContains(M28UnitInfo.refCategorySubmarine, oUnit.UnitId) then  tWZTeamData[M28Map.subrefWZBestAlliedSubmersibleRange] = oUnit[M28UnitInfo.refiAntiNavyRange] end
        end
    end
    tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] = tWZTeamData[M28Map.subrefWZThreatAlliedSurface] + tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible]

    --Decide what threat we want for this WZ
    local bNearbyEnemies = false

    if bDebugMessages == true then LOG(sFunctionRef..': Considering if enemy units in this or adjacent WZ, is table of enemy units for this WZ empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]))..'; Adjacent WZs='..repru(M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZOtherWaterZones]))) end
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
        bNearbyEnemies = true
    else
        if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZOtherWaterZones]) == false then
            local iAdjWZ
            for _, tWZSubtable in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZOtherWaterZones] do
                iAdjWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                --NEED to flag as nearby enemies if any enemy units in the WZ, or else can cause problems where we try to attack a unit in an adjacent water zone, and then think there is no such unit due to this flag if it is only based on combat threat
                if bDebugMessages == true then LOG(sFunctionRef..': Enemy combat threat for adjacent WZ iAdjWZ='..iAdjWZ..'; threat='..M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZThreatEnemySurface]..'; is table of enemy units empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits]))) end
                if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                    bNearbyEnemies = true
                    break
                end
            end
        end
    end
    tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] = bNearbyEnemies

    if bNearbyEnemies then
        tWZTeamData[M28Map.subrefWZCombatThreatWanted] = math.max(200, tWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal] * 2)
    else
        tWZTeamData[M28Map.subrefWZCombatThreatWanted] = 0
    end

    --If we have no friendly combat units and enemy has combat threat, then request less MAA, or none if we have no non-MAA/scout units
    if bDebugMessages == true then LOG(sFunctionRef..': Setting the MAA level wanted for iWaterZone='..iWaterZone..'; tWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal]='..tWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal]..'; tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]='..tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]..'; tWZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tWZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; tWZTeamData[M28Map.refiEnemyAirOtherThreat]='..tWZTeamData[M28Map.refiEnemyAirOtherThreat]..'; Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefWZTAlliedUnits]))) end
    if tWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal] < 11 * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] * M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech] or tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] >= math.min(1500, tWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal] * 0.9) or tWZTeamData[M28Map.subrefWZbCoreBase] then
        tWZTeamData[M28Map.subrefWZMAAThreatWanted] = math.max(tWZTeamData[M28Map.refiEnemyAirToGroundThreat] * 0.65 + tWZTeamData[M28Map.refiEnemyAirOtherThreat] * 0.15, tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] * 0.1)
    elseif M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefWZTAlliedUnits]) == false then
        local bHaveAlliedNonMAAOrScout = false
        local bHaveAlliedMAA = false
        for iUnit, oUnit in tWZTeamData[M28Map.subrefWZTAlliedUnits] do
            if EntityCategoryContains(M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryStructure + M28UnitInfo.refCategoryNavalSurface - M28UnitInfo.refCategoryMAA - M28UnitInfo.refCategoryLandScout, oUnit.UnitId) then
                bHaveAlliedNonMAAOrScout = true
                break
            elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId) then
                bHaveAlliedMAA = true
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': bHaveAlliedMAA='..tostring(bHaveAlliedMAA)..'; bHaveAlliedNonMAAOrScout='..tostring(bHaveAlliedNonMAAOrScout)) end
        if bHaveAlliedNonMAAOrScout or (bHaveAlliedMAA and tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0) then
            --SIgnificantly less MAA for dealing with non-air to ground threats
            if tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
                tWZTeamData[M28Map.subrefWZMAAThreatWanted] = math.max(tWZTeamData[M28Map.refiEnemyAirToGroundThreat], tWZTeamData[M28Map.refiEnemyAirOtherThreat] * 0.075, tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] * 0.2)
            else
                tWZTeamData[M28Map.subrefWZMAAThreatWanted] = math.max(tWZTeamData[M28Map.refiEnemyAirOtherThreat] * 0.075, tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] * 0.1)
            end
        else
            tWZTeamData[M28Map.subrefWZMAAThreatWanted] = 0
        end
    else
        tWZTeamData[M28Map.subrefWZMAAThreatWanted] = 0
    end

    --Increase MAA wanted if we have ACU in the WZ
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefAlliedACU]) == false then
        local tiMAAByTechForACU = {100, 400, 1000}
        if tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
            tWZTeamData[M28Map.subrefWZMAAThreatWanted] = tWZTeamData[M28Map.subrefWZMAAThreatWanted] + math.min(1600, tiMAAByTechForACU[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]] * 2)
        else
            tWZTeamData[M28Map.subrefWZMAAThreatWanted] = tWZTeamData[M28Map.subrefWZMAAThreatWanted] + tiMAAByTechForACU[M28Team.tTeamData[iTeam][M28Team.subrefiHighestFriendlyFactoryTech]]
        end
    end



    if bDebugMessages == true then LOG(sFunctionRef..': End of code, bNearbyEnemies='..tostring(bNearbyEnemies)..'; Allied combat='..(tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] or 'nil')..'; tWZTeamData[M28Map.subrefWZMAAThreatWanted]='..tWZTeamData[M28Map.subrefWZMAAThreatWanted]..'; tWZTeamData[M28Map.refiEnemyAirToGroundThreat]='..tWZTeamData[M28Map.refiEnemyAirToGroundThreat]..'; tWZTeamData[M28Map.refiEnemyAirOtherThreat]='..tWZTeamData[M28Map.refiEnemyAirOtherThreat]) end
    tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] = bNearbyEnemies
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function MoveToShieldTarget(oShield, tEnemyBase)
    local oBP = oShield:GetBlueprint()
    local iShieldDistanceWanted = math.max(3, oBP.Defense.Shield.ShieldSize * 0.5 - 1 - oBP.Physics.MaxSpeed - (oShield[M28Land.refoMobileShieldTarget]:GetBlueprint().Physics.MaxSpeed or 0))
    M28Orders.IssueTrackedMove(oShield, M28Utilities.MoveInDirection(oShield[M28Land.refoMobileShieldTarget]:GetPosition(), M28Utilities.GetAngleFromAToB(tEnemyBase,oShield[M28Land.refoMobileShieldTarget]:GetPosition()), iShieldDistanceWanted, true, false), math.min(5, iShieldDistanceWanted - 1), false, 'WShU'..oShield[M28Land.refoMobileShieldTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield[M28Land.refoMobileShieldTarget]))
end

function MoveToStealthTarget(oStealth, tEnemyBase)
    local oBP = oStealth:GetBlueprint()
    local iStealthDistanceWanted = math.max(8, oBP.Intel.RadarStealthFieldRadius - 1 - oBP.Physics.MaxSpeed - (oStealth[M28Land.refoMobileStealthTarget]:GetBlueprint().Physics.MaxSpeed or 0))
    M28Orders.IssueTrackedMove(oStealth, M28Utilities.MoveInDirection(oStealth[M28Land.refoMobileStealthTarget]:GetPosition(), M28Utilities.GetAngleFromAToB(tEnemyBase,oStealth[M28Land.refoMobileStealthTarget]:GetPosition()), iStealthDistanceWanted, true, false), math.min(5, iStealthDistanceWanted - 1), false, 'StU'..oStealth[M28Land.refoMobileStealthTarget].UnitId..M28UnitInfo.GetUnitLifetimeCount(oStealth[M28Land.refoMobileStealthTarget]))
end

function ShieldUnitsInWaterZone(tTeamTargetWZData, tShieldsToAssign, bAssignAllShields)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ShieldUnitsInWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    
    local bNoUnitsWantingShielding = true
    if M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) and M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileShield]) then
        M28Utilities.ErrorHandler('Are trying to send mobile shields to support a water zone that has no allied combat units in it and no units wanting shielding')
    else
        if M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileShield]) == false then
            for iTarget, oTarget in tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileShield] do
                if not(oTarget[M28Land.refoAssignedMobileShield]) then
                    if M28Utilities.IsTableEmpty(tShieldsToAssign) then
                        bNoUnitsWantingShielding = false
                        break
                    else
                        --Assign the closest mobile shield
                        local iCurDist
                        local iClosestDist = 100000
                        local iClosestRef

                        for iShield, oShield in tShieldsToAssign do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iShield='..iShield..'; Shield unit='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)) end
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oTarget:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestRef = iShield
                            end
                            break
                        end
                        tShieldsToAssign[iClosestRef][M28Land.refoMobileShieldTarget] = oTarget
                        oTarget[M28Land.refoAssignedMobileShield] = tShieldsToAssign[iClosestRef]
                        MoveToShieldTarget(tShieldsToAssign[iClosestRef], tTeamTargetWZData[M28Map.reftClosestEnemyBase])
                        table.remove(tShieldsToAssign, iClosestRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Have just removed shield with iClosestRef='..iClosestRef..' from the table of tShieldsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; size of table='..table.getn(tShieldsToAssign)) end
                    end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tShieldsToAssign) == false and bAssignAllShields then
            bNoUnitsWantingShielding = true
            --No units that want shielding - e.g. we might be telling mobile shields to defend here temporarily; dont assign the shields, instead just give them orders so they are still of some use
            if M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) == false then
                for iTarget, oTarget in tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits] do
                    if not(oTarget[M28Land.refoAssignedMobileShield]) then --redundancy
                        --Assign the closest mobile shield
                        local iCurDist
                        local iClosestDist = 100000
                        local iClosestRef

                        for iShield, oShield in tShieldsToAssign do
                            if bDebugMessages == true then LOG(sFunctionRef..': Considering entry iShield='..iShield..'; Shield unit='..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)) end
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oShield:GetPosition(), oTarget:GetPosition())
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                iClosestRef = iShield
                            end
                            break
                        end
                        --Dont record the shield as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoshieldtarget works
                        tShieldsToAssign[iClosestRef][M28Land.refoMobileShieldTarget] = oTarget
                        MoveToShieldTarget(tShieldsToAssign[iClosestRef], tTeamTargetWZData[M28Map.reftClosestEnemyBase])
                        tShieldsToAssign[iClosestRef][M28Land.refoMobileShieldTarget] = nil
                        table.remove(tShieldsToAssign, iClosestRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Backup shield assignment - Have removed shield with iClosestRef='..iClosestRef..' from the table of tShieldsToAssign; is table empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; size of table='..table.getn(tShieldsToAssign)) end
                        if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                    end
                end

                --Do we still have spare mobile shields?
                if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                    --Get closest unit to enemy base and assign all remaining shields temporarily here
                    local iCurDist
                    local iClosestDist = 100000
                    local oClosestToEnemyBase

                    for iTarget, oTarget in tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits] do
                        if M28UnitInfo.IsUnitValid(oTarget) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(oTarget:GetPosition(), tTeamTargetWZData[M28Map.reftClosestEnemyBase])
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oClosestToEnemyBase = oTarget
                            end
                        end
                    end
                    if oClosestToEnemyBase then
                        local tEnemyBase = tTeamTargetWZData[M28Map.reftClosestEnemyBase]
                        for iShield, oShield in tShieldsToAssign do
                            --Dont record the shield as helpin this unit, instead just have it move to the unit temporarily - so only change the variable so movetoshieldtarget works
                            if bDebugMessages == true then LOG(sFunctionRef..': About to tell shield '..(oShield.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oShield) or 'nil')..' to move towards oClosestToEnemyBase='..(oClosestToEnemyBase.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase) or 'nil')) end
                            oShield[M28Land.refoMobileShieldTarget] = oClosestToEnemyBase
                            MoveToShieldTarget(oShield, tEnemyBase)
                            oShield[M28Land.refoMobileShieldTarget] = nil
                            if bDebugMessages == true then LOG(sFunctionRef..': Backup shield assignment - have told shield '..oShield.UnitId..M28UnitInfo.GetUnitLifetimeCount(oShield)..' to go to the closest enemy in this WZ to enemy base='..oClosestToEnemyBase.UnitId..M28UnitInfo.GetUnitLifetimeCount(oClosestToEnemyBase)) end
                        end
                    elseif bDebugMessages == true then LOG(sFunctionRef..': No friendly units close to enemy base - assuming this is termpoary due to unit being destroyed')
                    end
                end
            end
        end
    end
    if bNoUnitsWantingShielding then
        --Flag that this WZ no longer wants mobile shields
        tTeamTargetWZData[M28Map.refbWZWantsMobileShield] = false
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageMobileShieldsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tMobileShields)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMobileShieldsInWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iWaterZone='..iWaterZone..'; Size of tMobileShields='..table.getn(tMobileShields)) end

    local iCurShield, iMaxShield
    local tShieldsToRetreat = {}
    local tShieldsToAssign = {}
    local tEnemyBase = tWZTeamData[M28Map.reftClosestEnemyBase]
    if M28Utilities.IsTableEmpty(tEnemyBase) then
        M28Utilities.ErrorHandler('Couldnt find enemy base, will try backup approach')
        local iCurDist
        local iClosestDist = 100000
        local oClosestBrain
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefWZMidpoint], M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oClosestBrain = oBrain
            end
        end
        tEnemyBase = M28Map.PlayerStartPoints[oClosestBrain:GetArmyIndex()]
    end

    for iUnit, oUnit in tMobileShields do
        iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, false)
        if bDebugMessages == true then LOG(sFunctionRef..': Considering what to do with unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iCurShield='..iCurShield..'; iMaxShield='..iMaxShield) end
        if iCurShield < iMaxShield * 0.5 then
            --Retreat
            table.insert(tShieldsToRetreat, oUnit)
        elseif oUnit[M28Land.refoMobileShieldTarget] and M28UnitInfo.IsUnitValid(oUnit[M28Land.refoMobileShieldTarget]) then
            --make sure we are behind the target
            MoveToShieldTarget(oUnit, tEnemyBase)
        else
            table.insert(tShieldsToAssign, oUnit)
        end
    end
    if M28Utilities.IsTableEmpty(tShieldsToRetreat) == false then
        local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
        if bDebugMessages == true then LOG(sFunctionRef..': Will give orders to retreat, size of tShieldsToRetreat='..table.getn(tShieldsToRetreat)) end
        for iUnit, oUnit in tShieldsToRetreat do
            if bDebugMessages == true then
                local iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, false)
                LOG(sFunctionRef..': About to tell unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to run due to a low shield. iCurShield='..iCurShield..'; iMaxShield='..iMaxShield)
            end
            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'WSRun'..iWaterZone)
        end
    end
    if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
        --Cycle through every water zone and record priority ones to shield
        if bDebugMessages == true then LOG(sFunctionRef..': Will give orders to tShieldsToAssign, size of table='..table.getn(tShieldsToAssign)) end
        local tiClosestWZWithNearbyThreat = {}
        local iClosestWZWithNoThreat
        local iClosestWZNotWantingShieldButWithUnits
        local iClosestWZWithAnyCombatUnits
        if not(tWZTeamData[M28Map.refbWZWantsMobileShield]) and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefWZTAlliedCombatUnits]) == false then iClosestWZNotWantingShieldButWithUnits = iWaterZone end
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
            for iEntry, tPathingDetails in tWZData[M28Map.subrefWZOtherWaterZones] do
                local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tPathingDetails[M28Map.subrefWZAWZRef]][M28Map.subrefWZTeamData][iTeam]
                if tTeamTargetWZData[M28Map.refbWZWantsMobileShield] then
                    if tTeamTargetWZData[M28Map.refiEnemyAirToGroundThreat] > 0 or tTeamTargetWZData[M28Map.subrefWZTThreatEnemyCombatTotal] >= 40 then
                        ShieldUnitsInWaterZone(tTeamTargetWZData, tShieldsToAssign)
                        if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                    elseif M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefTEnemyUnits]) == false or tTeamTargetWZData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then
                        table.insert(tiClosestWZWithNearbyThreat, tPathingDetails[M28Map.subrefWZAWZRef])
                    elseif not(iClosestWZWithNoThreat) then iClosestWZWithNoThreat = tPathingDetails[M28Map.subrefWZAWZRef]
                    end
                elseif not(iClosestWZNotWantingShieldButWithUnits) then
                    if tTeamTargetWZData[M28Map.subrefbWZWantsSupport] and M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) == false then iClosestWZNotWantingShieldButWithUnits = tPathingDetails[M28Map.subrefWZAWZRef] end
                    if not(iClosestWZWithAnyCombatUnits) and M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) == false then iClosestWZWithAnyCombatUnits = tPathingDetails[M28Map.subrefWZAWZRef] end
                end

            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished checking other zones we can path to for units wanting shielding, is tShieldsToAssign empty='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; Is M28Utilities.IsTableEmpty(tiClosestWZWithNearbyThreat) empty='..tostring(M28Utilities.IsTableEmpty(tiClosestWZWithNearbyThreat))) end
        if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
            if M28Utilities.IsTableEmpty(tiClosestWZWithNearbyThreat) == false then
                for _, iTargetWZ in  tiClosestWZWithNearbyThreat do
                    local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iTargetWZ][M28Map.subrefWZTeamData][iTeam]
                    ShieldUnitsInWaterZone(tTeamTargetWZData, tShieldsToAssign)
                    if M28Utilities.IsTableEmpty(tShieldsToAssign) then break end
                end
            end
            if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                if iClosestWZWithNoThreat then
                    local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iClosestWZWithNoThreat][M28Map.subrefWZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Have mobile shields to assign, closest WZ='..iClosestWZWithNoThreat..'; DOes this WZ want mobile shields='..tostring(tTeamTargetWZData[M28Map.refbWZWantsMobileShield] or false)..'; is table of units wanting shielding empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileShield]))) end
                    ShieldUnitsInWaterZone(tTeamTargetWZData, tShieldsToAssign)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Is tShieldsToAssign empty after checking for closest WZ with no threat='..tostring(M28Utilities.IsTableEmpty(tShieldsToAssign))..'; iClosestWZNotWantingShieldButWithUnits='..(iClosestWZNotWantingShieldButWithUnits or 'nil')) end
                if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                    --Dont have any water zones that want a mobile shield, but we have mobile shields - find the closest WZ  that wants surface support and has DF or IF units, and send them here; if that's this WZ, then have them go to the unit closest to the enemy in this WZ, but without assigning them
                    if iClosestWZNotWantingShieldButWithUnits or iClosestWZWithAnyCombatUnits then
                        local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][(iClosestWZNotWantingShieldButWithUnits or iClosestWZWithAnyCombatUnits)][M28Map.subrefWZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Have mobile shields to assign, closest WZ with friendly combat units that wants more units='..(iClosestWZNotWantingShieldButWithUnits or 'nil')..'; iClosestWZWithAnyCombatUnits='..(iClosestWZWithAnyCombatUnits or 'nil')..'; DOes this WZ want mobile shields='..tostring(tTeamTargetWZData[M28Map.refbWZWantsMobileShield] or false)..'; is table of units wanting shielding empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileShield]))) end
                        ShieldUnitsInWaterZone(tTeamTargetWZData, tShieldsToAssign, true)
                    end
                    if M28Utilities.IsTableEmpty(tShieldsToAssign) == false then
                        M28Utilities.ErrorHandler('couldnt find any water zones with friendly combat units so have nowhere to assign mobile shields; will send them all to the nearest rally point instead')
                        local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
                        for iUnit, oUnit in tShieldsToAssign do
                            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'WSBckup'..iWaterZone)
                        end

                    end

                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ManageMobileStealthsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tMobileStealths)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMobileStealthsInWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iPond='..iPond..'; iWaterZone='..iWaterZone..'; Size of tMobileStealths='..table.getn(tMobileStealths)) end

    local tStealthsToAssign = {}
    local tEnemyBase = tWZTeamData[M28Map.reftClosestEnemyBase]
    if M28Utilities.IsTableEmpty(tEnemyBase) then
        M28Utilities.ErrorHandler('Couldnt find enemy base, will try backup approach')
        local iCurDist
        local iClosestDist = 100000
        local oClosestBrain
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefWZMidpoint], M28Map.PlayerStartPoints[oBrain:GetArmyIndex()])
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oClosestBrain = oBrain
            end
        end
        tEnemyBase = M28Map.PlayerStartPoints[oClosestBrain:GetArmyIndex()]
    end

    for iUnit, oUnit in tMobileStealths do
        if oUnit[M28Land.refoMobileStealthTarget] and M28UnitInfo.IsUnitValid(oUnit[M28Land.refoMobileStealthTarget]) then
            --make sure we are behind the target
            MoveToStealthTarget(oUnit, tEnemyBase)
        else
            table.insert(tStealthsToAssign, oUnit)
        end
    end
    if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
        --Cycle through every water zone and record priority ones to Stealth
        if bDebugMessages == true then LOG(sFunctionRef..': Will give orders to tStealthsToAssign, size of table='..table.getn(tStealthsToAssign)) end
        local tiClosestWZWithNearbyThreat = {}
        local iClosestWZWithNoThreat
        local iClosestWZNotWantingStealthButWithUnits
        local iClosestWZWithAnyCombatUnits
        if tWZTeamData[M28Map.subrefbWZWantsSupport] and not(tWZTeamData[M28Map.refbWZWantsMobileStealth]) and M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefWZTAlliedCombatUnits]) == false then iClosestWZNotWantingStealthButWithUnits = iWaterZone end
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
            for iEntry, tPathingDetails in tWZData[M28Map.subrefWZOtherWaterZones] do
                local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tPathingDetails[M28Map.subrefWZAWZRef]][M28Map.subrefWZTeamData][iTeam]
                if tTeamTargetWZData[M28Map.refbWZWantsMobileStealth] then
                    if tTeamTargetWZData[M28Map.refiEnemyAirToGroundThreat] > 0 or tTeamTargetWZData[M28Map.subrefWZTThreatEnemyCombatTotal] >= 40 then
                        StealthUnitsInWaterZone(tTeamTargetWZData, tStealthsToAssign)
                        if M28Utilities.IsTableEmpty(tStealthsToAssign) then break end
                    elseif M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefTEnemyUnits]) == false or tTeamTargetWZData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then
                        table.insert(tiClosestWZWithNearbyThreat, tPathingDetails[M28Map.subrefWZAWZRef])
                    elseif not(iClosestWZWithNoThreat) then iClosestWZWithNoThreat = tPathingDetails[M28Map.subrefWZAWZRef]
                    end
                elseif not(iClosestWZNotWantingStealthButWithUnits) then
                    if tTeamTargetWZData[M28Map.subrefbWZWantsSupport] and M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) == false then iClosestWZNotWantingStealthButWithUnits = tPathingDetails[M28Map.subrefWZAWZRef] end
                    if not(iClosestWZWithAnyCombatUnits) and M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.subrefWZTAlliedCombatUnits]) == false then iClosestWZWithAnyCombatUnits = tPathingDetails[M28Map.subrefWZAWZRef] end
                end

            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished checking other zones we can path to for units wanting Stealthing, is tStealthsToAssign empty='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; Is M28Utilities.IsTableEmpty(tiClosestWZWithNearbyThreat) empty='..tostring(M28Utilities.IsTableEmpty(tiClosestWZWithNearbyThreat))) end
        if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
            if M28Utilities.IsTableEmpty(tiClosestWZWithNearbyThreat) == false then
                for _, iTargetWZ in  tiClosestWZWithNearbyThreat do
                    local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iTargetWZ][M28Map.subrefWZTeamData][iTeam]
                    StealthUnitsInWaterZone(tTeamTargetWZData, tStealthsToAssign)
                    if M28Utilities.IsTableEmpty(tStealthsToAssign) then break end
                end
            end
            if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                if iClosestWZWithNoThreat then
                    local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iClosestWZWithNoThreat][M28Map.subrefWZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Have mobile Stealths to assign, closest WZ='..iClosestWZWithNoThreat..'; DOes this WZ want mobile Stealths='..tostring(tTeamTargetWZData[M28Map.refbWZWantsMobileStealth] or false)..'; is table of units wanting Stealthing empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileStealth]))) end
                    StealthUnitsInWaterZone(tTeamTargetWZData, tStealthsToAssign)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Is tStealthsToAssign empty after checking for closest WZ with no threat='..tostring(M28Utilities.IsTableEmpty(tStealthsToAssign))..'; iClosestWZNotWantingStealthButWithUnits='..(iClosestWZNotWantingStealthButWithUnits or 'nil')) end
                if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                    --Dont have any water zones that want a mobile Stealth, but we have mobile Stealths - find the closest WZ  that wants DF support and has DF units, and send them here; if that's this WZ, then have them go to the unit closest to the enemy in this WZ, but without assigning them
                    if iClosestWZNotWantingStealthButWithUnits or iClosestWZWithAnyCombatUnits then
                        local tTeamTargetWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][(iClosestWZNotWantingStealthButWithUnits or iClosestWZWithAnyCombatUnits)][M28Map.subrefWZTeamData][iTeam]
                        if bDebugMessages == true then LOG(sFunctionRef..': Have mobile Stealths to assign, closest WZ with friendly combat units that wants more units='..(iClosestWZNotWantingStealthButWithUnits or 'nil')..'; iClosestWZWithAnyCombatUnits='..(iClosestWZWithAnyCombatUnits or 'nil')..'; DOes this WZ want mobile Stealths='..tostring(tTeamTargetWZData[M28Map.refbWZWantsMobileStealth] or false)..'; is table of units wanting Stealthing empty='..tostring(M28Utilities.IsTableEmpty(tTeamTargetWZData[M28Map.reftoWZUnitsWantingMobileStealth]))) end
                        StealthUnitsInWaterZone(tTeamTargetWZData, tStealthsToAssign, true)
                    end
                    if M28Utilities.IsTableEmpty(tStealthsToAssign) == false then
                        M28Utilities.ErrorHandler('couldnt find any water zones with friendly combat units so have nowhere to assign mobile Stealths; will send them all to the nearest rally point instead')
                        local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
                        for iUnit, oUnit in tStealthsToAssign do
                            M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'SBckup'..iWaterZone)
                        end

                    end

                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordUnitAsReceivingWaterZoneAssignment(oUnit, iWaterZone, iCurWZValue)
    oUnit[refiCurrentWZAssignmentValue] = iCurWZValue
    oUnit[refiCurrentAssignmentWaterZone] = iWaterZone
    oUnit[refiTimeOfLastWZAssignment] = GetGameTimeSeconds()
    if oUnit[M28Land.refiCurrentAssignmentPlateauAndLZ] then
        oUnit[M28Land.refiCurrentAssignmentValue] = nil
        oUnit[M28Land.refiCurrentAssignmentPlateauAndLZ] = nil
    end
end

function MoveUnassignedLandUnits(tWZData, tWZTeamData, iPond, iWaterZone, iTeam, tAmphibiousUnits)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'MoveUnassignedLandUnits'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Decides where to send any units that are part of this water zone (ignores those from an adjacent waterzone that were available)
    local tUnitsInThisZone = {}
    for iUnit, oUnit in tAmphibiousUnits do
        if oUnit[refiCurrentAssignmentWaterZone] == iWaterZone then
            table.insert(tUnitsInThisZone, oUnit)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code for the game time='..GetGameTimeSeconds()..', is tUnitsInThisZone empty='..tostring(M28Utilities.IsTableEmpty(tUnitsInThisZone))) end
    if M28Utilities.IsTableEmpty(tUnitsInThisZone) == false then
        --Find the nearest land zone wanting support:
        local iPlateau = NavUtils.GetLabel(M28Map.refPathingTypeHover, tWZData[M28Map.subrefWZMidpoint])
        if not(iPlateau) then
            M28Utilities.ErrorHandler('Dont have a plateau for midpoint of water zone '..(WaterZone or 'nil')..' in iPond '..(iPond or 'nil'))
            --will still try and continue since have recorded plateau for the adjacent land zones anyway
        end
        local iLZToSupport
        --Does this WZ have adjacent LZ wanting support?
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]) == false then
            for iEntry, tSubtable in tWZData[M28Map.subrefAdjacentLandZones] do
                if M28Map.tAllPlateaus[tSubtable[M28Map.subrefWPlatAndLZNumber][1]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefWPlatAndLZNumber][2]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsSupport] then
                    iLZToSupport = tSubtable[M28Map.subrefWPlatAndLZNumber][2]
                    iPlateau = tSubtable[M28Map.subrefWPlatAndLZNumber][1]
                    break
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': iLZToSupport after checking adjacent LZ to this WZ='..(iLZToSupport or 'nil')..'; did this WZ have adjacent LZ? is table empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefAdjacentLandZones]))) end
        if not(iLZToSupport) then
            --Cycle through every other water zone and try the same thing
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                for iWZEntry, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                    local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tWZSubtable[M28Map.subrefWZAWZRef]]
                    if M28Utilities.IsTableEmpty(tAltWZData[M28Map.subrefAdjacentLandZones]) == false then
                        for iEntry, tSubtable in tAltWZData[M28Map.subrefAdjacentLandZones] do
                            if M28Map.tAllPlateaus[tSubtable[M28Map.subrefWPlatAndLZNumber][1]][M28Map.subrefPlateauLandZones][tSubtable[M28Map.subrefWPlatAndLZNumber][2]][M28Map.subrefLZTeamData][iTeam][M28Map.subrefbLZWantsSupport] then
                                iLZToSupport = tSubtable[M28Map.subrefWPlatAndLZNumber][2]
                                iPlateau = tSubtable[M28Map.subrefWPlatAndLZNumber][1]
                                break
                            end
                        end
                    end
                    if iLZToSupport then break end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iLZToSupport after checking adjacent LZ to all other WZ='..(iLZToSupport or 'nil')) end
            if not(iLZToSupport) then
                --Get the LZ of the closest base
                iPlateau, iLZToSupport = M28Map.GetPlateauAndLandZoneReferenceFromPosition(tWZTeamData[M28Map.reftClosestEnemyBase])
                if bDebugMessages == true then LOG(sFunctionRef..': iLZToSupport after checking nearest enemy base land zone='..(iLZToSupport or 'nil')) end
            end
        end
        if not(iLZToSupport) then M28Utilities.ErrorHandler('Unable to find a LZ needing support for water zone '..iWaterZone..'; Pond '..iPond)
        else
            --We have a LZ to support - decide if we want to send our units there, or if we want to keep them in the water and build up forces
            --If the LZ is a core base LZ or adjacent to a LZ then support
            local tLZData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZToSupport]
            local tLZTeamData = tLZData[M28Map.subrefLZTeamData][iTeam]

            local bAttackWithEverything = false

            if tLZTeamData[M28Map.subrefLZbCoreBase] or not(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]) or (M28Utilities.IsTableEmpty(tLZTeamData[M28Map.subrefLZTAlliedUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tLZTeamData[M28Map.subrefLZTAlliedUnits])) == false) then
                bAttackWithEverything = true
                if bDebugMessages == true then LOG(sFunctionRef..': No dangerous enemies in this LZ or is a core base, or allied structures are here, so attack with everything. tLZTeamData[M28Map.subrefLZbCoreBase]='..tostring(tLZTeamData[M28Map.subrefLZbCoreBase])..'; tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ]='..tostring(tLZTeamData[M28Map.subrefbDangerousEnemiesInThisLZ])) end
            else
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                        if tAltLZTeamData[M28Map.subrefLZbCoreBase] or (M28Utilities.IsTableEmpty(tAltLZTeamData[M28Map.subrefLZTAlliedUnits]) == false and M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryStructure, tAltLZTeamData[M28Map.subrefLZTAlliedUnits])) == false) then
                            bAttackWithEverything = true
                        end
                    end
                end
            end
            local iBestEnemyDFRange = 0
            if bDebugMessages == true then LOG(sFunctionRef..': bAttackWithEverything after checking if we want to support a core base/LZ with structures='..tostring(bAttackWithEverything)) end
            if not(bAttackWithEverything) then
                if bDebugMessages == true then LOG(sFunctionRef..': About to check our threat vs enemy threat') end
                --Do we want to send all units due to having more threat than enemy? Or only if we outrange?
                local iOurCombatThreat = M28UnitInfo.GetCombatThreatRating(tUnitsInThisZone) + tLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]
                --Calc enemy threat and range in this and adjacent LZs (and also factor in friendly threat in these LZs)
                iBestEnemyDFRange = math.max(tLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange], tLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange])
                local iEnemyCombatThreat = tLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal]
                if M28Utilities.IsTableEmpty(tLZData[M28Map.subrefLZAdjacentLandZones]) == false then
                    for iEntry, iAdjLZ in tLZData[M28Map.subrefLZAdjacentLandZones] do
                        local tAltLZTeamData = M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iAdjLZ][M28Map.subrefLZTeamData][iTeam]
                        iBestEnemyDFRange = math.max(iBestEnemyDFRange, tAltLZTeamData[M28Map.subrefLZThreatEnemyBestMobileDFRange], tAltLZTeamData[M28Map.subrefLZThreatEnemyBestStructureDFRange])
                        iEnemyCombatThreat = iEnemyCombatThreat + tAltLZTeamData[M28Map.subrefLZTThreatEnemyCombatTotal]
                        iOurCombatThreat = iOurCombatThreat + tAltLZTeamData[M28Map.subrefLZTThreatAllyCombatTotal]
                    end
                end
                bAttackWithEverything = M28Conditions.HaveEnoughThreatToAttack(tLZTeamData, iOurCombatThreat, iEnemyCombatThreat, 0, false)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering if should attack with everything based on adjacent LZ threat, iOurCombatThreat='..iOurCombatThreat..'; iBestEnemyDFRange='..iBestEnemyDFRange..'; iEnemyCombatThreat='..iEnemyCombatThreat..'; bAttackWithEverything='..tostring(bAttackWithEverything)) end
            end

            --Move units to the LZ to support if we outrange or have sufficient threat
            if bDebugMessages == true then LOG(sFunctionRef..': Will tell units to move to iLZToSupport='..iLZToSupport..'; on Plateau '..iPlateau..'; Dist to WZ midpoint='..M28Utilities.GetDistanceBetweenPositions(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iLZToSupport][M28Map.subrefLZMidpoint], tWZData[M28Map.subrefWZMidpoint])..'; bAttackWithEverything='..tostring(bAttackWithEverything)..'; iBestEnemyDFRange='..iBestEnemyDFRange) end
            local tDestination = tLZData[M28Map.subrefLZMidpoint]
            local tHoverRallyPoint
            local tAmphibiousRallyPoint = tWZData[M28Map.subrefWZMidpoint]
            if not(bAttackWithEverything) then
                --Decide if we want to consolidate hover(surface) units at the waterzone midpoint or not
                local iClosestCombatEnemyDist = 100000
                if M28Utilities.IsTableEmpty(tLZTeamData[M28Map.reftoNearestCombatEnemies]) == false then
                    for iEnemy, oEnemy in tLZTeamData[M28Map.reftoNearestCombatEnemies] do
                        iClosestCombatEnemyDist = math.min(iClosestCombatEnemyDist, M28Utilities.GetDistanceBetweenPositions(oEnemy:GetPosition(), tAmphibiousRallyPoint))
                    end
                end
                if iClosestCombatEnemyDist - iBestEnemyDFRange <= 20 then
                    tHoverRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
                else
                    --Safe to use amphibious rally point
                    tHoverRallyPoint = tAmphibiousRallyPoint
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': About to give units orders to advance ore retreat or consolidate, bAttackWithEverything='..tostring(bAttackWithEverything)..'; tAmphibiousRallyPoint='..repru(tAmphibiousRallyPoint)..'; tHoverRallyPoint='..repru(tHoverRallyPoint)) end
            for iUnit, oUnit in tUnitsInThisZone do
                if bAttackWithEverything or ((oUnit[M28UnitInfo.refiDFRange] or 0) > iBestEnemyDFRange and not(EntityCategoryContains(categories.AMPHIBIOUS, oUnit.UnitId))) then
                    M28Orders.IssueTrackedMove(oUnit, tDestination, 6, false, 'NM2LZ'..iLZToSupport..'Fr'..iWaterZone)
                else
                    --Move to WZ midpoint
                    if EntityCategoryContains(categories.AMPHIBIOUS, oUnit.UnitId) then
                        M28Orders.IssueTrackedMove(oUnit, tAmphibiousRallyPoint, 6, false, 'NACons'..iWaterZone)
                    else
                        M28Orders.IssueTrackedMove(oUnit, tHoverRallyPoint, 6, false, 'NHCons'..iWaterZone)
                    end
                end
            end
        end
    end
end

function ManageSpecificWaterZone(aiBrain, iTeam, iPond, iWaterZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageSpecificWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Record enemy threat
    local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone]
    local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
    if bDebugMessages == true then LOG(sFunctionRef..': About to update threat for iPond='..iPond..'; iWaterZone='..iWaterZone..'; iTeam='..iTeam..'; Is WZData empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData))) end
    RecordGroundThreatForWaterZone(tWZTeamData, iTeam, iPond, iWaterZone)
    RecordAirThreatForWaterZone(tWZTeamData, iTeam, iPond, iWaterZone)

    tWZTeamData[M28Map.subrefWZTAlliedCombatUnits] = {}
    tWZTeamData[M28Map.reftoWZUnitsWantingMobileShield] = {}
    tWZTeamData[M28Map.refbWZWantsMobileShield] = false --will change later
    tWZTeamData[M28Map.reftoWZUnitsWantingMobileStealth] = {}
    tWZTeamData[M28Map.refbWZWantsMobileStealth] = false --will change later

    local tEngineers, tScouts, tMobileShields, tMobileStealths, tOtherUnitsToRetreat, tAvailableSubmarines
    local iCurShield, iMaxShield
    local bWaterZoneOrAdjHasUnitsWantingScout = false
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of allied units empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefWZTAlliedUnits]))) end
    local bUpdateEnemyDataHere = true --Will handle this logic in logic for managing water zone units if htis is false
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefWZTAlliedUnits]) == false then
        --Decide on what to do with units in this WZ
        tEngineers = {}
        tScouts = {}
        tMobileShields = {}
        tMobileStealths = {}
        tOtherUnitsToRetreat = {} --Intended for e.g. fatboys and units with personal shield
        tAvailableSubmarines = {}
        local tAmphibiousUnits = {}
        local tAvailableCombatUnits = {}
        local tUnavailableUnitsInThisWZ = {}
        local tTempOtherUnits = {}
        local tAvailableMAA = {}
        local iCurWZValue = tWZTeamData[M28Map.subrefWZTValue]

        local iOurBestDFRange = 0
        local iOurBestIndirectRange = 0
        local bIncludeUnit

        local iMobileShieldMassThreshold = 750 --When assigning mobile shields will also restrict further so e.g. seraphim mobile shields will have a higher threshold
        local iMobileShieldHigherMAAMassThreshold = 1500 --for if we have MAA and enemy doesnt have much air threat
        local iMobileStealthMassThreshold = 700 --will get adjusted further
        local iMobileStealthHigherMassThreshold = 1500 --i.e. wont stealth loyalists and titans
        local iUnitMassCost
        local iMobileStealthLowerThresholdCount = 0 --Used to avoid assigning too many mobile stealth at once to units not exceeding the higher mass threshold
        local iLZIslandGivingOrder, iLZIslandTravelingTo
        if M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] > 600 and (M28Team.tTeamData[iTeam][M28Team.refiEnemyAirToGroundThreat] >= 2000 or tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0) then iMobileShieldHigherMAAMassThreshold = iMobileShieldMassThreshold end


        for iUnit, oUnit in tWZTeamData[M28Map.subrefWZTAlliedUnits] do
            if oUnit:GetFractionComplete() == 1 then
                if EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) then
                    table.insert(tEngineers, oUnit)
                    bWaterZoneOrAdjHasUnitsWantingScout = true
                elseif EntityCategoryContains(categories.COMMAND, oUnit.UnitId) then
                    --ACU logic - handled via M28ACU file, as amy not want to kite with it
                    bWaterZoneOrAdjHasUnitsWantingScout = true
                elseif EntityCategoryContains(M28UnitInfo.refCategoryAllAmphibiousAndNavy * categories.MOBILE, oUnit.UnitId) then
                    if EntityCategoryContains(M28UnitInfo.refCategoryLandScout, oUnit.UnitId) then
                        table.insert(tScouts, oUnit)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryShieldBoat, oUnit.UnitId) then
                        table.insert(tMobileShields, oUnit)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryStealthBoat, oUnit.UnitId) then
                        table.insert(tMobileStealths, oUnit)
                    elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA + M28UnitInfo.refCategoryMobileLand + M28UnitInfo.refCategoryNavalSurface + M28UnitInfo.refCategorySubmarine - categories.COMMAND - M28UnitInfo.refCategoryRASSACU, oUnit.UnitId) then
                        bIncludeUnit = false
                        bWaterZoneOrAdjHasUnitsWantingScout = true
                        --Is the unit available for use by this water zone?
                        --Is the unit's priority lower than this?
                        if bDebugMessages == true then LOG(sFunctionRef..': Considering if have available combat unit, oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; oUnit[refiCurrentWZAssignmentValue]='..(oUnit[refiCurrentWZAssignmentValue] or 'nil')..'; oUnit[refiCurrentAssignmentWaterZone]='..(oUnit[refiCurrentAssignmentWaterZone] or 'nil')) end
                        if (oUnit[refiCurrentWZAssignmentValue] or 0) < iCurWZValue or (oUnit[refiCurrentAssignmentWaterZone] == iWaterZone or (GetGameTimeSeconds() - (oUnit[refiTimeOfLastWZAssignment] or 0) >= 10 and not(oUnit[M28Land.refiTimeOfLastAssignment]))) then
                            --Is it a unit with a shield that wants to retreat so its shield can regen?
                            iCurShield, iMaxShield = M28UnitInfo.GetCurrentAndMaximumShield(oUnit, true)
                            if iMaxShield > 0 and iCurShield < iMaxShield * 0.35 and iMaxShield > oUnit:GetMaxHealth() * 0.8 then --primarily fatboy, but in theory could affect SACUs
                                table.insert(tOtherUnitsToRetreat, oUnit)
                                oUnit[refiCurrentWZAssignmentValue] = 100000
                            else
                                bIncludeUnit = true
                                if EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId) then
                                    table.insert(tAvailableMAA, oUnit)
                                elseif EntityCategoryContains(M28UnitInfo.refCategorySubmarine - M28UnitInfo.refCategorySeraphimDestroyer, oUnit.UnitId) then
                                    table.insert(tAvailableSubmarines, oUnit)
                                elseif ((oUnit[M28UnitInfo.refiDFRange] or 0) > 0 or (oUnit[M28UnitInfo.refiAntiNavyRange] or 0) > 0) and EntityCategoryContains(M28UnitInfo.refCategoryNavalSurface + categories.HOVER - M28UnitInfo.refCategoryLandExperimental * categories.AMPHIBIOUS - M28UnitInfo.refCategoryLandCombat * categories.AMPHIBIOUS, oUnit.UnitId) then
                                    table.insert(tAvailableCombatUnits, oUnit)
                                    table.insert(tWZTeamData[M28Map.subrefWZTAlliedCombatUnits], oUnit)
                                else
                                    table.insert(tAmphibiousUnits, oUnit)
                                end
                                if bIncludeUnit then
                                    RecordUnitAsReceivingWaterZoneAssignment(oUnit, iWaterZone, iCurWZValue)
                                end
                            end
                            --Is this a land unit traveling from 1 island to another island? In which case also want to consider
                        elseif oUnit[refiCurrentAssignmentWaterZone] == nil and oUnit[refiCurrentAssignmentPlateauAndLZ][2] then
                            local tLastOrder = oUnit[M28Orders.reftiLastOrders][oUnit[M28Orders.refiOrderCount]]
                            if tLastOrder and tLastOrder[M28Orders.subrefiOrderType] == M28Orders.refiOrderIssueMove then
                                local tAssignmentLZData = M28Map.tAllPlateaus[oUnit[refiCurrentAssignmentPlateauAndLZ][1]][M28Map.subrefPlateauLandZones][oUnit[refiCurrentAssignmentPlateauAndLZ][2]]

                                iLZIslandGivingOrder = NavUtils.GetLabel(M28Map.refPathingTypeLand, tAssignmentLZData[M28Map.subrefLZMidpoint])
                                iLZIslandTravelingTo = NavUtils.GetLabel(M28Map.refPathingTypeLand, tLastOrder[M28Orders.subreftOrderPosition])
                                if iLZIslandTravelingTo and not(iLZIslandGivingOrder == iLZIslandTravelingTo) then
                                    bIncludeUnit = true
                                end
                                if bDebugMessages == true then LOG(sFunctionRef..': Have a unit that was given a plateau and LZ assignment and has no WZ assignment, Unit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; iLZIslandGivingOrder='..(iLZIslandGivingOrder or 'nil')..'; iLZIslandTravelingTo='..(iLZIslandTravelingTo or 'nil')..'; bIncludeUnit='..tostring(bIncludeUnit)) end

                            end
                            if bIncludeUnit then
                                if bIncludeUnit then
                                    RecordUnitAsReceivingWaterZoneAssignment(oUnit, iWaterZone, iCurWZValue)

                                end
                            else
                                table.insert(tUnavailableUnitsInThisWZ, oUnit)
                            end
                        else
                            table.insert(tUnavailableUnitsInThisWZ, oUnit)
                        end
                        iUnitMassCost = oUnit:GetBlueprint().Economy.BuildCostMass
                        if iUnitMassCost >= iMobileShieldMassThreshold and (iUnitMassCost >= iMobileShieldHigherMAAMassThreshold or iMobileShieldHigherMAAMassThreshold == iMobileShieldMassThreshold or not(EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId))) then
                            table.insert(tWZTeamData[M28Map.reftoWZUnitsWantingMobileShield], oUnit)
                        end
                        if iUnitMassCost >= iMobileStealthHigherMassThreshold then
                            table.insert(tWZTeamData[M28Map.reftoWZUnitsWantingMobileStealth], oUnit)
                        elseif iUnitMassCost >= iMobileStealthMassThreshold and EntityCategoryContains(M28UnitInfo.refCategorySkirmisher + M28UnitInfo.refCategoryIndirect - categories.TECH1, oUnit.UnitId) then
                            --Only say we want a mobile shield if the unit doesnt have one assigned
                            iMobileStealthLowerThresholdCount = iMobileStealthLowerThresholdCount + 1

                            if iMobileStealthLowerThresholdCount >= 3 or oUnit[M28Land.refoAssignedMobileStealth] then
                                iMobileStealthLowerThresholdCount = 0
                                table.insert(tWZTeamData[M28Map.reftoWZUnitsWantingMobileStealth], oUnit)
                            end
                        end
                    end
                elseif EntityCategoryContains(categories.STRUCTURE, oUnit.UnitId) then
                    --Structure logic - handled separately e.g. via M28Factory for factories
                else
                    table.insert(tTempOtherUnits, oUnit)
                    LOG('Adding unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' to table of temp other units - need to add logic to handle such a unit - likely just a pathfinding error')
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of engineers empty='..tostring(M28Utilities.IsTableEmpty(tEngineers))..'; Is table of combat units just for this zone empty='..tostring(M28Utilities.IsTableEmpty(tAvailableCombatUnits))) end

        --Mobile shield data:
        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoWZUnitsWantingMobileShield]) == false then
            for iUnit, oUnit in tWZTeamData[M28Map.reftoWZUnitsWantingMobileShield] do
                if oUnit[M28Land.refoAssignedMobileShield] then
                    if not(M28UnitInfo.IsUnitValid(oUnit[M28Land.refoAssignedMobileShield])) then
                        oUnit[M28Land.refoAssignedMobileShield] = nil
                        tWZTeamData[M28Map.refbWZWantsMobileShield] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Recording that the water zone '..iWaterZone..' wants mobile shields as a unit that had a mobile shield no longerh as a valid one') end
                    end
                else
                    tWZTeamData[M28Map.refbWZWantsMobileShield] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Recording that the water zone '..iWaterZone..' wants mobile shields as it has a unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that doesnt have an assigned mobile shield yet') end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tMobileShields) == false then
            ManageMobileShieldsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tMobileShields)
        end
        --Mobile stealth data:
        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoWZUnitsWantingMobileStealth]) == false then
            for iUnit, oUnit in tWZTeamData[M28Map.reftoWZUnitsWantingMobileStealth] do
                if oUnit[M28Land.refoAssignedMobileStealth] then
                    if not(M28UnitInfo.IsUnitValid(oUnit[M28Land.refoAssignedMobileStealth])) then
                        oUnit[M28Land.refoAssignedMobileStealth] = nil
                        tWZTeamData[M28Map.refbWZWantsMobileStealth] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Recording that the water zone '..iWaterZone..' wants mobile Stealths as a unit that had a mobile Stealth no longerh as a valid one') end
                    end
                else
                    tWZTeamData[M28Map.refbWZWantsMobileStealth] = true
                    if bDebugMessages == true then LOG(sFunctionRef..': Recording that the water zone '..iWaterZone..' wants mobile Stealths as it has a unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' that doesnt have an assigned mobile Stealth yet') end
                end
            end
        end
        if M28Utilities.IsTableEmpty(tMobileStealths) == false then
            ManageMobileStealthsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tMobileStealths)
        end

        local iCurCombatThreat = tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal]
        local iCurMAAThreat = tWZTeamData[M28Map.subrefWZThreatAlliedAA]

        local bConsiderAdjacentCombat = false
        local bConsiderAdjacentMAA = false
        if iCurCombatThreat < tWZTeamData[M28Map.subrefWZCombatThreatWanted] then bConsiderAdjacentCombat = true end
        if iCurMAAThreat < tWZTeamData[M28Map.subrefWZMAAThreatWanted] then bConsiderAdjacentMAA = true end


        --Add adjacent combat units if the water zone is lower priority than us and the adjacent WZ doesnt have combat units of a significant threat in it
        local iCurUnitThreat
        if bDebugMessages == true then LOG(sFunctionRef..': Will consider including adjacent combat units for WZ '..iWaterZone..' with iCurWZValue='..iCurWZValue..'; is table of adjacent WZs empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]))..'; bConsiderAdjacentCombat='..tostring(bConsiderAdjacentCombat)) end
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false and bConsiderAdjacentCombat then
            local iAdjWZ
            for iEntry, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                iAdjWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                local tAltWZTeam = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                if bDebugMessages == true then LOG(sFunctionRef..': iPond='..iPond..'; Base WZ='..iWaterZone..'; iAdjWZ='..iAdjWZ..'; WZTValue='..repru(tAltWZTeam[M28Map.subrefWZTValue])..'; Is table of allied combat units empty='..tostring(M28Utilities.IsTableEmpty(tAltWZTeam[M28Map.subrefWZTAlliedCombatUnits]))) end
                if not(bWaterZoneOrAdjHasUnitsWantingScout) and M28Utilities.IsTableEmpty(tAltWZTeam[M28Map.subrefWZTAlliedCombatUnits]) == false then bWaterZoneOrAdjHasUnitsWantingScout = true end
                if tAltWZTeam[M28Map.subrefWZTValue] < iCurWZValue and tAltWZTeam[M28Map.subrefWZTThreatEnemyCombatTotal] <= 50 and M28Utilities.IsTableEmpty(tAltWZTeam[M28Map.subrefWZTAlliedCombatUnits]) == false then
                    for iUnit, oUnit in tAltWZTeam[M28Map.subrefWZTAlliedCombatUnits] do
                        if bDebugMessages == true then LOG(sFunctionRef..': Deciding if we want to add adjacent oUnit '..(oUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oUnit) or 'nil')..' with cur assignment value '..(oUnit[refiCurrentWZAssignmentValue] or 0)..' and cur assignemnt WZ='..(oUnit[refiCurrentAssignmentWaterZone] or 'nil')) end
                        if not(oUnit.Dead) and ((oUnit[refiCurrentWZAssignmentValue] or 0) < iCurWZValue or (oUnit[refiCurrentAssignmentWaterZone] == iAdjWZ)) then
                            --Combat unit related
                            if bConsiderAdjacentCombat and (oUnit[M28UnitInfo.refiDFRange] > 0 or oUnit[M28UnitInfo.refiAntiNavyRange] > 0) then
                                table.insert(tAvailableCombatUnits, oUnit)
                                RecordUnitAsReceivingWaterZoneAssignment(oUnit, iWaterZone, iCurWZValue)

                                iCurUnitThreat = M28UnitInfo.GetCombatThreatRating({ oUnit })

                                if iCurUnitThreat > tWZTeamData[M28Map.subrefWZCombatThreatWanted] then
                                    bConsiderAdjacentCombat = false
                                    if not(bConsiderAdjacentMAA) then break end
                                end
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryMAA, oUnit.UnitId) then
                                table.insert(tAvailableMAA, oUnit)
                                RecordUnitAsReceivingWaterZoneAssignment(oUnit, iWaterZone, iCurWZValue)

                                iCurUnitThreat = M28UnitInfo.GetAirThreatLevel({ oUnit }, false, false, true)
                                iCurMAAThreat = iCurMAAThreat + iCurUnitThreat
                                if iCurMAAThreat > tWZTeamData[M28Map.subrefWZMAAThreatWanted] then
                                    bConsiderAdjacentMAA = false
                                    if not(bConsiderAdjacentCombat) then break end
                                end
                            end
                        end
                    end
                    if not(bConsiderAdjacentCombat) and not(bConsiderAdjacentMAA) then break end
                end
            end
        end

        if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then
            if bDebugMessages == true then LOG(sFunctionRef..': About to manage combat units in the WZ') end
            local tRemainingLandUnits = ManageCombatUnitsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tAvailableCombatUnits, tAvailableSubmarines, tUnavailableUnitsInThisWZ)
            if M28Utilities.IsTableEmpty(tRemainingLandUnits) == false then
                for iUnit, oUnit in tRemainingLandUnits do
                    table.insert(tAmphibiousUnits, oUnit)
                end
            end
            bUpdateEnemyDataHere = false
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Is table of MAA empty='..tostring(M28Utilities.IsTableEmpty(tAvailableMAA))..'; Is table of entity filtered dow nto MAA empty='..tostring(M28Utilities.IsTableEmpty(EntityCategoryFilterDown(M28UnitInfo.refCategoryMAA, tWZTeamData[M28Map.subrefWZTAlliedUnits])))) end
        if M28Utilities.IsTableEmpty(tAvailableMAA) == false then
            ManageMAAInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tAvailableMAA)
        end

        if M28Utilities.IsTableEmpty(tOtherUnitsToRetreat) == false then
            RetreatOtherUnitsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tOtherUnitsToRetreat)
        end

        if M28Utilities.IsTableEmpty(tTempOtherUnits) == false then
            M28Utilities.ErrorHandler('To add logic to handle non engineers in a WZ')
        end

        --Decide where to send any unassigned land pathable units
        if bDebugMessages == true then LOG(sFunctionRef..': Is tAmphibiousUnits empty='..tostring(M28Utilities.IsTableEmpty(tAmphibiousUnits))) end
        if M28Utilities.IsTableEmpty(tAmphibiousUnits) == false then
            MoveUnassignedLandUnits(tWZData, tWZTeamData, iPond, iWaterZone, iTeam, tAmphibiousUnits)
        end

    end
    --Update enemy ranges for this WZ and decide if this WZ still wants support, if we havent run our main combat management logic
    if bDebugMessages == true then LOG(sFunctionRef..': Will update enemy data for this WZ if are enemies in this WZ. bUpdateEnemyDataHere='..tostring(bUpdateEnemyDataHere or false)) end
    if bUpdateEnemyDataHere then
        RecordClosestAdjacentRangesAndEnemies(tWZData, tWZTeamData, iPond, iWaterZone, iTeam)
        if tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] and tWZTeamData[M28Map.subrefWZTValue] >= 200 then
            UpdateIfWaterZoneWantsSupport(tWZTeamData, true)
            if bDebugMessages == true then LOG(sFunctionRef..': Will update to flag this water zone wants combat support') end
        else
            UpdateIfWaterZoneWantsSupport(tWZTeamData, false)
        end
    end
    --Handle engineers and even if no engineers still decide what engineers we would want for hte WZ
    M28Engineer.ConsiderLandOrWaterZoneEngineerAssignment(tWZTeamData, iTeam, iPond, iWaterZone, tEngineers, true) --Should update the water zone engineer requirements, even if tEngineers itself is empty

    ManageWaterZoneScouts(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tScouts, bWaterZoneOrAdjHasUnitsWantingScout)

    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iPond='..iPond..'; iWaterZone='..iWaterZone) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function AssignValuesToWaterZones(iTeam)
    --Periodically cycles through every water zone and refreshes the unit details
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignValuesToWaterZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef .. ': About to start the main loop for assigning values to water zones provided we have friendly M28 brains in the team ' .. iTeam .. '; is table empty=' .. tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))..'; Is M28Map.tPondDetails empty='..tostring(M28Utilities.IsTableEmpty(M28Map.tPondDetails))) end
    local iCurValue
    local iBuildLocationSegmentX, iBuildLocationSegmentZ
    if M28Utilities.IsTableEmpty(M28Map.tPondDetails) == false then
        for iPond, tPondSubtable in M28Map.tPondDetails do
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                if tPondSubtable[M28Map.subrefBuildLocationByStartPosition][oBrain:GetArmyIndex()] then
                    iBuildLocationSegmentX, iBuildLocationSegmentZ = M28Map.GetPathingSegmentFromPosition(tPondSubtable[M28Map.subrefBuildLocationByStartPosition][oBrain:GetArmyIndex()])
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering oBrain='..oBrain.Nickname..' on iTeam='..iTeam..'; iBuildLocationSegmentX='..iBuildLocationSegmentX..'; iBuildLocationSegmentZ='..iBuildLocationSegmentZ..'; Water zone for these segments='..M28Map.tWaterZoneBySegment[iBuildLocationSegmentX][iBuildLocationSegmentZ]) end
                    if M28Map.tWaterZoneBySegment[iBuildLocationSegmentX][iBuildLocationSegmentZ] then
                        local tWZTeamData = tPondSubtable[M28Map.subrefPondWaterZones][M28Map.tWaterZoneBySegment[iBuildLocationSegmentX][iBuildLocationSegmentZ]][M28Map.subrefWZTeamData][iTeam]
                        tWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation] = true
                        if bDebugMessages == true then LOG(sFunctionRef..': Have flagged that water zone '..M28Map.tWaterZoneBySegment[iBuildLocationSegmentX][iBuildLocationSegmentZ]..'; Contains a naval build location') end
                    end
                end

            end
        end


        while M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false do
            local iBaseCategory = M28UnitInfo.refCategoryNavalFactory
            for iPond, tPondSubtable in M28Map.tPondDetails do
                if M28Utilities.IsTableEmpty(tPondSubtable[M28Map.subrefPondWaterZones]) == false then
                    for iWaterZone, tWZData in tPondSubtable[M28Map.subrefPondWaterZones] do
                        if bDebugMessages == true then LOG(sFunctionRef..': About to refresh value of iPond='..iPond..'; iWaterZone='..iWaterZone..' for team '..iTeam) end
                        --Decide on value of the water zone ignoring distance:
                        iCurValue = 1000
                        --Are we adjacent to a core base? If so increase the value; also increase value if we are a core base
                        local tWZTeamData = tWZData[M28Map.subrefWZTeamData][iTeam]
                        if tWZTeamData[M28Map.subrefWZbCoreBase] then iCurValue = iCurValue * 2
                        elseif M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                            for iEntry, tAltWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                                if M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tAltWZSubtable[M28Map.subrefWZAWZRef]][M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZbCoreBase] then
                                    iCurValue = iCurValue * 1.5
                                    break
                                end
                            end
                        end

                        --Record the value
                        tWZTeamData[M28Map.subrefWZTValue] = iCurValue
                        tWZTeamData[M28Map.subrefWZbCoreBase] = nil

                        --Is this a core base water zone?
                        if tWZTeamData[M28Map.subrefWZbContainsNavalBuildLocation] then
                            if bDebugMessages == true then LOG(sFunctionRef..': Setting iWaterZone='..iWaterZone..' to be a WZ core base as it contains a naval build location') end
                            tWZTeamData[M28Map.subrefWZbCoreBase] = true
                        elseif M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZTAlliedUnits]) == false then
                            local tFactories = EntityCategoryFilterDown(iBaseCategory, tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZTAlliedUnits])
                            if M28Utilities.IsTableEmpty(tFactories) == false then
                                if bDebugMessages == true then LOG(sFunctionRef..': Setting iWaterZone='..iWaterZone..' to be a WZ core base as it contains factories') end
                                tWZData[M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZbCoreBase] = true
                            end
                        end

                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(1)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    end
                end
            end
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            WaitTicks(1)
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function WaterZoneOverseer(iTeam)
    --Periodically cycles through every water zone and refreshes the unit details
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'WaterZoneOverseer'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    while not(M28Map.bWaterZoneInitialCreation) do
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitTicks(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if GetGameTimeSeconds() >= 60 then break end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitSeconds(1) --make sure other code such as team initialisation has run
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local aiBrain = M28Land.GetFirstActiveBrain(iTeam)

    if bDebugMessages == true then LOG(sFunctionRef..': About to start the main loop for water zones provided we have friendly M28 brains in the team '..iTeam..'; is table empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
        ForkThread(AssignValuesToWaterZones, iTeam)
    end

    while M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false do
        if bDebugMessages == true then LOG(sFunctionRef..': Will call logic to refresh every unit in a water zone') end
        ForkThread(ManageAllWaterZones, aiBrain, iTeam)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        WaitSeconds(1)
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
        if aiBrain.M28IsDefeated and M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]) == false then
            aiBrain = M28Land.GetFirstActiveBrain(iTeam)
        end
        if bDebugMessages == true then LOG(sFunctionRef..': About to restart the loop for team '..iTeam..'; aiBrain referred to='..(aiBrain.Nickname or 'nil')..'; Is table of active m28 brains='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains]))) end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordClosestAdjacentRangesAndEnemies(tWZData, tWZTeamData, iPond, iWaterZone, iTeam)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordClosestAdjacentRangesAndEnemies'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    tWZTeamData[M28Map.reftoNearestCombatEnemies] = {}
    
    local iEnemyBestAntiNavyRange = 0
    local iEnemyBestCombatRange = 0

    
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code, iTeam='..iTeam..'; iPond='..iPond..'; iWaterZone='..iWaterZone..'; Enemies in this or adjacent WZ='..tostring(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])) end
    if tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then        
        iEnemyBestAntiNavyRange = tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange]
        iEnemyBestCombatRange = math.max(tWZTeamData[M28Map.subrefWZBestEnemyDFRange], iEnemyBestAntiNavyRange)


        --Adjust the ranges to factor in adjacent water zones
        local iLowestDistUntilInRange = 10000
        local oLowestDFDistUntilInRange
        local tMidpoint = tWZData[M28Map.subrefWZMidpoint]
        local iCurDistUntilInRange
        if bDebugMessages == true then LOG(sFunctionRef..': Best DF range for this zone only='..tWZTeamData[M28Map.subrefWZBestEnemyDFRange]..'; best antinavy='..tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange]..';  Is table of adjacent WZs empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]))) end
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
            for iEntry, iAdjWaterZone in tWZData[M28Map.subrefWZAdjacentWaterZones] do
                iLowestDistUntilInRange = 10000
                oLowestDFDistUntilInRange = nil
                local tAltWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWaterZone][M28Map.subrefWZTeamData][iTeam]
                iEnemyBestAntiNavyRange = math.max(iEnemyBestAntiNavyRange, tAltWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange])
                iEnemyBestCombatRange = math.max(iEnemyBestAntiNavyRange, tAltWZTeamData[M28Map.subrefWZBestEnemyDFRange])

                if bDebugMessages == true then LOG(sFunctionRef..': Considering adjacent WZ '..iAdjWaterZone..'; tAltWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange]='..tAltWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange]..'; tAltWZTeamData[M28Map.subrefWZBestEnemyDFRange]='..tAltWZTeamData[M28Map.subrefWZBestEnemyDFRange]) end
                if M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.subrefTEnemyUnits]) == false and tAltWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal] >= 10 then
                    for iUnit, oUnit in tAltWZTeamData[M28Map.subrefTEnemyUnits] do
                        if oUnit[M28UnitInfo.refiDFRange] > 0 or oUnit[M28UnitInfo.refiAntiNavyRange] > 0 then
                            iCurDistUntilInRange = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], tMidpoint) - math.max((oUnit[M28UnitInfo.refiDFRange] or 0), (oUnit[M28UnitInfo.refiAntiNavyRange] or 0))
                            if iCurDistUntilInRange < iLowestDistUntilInRange then
                                oLowestDFDistUntilInRange = oUnit
                                iLowestDistUntilInRange = iCurDistUntilInRange
                            end
                        end
                    end
                end
                if oLowestDFDistUntilInRange  then
                    table.insert(tWZTeamData[M28Map.reftoNearestCombatEnemies], oLowestDFDistUntilInRange)
                end
            end
        end

        --Add all units from this zone into reftoNearestCombatEnemies
        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false and tWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal] then
            for iUnit, oUnit in tWZTeamData[M28Map.subrefTEnemyUnits] do
                if oUnit[M28UnitInfo.refiDFRange] > 0 or oUnit[M28UnitInfo.refiAntiNavyRange] > 0 then
                    table.insert(tWZTeamData[M28Map.reftoNearestCombatEnemies], oUnit)
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iEnemyBestAntiNavyRange='..iEnemyBestAntiNavyRange..'; iEnemyBestCombatRange='..iEnemyBestCombatRange) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iEnemyBestAntiNavyRange, iEnemyBestCombatRange
end

function ManageCombatUnitsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tAvailableCombatUnits, tAvailableSubmarines, tUnavailableUnitsInThisWZ)
    --Handles logic for main combat units (direct and indirect fire mobile units) that are noted as available to the land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageCombatUnitsInWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tUnassignedLandUnits
    if bDebugMessages == true then LOG(sFunctionRef..': start of code, iTeam='..iTeam..'; iPond='..iPond..'; iWaterZone='..iWaterZone..'; Is table of available combat units empty='..tostring(M28Utilities.IsTableEmpty(tAvailableCombatUnits))..'; Is table of available subs empty='..tostring(M28Utilities.IsTableEmpty(tAvailableSubmarines))..'; Are there enemy units in this or adjacent WZ='..tostring(tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ])) end

    local bWantReinforcements = false

    --Record which untis in adjacent zones are nearest to us:
    local iEnemyBestAntiNavyRange, iEnemyBestCombatRange = RecordClosestAdjacentRangesAndEnemies(tWZData, tWZTeamData, iPond, iWaterZone, iTeam)
    local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)

    --If enemy has units in this or adjacent WZ, then decide what to do
    if tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] then
        local bEnemyHasNoCombatUnits = M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies])
        local oNearestEnemyToMidpoint
        local iClosestDist = 100000
        local iCurDist
        for iUnit, oUnit in tWZTeamData[M28Map.subrefTEnemyUnits] do
            iCurDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefWZMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
            if iCurDist < iClosestDist then
                iClosestDist = iCurDist
                oNearestEnemyToMidpoint = oUnit
            end
        end

        if not(oNearestEnemyToMidpoint) then
            local iAdjWZ
            for _, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                iAdjWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits]) == false then
                    for iUnit, oUnit in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits] do
                        if M28UnitInfo.IsUnitValid(oUnit) then
                            iCurDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefWZMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                            if iCurDist < iClosestDist then
                                iClosestDist = iCurDist
                                oNearestEnemyToMidpoint = oUnit
                            end
                        end
                    end
                end
            end
            if not(oNearestEnemyToMidpoint) then
                if bDebugMessages == true then LOG(sFunctionRef..': WZ has flagged it has enemies here or in adjacent WZ but couldnt find any; iPond='..iPond..'; WZ='..iWaterZone) end
                tWZTeamData[M28Map.subrefbEnemiesInThisOrAdjacentWZ] = false
            end
        end

        --First consider submarines
        --Do we have shot blocked on non-skirmisher units, no indirect fire units, and have signficantly more threat than the enemy or are on an island beachhead? If so then move instead of attakc-moving when attacking
        local bMoveBlockedNotAttackMove = false
        if tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] > tWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal] * 3 then
            bMoveBlockedNotAttackMove = true
        end

        if tWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal] * 1.5 > M28UnitInfo.GetCombatThreatRating(tAvailableCombatUnits, false, true) + M28UnitInfo.GetCombatThreatRating(tAvailableSubmarines, false, true) then
            bWantReinforcements = true
            if bDebugMessages == true then LOG(sFunctionRef..': Want reinforcements as enemy combat exceeds our combat rating, tWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal]='..tWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal]..'; Our combat units rating='..M28UnitInfo.GetCombatThreatRating(tAvailableCombatUnits, false, true)) end
        end

        local bUpdateNearestUnit = false
        local bCheckIfNearestUnitVisible = false


        if M28Utilities.IsTableEmpty(tAvailableSubmarines) == false then
            local iEnemyBestAntiNavyRange = tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange]

            if tWZTeamData[M28Map.subrefWZBestAlliedSubmersibleRange] > iEnemyBestAntiNavyRange then
                --Scenario 1 - our subs outrange enemy antinavy
                local tOutrangedCombatUnits = {}
                local tUnitsToSupport = {}
                local bAttackWithOutrangedSubUnits = false
                if tWZTeamData[M28Map.subrefWZbCoreBase] then bAttackWithOutrangedSubUnits = true
                elseif tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] > tWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal] then bAttackWithOutrangedSubUnits = true
                end

                if M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToMidpoint:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) >= 10 then bCheckIfNearestUnitVisible = true end

                for iUnit, oUnit in tAvailableSubmarines do
                    if oUnit[M28UnitInfo.refiAntiNavyRange] > iEnemyBestAntiNavyRange then
                        table.insert(tUnitsToSupport, oUnit)
                        --Consider kiting logic unless want to use shot blocked override logic
                        if bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] then
                            M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'NSBlckM'..iWaterZone)
                            --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                            if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                        else

                            --Are we in range of any enemy?
                            if bEnemyHasNoCombatUnits or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tWZTeamData[M28Map.reftoNearestCombatEnemies], oUnit[M28UnitInfo.refiAntiNavyRange] * 0.94, iTeam, false)) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Not in range of enemy yet, and we outrange enemy; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Antinavy range='..oUnit[M28UnitInfo.refiAntiNavyRange]..'; oNearestEnemyToMidpoint='..oNearestEnemyToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToMidpoint)..'; oNearestEnemyToMidpoint antinavy range='..(oNearestEnemyToMidpoint[M28UnitInfo.refiAntiNavyRange] or 'nil')..'; Distance to the nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; Enemy unit actual position='..repru(oNearestEnemyToMidpoint:GetPosition())..'; Enemy last recorded position='..repru(oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Our unit position='..repru(oUnit:GetPosition())..'; WZ midpoint position='..repru(tWZData[M28Map.subrefWZMidpoint])) end
                                --Not in range yet, so attack move to the nearest enemy
                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit[M28UnitInfo.refiAntiNavyRange] * 0.5, false, 'NSKAMve'..iWaterZone)
                            else
                                --Enemy has DF units and they are already in our range so retreat
                                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'NSKRetr'..iWaterZone)
                                --If enemy is able to shoot us then get DF support
                                if not(bAttackWithOutrangedSubUnits) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tWZTeamData[M28Map.reftoNearestCombatEnemies], 4, iTeam, true) then
                                    bAttackWithOutrangedSubUnits = true
                                end
                                --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                            end
                        end
                    else
                        if oUnit[M28UnitInfo.refiAntiNavyRange] > 0 then
                            --We dont outrange the enemy, but we do have other units that do
                            table.insert(tOutrangedCombatUnits, oUnit)
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(tOutrangedCombatUnits) == false then
                    if bAttackWithOutrangedSubUnits then
                        for iUnit, oUnit in tOutrangedCombatUnits do
                            if bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] then
                                M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'WSOBlckM'..iWaterZone)
                                --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                            else
                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit[M28UnitInfo.refiAntiNavyRange] * 0.5, false, 'WSSRDFA'..iWaterZone)
                            end
                        end
                    else
                        if M28Utilities.IsTableEmpty(tUnitsToSupport) == false then
                            --Short range units can stay back and provide support - stay inbetween our long range units and the rally point
                            local iCurDist
                            local iClosestDist
                            local oClosestUnit
                            for iSRUnit, oSRUnit in tOutrangedCombatUnits do
                                iClosestDist = 100000
                                for iLRUnit, oLRUnit in tUnitsToSupport do
                                    iCurDist = M28Utilities.GetRoughDistanceBetweenPositions(oSRUnit:GetPosition(), oLRUnit:GetPosition())
                                    if iCurDist < iClosestDist then
                                        iClosestDist = iCurDist
                                        oClosestUnit = oLRUnit
                                    end
                                end
                                M28Orders.IssueTrackedMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), tRallyPoint), 5, true, false), 5, false, 'WSSRSup'..iWaterZone)
                            end
                        else
                            M28Utilities.ErrorHandler('We somehow think we outrange the enemy with subs, but have no subs units with a long range')
                        end
                    end
                end
            elseif tWZTeamData[M28Map.subrefWZbCoreBase] or (tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] > tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy] and (tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] * 1.5 > tWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal] or tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] * 1.75 > tWZTeamData[M28Map.subrefWZThreatEnemyAntiNavy])) then
                --SCENARIO 2 - We are either near our core naval factory or we have a greater threat than the enemy - attack
                for iUnit, oUnit in tAvailableSubmarines do
                    if bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] then
                        M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'SWBAWE'..iWaterZone)
                        --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                        if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                    else
                        M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'SWAWE'..iWaterZone)
                    end
                end
            else
                --Scenario 3 - want to retreat
                for iUnit, oUnit in tAvailableSubmarines do
                    --Only retreat units from this WZ
                    if oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] == iWaterZone then
                        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'WSRetr'..iWaterZone)
                    end
                end
            end
        end


        --Now consider non-submarine combat units
        if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then
            local iEnemyBestRange = math.max(tWZTeamData[M28Map.subrefWZBestEnemyAntiNavyRange], tWZTeamData[M28Map.subrefWZBestEnemyDFRange])

            if tWZTeamData[M28Map.subrefWZBestAlliedDFRange] > iEnemyBestRange then
                --Scenario 1 - our ships outrange enemy
                local tOutrangedCombatUnits = {}
                local tUnitsToSupport = {}
                local bAttackWithOutrangedUnits = false
                if tWZTeamData[M28Map.subrefWZbCoreBase] then bAttackWithOutrangedUnits = true
                elseif tWZTeamData[M28Map.subrefWZThreatAlliedSubmersible] * 1.5 > tWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal] then bAttackWithOutrangedUnits = true
                end

                if M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToMidpoint:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) >= 10 then bCheckIfNearestUnitVisible = true end

                for iUnit, oUnit in tAvailableCombatUnits do
                    if math.max(oUnit[M28UnitInfo.refiAntiNavyRange], oUnit[M28UnitInfo.refiDFRange]) > iEnemyBestAntiNavyRange then
                        table.insert(tUnitsToSupport, oUnit)
                        --Consider kiting logic unless want to use shot blocked override logic
                        if bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] then
                            M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'NSBlckM'..iWaterZone)
                            --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                            if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                        else

                            --Are we in range of any enemy?
                            if bEnemyHasNoCombatUnits or not(M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tWZTeamData[M28Map.reftoNearestCombatEnemies], math.max(oUnit[M28UnitInfo.refiAntiNavyRange], oUnit[M28UnitInfo.refiDFRange]) * 0.94, iTeam, false)) then
                                if bDebugMessages == true then LOG(sFunctionRef..': Not in range of enemy yet, and we outrange enemy; oUnit='..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Antinavy range='..oUnit[M28UnitInfo.refiAntiNavyRange]..'; DF range='..oUnit[M28UnitInfo.refiDFRange]..'; oNearestEnemyToMidpoint='..oNearestEnemyToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToMidpoint)..'; oNearestEnemyToMidpoint antinavy range='..(oNearestEnemyToMidpoint[M28UnitInfo.refiAntiNavyRange] or 'nil')..'; Distance to the nearest enemy to midpoint='..M28Utilities.GetDistanceBetweenPositions(oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit:GetPosition())..'; Enemy unit actual position='..repru(oNearestEnemyToMidpoint:GetPosition())..'; Enemy last recorded position='..repru(oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Our unit position='..repru(oUnit:GetPosition())..'; WZ midpoint position='..repru(tWZData[M28Map.subrefWZMidpoint])) end
                                --Not in range yet, so attack move to the nearest enemy
                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oUnit[M28UnitInfo.refiDFRange] * 0.5, false, 'NKAMve'..iWaterZone)
                            else
                                --Enemy has DF units and they are already in our range so retreat
                                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'NKRetr'..iWaterZone)
                                --If enemy is able to shoot us then get DF support
                                if not(bAttackWithOutrangedUnits) and M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tWZTeamData[M28Map.reftoNearestCombatEnemies], 4, iTeam, true) then
                                    bAttackWithOutrangedUnits = true
                                end
                                --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                            end
                        end
                    else
                        if oUnit[M28UnitInfo.refiAntiNavyRange] > 0 or oUnit[M28UnitInfo.refiDFRange] > 0 then
                            --We dont outrange the enemy, but we do have other units that do
                            table.insert(tOutrangedCombatUnits, oUnit)
                        end
                    end
                end
                if M28Utilities.IsTableEmpty(tOutrangedCombatUnits) == false then
                    if bAttackWithOutrangedUnits then
                        for iUnit, oUnit in tOutrangedCombatUnits do
                            if bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] then
                                M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'WOBlckM'..iWaterZone)
                                --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                                if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                            else
                                M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], math.max(oUnit[M28UnitInfo.refiAntiNavyRange], oUnit[M28UnitInfo.refiDFRange])* 0.5, false, 'WSRDFA'..iWaterZone)
                            end
                        end
                    else
                        if M28Utilities.IsTableEmpty(tUnitsToSupport) == false then
                            --Short range units can stay back and provide support - stay inbetween our long range units and the rally point
                            local iCurDist
                            local iClosestDist
                            local oClosestUnit
                            for iSRUnit, oSRUnit in tOutrangedCombatUnits do
                                iClosestDist = 100000
                                for iLRUnit, oLRUnit in tUnitsToSupport do
                                    iCurDist = M28Utilities.GetRoughDistanceBetweenPositions(oSRUnit:GetPosition(), oLRUnit:GetPosition())
                                    if iCurDist < iClosestDist then
                                        iClosestDist = iCurDist
                                        oClosestUnit = oLRUnit
                                    end
                                end
                                M28Orders.IssueTrackedMove(oSRUnit, M28Utilities.MoveInDirection(oClosestUnit:GetPosition(), M28Utilities.GetAngleFromAToB(oClosestUnit:GetPosition(), tRallyPoint), 5, true, false), 5, false, 'WSRSup'..iWaterZone)
                            end
                        else
                            M28Utilities.ErrorHandler('We somehow think we outrange the enemy with surface units, but have no units with a long range')
                        end
                    end
                end
            elseif tWZTeamData[M28Map.subrefWZbCoreBase] or tWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] * 1.5 > tWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal] then
                --SCENARIO 2 - We are either near our core naval factory or we have a greater threat than the enemy - attack
                for iUnit, oUnit in tAvailableCombatUnits do
                    if bMoveBlockedNotAttackMove and oUnit[M28UnitInfo.refbLastShotBlocked] then
                        M28Orders.IssueTrackedMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'WBAWE'..iWaterZone)
                        --If we are close to the last known position such that we will be able to see there is no longer a unit there, then update this unit's position for next cycle
                        if bCheckIfNearestUnitVisible and not(bUpdateNearestUnit) and M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam]) <= 18 then bUpdateNearestUnit = true end
                    else
                        M28Orders.IssueTrackedAggressiveMove(oUnit, oNearestEnemyToMidpoint[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], 6, false, 'WAWE'..iWaterZone)
                    end
                end
            else
                --Scenario 3 - want to retreat
                for iUnit, oUnit in tAvailableCombatUnits do
                    --Only retreat units from this WZ
                    if oUnit[M28UnitInfo.reftAssignedWaterZoneByTeam][iTeam] == iWaterZone then
                        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'WRetr'..iWaterZone)
                    end
                end
            end
        end

        if bUpdateNearestUnit then
            local aiBrain
            for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
                aiBrain = oBrain
                break
            end
            M28Team.UpdateUnitLastKnownPosition(aiBrain, oNearestEnemyToMidpoint, true)
        end



    else
        --No enemies in the water zone or adjacent so will look to reinforce another water zone


        --Do we have adjacent zones wanting reinforcements?
        local iWZToSupport

        if bDebugMessages == true then LOG(sFunctionRef..': Dont have any enemy units in this WZ or adjacent WZ, so will consider supporting other water zones') end
        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
            for iEntry, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                if M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][tWZSubtable[M28Map.subrefWZAWZRef]][M28Map.subrefWZTeamData][iTeam][M28Map.subrefbWZWantsSupport] then
                    iWZToSupport = tWZSubtable[M28Map.subrefWZAWZRef]
                    break
                end
            end
        end
        if iWZToSupport then
            local tSupportWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWZToSupport]
            if bDebugMessages == true then LOG(sFunctionRef..': Want to support WZ '..iWZToSupport) end
            if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then
                for iUnit, oUnit in tAvailableCombatUnits do
                    M28Orders.IssueTrackedMove(oUnit, tSupportWZData[M28Map.subrefWZMidpoint], 6, false, 'NDFMovWZ'..iWZToSupport..';'..iWaterZone)
                end
            end
            if M28Utilities.IsTableEmpty(tAvailableSubmarines) == false then
                for iUnit, oUnit in tAvailableSubmarines do
                    M28Orders.IssueTrackedMove(oUnit, tSupportWZData[M28Map.subrefWZMidpoint], 6, false, 'NSDFMovWZ'..iWZToSupport..';'..iWaterZone)
                end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Cant find any WZ that wants support, so do different things based on the unit we have') end
            --Submarines - dont do anything as want them nearby and dont want htem going to a predictable location (midpoint of waterzone)

            --Hover and amphibious units - find the closest land zone that wants reinforcements
            if M28Utilities.IsTableEmpty(tAvailableCombatUnits) == false then
                tUnassignedLandUnits = EntityCategoryFilterDown(M28UnitInfo.refCategoryAmphibiousCombat, tAvailableCombatUnits)
                local tOtherNavy = EntityCategoryFilterDown(categories.ALLUNITS - M28UnitInfo.refCategoryAmphibiousCombat, tAvailableCombatUnits)
                --Will return tUnassignedLandUnits so can combine with any other units that dont want to treat as combat units for these purposes
                --Other navy - consider bombardment of mexes and land units - consider doing via a separate function based on a set of units
                if M28Utilities.IsTableEmpty(tOtherNavy) == false then
                    --consider doing via a separate function based on a set of units both to keep code tidy and incase we end up wanting to give certain untis bombardment orders from the main logic above
                    M28Utilities.ErrorHandler('To add bombardment code for surface navy')
                end
            end

        end
    end

    UpdateIfWaterZoneWantsSupport(tWZTeamData, bWantReinforcements)
    if bDebugMessages == true then LOG(sFunctionRef..': Just recorded if this WZ wants support, bWantReinforcements='..tostring(bWantReinforcements)..'; is tUnassignedLandUnits empty='..tostring(M28Utilities.IsTableEmpty(tUnassignedLandUnits))) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tUnassignedLandUnits
end

function ManageMAAInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tAvailableMAA)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageMAAInWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)

    --First split the MAA into those that need to run (due to being in range of DF units) and those that can advance
    local tMAAToAdvance = {}
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftoNearestCombatEnemies]) then
        --No DF enemies so treat all MAA as being available
        tMAAToAdvance = tAvailableMAA
    else
        local iRunThreshold = 30
        if tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then
            iRunThreshold = 15
        end
        for iUnit, oUnit in tAvailableMAA do
            --Run if within 30 of being in range of enemy combat
            if M28Conditions.CloseToEnemyUnit(oUnit:GetPosition(), tWZTeamData[M28Map.reftoNearestCombatEnemies], iRunThreshold, iTeam, true) then
                if bDebugMessages == true then
                    LOG(sFunctionRef..': MAA '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is too close to enemy, iRunThreshold='..iRunThreshold..'; will run back; will list out enemy units and distance to us in a moment')
                    for iEnemy, oEnemy in tWZTeamData[M28Map.reftoNearestCombatEnemies] do
                        LOG('oEnemy='..oEnemy.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemy)..'; DF r ange='..(oEnemy[M28UnitInfo.refiDFRange] or 'nil')..'; Dist to this MAA unit='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemy[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Actual distance using actual position='..M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), oEnemy:GetPosition()))
                    end
                end
                M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 6, false, 'NRun'..iWaterZone)
            else
                table.insert(tMAAToAdvance, oUnit)
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Is table of tMAAToAdvance empty='..tostring(M28Utilities.IsTableEmpty(tMAAToAdvance))) end


    --If enemy has air units in this zone then send the MAA to advance units towards it, but avoid enemy land units
    if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': Number of MAA units to advance='..table.getn(tMAAToAdvance)..'; Is table of enemy air units for this WZ '..iWaterZone..' empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftWZEnemyAirUnits]))) end
        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.reftWZEnemyAirUnits]) == false then
            --Move towards the nearest enemy air unit to the WZ midpoint
            local oNearestEnemyToMidpoint
            local iClosestDist = 100000
            local iCurDist
            --Get closest enemy air unit
            for iUnit, oUnit in tWZTeamData[M28Map.reftWZEnemyAirUnits] do
                iCurDist = M28Utilities.GetDistanceBetweenPositions(tWZData[M28Map.subrefWZMidpoint], oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])
                if iCurDist < iClosestDist then
                    iClosestDist = iCurDist
                    oNearestEnemyToMidpoint = oUnit
                end
            end

            --Move towards the air unit
            local tOrderPosition = oNearestEnemyToMidpoint:GetPosition()
            if bDebugMessages == true then
                LOG(sFunctionRef..': GameTime='..GetGameTimeSeconds()..' Will order every MAA to move to oNearestEnemyToMidpoint='..oNearestEnemyToMidpoint.UnitId..M28UnitInfo.GetUnitLifetimeCount(oNearestEnemyToMidpoint)..' at position '..repru(oNearestEnemyToMidpoint:GetPosition()))
                M28Utilities.DrawLocation(tOrderPosition)
            end

            for iUnit, oUnit in tMAAToAdvance do
                M28Orders.IssueTrackedMove(oUnit, tOrderPosition, 7, false, 'NMNA')
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Will do reprs of orders of the first unit in tMAAToAdvance, '..tMAAToAdvance[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tMAAToAdvance[1])..': '..reprs(tMAAToAdvance[1][M28Orders.reftiLastOrders])) end

        else
            local tWZToReinforceModDistance = {}
            local iCurModDist
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': About to consider all other adjacent land zones to iWaterZone '..iWaterZone..', reprs of tWZData[M28Map.subrefWZOtherWaterZones]='..reprs(tWZData[M28Map.subrefWZOtherWaterZones])) end
                local iAltWZ
                for iEntry, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                    iAltWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                    local tAltTeamWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAltWZ][M28Map.subrefWZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering whether to send MAA to assist alt WZ iAltWZ='..iAltWZ..'; tAltTeamWZData[M28Map.subrefWZMAAThreatWanted]='..tAltTeamWZData[M28Map.subrefWZMAAThreatWanted]..'; tAltTeamWZData[M28Map.subrefWZThreatAlliedAA]='..tAltTeamWZData[M28Map.subrefWZThreatAlliedAA]..'; Air to ground threat in this alt WZ='..tAltTeamWZData[M28Map.refiEnemyAirToGroundThreat]) end
                    if tAltTeamWZData[M28Map.subrefWZMAAThreatWanted] > tAltTeamWZData[M28Map.subrefWZThreatAlliedAA] then
                        iCurModDist = tWZSubtable[M28Map.subrefWZAWZDistance]
                        if tAltTeamWZData[M28Map.refiEnemyAirToGroundThreat] > 0 then
                            iCurModDist = iCurModDist - 200
                            if tAltTeamWZData[M28Map.subrefWZTThreatAllyCombatTotal] > 0 then iCurModDist = iCurModDist - 35 end
                        elseif tAltTeamWZData[M28Map.refiEnemyAirOtherThreat] > 45 then iCurModDist = iCurModDist - 100
                        end
                        if M28Utilities.IsTableEmpty(tAltTeamWZData[M28Map.subrefWZTAlliedUnits]) then iCurModDist = iCurModDist + 100 end
                        if tAltTeamWZData[M28Map.subrefWZTThreatEnemyCombatTotal] > 6 then
                            iCurModDist = iCurModDist + 50
                            if tAltTeamWZData[M28Map.subrefWZTThreatAllyCombatTotal] == 0 then
                                iCurModDist = iCurModDist + 150
                            elseif tAltTeamWZData[M28Map.subrefWZTThreatEnemyCombatTotal] > tAltTeamWZData[M28Map.subrefWZTThreatAllyCombatTotal] then
                                iCurModDist = iCurModDist + 75
                            end
                        end
                        tWZToReinforceModDistance[iAltWZ] = iCurModDist
                    end
                end
                for iWZ, iModDist in M28Utilities.SortTableByValue(tWZToReinforceModDistance, false) do
                    SendMAAToSupportWaterZone(tMAAToAdvance, iPond, iTeam, iWZ)
                    if M28Utilities.IsTableEmpty(tMAAToAdvance) then
                        break
                    end
                end

                if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                    if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                        if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                            for iEntry, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                                iAltWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                                local tAltWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAltWZ][M28Map.subrefWZTeamData][iTeam]
                                if M28Utilities.IsTableEmpty(tAltWZTeamData[M28Map.subrefWZTAlliedUnits]) == false and tAltWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal] < tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] and tAltWZTeamData[M28Map.subrefWZThreatAlliedAA] < tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] * 0.4 then
                                    SendMAAToSupportWaterZone(tMAAToAdvance, iPond, iTeam, iAltWZ)
                                end
                            end
                        end
                    end
                end



                --Do we have any MAA remaining after sending MAA to any WZ wanting support?
                if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                    local iFactorAdjust
                    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                        for iEntry, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                            iAltWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                            local tAltWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAltWZ][M28Map.subrefWZTeamData][iTeam]
                            if tAltWZTeamData[M28Map.subrefWZTThreatAllyCombatTotal] > 10 or tAltWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal] < 10 then
                                iFactorAdjust = 2
                                if tWZTeamData[M28Map.refiEnemyAirToGroundThreat] > 0 then iFactorAdjust = 4 end
                                SendMAAToSupportWaterZone(tMAAToAdvance, iPond, iTeam, iAltWZ, iFactorAdjust)
                            end
                        end
                    end
                end
            end
            if M28Utilities.IsTableEmpty(tMAAToAdvance) == false then
                if bDebugMessages == true then LOG(sFunctionRef..': Still have spare MAA, will go to rally point') end
                for iUnit, oUnit in tMAAToAdvance do
                    M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 10, false, 'NBRtr'..iWaterZone)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function SendMAAToSupportWaterZone(tMAAToAdvance, iPond, iTeam, iWZToSupport, iMAAFactorAdjust)
    --Assigns MAA to the water zone up to the level at which the WZ doesnt want more MAA support, but increases the MAA wanted by the water zone by iMAAFactorAdjust (or 1 if not specified)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SendMAAToSupportWaterZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tAltWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWZToSupport]
    local tAltTeamWZData = tAltWZData[M28Map.subrefWZTeamData][iTeam]
    local tDistToTargetByRef = {}
    local tTargetPosition = tAltWZData[M28Map.subrefWZMidpoint]
    if not(tAltTeamWZData[M28Map.subrefWZMAAThreatWanted]) or not(tAltTeamWZData[M28Map.subrefWZThreatAlliedAA]) then
        M28Utilities.ErrorHandler('Have nil MAA or AllyGroundAA threat for iWZToSupport='..(iWZToSupport or 'nil')..'; see log for more info')
        LOG(sFunctionRef..': MAA iTeam='..(iTeam or 'nil')..'; iPond='..(iPond or 'nil')..'; iWZToSupport='..(iWZToSupport or 'nil')..'; tAltTeamWZData[M28Map.subrefWZThreatAlliedAA]='..(tAltTeamWZData[M28Map.subrefWZThreatAlliedAA] or 'nil')..'; reprs of teamWZData='..reprs(tAltTeamWZData))
    else
        local iMAAThreatWanted = tAltTeamWZData[M28Map.subrefWZMAAThreatWanted] * (iMAAFactorAdjust or 1) - tAltTeamWZData[M28Map.subrefWZThreatAlliedAA]

        for iUnit, oUnit in tMAAToAdvance do
            tDistToTargetByRef[iUnit] = M28Utilities.GetDistanceBetweenPositions(oUnit:GetPosition(), tTargetPosition)
        end
        local tbRemovedMAAReferencesByRef = {}
        for iUnitRef, iDistance in M28Utilities.SortTableByValue(tDistToTargetByRef, false) do
            M28Orders.IssueTrackedMove(tMAAToAdvance[iUnitRef], tTargetPosition, 10, false, 'NMVEWZ'..iWZToSupport)
            iMAAThreatWanted = iMAAThreatWanted - M28UnitInfo.GetAirThreatLevel({ tMAAToAdvance[iUnitRef] }, false, false, true, false, false, false)
            tbRemovedMAAReferencesByRef[iUnitRef] = true
            if iMAAThreatWanted < 0 then break end
        end
        if M28Utilities.IsTableEmpty(tbRemovedMAAReferencesByRef) == false then
            --Remove any MAA that have given orders from tMAAToAdvance:
            local iRevisedIndex = 1
            local iTableSize = table.getn(tMAAToAdvance)

            for iOrigIndex=1, iTableSize do
                if tMAAToAdvance[iOrigIndex] then
                    if not(tbRemovedMAAReferencesByRef[iOrigIndex]) then --I.e. this should run the logic to decide whether we want to keep this entry of the table or remove it
                        --We want to keep the entry; Move the original index to be the revised index number (so if e.g. a table of 1,2,3 removed 2, then this would've resulted in the revised index being 2 (i.e. it starts at 1, then icnreases by 1 for the first valid entry); this then means we change the table index for orig index 3 to be 2
                        if (iOrigIndex ~= iRevisedIndex) then
                            tMAAToAdvance[iRevisedIndex] = tMAAToAdvance[iOrigIndex];
                            tMAAToAdvance[iOrigIndex] = nil;
                        end
                        iRevisedIndex = iRevisedIndex + 1; --i.e. this will be the position of where the next value that we keep will be located
                    else
                        tMAAToAdvance[iOrigIndex] = nil;
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RetreatOtherUnitsInWaterZone(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tOtherUnitsToRetreat)
    local tRallyPoint = GetNearestWaterRallyPoint(tWZData, iTeam, iPond, iWaterZone)
    for iUnit, oUnit in tOtherUnitsToRetreat do
        M28Orders.IssueTrackedMove(oUnit, tRallyPoint, 10, false, 'NOtRet', false)
    end
end

function ManageWaterZoneScouts(tWZData, tWZTeamData, iTeam, iPond, iWaterZone, tScouts, bWaterZoneContainsNonScouts)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ManageWaterZoneScouts'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    tWZTeamData[M28Map.refbWantLandScout] = false
    if bDebugMessages == true then LOG(sFunctionRef..': Considering if we want a land scout for iPond '..iPond..'; iWaterZone='..iWaterZone..'; bLandZoneContainsNonScouts='..tostring(bLandZoneContainsNonScouts or false)..'; Enemy combat threat='..tWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal]..'; Is table of land scouts traveling here empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefWZTScoutsTravelingHere]))..'; Is table of scouts currently in this WZ empty='..tostring(M28Utilities.IsTableEmpty(tScouts))) end
    if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefWZTScoutsTravelingHere]) then
        --Want a land scout for htis land zone, unless we already have one traveling here; if we have available land scouts then will change this flag back to false
        tWZTeamData[M28Map.refbWantLandScout] = true
        if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; We want to get a scout for this WZ '..(iWaterZone or 'nil')..' on pond '..(iPond or 'nil')..' with island '..(tWZData[M28Map.subrefWZIslandRef] or 'nil')) end
    end

    --Do we have any land scouts that are available? if so then assign to an adjacent land zone if the adjacent zone wants scouts
    if M28Utilities.IsTableEmpty(tScouts) == false then
        local tAvailableScouts = {}
        local bCheckForEnemies = false
        local tEnemyUnitTablesToConsider = {}
        --Check for neemies if there are any in this or adjacent land zone
        if M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefTEnemyUnits]) == false then
            --if tWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal] > 0 then
            table.insert(tEnemyUnitTablesToConsider, tWZTeamData[M28Map.subrefTEnemyUnits])
        end
        if M28Utilities.IsTableEmpty(M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZOtherWaterZones]) == false then
            local iAdjWZ
            for _, tWZSubtable in M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iWaterZone][M28Map.subrefWZOtherWaterZones] do
                iAdjWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                if bDebugMessages == true then LOG(sFunctionRef..': Checking if enemies in iAdjWZ='..iAdjWZ..'; enemy combat total='..M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZTThreatEnemyCombatTotal]) end
                if M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZTThreatEnemyCombatTotal] > 0 then
                    table.insert(tEnemyUnitTablesToConsider, M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefTEnemyUnits])
                end
            end
        end
        if M28Utilities.IsTableEmpty(tEnemyUnitTablesToConsider) == false then bCheckForEnemies = true end

        local oEnemyToRunFrom
        local oPrevEnemyToRunFrom
        local iRunThreshold = 20 --If get this close to being in range of an enemy should try to run
        if bDebugMessages == true then LOG(sFunctionRef..': About to consider orders for scouts in this WZ, size of tScouts='..table.getn(tScouts)..'; bCheckForEnemies='..tostring(bCheckForEnemies)..'; Enemy combat total='..tWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal]) end
        local iCurDist
        for iScout, oScout in tScouts do
            if bCheckForEnemies then
                oEnemyToRunFrom = nil
                if oPrevEnemyToRunFrom and M28Utilities.GetDistanceBetweenPositions(oPrevEnemyToRunFrom[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) - (oPrevEnemyToRunFrom[M28UnitInfo.refiDFRange] or 0) <= iRunThreshold then
                    --Run from same enemy
                    oEnemyToRunFrom = oPrevEnemyToRunFrom
                else
                    for iUnitTable, tUnitTable in tEnemyUnitTablesToConsider do
                        for iUnit, oUnit in tUnitTable do
                            if bDebugMessages == true then LOG(sFunctionRef..': Looking for enemy to run from for scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..', considering enemy unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..'; Unit DF range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Unit position='..repru(oUnit:GetPosition())..'; Unit last known position='..repru(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam])..'; Dist between last known position and scout='..M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition())..'; Unit range='..(oUnit[M28UnitInfo.refiDFRange] or 'nil')..'; iRunThreshold='..iRunThreshold..'; Is distance within run threshold='..tostring(M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) - (oUnit[M28UnitInfo.refiDFRange] or 0) <= iRunThreshold)..'; bConsiderAttacking='..tostring(bConsiderAttacking)..'; Unit df range='..(oUnit[M28UnitInfo.refiDFRange] or 0)..'; Unit build range='..(oUnit:GetBlueprint().Economy.MaxBuildDistance or 'nil')) end
                            if (oUnit[M28UnitInfo.refiDFRange] or 0) > 0 and not(oUnit == oPrevEnemyToRunFrom) then
                                iCurDist = M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) - (oUnit[M28UnitInfo.refiDFRange] or 0)
                                if iCurDist <= iRunThreshold then
                                    oEnemyToRunFrom = oUnit
                                    if bDebugMessages == true then LOG(sFunctionRef..': Want to run from unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' so will stop searching') end
                                    break
                                elseif bDebugMessages == true then LOG(sFunctionRef..': Unit '..oUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oUnit)..' is too far away for us to run from it, will keep looking')
                                end
                                --Check if about to get in range of engineer that can reclaim us - have done +8 as lower values resulted in some cases in the engineer being able to reclaim the scout
                            elseif EntityCategoryContains(M28UnitInfo.refCategoryEngineer, oUnit.UnitId) and M28Utilities.GetDistanceBetweenPositions(oUnit[M28UnitInfo.reftLastKnownPositionByTeam][iTeam], oScout:GetPosition()) <= 8 + (oUnit:GetBlueprint().Economy.MaxBuildDistance or 3) then
                                oEnemyToRunFrom = oUnit
                                break
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Do we have a valid enemy unit to run from='..tostring(M28UnitInfo.IsUnitValid(oEnemyToRunFrom))..'; ENemy ID if any='..(oEnemyToRunFrom.UnitId or 'nil')) end
            end
            if oEnemyToRunFrom then
                tWZTeamData[M28Map.refbWantLandScout] = false
                if bDebugMessages == true then LOG(sFunctionRef..': Want scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..' to run from oEnemyToRunFrom '..oEnemyToRunFrom.UnitId..M28UnitInfo.GetUnitLifetimeCount(oEnemyToRunFrom)..' unless iti s a combat scout vs an engineer/mex in a low threat WZ in which case want it to attack the unit; WZ combat total='..tWZTeamData[M28Map.subrefWZTThreatEnemyCombatTotal]..'; Scout DF range='..(oScout[M28UnitInfo.refiDFRange] or 'nil')..'; Do we have a combat scout='..tostring(EntityCategoryContains(M28UnitInfo.refCategoryCombatScout, oScout.UnitId))..'; Distance to nearest enemy='..M28Utilities.GetDistanceBetweenPositions(oEnemyToRunFrom:GetPosition(), oScout:GetPosition())) end
                oPrevEnemyToRunFrom = oEnemyToRunFrom
                local iPlateau = M28Map.GetPlateauAndLandZoneReferenceFromPosition(oScout:GetPosition())
                M28Land.RunFromEnemy(oScout, oEnemyToRunFrom, iTeam, iPlateau, 16)
            else
                if bDebugMessages == true then LOG(sFunctionRef..': No nearby enemy to run from, Considering if scout '..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)..' is available; refiWZToMoveTo='..repru(oScout[refiWZToMoveTo])) end
                if oScout[refiWZToMoveTo] then
                    --Make scout available if its target WZ is this WZ
                    if oScout[refiWZToMoveTo] == iWaterZone then
                        --Clear this unit from list of traveling units, but dont make it available as want a slight delay, so want it to be available on the next cycle
                        if bDebugMessages == true then LOG(sFunctionRef..': Scout is traveling to this land zone and is here so will clear the trackers so next cycle it is shown as available') end
                        RemoveUnitFromListOfUnitsTravelingToWaterZone(oScout)
                        tWZTeamData[M28Map.refbWantLandScout] = false
                    else
                        --Scout should be traveling to another land zone - if it has no orders then refresh them
                        if bDebugMessages == true then LOG(sFunctionRef..': Scout should travel to another water zone so order it to travel there') end
                        local iTravelPond = M28Map.tiPondByWaterZone[oScout[refiWZToMoveTo]]
                        M28Orders.IssueTrackedMove(oScout, M28Map.tPondDetails[iTravelPond][M28Map.subrefPondWaterZones][M28Map.subrefWZMidpoint], 6, false, 'TWZ'..oScout[refiWZToMoveTo])
                    end
                elseif oScout[M28Land.reftiPlateauAndLZToMoveTo] then
                    --Scout is going to a land zone not a water zone
                    if bDebugMessages == true then LOG(sFunctionRef..': Scout should travel to another land zone so order it to travel there') end
                    M28Orders.IssueTrackedMove(oScout, M28Map.tAllPlateaus[oScout[M28Land.reftiPlateauAndLZToMoveTo][1]][M28Map.subrefPlateauLandZones][oScout[M28Land.reftiPlateauAndLZToMoveTo][2]][M28Map.subrefLZMidpoint], 6, false, 'NTLZ'..oScout[M28Land.reftiPlateauAndLZToMoveTo][2])
                else
                    --Scout has no nearby enemies to run from, and isnt traveling to a water zone, so it should be available for use
                    if bDebugMessages == true then LOG(sFunctionRef..': Dont want to run or attack with scout and it isnt already assigned to another LZ or WZ so will aadd to table of available scouts, oScout='..oScout.UnitId..M28UnitInfo.GetUnitLifetimeCount(oScout)) end
                    table.insert(tAvailableScouts, oScout)
                end
            end
        end

        if bDebugMessages == true then LOG(sFunctionRef..': Is available scout table empty='..tostring(M28Utilities.IsTableEmpty(tAvailableScouts))) end

        if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
            --First assign any available scouts to adjacent water zones wanting scouts
            if bDebugMessages == true then LOG(sFunctionRef..': Will first allocate scouts to any adjacent land zones that want a scout. Is table of adj zones empty='..tostring(M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]))) end
            if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                local iAdjWZ
                for _, tWZSubtable in tWZData[M28Map.subrefWZOtherWaterZones] do
                    iAdjWZ = tWZSubtable[M28Map.subrefWZAWZRef]
                    local tWZTeamData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam]
                    if bDebugMessages == true then LOG(sFunctionRef..': Consideri niAdjWZ='..iAdjWZ..'; Does this WZ want land scout='..tostring(tWZTeamData[M28Map.refbWantLandScout] or false)..'; Is table of traveling scouts here empty='..tostring(M28Utilities.IsTableEmpty(tWZTeamData[M28Map.subrefWZTScoutsTravelingHere]))) end
                    if tWZTeamData[M28Map.refbWantLandScout] then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will send land scout '..tAvailableScouts[1].UnitId..M28UnitInfo.GetUnitLifetimeCount(tAvailableScouts[1])..' to go to adjacent water zone '..iAdjWZ) end


                        GetUnitToTravelToWaterZone(tAvailableScouts[1], iPond, iAdjWZ, M28Map.subrefWZTScoutsTravelingHere)
                        tWZTeamData[M28Map.refbWantLandScout] = false
                        table.remove(tAvailableScouts, 1)
                        if M28Utilities.IsTableEmpty(tAvailableScouts) then break end
                    end
                end

            end
            if M28Utilities.IsTableEmpty(tAvailableScouts) == false then
                tWZTeamData[M28Map.refbWantLandScout] = false
                --If we are here then we still have available land scouts; if we have ap atrol path then patrol; if we have a mex then go here, if we have an adjcent zone go here, otherwise move randomly if we have no orders
                for iScout, oScout in tAvailableScouts do
                    if M28Utilities.IsTableEmpty(tWZData[M28Map.subreftPatrolPath]) == false then
                        --Patrol the land zone
                        M28Orders.PatrolPath(oScout, tWZData[M28Map.subreftPatrolPath], false, 'NSP')
                    else
                        --Do nothing if scout is moving as maybe it landed on a segment just out of the zone it shoudl have been in
                        if not(oScout:IsUnitState('Moving')) then
                            M28Orders.UpdateRecordedOrders(oScout)
                            if (oScout[M28Orders.refiOrderCount] or 0) == 0 then
                                --Want ot get somewhere to move to as a backup
                                --Do we have an adjacent WZ? If so move here
                                if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZOtherWaterZones]) == false then
                                    GetUnitToTravelToWaterZone(tAvailableScouts[1], iPond, tWZData[M28Map.subrefWZOtherWaterZones][1], M28Map.subrefWZTScoutsTravelingHere)
                                else
                                    --No adjacent WZs, and no mexes in this WZ, so just move randomly
                                    M28Orders.IssueTrackedMove(oScout, M28Utilities.MoveInDirection(oScout:GetPosition(), math.random(1, 360), math.random(10, 30), true, false), 5, false, 'NBackupRnd')
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetWaterZoneToRunTo(iTeam, iPond, iCurWaterZone, sPathing, tOptionalStartPosition, tOptionalEnemyPositionToRunFrom)
    --Returns cur WZ if no WZ to run to, otherwise returns the land zone we think is best to run to from iCurLandZone
    --tOptionalStartPosition - if nil then will use midpoint of iCurLandZone
    --tOptionalEnemyPositionToRunFrom - if this is specified, then will pick al ocation based on angle from the start position to the location vs the start position angle to the enemy position to run to (so we run in the opposite direction to the enemy position if the opposite direction WZ is safe)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetWaterZoneToRunTo'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if bDebugMessages == true then LOG(sFunctionRef..': iTeam='..iTeam..'; iPond='..iPond..'; iCurWaterZone='..iCurWaterZone..'; sPathing='..sPathing..'; tOptionalStartPosition='..repru(tOptionalStartPosition)..'; tOptionalEnemyPositionToRunFrom='..repru(tOptionalEnemyPositionToRunFrom)) end

    local tWZShortlist = {}
    local tWZData = M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iCurWaterZone]
    --See if there are any adjacent water zones without enemy units
    if M28Utilities.IsTableEmpty(tWZData[M28Map.subrefWZAdjacentWaterZones]) == false then
        for iEntry, iAdjWZ in tWZData[M28Map.subrefWZAdjacentWaterZones] do
            if M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iAdjWZ][M28Map.subrefWZTeamData][iTeam][M28Map.subrefWZTThreatEnemyCombatTotal] == 0 then
                table.insert(tWZShortlist, iAdjWZ)
            end
        end
    end
    if M28Utilities.IsTableEmpty(tWZShortlist) then
        --Nowhere to run to
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return iCurWaterZone
    else
        local tStartPoint = (tOptionalStartPosition or tWZData[M28Map.subrefWZMidpoint])
        local iPreferredWZRef
        if tOptionalEnemyPositionToRunFrom then
            --Go to the angle furthest in angle away from the nearest enemy
            local iAngleToEnemy = M28Utilities.GetAngleFromAToB(tStartPoint, tOptionalEnemyPositionToRunFrom)
            local iCurAngleDif
            local iHighestAngleDif = 0
            for _, iPossibleWZ in tWZShortlist do
                iCurAngleDif = M28Utilities.GetAngleDifference(iAngleToEnemy, M28Utilities.GetAngleFromAToB(tStartPoint, M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iPossibleWZ][M28Map.subrefWZMidpoint]))
                if iCurAngleDif > iHighestAngleDif then
                    iHighestAngleDif = iCurAngleDif
                    iPreferredWZRef = iPossibleWZ
                end
            end
        else
            --dont have angle to nearest enemy so just pick the closest land zone

            local iClosestWZDistance = 100000
            local iCurDist
            for _, iPossibleWZ in tWZShortlist do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering distance from tStartPoint to iPossibleWZ '..(iPossibleWZ or 'nil')..'; Midpoint of that WZ='..repru(M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleWZ][M28Map.subrefWZMidpoint])..'; iCurDist='..(M28Utilities.GetTravelDistanceBetweenPositions(tStartPoint, M28Map.tAllPlateaus[iPlateau][M28Map.subrefPlateauLandZones][iPossibleWZ][M28Map.subrefWZMidpoint], sPathing) or 'nil')) end
                iCurDist = M28Utilities.GetTravelDistanceBetweenPositions(tStartPoint, M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iPossibleWZ][M28Map.subrefWZMidpoint], sPathing)
                --Backup - if the built in pathfinding doesnt htink we can path there (e.g. we are by a cliff) then use straight line distance
                if not(iCurDist) then iCurDist = M28Utilities.GetDistanceBetweenPositions(tStartPoint, M28Map.tPondDetails[iPond][M28Map.subrefPondWaterZones][iPossibleWZ][M28Map.subrefWZMidpoint]) + 30 end

                if iCurDist < iClosestWZDistance then
                    iClosestWZDistance = iCurDist
                    iPreferredWZRef = iPossibleWZ
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        return (iPreferredWZRef or iCurWaterZone)
    end

end