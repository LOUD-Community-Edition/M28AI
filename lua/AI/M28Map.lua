---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 16/11/2022 07:22
---

local M28Profiling = import('/mods/M28AI/lua/AI/M28Profiling.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local NavUtils = import("/lua/sim/navutils.lua")

--Pathing types
--NavLayers 'Land' | 'Water' | 'Amphibious' | 'Hover' | 'Air'
refPathingTypeAmphibious = 'Amphibious'
refPathingTypeNavy = 'Water'
refPathingTypeAir = 'Air'
refPathingTypeLand = 'Land'
refPathingTypeNone = 'None'
refPathingTypeAll = {refPathingTypeAmphibious, refPathingTypeNavy, refPathingTypeAir, refPathingTypeLand}

--Map size
rMapPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2} - Set at start of the game, use instead of the scenarioinfo method
iMaxLandSegmentX = 1
iMaxLandSegmentZ = 1

iMapWaterHeight = 0 --Surface height of water on the map

--Resource information
tMassPoints = {} --[x] is an integer count, returns the location of a mass point; stores all mexes on the map
tHydroPoints = {} --[x] is an integer count, returns the location of a hydro point; stores all hydro points on the map
tMexByPathingAndGrouping = {} --Stores position of each mex based on the pathing group that it's part of; [a][b][c]: [a] = pathing type ('Land' etc.); [b] = Segment grouping; [c] = Mex position
tHydroByPathingAndGrouping = {} --as above but for hydros


--Plateaus - core
tAllPlateausWithMexes = {} --[x] = AmphibiousPathingGroup, [y]: subrefs, e.g. subrefPlateauMexes;
--aibrain variables for plateaus:
reftPlateausOfInterest = 'M27PlateausOfInterest' --[x] = Amphibious pathing group; will record a table of the pathing groups we're interested in expanding to, returns the location of then earest mex
refiLastPlateausUpdate = 'M27LastTimeUpdatedPlateau' --gametime that we last updated the plateaus
reftOurPlateauInformation = 'M27OurPlateauInformation' --[x] = AmphibiousPathingGroup; [y] = subref, e.g. subrefPlateauLandFactories; Used to store details such as factories on the plateau
refiOurBasePlateauGroup = 'M27PlateausOurBaseGroup' --Segment group of our base (so can easily check somewhere is in a dif plateau)

--subrefs for tables
--tAllPlateausWithMexes subrefs
subrefPlateauMexes = 'M27PlateauMex' --[x] = mex count, returns mex position
subrefPlateauMinXZ = 'M27PlateauMinXZ' --{x,z} min values
subrefPlateauMaxXZ = 'M27PlateauMaxXZ' --{x,z} max values - i.e. can create a rectangle covering entire plateau using min and max xz values
subrefPlateauTotalMexCount = 'M27PlateauMexCount' --Number of mexes on the plateau
subrefPlateauReclaimSegments = 'M27PlateauReclaimSegments' --[x] = reclaim segment x, [z] = reclaim segment z, returns true if part of plateau
subrefPlateauMidpoint = 'M27PlateauMidpoint' --Location of the midpoint of the plateau
subrefPlateauMaxRadius = 'M27PlateauMaxRadius' --Radius to use to ensure the circle coveres the square of the plateau
subrefPlateauContainsActiveStart = 'M27PlateauContainsActiveStart' --True if the plateau is pathable amphibiously to a start position that was active at the start of the game

--reftOurPlateauInformation subrefs (NOTE: If adding more info here need to update in several places, including ReRecordUnitsAndPlatoonsInPlateaus)
subrefPlateauLandFactories = 'M27PlateauLandFactories'

subrefPlateauLandCombatPlatoons = 'M27PlateauLandCombatPlatoons'
subrefPlateauIndirectPlatoons = 'M27PlateauIndirectPlatoons'
subrefPlateauMAAPlatoons = 'M27PlateauMAAPlatoons'
subrefPlateauScoutPlatoons = 'M27PlateauScoutPlatoons'

subrefPlateauEngineers = 'M27PlateauEngineers' --[x] is engineer unique ref (per m27engineeroverseer), returns engineer object

--Plateaus - Land zone variables
subrefPlateauLandZones = 'M27PlateauLandZones' --against the main plateau table, stores info on land zones for that plateau
subrefLandZoneCount = 'M27PlateauZoneCount' --against the main plateau table, records how many land zones there are (alternative to table.getn on the land zones)
iLandZoneSegmentSize = 5 --Gets updated by the SetupLandZones - the size of one side of the square that is the lowest resolution land zones go to; each segment that is land pathable gets assigned to a land zone
tLandZonesByPlateau = {} --[x] is the plateau group number, returns a table where [y] is the land zone number, which then returns details on the land zone; use tLandZoneBySegment to get a zone reference from land segments
subrefLZMexCount = 'MexCount' --against tLandZonesByPlateau[iPlateau][iLZ], returns number of mexes in the LZ
subrefLZMexLocations = 'MexLoc' --against tLandZonesByPlateau[iPlateau][iLZ], returns table of mex locations in the LZ
subrefLZReclaimMass = 'ReclaimMass' --against tLandZonesByPlateau[iPlateau][iLZ], returns total mass reclaim in the LZ

--Land pathing segment data
tLandZoneBySegment = {} --[x][z] should be the x and z segments baed on iLandZoneSegmentSize, and should return the land zone number, or nil if there is none
tTempZoneTravelDistanceBySegment = {} --[x][z] should be the x and z segments, used to temporarily store the distance values for segments at start of the game when setting up land zones

function GetPathingSegmentFromPosition(tPosition)
    --The map is divided into equal sized square segments; this can be used to get the segment X and Z references
    return math.floor( (tPosition[1] - rMapPlayableArea[1]) / iLandZoneSegmentSize) + 1, math.floor((tPosition[3] - rMapPlayableArea[2]) / iLandZoneSegmentSize) + 1
end

function GetPositionFromPathingSegments(iSegmentX, iSegmentZ)
    --If given base level segment positions
    local x = iSegmentX * iLandZoneSegmentSize - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[1]
    local z = iSegmentZ * iLandZoneSegmentSize - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[2] --If changing this, then also update AssignRemainingSegmentsToLandZone which manually does this for performance
    return {x, GetTerrainHeight(x, z), z}
end

function GetReclaimSegmentsFromLocation(tLocation)
    --Returns the reclaim segment X and Z values for a given location on the map
    return math.ceil(tLocation[1] / iReclaimSegmentSizeX), math.ceil(tLocation[3] / iReclaimSegmentSizeZ)
end

function GetReclaimLocationFromSegment(iReclaimSegmentX, iReclaimSegmentZ)
    --e.g. segment (1,1) will be 0 to ReclaimSegmentSizeX and 0 to ReclaimSegmentSizeZ in size
    --This will return the midpoint
    local iX = math.max(rMapPlayableArea[1], math.min(rMapPlayableArea[3], (iReclaimSegmentX - 0.5) * iReclaimSegmentSizeX))
    local iZ = math.max(rMapPlayableArea[2], math.min(rMapPlayableArea[4], (iReclaimSegmentZ - 0.5) * iReclaimSegmentSizeZ))
    return {iX, GetSurfaceHeight(iX, iZ), iZ}
end

function SetupPlayableAreaAndSegmentSizes()
    --Sets up key values needed to divide the map up into segments - shoudl be called as one of the first pieces of code
    local bDebugMessages = true if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DetermineReclaimAndLandSegmentSizes'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)
    if ScenarioInfo.MapData.PlayableRect then
        rMapPlayableArea = ScenarioInfo.MapData.PlayableRect
    else
        rMapPlayableArea = {0, 0, ScenarioInfo.size[1], ScenarioInfo.size[2]}
    end


    --Decide on zone size
    local iHighestSize = math.max(rMapPlayableArea[3] - rMapPlayableArea[1], rMapPlayableArea[4] - rMapPlayableArea[2])
    local iTableSizeCap = 25000 --tried with 50k but on a 10km map it took too long to do the initial setup

    --50000 = SegmentCount^2; SegmentCount = iTotalSize / SegmentSize; (TotalSize/SegmentSize)^2 = 50k; SemgentSize = TotalSize/Sqrt(50k)
    iLandZoneSegmentSize = math.ceil(iHighestSize / math.sqrt(iTableSizeCap))

    --Record the max values
    iMaxLandSegmentX, iMaxLandSegmentZ = GetPathingSegmentFromPosition({rMapPlayableArea[3], 0, rMapPlayableArea[4]})

    if bDebugMessages == true then LOG(sFunctionRef..': iHighestSize='..iHighestSize..'; iTableSizeCap='..iTableSizeCap..'; iLandZoneSegmentSize='..iLandZoneSegmentSize..'; Max Segment X-Z='..iMaxLandSegmentX..'-'..iMaxLandSegmentZ) end


    local iMinReclaimSegmentSize = 8.5 --Engineer build range is 6; means that a square of about 4.2 will fit inside this circle; If have 2 separate engineers assigned to adjacent reclaim segments, and want their build range to cover the two areas, then would want a gap twice this, so 8.4; will therefore go with min size of 8
    local iMapSizeX = rMapPlayableArea[3] - rMapPlayableArea[1]
    local iMapSizeZ = rMapPlayableArea[4] - rMapPlayableArea[2]
    iReclaimSegmentSizeX = math.max(iMinReclaimSegmentSize, iMapSizeX / iLandZoneSegmentSize)
    iReclaimSegmentSizeZ = math.max(iMinReclaimSegmentSize, iMapSizeZ / iLandZoneSegmentSize)
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

function RecordResourcePoint(sResourceType,x,y,z,size)
    --called by hook into simInit, more reliable method of figuring out if have adaptive map
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordResourcePoint'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': sResourceType='..sResourceType..'; x='..x..'; y='..y..'; z='..z..'; size='..repru(size)..'; Mass count pre update='..table.getn(tMassPoints)..'; Hydro points pre update='..table.getn(tHydroPoints)) end

    if sResourceType == 'Mass' then
        table.insert(tMassPoints, {x,y,z})
    elseif sResourceType == 'Hydrocarbon' then
        table.insert(tHydroPoints, {x,y,z})
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of hook; Mass points post update='..table.getn(tMassPoints)..'; Hydro poitns post update='..table.getn(tHydroPoints)) end
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

function GetSegmentGroupOfLocation(sPathing, tLocation)
    return NavUtils.GetLabel(sPathing, tLocation)
end

function RecordMexForPathingGroup()
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordMexForPathingGroup'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': About to record mexes for each pathing group. MassPoints='..repru(tMassPoints)) end
    local tsPathingTypes = {refPathingTypeAmphibious, refPathingTypeNavy, refPathingTypeLand}
    local iCurResourceGroup
    local iValidCount = 0
    tMexByPathingAndGrouping = {}
    if bDebugMessages == true then
        LOG(sFunctionRef..': NavUtils test - will cycle through each mex and get land label')
        for iMex, tMex in tMassPoints do
            LOG(sFunctionRef..': tMex='..repru(tMex)..'; Label='..(NavUtils.GetLabel('Land', tMex) or 'nil'))
            if not(NavUtils.GetLabel('Land', tMex)) then
                LOG(sFunctionRef..': WARNING - dont have a land label for mex '..repru(tMex))
            else
                LOG(sFunctionRef..': Have a land label for mex '..repru(tMex)..' so will stop with warning messages as pathing apepars generated')
                break
            end
        end
    end
    for iPathingType, sPathing in tsPathingTypes do
        tMexByPathingAndGrouping[sPathing] = {}
        iValidCount = 0

        if bDebugMessages == true then
            LOG(sFunctionRef..': About to record all mexes for pathing type sPathing='..sPathing)
        end

        for iCurMex, tMexLocation in tMassPoints do
            iValidCount = iValidCount + 1
            iCurResourceGroup = NavUtils.GetLabel(sPathing, tMexLocation)
            if not(iCurResourceGroup) then
                if bDebugMessages == true then LOG('Dont have a resource group for mex location '..repru(tMexLocation)..'; This is expected if mexes are located outside the playable area or are testing water pathing for land mexes and vice versa') end
            else
                if bDebugMessages == true then
                    LOG(sFunctionRef..': iCurMex='..iCurMex..'; About to get segment group for pathing='..sPathing..'; location='..repru((tMexLocation or {'nil'}))..'; iCurResourceGroup='..(iCurResourceGroup or 'nil'))
                    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tMexLocation)
                    LOG(sFunctionRef..': Pathing segments='..(iSegmentX or 'nil')..'; iSegmentZ='..(iSegmentZ or 'nil')..'; rMapPlayableArea='..repru(rMapPlayableArea)..'; iLandZoneSegmentSize='..(iLandZoneSegmentSize or 'nil'))
                end
                if tMexByPathingAndGrouping[sPathing][iCurResourceGroup] == nil then
                    tMexByPathingAndGrouping[sPathing][iCurResourceGroup] = {}
                    iValidCount = 1
                else iValidCount = table.getn(tMexByPathingAndGrouping[sPathing][iCurResourceGroup]) + 1
                end
                tMexByPathingAndGrouping[sPathing][iCurResourceGroup][iValidCount] = tMexLocation
                if bDebugMessages == true then LOG(sFunctionRef..': iValidCount='..iValidCount..'; sPathing='..sPathing..'; iCurResourceGroup='..iCurResourceGroup..'; just added tMexLocation='..repru(tMexLocation)..' to this group') end
            end
        end
        if sPathing == refPathingTypeLand and iValidCount == 0 then M28Utilities.ErrorHandler('Dont have any mexes recording for land pathing type') end
    end
    if bDebugMessages == true then LOG(sFunctionRef..'; tMexByPathingAndGrouping='..repru(tMexByPathingAndGrouping)) end
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

function RecordAllPlateaus()
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAllPlateaus'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)
    --Records any plateaus that contain mexes, along with info on the plateau such as a rectangle that covers the entire plateau

    --tMexByPathingAndGrouping --[a][b][c]: [a] = pathing type ('Land' etc.); [b] = Segment grouping; [c] = Mex position
    --tAllPlateausWithMexes = {} --v41 - decided to take this out to see if it helps with issue where plateau number changes and all existing platoons become invalid


    local iCurPlateauMex, iMinX, iMaxX, iMinZ, iMaxZ, iSegmentCount
    local iMinSegmentX, iMinSegmentZ, iMaxSegmentX, iMaxSegmentZ, iCurSegmentGroup

    if bDebugMessages == true then LOG(sFunctionRef..': About to get max map segment X and Z based on rMapPlayableArea='..repru(rMapPlayableArea)) end
    local iMapMaxSegmentX, iMapMaxSegmentZ = GetPathingSegmentFromPosition({rMapPlayableArea[3], 0, rMapPlayableArea[4]})
    local iStartSegmentX, iStartSegmentZ
    local bSearchingForBoundary
    local iCurCount
    local tSegmentPosition
    local iReclaimSegmentStartX, iReclaimSegmentStartZ, iReclaimSegmentEndX, iReclaimSegmentEndZ
    local sPathing = refPathingTypeAmphibious




    for iSegmentGroup, tSubtable in tMexByPathingAndGrouping[sPathing] do
        if not(tAllPlateausWithMexes[iSegmentGroup]) then

            --if not(tiBasePathingGroups[iSegmentGroup]) and not(tAllPlateausWithMexes[iSegmentGroup]) then
            --Have a plateau with mexes that havent already recorded
            tAllPlateausWithMexes[iSegmentGroup] = {}
            tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMexes] = {}
            iCurPlateauMex = 0
            for iMex, tMex in tMexByPathingAndGrouping[sPathing][iSegmentGroup] do
                iCurPlateauMex = iCurPlateauMex + 1
                tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMexes][iCurPlateauMex] = tMex
            end
            tAllPlateausWithMexes[iSegmentGroup][subrefPlateauTotalMexCount] = iCurPlateauMex
            if iCurPlateauMex > 0 then
                --Record size information

                --Start from mex, and move up on map to determine top point; then move left to determine left point, and right to determine right point
                --i.e. dont want to go through every segment on map every time since could take ages if lots of plateaus and may only be dealing with small area
                iStartSegmentX, iStartSegmentZ = GetPathingSegmentFromPosition(tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMexes][1])

                --First find the smallest z (so go up)
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount > iStartSegmentZ then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments(iStartSegmentX, iStartSegmentZ - iCurCount))  --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX][iStartSegmentZ - iCurCount]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartX = 1, iMapMaxSegmentX do
                            iCurSegmentGroup = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments(iAltStartX, iStartSegmentZ - iCurCount)) --tPathingSegmentGroupBySegment[sPathing][iAltStartX][iStartSegmentZ - iCurCount]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentX = iAltStartX
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                --Will have the min Z value now
                iMinSegmentZ = iStartSegmentZ - iCurCount + 1


                --Now check for the min X value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount > iStartSegmentX then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments((iStartSegmentX - iCurCount), iStartSegmentZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX - iCurCount][iStartSegmentZ]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same X value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartZ = iMinSegmentZ, iMapMaxSegmentZ do
                            iCurSegmentGroup = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments((iStartSegmentX - iCurCount), iAltStartZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX - iCurCount][iAltStartZ]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentZ = iAltStartZ
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end

                --Will now have the min X value
                iMinSegmentX = iStartSegmentX - iCurCount + 1

                --Now get max Z value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount + iStartSegmentZ > iMapMaxSegmentZ then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments(iStartSegmentX, (iStartSegmentZ + iCurCount))) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX][iStartSegmentZ + iCurCount]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartX = iMinSegmentX, iMapMaxSegmentX do
                            iCurSegmentGroup = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments(iAltStartX, (iStartSegmentZ + iCurCount))) --tPathingSegmentGroupBySegment[sPathing][iAltStartX][iStartSegmentZ + iCurCount]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentX = iAltStartX
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                iMaxSegmentZ = iStartSegmentZ + iCurCount - 1

                --Now get the max X value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount + iStartSegmentX > iMapMaxSegmentX then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments((iStartSegmentX + iCurCount), iStartSegmentZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX + iCurCount][iStartSegmentZ]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartZ = iMinSegmentZ, iMaxSegmentZ do
                            iCurSegmentGroup = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments((iStartSegmentX + iCurCount), iAltStartZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX + iCurCount][iAltStartZ]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentZ = iAltStartZ
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                iMaxSegmentX = iStartSegmentX + iCurCount - 1

                tSegmentPosition = GetPositionFromPathingSegments(iMinSegmentX, iMinSegmentZ)
                tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMinXZ] = {tSegmentPosition[1], tSegmentPosition[3]}
                iReclaimSegmentStartX, iReclaimSegmentStartZ = GetReclaimSegmentsFromLocation(tSegmentPosition)

                tSegmentPosition = GetPositionFromPathingSegments(iMaxSegmentX, iMaxSegmentZ)
                tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMaxXZ] = {tSegmentPosition[1], tSegmentPosition[3]}
                iReclaimSegmentEndX, iReclaimSegmentEndZ = GetReclaimSegmentsFromLocation(tSegmentPosition)


                --Record all reclaim segments that are part of the plateau
                tAllPlateausWithMexes[iSegmentGroup][subrefPlateauReclaimSegments] = {}
                for iCurReclaimSegmentX = iReclaimSegmentStartX, iReclaimSegmentEndX do
                    tAllPlateausWithMexes[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX] = {}
                    for iCurReclaimSegmentZ = iReclaimSegmentStartZ, iReclaimSegmentEndZ do
                        if iSegmentGroup == GetSegmentGroupOfLocation(sPathing, GetReclaimLocationFromSegment(iCurReclaimSegmentX, iCurReclaimSegmentZ)) then
                            tAllPlateausWithMexes[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX][iCurReclaimSegmentZ] = true
                        end
                    end
                end
                --Clear any empty values
                for iCurReclaimSegmentX = iReclaimSegmentStartX, iReclaimSegmentEndX do
                    if tAllPlateausWithMexes[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX] and M28Utilities.IsTableEmpty(tAllPlateausWithMexes[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX]) then tAllPlateausWithMexes[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX] = nil end
                end

                --Record midpoint
                local iXRadius = (tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMaxXZ][1] - tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMinXZ][1])*0.5
                local iZRadius = (tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMaxXZ][2] - tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMinXZ][2])*0.5
                tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMidpoint] = {tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMinXZ][1] + iXRadius, 0, tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMinXZ][2] + iZRadius}
                tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMidpoint][2] = GetTerrainHeight(tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMidpoint][1], tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMidpoint][3])
                --CIrcle radius will be the square/rectangle diagonal, so (square radius^2*2)^0.5 for a square, or (x^2+z^2)^0.5

                tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMaxRadius] = (iXRadius^2+iZRadius^2)^0.5
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, listing tAllPlateausWithMexes='..repru(tAllPlateausWithMexes)) end
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

function AddNewLandZoneReferenceToPlateau(iPlateauGroup)
    --Adds a new land zone reference number to iPlateauGroup, assumes that information about the zone will be added later
    --To get the land zone created by this immediately after it is created, use iLandZone = tAllPlateausWithMexes[iPlateauGroup][subrefLandZoneCount]
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddNewLandZoneReferenceToPlateau'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)


    if not(tAllPlateausWithMexes[iPlateauGroup]) then
        --Presumably we have a plateau with no mexes
        tAllPlateausWithMexes[iPlateauGroup] = {}
        tAllPlateausWithMexes[iPlateauGroup][subrefPlateauTotalMexCount] = 0
    end
    if not(tAllPlateausWithMexes[iPlateauGroup][subrefLandZoneCount]) then
        tAllPlateausWithMexes[iPlateauGroup][subrefLandZoneCount] = 0
        tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones] = {}
    end
    tAllPlateausWithMexes[iPlateauGroup][subrefLandZoneCount] = (tAllPlateausWithMexes[iPlateauGroup][subrefLandZoneCount] or 0) + 1
    local iLandZone = tAllPlateausWithMexes[iPlateauGroup][subrefLandZoneCount]
    tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones][iLandZone] = {}
    tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones][iLandZone][subrefLZMexCount] = 0
    tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones][iLandZone][subrefLZMexLocations] = {}
    tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones][iLandZone][subrefLZReclaimMass] = 0

    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end



function CreateNewLandZoneAtSegment(iBaseSegmentX, iBaseSegmentZ)
    --Creates a new land zone reference at the land segment given by iBaseSegmentX-iBaseSegmentZ (includes adding new land zone reference to the plateau group that these segments are part of)
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CreateNewLandZoneAtSegment'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)

    --First check we dont have a zone assigned already (redundancy)
    if not(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]) then
        --PlateauGroup ref will be the amphibious pathing ref from navutils.getlabel (since that's what is used to define mexes by amphibious pathing group, and plateau recognition then uses the same reference)
        local tMidpoint = GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
        local iPlateauGroup = NavUtils.GetLabel(refPathingTypeAmphibious, tMidpoint)
        AddNewLandZoneReferenceToPlateau(iPlateauGroup)
        local iLandZone = tAllPlateausWithMexes[iPlateauGroup][subrefLandZoneCount]
        if not(tLandZoneBySegment[iBaseSegmentX]) then tLandZoneBySegment[iBaseSegmentX] = {} end
        tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ] = iLandZone
    end
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

function AddMexToLandZone(iPlateauGroup, iOptionalLandZone, iPlateauMexRef, tTempLandZoneByMexRef)
    --Determine the land zone if it isnt specified

    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddMexToLandZone'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)


    local iLandZone
    if iOptionalLandZone then iLandZone = iOptionalLandZone
    else
        AddNewLandZoneReferenceToPlateau(iPlateauGroup)
        iLandZone = tAllPlateausWithMexes[iPlateauGroup][subrefLandZoneCount]
    end

    --Add the mex to this land zone
    tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones][iLandZone][subrefLZMexCount] = tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones][iLandZone][subrefLZMexCount] + 1
    table.insert(tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones][iLandZone][subrefLZMexLocations], tAllPlateausWithMexes[iPlateauGroup][subrefPlateauMexes][iPlateauMexRef])
    tTempLandZoneByMexRef[iPlateauMexRef] = iLandZone
    local iCurSegmentX, iCurSegmentZ = GetPathingSegmentFromPosition(tAllPlateausWithMexes[iPlateauGroup][subrefPlateauMexes][iPlateauMexRef])
    if not(tLandZoneBySegment[iCurSegmentX]) then tLandZoneBySegment[iCurSegmentX] = {} end
    tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] = iLandZone

    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

function AssignTempSegmentsWithDistance()
    --Assumes tTempZoneTravelDistanceBySegment has been setup and is a table that has [xsegment][zsegment] values and returns a tablle with [zone] as the key, with the distance to a previously recorded segment in that zone
    --Goes through all the distance values in tTempZoneTravelDistanceBySegment and picks the lowest distance, and then assigns the X+Z segment to that land zone

    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignTempSegmentsWithDistance'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)


    local iLowestDistance
    local iLowestZone
    for iCurSegmentX, tSubtable in tTempZoneTravelDistanceBySegment do
        if not(tLandZoneBySegment[iCurSegmentX]) then tLandZoneBySegment[iCurSegmentX] = {} end
        for iCurSegmentZ, tDistanceByZone in tSubtable do
            --Have we not recorded a zone for this segment?
            if not(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]) then
                iLowestDistance = 10000
                iLowestZone = nil
                for iZone, iDistance in tDistanceByZone do
                    if iDistance < iLowestDistance then
                        iLowestDistance = iDistance
                        iLowestZone = iZone
                    end
                end
                tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] = iLowestZone
            end
            tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ] = nil --Clear the value so when we cycle through in the future we dont have to worry about
        end
    end

    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

function AssignSegmentsNearMexesToLandZones()
    --Assigns every land pathable segment to a land zone

    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignSegmentsNearMexesToLandZones'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)


    local iMaxSegmentSearchDistance = math.max(4, math.ceil(50 / iLandZoneSegmentSize)) --NOTE: If changing this consider if also want to change the value for AssignRemainingSegmentsToLandZones
    local iDistanceCap = math.max(50, iMaxSegmentSearchDistance * iLandZoneSegmentSize)
    local iBaseSegmentX, iBaseSegmentZ
    local iPathingGroupWanted
    local tCurPosition
    local iCurZone
    local iCurTravelDist
    tTempZoneTravelDistanceBySegment = {} --[x][z] are the segment x and z values, returns a table with a key which is the zone ID, which returns the travel distance for that zone
    local iCurSegmentX, iCurSegmentZ
    for iPlateauGroup, tPlateauSubtable in tAllPlateausWithMexes do
        for iMex, tMex in tPlateauSubtable[subrefPlateauMexes] do
            iBaseSegmentX, iBaseSegmentZ = GetPathingSegmentFromPosition(tMex)
            iPathingGroupWanted = NavUtils.GetLabel(refPathingTypeLand, tMex)
            iCurZone = tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]
            for iSegmentXAdjust = 1, iMaxSegmentSearchDistance, 1 do
                iCurSegmentX = iBaseSegmentX + iSegmentXAdjust
                if not(tLandZoneBySegment[iCurSegmentX]) then
                    tLandZoneBySegment[iCurSegmentX] = {}
                    tTempZoneTravelDistanceBySegment[iCurSegmentX] = {}
                end
                for iSegmentZAdjust = 1, iMaxSegmentSearchDistance, 1 do
                    iCurSegmentZ = iBaseSegmentZ + iSegmentZAdjust
                    tCurPosition = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                    if NavUtils.GetLabel(refPathingTypeLand, tCurPosition) == iPathingGroupWanted then
                        if not(tTempZoneTravelDistanceBySegment[iCurSegmentX]) then tTempZoneTravelDistanceBySegment[iCurSegmentX] = {} end
                        if not(tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ]) then
                            tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ] = {}
                        end
                        iCurTravelDist = M28Utilities.GetTravelDistanceBetweenPositions(tMex, tCurPosition)
                        if (iCurTravelDist or 100000) < iDistanceCap then
                            tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ][iCurZone] = math.min(iCurTravelDist, (tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ][iCurZone] or 100000))
                        end
                    end
                end
            end

        end
    end
    --Now go through each segment in tTempZoneTravelDistanceBySegment and pick the lowest value
    AssignTempSegmentsWithDistance()

    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

function RecordTemporaryTravelDistanceForBaseSegment(iBaseSegmentX, iBaseSegmentZ, iLandPathingGroupWanted, tBasePosition, iMaxSegmentSearchDistance, iDistanceCap, bUseRoughPathingDistance)
    --Cycle through adjacent segments to see if they have a zone, and if so check how far away the segment is from the base segment
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordTemporaryTravelDistanceForBaseSegment'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)
    if iBaseSegmentX == 1 then bDebugMessages = true end

    local tCurPosition
    local iCurZone, iCurTravelDist
    local bAbort = false --if we find a really close location then will stop looking for better ones

    if bDebugMessages == true then LOG(sFunctionRef..': About to look for segments near base segment '..iBaseSegmentX..'-'..iBaseSegmentZ..'; iMaxSegmentSearchDistance='..iMaxSegmentSearchDistance..'; iDistanceCap='..iDistanceCap..'; iLandPathingGroupWanted='..(iLandPathingGroupWanted or 'nil')) end

    local iAbortThreshold --= iLandZoneSegmentSize + 1

    function CheckAndRecordTemporaryDistanceForCurSegment(iCurSegmentX, iCurSegmentZ)
        --Does the segment have a land zone assigned, and we haven't just assigned it in this loop?
        if bDebugMessages == true then
            LOG(sFunctionRef..': Considering curSegmentX-z='..iCurSegmentX..'-'..iCurSegmentZ..'; Will note if we have a landzone for this')
            if tLandZoneBySegment[iCurSegmentX] then LOG('tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]='..repru(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]))
            else
                LOG('Dont have any land zone for anything with semgnet X='..iCurSegmentX)
            end
        end
        if tLandZoneBySegment[iCurSegmentX] and tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] then --and (not(tTempZoneTravelDistanceBySegment[iCurSegmentX]) or not(tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ])) then
            tCurPosition = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
            if bDebugMessages == true then LOG(sFunctionRef..': Have a land zone for CurSegmentX-Z'..iCurSegmentX..'-'..iCurSegmentZ..'; Pathing label of this segment='..NavUtils.GetLabel(refPathingTypeLand, tCurPosition)..'; iLandPathingGroupWanted='..iLandPathingGroupWanted) end
            if NavUtils.GetLabel(refPathingTypeLand, tCurPosition) == iLandPathingGroupWanted then

                if bUseRoughPathingDistance then
                    iCurTravelDist = M28Utilities.GetApproxTravelDistanceBetweenPositions(tBasePosition, tCurPosition)
                else
                    iCurTravelDist = M28Utilities.GetTravelDistanceBetweenPositions(tBasePosition, tCurPosition)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iCurTravelDist='..iCurTravelDist) end
                if (iCurTravelDist or 100000) < iDistanceCap then

                    --Update the distance between the bsae segment and a segment in iCurZone to the lower of the current distance and any previously recorded distance
                    iCurZone = tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]
                    if bDebugMessages == true then LOG(sFunctionRef..': We have a segment nearby with a land zone, iCurZone='..iCurZone..'; will record iCurTravelDist of '..iCurTravelDist..'; against the base segment') end
                    tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ][iCurZone] = math.min(iCurTravelDist, (tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ][iCurZone] or 100000))
                    if iCurTravelDist <= iAbortThreshold then
                        if bDebugMessages == true then LOG(sFunctionRef..': Found a really close segment so will stop looking for more') end
                        bAbort = true
                    end
                end
            end
        end
    end

    local iMaxAdjustedX, iMaxAdjustedZ, iMinAdjustedX, iMinAdjustedZ, iZInterval

    for iAdjustmentSize = 1, iMaxSegmentSearchDistance do
        iAbortThreshold = iLandZoneSegmentSize * (iAdjustmentSize + 0.5)
        iMaxAdjustedX = math.min(iAdjustmentSize + iBaseSegmentX, iMaxLandSegmentX)
        iMaxAdjustedZ = math.min(iAdjustmentSize + iBaseSegmentZ, iMaxLandSegmentZ)
        iMinAdjustedX = math.max(1, iBaseSegmentX-iAdjustmentSize)
        iMinAdjustedZ = math.max(1, iBaseSegmentZ-iAdjustmentSize)
        iZInterval = math.max(1, iMaxAdjustedZ - iMinAdjustedZ)



        for iCurSegmentX = iMinAdjustedX, iMaxAdjustedX, 1 do
            if iCurSegmentX == iMinAdjustedX or iCurSegmentX == iMaxAdjustedX then
                for iCurSegmentZ = iMinAdjustedZ, iMaxAdjustedZ, 1 do
                    CheckAndRecordTemporaryDistanceForCurSegment(iCurSegmentX, iCurSegmentZ)
                    if bAbort then break end
                end
            else
                for iCurSegmentZ = iMinAdjustedZ, iMaxAdjustedZ, iZInterval do
                    CheckAndRecordTemporaryDistanceForCurSegment(iCurSegmentX, iCurSegmentZ)
                    if bAbort then break end
                end
            end
            if bAbort then break end
        end
    end

    --Conider core segments first as most of the time we should ahve a really close segment
    --[[
    if bDebugMessages == true then LOG(sFunctionRef..': About to check the immediately adjacent segments to base segment '..iBaseSegmentX..'-'..iBaseSegmentZ..'; iAbortThreshold='..iAbortThreshold) end
    local tNearestSegment = {}
    for iCurSegmentX = math.max(1, iBaseSegmentX - 1), math.min(iBaseSegmentX + 1, iMaxLandSegmentX) , 1 do
        if not(tNearestSegment[iCurSegmentX]) then tNearestSegment[iCurSegmentX] = {} end
        for iCurSegmentZ = math.max(1, iBaseSegmentZ - 1), math.min(iBaseSegmentZ + 1, iMaxLandSegmentZ), 1 do
            if iCurSegmentX == iBaseSegmentX and iCurSegmentZ == iBaseSegmentZ then
                --Do nothing
            else
                CheckAndRecordTemporaryDistanceForCurSegment(iCurSegmentX, iCurSegmentZ)
                if bAbort then break end
            end
            tNearestSegment[iCurSegmentX][iCurSegmentZ] = true
        end
        if bAbort then break end
    end

    iAbortThreshold = iAbortThreshold + iLandZoneSegmentSize
    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking adjacent segments, increased iAbortThreshold='..iAbortThreshold..'; bAbort='..tostring(bAbort)) end

    if iMaxSegmentSearchDistance > 1 and not(bAbort) then
        for iCurSegmentX = math.max(1, iBaseSegmentX - iMaxSegmentSearchDistance), math.min(iBaseSegmentX + iMaxSegmentSearchDistance, iMaxLandSegmentX) , 1 do
            for iCurSegmentZ = math.max(1, iBaseSegmentZ - iMaxSegmentSearchDistance), math.min(iBaseSegmentZ + iMaxSegmentSearchDistance, iMaxLandSegmentZ), 1 do
                if tNearestSegment[iCurSegmentX] and tNearestSegment[iCurSegmentX][iCurSegmentZ] then
                    --do nothing
                else
                    CheckAndRecordTemporaryDistanceForCurSegment(iCurSegmentX, iCurSegmentZ)
                    if bAbort then break end
                end
            end
            if bAbort then break end
        end
    end--]]
    if bDebugMessages == true then LOG(sFunctionRef..': Finsihed recording if we have any nearby zones that can path here, tTempZoneTravelDistanceBySegment for base segment '..iBaseSegmentX..'-'..iBaseSegmentZ..'='..repru(tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ])..'; bAbort='..tostring(bAbort)) end

    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

function AssignNearbySegmentsToSameLandZone(iBaseSegmentX, iBaseSegmentZ, iLandZone, iSegmentSearchRange, iDistanceCap)
    local iCurTravelDist
    for iCurSegmentX = math.max(1, iBaseSegmentX - iSegmentSearchRange), math.min(iBaseSegmentX + iSegmentSearchRange, iMaxLandSegmentX), 1 do
        for iCurSegmentZ = math.max(1, iBaseSegmentZ - iSegmentSearchRange), math.min(iBaseSegmentZ + iSegmentSearchRange, iMaxLandSegmentZ), 1 do
            if not(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]) then
                iCurTravelDist = M28Utilities.GetTravelDistanceBetweenPositions(GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ), GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ))
                if (iCurTravelDist or 100000) <= iDistanceCap then
                    if not(tLandZoneBySegment[iCurSegmentX]) then tLandZoneBySegment[iCurSegmentX] = {} end
                    tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] = iLandZone
                end
            end
        end
    end
end


function AssignRemainingSegmentsToLandZones()
    local bDebugMessages = true if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignRemainingSegmentsToLandZones'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)

    --rMapPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2}
    local iLandPathingGroupWanted

    local iMaxSegmentSearchDistance = math.max(3, math.ceil(40 / iLandZoneSegmentSize)) --NOTE: If changing this consider if also want to change the value for AssignSegmentsNearMexesToLandZones; for first draft have this as slightly lower
    local iDistanceCap = math.max(40, iMaxSegmentSearchDistance * iLandZoneSegmentSize)

    local tCurPosition
    --tTempZoneTravelDistanceBySegment = {} --figure no harm in retaining previous table temporarily
    local iCurTravelDist
    local tBasePosition, iCurZone
    local tSegmentsWithoutNearbyZone = {}
    local tNewlyCreatedBaseZones = {}
    local tSamePathingGroupNearbySegments = {} --returns a table of X-Z values for all nearby segments


    --Create a new zone for any locations with no nearby pathable zones

    local iNewZoneCount = 0
    local iBasePositionX = - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[1]
    local iBasePositionZ
    local iNearbyAssignmentSegmentRange = math.min(iMaxSegmentSearchDistance, math.ceil(iMaxSegmentSearchDistance * 0.5) + 1)

    function CheckForNearbyZonesAndCreateNewZoneIfNeeded(iBaseSegmentX, iBaseSegmentZ, iBasePositionX, iBasePositionZ, bUseRoughPathingDistance)
        if not(tLandZoneBySegment[iBaseSegmentX] and tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]) then
            tBasePosition = {iBasePositionX, 0, iBasePositionZ} --GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
            iLandPathingGroupWanted = NavUtils.GetLabel(refPathingTypeLand, tBasePosition)
            if (iLandPathingGroupWanted or 0) > 0 then
                --Dont create a new zone if we have a nearby zone
                if not(tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ]) then
                    if not(tTempZoneTravelDistanceBySegment[iBaseSegmentX]) then tTempZoneTravelDistanceBySegment[iBaseSegmentX] = {} end
                    tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ] = {}
                end

                --Cycle through adjacent segments to see if they have a zone, and if so check how far away the segment is from the base segment
                RecordTemporaryTravelDistanceForBaseSegment(iBaseSegmentX, iBaseSegmentZ, iLandPathingGroupWanted, tBasePosition, iMaxSegmentSearchDistance, iDistanceCap, bUseRoughPathingDistance)

                --Create a new zone if no segments nearby that already have a land zone that we can path to
                if M28Utilities.IsTableEmpty(tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ]) then
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Have no temp travel distance recorded so have created a new land zone for segmentX-Z='..iBaseSegmentX..'-'..iBaseSegmentZ..'; Position from segments='..repru(GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ))..'; tBasePosition (should be the same)='..repru(tBasePosition)..'; will draw midpoint in red.  iNewZoneCount before increasing by 1='..iNewZoneCount..'; Plateau group of the segment midpoint='..(NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)) or 'nil'))
                        M28Utilities.DrawLocation(GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ))
                    end
                    CreateNewLandZoneAtSegment(iBaseSegmentX, iBaseSegmentZ)
                    iNewZoneCount = iNewZoneCount + 1

                    --Assign very nearby segments to this
                    AssignNearbySegmentsToSameLandZone(iBaseSegmentX, iBaseSegmentZ, iNewZoneCount, iNearbyAssignmentSegmentRange, iDistanceCap)

                    --if not(tNewlyCreatedBaseZones[iBaseSegmentX]) then tNewlyCreatedBaseZones[iBaseSegmentX] = {} end
                    --tNewlyCreatedBaseZones[iBaseSegmentX][iBaseSegmentZ] = true
                end
            end
        end
    end

    for iBaseSegmentX = iMaxSegmentSearchDistance, iMaxLandSegmentX, iMaxSegmentSearchDistance do
        iBasePositionX = iBasePositionX + iLandZoneSegmentSize * iMaxSegmentSearchDistance --Manually done instead of GetPositionFromPathingSegments for performance
        iBasePositionZ = - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[2]

        if not(tLandZoneBySegment[iBaseSegmentX]) then tLandZoneBySegment[iBaseSegmentX] = {} end
        if not(tTempZoneTravelDistanceBySegment[iBaseSegmentX]) then
            tTempZoneTravelDistanceBySegment[iBaseSegmentX] = {}
        end
        for iBaseSegmentZ = iMaxSegmentSearchDistance, iMaxLandSegmentZ, iMaxSegmentSearchDistance do
            iBasePositionZ = iBasePositionZ + iLandZoneSegmentSize * iMaxSegmentSearchDistance
            --Check we dont already have a zone assigned
            CheckForNearbyZonesAndCreateNewZoneIfNeeded(iBaseSegmentX, iBaseSegmentZ, iBasePositionX, iBasePositionZ)
        end
        --WaitTicks(1)
        if bDebugMessages == true then LOG(sFunctionRef..': Finished all iBaseSegmentX='..iBaseSegmentX..'; moving to next X segments, systemtime='..GetSystemTimeSecondsOnlyForProfileUse()) end
    end
    --Now go through each segment considered and pick the lowest value distance as the assigned land zone
    AssignTempSegmentsWithDistance()
    if bDebugMessages == true then LOG(sFunctionRef..': Finished assigning land zones for locations with no nearby zones, systemtime='..GetSystemTimeSecondsOnlyForProfileUse()) end

    iBasePositionX = - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[1]
    for iBaseSegmentX = 1, iMaxLandSegmentX do
        iBasePositionX = iBasePositionX + iLandZoneSegmentSize --Manually done instead of GetPositionFromPathingSegments for performance
        iBasePositionZ = - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[2]
        for iBaseSegmentZ = 1, iMaxLandSegmentZ do
            iBasePositionZ = iBasePositionZ + iLandZoneSegmentSize
            CheckForNearbyZonesAndCreateNewZoneIfNeeded(iBaseSegmentX, iBaseSegmentZ, iBasePositionX, iBasePositionZ, true)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finsihed creating land zones for any remaining locations with no nearby land zone, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    AssignTempSegmentsWithDistance()
    if bDebugMessages == true then LOG(sFunctionRef..': Finsihed assigning zones for any temporary distances for the zones created in the previous step, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    --Now that we have recorded land zones for locations with no nearby land zone, repeat the process of going through segments without a zone, but only for segments around those that we have created
    --[[if M28Utilities.IsTableEmpty(tNewlyCreatedBaseZones) == false then
        for iBaseSegmentX, tSubtable in tNewlyCreatedBaseZones do
            for iBaseSegmentZ, bRecorded in tNewlyCreatedBaseZones do
                tBasePosition = GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
                iLandPathingGroupWanted = NavUtils.GetLabel(refPathingTypeLand, tBasePosition)
                if (iLandPathingGroupWanted or 0) > 0 then
                    for iCurSegmentX = math.max(1, iBaseSegmentX -  iMaxSegmentSearchDistance), math.min(iMaxLandSegmentX, iBaseSegmentX + iMaxSegmentSearchDistance) do
                        for iCurSegmentZ = math.max(1, iBaseSegmentZ -  iMaxSegmentSearchDistance), math.min(iMaxLandSegmentZ, iBaseSegmentZ + iMaxSegmentSearchDistance) do
                            if not(tLandZoneBySegment[iCurSegmentX]) or not(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]) then
                                tCurPosition = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                                if NavUtils.GetLabel(refPathingTypeLand, tCurPosition) == iLandPathingGroupWanted then
                                    RecordTemporaryTravelDistanceForBaseSegment(iCurSegmentX, iCurSegmentZ, iLandPathingGroupWanted, tBasePosition, iMaxSegmentSearchDistance, iDistanceCap)
                                end
                            end
                        end
                    end
                end
            end
        end
    end--]]
    --Now go through each segment considered above and pick the lowest value distance as the assigned land zone
    --AssignTempSegmentsWithDistance()


    --Redundancy - cycle through any zones that dont have a segment and create new zones for them - hopefully this shouldnt be possible provided we have setup the segment search ranges correctly above
    for iBaseSegmentX = 1, iMaxLandSegmentX do
        for iBaseSegmentZ = 1, iMaxLandSegmentZ do
            if not(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]) then
                tBasePosition = GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
                iLandPathingGroupWanted = NavUtils.GetLabel(refPathingTypeLand, tBasePosition)
                if (iLandPathingGroupWanted or 0) > 1 then
                    M28Utilities.ErrorHandler('Have an unassigned land zone='..iBaseSegmentX..'-'..iBaseSegmentZ)
                    CreateNewLandZoneAtSegment(iBaseSegmentX, iBaseSegmentZ)
                    RecordTemporaryTravelDistanceForBaseSegment(iBaseSegmentX, iBaseSegmentZ, iLandPathingGroupWanted, tBasePosition, iMaxSegmentSearchDistance, iDistanceCap)
                    AssignTempSegmentsWithDistance()
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished redundancy of checking every segment has a land zone if it is land pathable, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

function AssignMexesALandZone()
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignMexesALandZone'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)

    --Key config values
    local iNearbyMexRange = 40 --Initially mexes will be grouped together based on this


    if bDebugMessages == true then LOG('About to setup land zones') end

    local tiLandZoneByMexRef

    function AddNearbyMexesToLandZone(iPlateauGroup, iCurLandZone, tMex)
        local iLandGroupWanted = NavUtils.GetLabel(refPathingTypeLand, tMex)
        for iAltMex, tAltMex in tAllPlateausWithMexes[iPlateauGroup][subrefPlateauMexes] do
            if not(tiLandZoneByMexRef[iAltMex]) then
                if NavUtils.GetLabel(refPathingTypeLand, tAltMex) == iLandGroupWanted and not(IsUnderwater(tAltMex, false, 0.1)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iAltMex='..iAltMex..'; Distance straight line='..M28Utilities.GetDistanceBetweenPositions(tAltMex, tMex)..'; Travel distance='..M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex)) end
                    if M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex) <= iNearbyMexRange then
                        AddMexToLandZone(iPlateauGroup, iCurLandZone, iAltMex, tiLandZoneByMexRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Added mex '..iAltMex..' with position '..repru(tAltMex)..' to land zone, tiLandZoneByMexRef='..(tiLandZoneByMexRef[iAltMex] or 'nil')..'; Distance in straight line='..M28Utilities.GetDistanceBetweenPositions(tAltMex, tMex)..'; Travel distance='..M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex)) end
                        AddNearbyMexesToLandZone(iPlateauGroup, iCurLandZone, tAltMex) --Needs to be recursive or else can end up with 2 mees that are really close to each other not being in the same group depending on the order in which the original mexes are called
                    end
                end
            end
        end
    end
    --First assign zones to mex locations - group mexes that are near each other in the same zone
    local iCurLandZone
    for iPlateauGroup, tPlateauSubtable in tAllPlateausWithMexes do
        tiLandZoneByMexRef = {} --[x] is the mex ref from tPlateauSubtable[subrefPlateauMexes]
        tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones] = {}
        for iMex, tMex in tPlateauSubtable[subrefPlateauMexes] do
            if not(IsUnderwater(tMex, false, 0.1)) then
                if bDebugMessages == true then LOG(sFunctionRef..': Plateau='..iPlateauGroup..': Considering mex with plateau mex ref='..iMex..'; position='..repru(tMex)..'; tiLandZoneByMexRef for this ref='..(tiLandZoneByMexRef[iMex] or 'nil')) end
                if not(tiLandZoneByMexRef[iMex]) then
                    AddMexToLandZone(iPlateauGroup, nil, iMex, tiLandZoneByMexRef)
                    iCurLandZone = tiLandZoneByMexRef[iMex]
                    if bDebugMessages == true then LOG(sFunctionRef..': Added mex '..iMex..' with position '..repru(tMex)..' to land zone, tiLandZoneByMexRef='..(tiLandZoneByMexRef[iMex] or 'nil')) end



                    --Cycle through each other mex in the plateau and if it is within iNearbyMexRange then assign it to the same group if it hasnt had a group assigned already
                    AddNearbyMexesToLandZone(iPlateauGroup, iCurLandZone, tMex)
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording land zone mexes for iPlateauGroup='..iPlateauGroup..'; Size of land zones table='..table.getn(tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones])) end
    end
    bDebugMessages = true
    --Debug - draw the groupings of mexes with rectangles around them:
    if bDebugMessages == true then
        local iColour = 0
        for iPlateauGroup, tPlateauSubtable in tAllPlateausWithMexes do
            LOG(sFunctionRef..': About to draw results of land zones for iPlateauGroup='..iPlateauGroup..'; tiLandZoneByMexRef='..repru(tiLandZoneByMexRef)..'; tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones]='..repru(tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones]))
            iColour = iColour + 1
            if iColour > 7 then iColour = 1 end
            --Draw the mex groupings
            for iZone, tZone in tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones] do
                local iMinX = 100000
                local iMaxX = 0
                local iMinZ = 100000
                local iMaxZ = 0

                for iMex, tMex in tZone[subrefLZMexLocations] do
                    iMinX = math.min(tMex[1], iMinX)
                    iMaxX = math.max(tMex[1], iMaxX)
                    iMinZ = math.min(tMex[3], iMinZ)
                    iMaxZ = math.max(tMex[3], iMaxZ)
                end
                M28Utilities.DrawRectangle(Rect(iMinX, iMinZ, iMaxX, iMaxZ), iColour, 1000, 10)
            end
        end
    end

    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

function DrawLandZones()
    local bDebugMessages = true if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DrawLandZones'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)

    local tColourTable = M28Utilities.GenerateDistinctColorTable(100)


    function GetColourFromLandZoneNumber(iLandZoneRef)
        local iColour = iLandZoneRef
        while iColour >= 100 do
            iColour = iColour - 100
        end
        return tColourTable[iColour]
    end
    
    if bDebugMessages == true then LOG(sFunctionRef..': Will now draw every land zone in every plateau, cycling the colour used') end
    local tLocation, iLandZoneRef
    for iCurSegmentX = 1, iMaxLandSegmentX do
        for iCurSegmentZ = 1, iMaxLandSegmentZ do
            iLandZoneRef = tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]
            if (iLandZoneRef or 0) > 0 then
                tLocation = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                --M28Utilities.DrawLocation(tLocation, GetColourFromLandZoneNumber(iLandZoneRef), nil, iLandZoneSegmentSize - 0.1)
                M28Utilities.DrawLocation(tLocation, GetColourFromLandZoneNumber(iLandZoneRef), nil, iLandZoneSegmentSize - 0.1)
            end
        end
    end

    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

function SetupLandZones()
    --Divdeds the map into land pathable zones based on mex placement
    --Intended to be called at start of game when AI is created (so after siminit and recordresourcepoints has run)

    local bDebugMessages = true if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupLandZones'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)


    AssignMexesALandZone()
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
    WaitTicks(1)
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)

    AssignSegmentsNearMexesToLandZones()
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
    WaitTicks(1)
    bDebugMessages = true
    if bDebugMessages == true then DrawLandZones() end
    bDebugMessages = false
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)

    AssignRemainingSegmentsToLandZones()

    --Clear variables that we no longer need:
    tTempZoneTravelDistanceBySegment =  nil

    --If debug enabled, draw land zones
    if bDebugMessages == true then
        DrawLandZones()
    end

    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

function IsUnderwater(tPosition, bReturnSurfaceHeightInstead, iOptionalAmountToBeUnderwater)
    --Returns true if tPosition underwater, otherwise returns false
    --bReturnSurfaceHeightInstead:: Return the actual height at which underwater, instead of true/false
    if bReturnSurfaceHeightInstead then return iMapWaterHeight
    else
        if M28Utilities.IsTableEmpty(tPosition) == true then
            M28Utilities.ErrorHandler('tPosition is empty')
        else
            if iMapWaterHeight > tPosition[2] + (iOptionalAmountToBeUnderwater or 0) then
                --Check we're not just under an arch but are actually underwater
                if not(GetTerrainHeight(tPosition[1], tPosition[3]) == iMapWaterHeight) then
                    return true
                end
            end
        end
        return false
    end
end

function GetMapWaterHeight()
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetMapWaterHeight'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)
    --rMapPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2} - Set at start of the game, use instead of the scenarioinfo method
    local iWaterCount = 0
    local iWaterLevel = 10000
    local iCurTerrainHeight = 10000
    local iInterval = 1
    for iX = rMapPlayableArea[1] + iInterval, rMapPlayableArea[3], iInterval do
        for iZ = rMapPlayableArea[2] + iInterval, rMapPlayableArea[4], iInterval do
            iCurTerrainHeight =  GetTerrainHeight(iX, iZ)
            if GetSurfaceHeight(iX, iZ) > GetTerrainHeight(iX, iZ) then
                iWaterCount = iWaterCount + 1
                iWaterLevel = math.min(iWaterLevel, GetSurfaceHeight(iX, iZ))
                if bDebugMessages == true then LOG(sFunctionRef..': Found water at position X-Z='..iX..'-'..iZ..'; Surface height='..GetSurfaceHeight(iX, iZ)..'; Terrain height='..GetTerrainHeight(iX, iZ)) end
                if iWaterCount >= 3 then
                    break
                end
            else
                --Backup for maps like theta passage arch - have commented out as running on theta passage with interval of 1 it never triggers a water count in the first place, but could remove comments if do come across this issue
                --if bDebugMessages == true and iWaterCount > 0 and GetTerrainHeight(iX, iZ) < iWaterLevel and iWaterLevel < 10000 then LOG(sFunctionRef..': Have suspected arch previously so will adjust water level to terrain height='..GetTerrainHeight(iX, iZ)..'; for iX-Z='..iX..'-'..iZ..'; prev iWaterLevel='..iWaterLevel) end
                --iWaterLevel = math.min(iWaterLevel, GetTerrainHeight(iX, iZ))
            end
        end
        if iWaterCount >= 3 then break end
    end
    if iWaterCount == 0 then iMapWaterHeight = 0
    else
        iMapWaterHeight = iWaterLevel
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iWaterCount='..iWaterCount..'; iMapWaterHeight='..iMapWaterHeight) end
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end





function TempTest()

    --Open palms - draw line between 2 of the mexes in the bottom left part of the main (land pathable fro mbase) area:
    local tStart = {180.5, 15.001953125, 429.5}
    local tEnd = {199.5, 14.314453125, 459.5}
    M28Utilities.DrawLocation(tStart, 2)
    M28Utilities.DrawLocation(tEnd, 3)
    local tFullPath, iPathSize, iDistance = NavUtils.PathTo('Land', tStart, tEnd, nil)
    for iValue = 1, 10 do
        local sRandomColour = M28Utilities.GrabRandomDistinctColour(1)
        LOG('Will GrabRandomDistinctColour,='..sRandomColour)
        local tNewLocation = {tStart[1] + (iValue) * 3, 0, tStart[3] + (iValue) * 3}
        tNewLocation[2] = GetSurfaceHeight(tNewLocation[1], tNewLocation[3])

        M28Utilities.DrawLocation( tNewLocation, sRandomColour )
        --M28Utilities.DrawPath(tFullPath, sRandomColour, nil)
    end

    M28Utilities.DrawPath(tFullPath, 1, nil)

end

function SetupMap()
    --Sets up non-brain specific info on the map
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupMap'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)

    SetupPlayableAreaAndSegmentSizes()

    --Generate pathing
    if not(NavUtils.IsGenerated()) then
        local NavGen = import("/lua/sim/navgenerator.lua")
        NavGen.Generate()
    end

    GetMapWaterHeight()

    RecordMexForPathingGroup()

    RecordAllPlateaus() --Needed first since will organise land zones by plateau

    TempTest()
    SetupLandZones()

    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end
