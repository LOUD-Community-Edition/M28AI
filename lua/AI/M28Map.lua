---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 16/11/2022 07:22
---

local M28Profiling = import('/mods/M28AI/lua/AI/M28Profiling.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local NavUtils = import("/lua/sim/navutils.lua")

--Pathing types
--NavLayers 'Land' | 'Water' | 'Amphibious' | 'Hover' | 'Air'
refPathingTypeAmphibious = 'Amphibious'
refPathingTypeNavy = 'Water'
refPathingTypeAir = 'Air'
refPathingTypeLand = 'Land'
refPathingTypeNone = 'None'
refPathingTypeAll = {refPathingTypeAmphibious, refPathingTypeNavy, refPathingTypeAir, refPathingTypeLand}

--Map size
rMapPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2} - Set at start of the game, use instead of the scenarioinfo method

iMapWaterHeight = 0 --Surface height of water on the map

--Resource information
tMassPoints = {} --[x] is an integer count, returns the location of a mass point; stores all mexes on the map
tHydroPoints = {} --[x] is an integer count, returns the location of a hydro point; stores all hydro points on the map
tMexByPathingAndGrouping = {} --Stores position of each mex based on the pathing group that it's part of; [a][b][c]: [a] = pathing type ('Land' etc.); [b] = Segment grouping; [c] = Mex position
tHydroByPathingAndGrouping = {} --as above but for hydros


--Plateaus - core
tAllPlateausWithMexes = {} --[x] = AmphibiousPathingGroup, [y]: subrefs, e.g. subrefPlateauMexes;
--aibrain variables for plateaus:
reftPlateausOfInterest = 'M27PlateausOfInterest' --[x] = Amphibious pathing group; will record a table of the pathing groups we're interested in expanding to, returns the location of then earest mex
refiLastPlateausUpdate = 'M27LastTimeUpdatedPlateau' --gametime that we last updated the plateaus
reftOurPlateauInformation = 'M27OurPlateauInformation' --[x] = AmphibiousPathingGroup; [y] = subref, e.g. subrefPlateauLandFactories; Used to store details such as factories on the plateau
refiOurBasePlateauGroup = 'M27PlateausOurBaseGroup' --Segment group of our base (so can easily check somewhere is in a dif plateau)

--subrefs for tables
--tAllPlateausWithMexes subrefs
subrefPlateauMexes = 'M27PlateauMex' --[x] = mex count, returns mex position
subrefPlateauMinXZ = 'M27PlateauMinXZ' --{x,z} min values
subrefPlateauMaxXZ = 'M27PlateauMaxXZ' --{x,z} max values - i.e. can create a rectangle covering entire plateau using min and max xz values
subrefPlateauTotalMexCount = 'M27PlateauMexCount' --Number of mexes on the plateau
subrefPlateauReclaimSegments = 'M27PlateauReclaimSegments' --[x] = reclaim segment x, [z] = reclaim segment z, returns true if part of plateau
subrefPlateauMidpoint = 'M27PlateauMidpoint' --Location of the midpoint of the plateau
subrefPlateauMaxRadius = 'M27PlateauMaxRadius' --Radius to use to ensure the circle coveres the square of the plateau
subrefPlateauContainsActiveStart = 'M27PlateauContainsActiveStart' --True if the plateau is pathable amphibiously to a start position that was active at the start of the game

--reftOurPlateauInformation subrefs (NOTE: If adding more info here need to update in several places, including ReRecordUnitsAndPlatoonsInPlateaus)
subrefPlateauLandFactories = 'M27PlateauLandFactories'

subrefPlateauLandCombatPlatoons = 'M27PlateauLandCombatPlatoons'
subrefPlateauIndirectPlatoons = 'M27PlateauIndirectPlatoons'
subrefPlateauMAAPlatoons = 'M27PlateauMAAPlatoons'
subrefPlateauScoutPlatoons = 'M27PlateauScoutPlatoons'

subrefPlateauEngineers = 'M27PlateauEngineers' --[x] is engineer unique ref (per m27engineeroverseer), returns engineer object

--Plateaus - Land zone variables
subrefPlateauLandZones = 'M27PlateauLandZones' --against the main plateau table, stores info on land zones for that plateau
subrefLandZoneCount = 'M27PlateauZoneCount' --against the main plateau table, records how many land zones there are (alternative to table.getn on the land zones)
iLandZoneSegmentSize = 5 --Gets updated by the SetupLandZones - the size of one side of the square that is the lowest resolution land zones go to; each segment that is land pathable gets assigned to a land zone
tLandZonesByPlateau = {} --[x] is the plateau group number, returns a table where [y] is the land zone number, which then returns details on the land zone
subrefLZMexCount = 'MexCount' --against tLandZonesByPlateau[iPlateau][iLZ], returns number of mexes in the LZ
subrefLZMexLocations = 'MexLoc' --against tLandZonesByPlateau[iPlateau][iLZ], returns table of mex locations in the LZ
subrefLZReclaimMass = 'ReclaimMass' --against tLandZonesByPlateau[iPlateau][iLZ], returns total mass reclaim in the LZ

--Land pathing segment data
tLandSegmentsAssignedZone = {} --[x][z] should be the x and z segments baed on iLandZoneSegmentSize, and should return the land zone number, or nil if there is none

function GetPathingSegmentFromPosition(tPosition)
    --The map is divided into equal sized square segments; this can be used to get the segment X and Z references
    return math.floor( (tPosition[1] - rMapPlayableArea[1]) / iLandZoneSegmentSize) + 1, math.floor((tPosition[3] - rMapPlayableArea[2]) / iLandZoneSegmentSize) + 1
end

function GetPositionFromPathingSegments(iSegmentX, iSegmentZ)
    --If given base level segment positions
    local x = iSegmentX * iLandZoneSegmentSize - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[1]
    local z = iSegmentZ * iLandZoneSegmentSize - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[2]
    return {x, GetTerrainHeight(x, z), z}
end

function GetReclaimSegmentsFromLocation(tLocation)
    --Returns the reclaim segment X and Z values for a given location on the map
    return math.ceil(tLocation[1] / iReclaimSegmentSizeX), math.ceil(tLocation[3] / iReclaimSegmentSizeZ)
end

function GetReclaimLocationFromSegment(iReclaimSegmentX, iReclaimSegmentZ)
    --e.g. segment (1,1) will be 0 to ReclaimSegmentSizeX and 0 to ReclaimSegmentSizeZ in size
    --This will return the midpoint
    local iX = math.max(rMapPlayableArea[1], math.min(rMapPlayableArea[3], (iReclaimSegmentX - 0.5) * iReclaimSegmentSizeX))
    local iZ = math.max(rMapPlayableArea[2], math.min(rMapPlayableArea[4], (iReclaimSegmentZ - 0.5) * iReclaimSegmentSizeZ))
    return {iX, GetSurfaceHeight(iX, iZ), iZ}
end

function SetupPlayableAreaAndSegmentSizes()
    --Sets up key values needed to divide the map up into segments - shoudl be called as one of the first pieces of code
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DetermineReclaimAndLandSegmentSizes'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)
    if ScenarioInfo.MapData.PlayableRect then
        rMapPlayableArea = ScenarioInfo.MapData.PlayableRect
    else
        rMapPlayableArea = {0, 0, ScenarioInfo.size[1], ScenarioInfo.size[2]}
    end


    --Decide on zone size
    local iHighestSize = math.max(rMapPlayableArea[3] - rMapPlayableArea[1], rMapPlayableArea[4] - rMapPlayableArea[2])
    local iTableSizeCap = 50000

    --50000 = SegmentCount^2; SegmentCount = iTotalSize / SegmentSize; (TotalSize/SegmentSize)^2 = 50k; SemgentSize = TotalSize/Sqrt(50k)
    iLandZoneSegmentSize = math.ceil(iHighestSize / math.sqrt(iTableSizeCap))

    if bDebugMessages == true then LOG(sFunctionRef..': iHighestSize='..iHighestSize..'; iTableSizeCap='..iTableSizeCap..'; iLandZoneSegmentSize='..iLandZoneSegmentSize) end


    local iMinReclaimSegmentSize = 8.5 --Engineer build range is 6; means that a square of about 4.2 will fit inside this circle; If have 2 separate engineers assigned to adjacent reclaim segments, and want their build range to cover the two areas, then would want a gap twice this, so 8.4; will therefore go with min size of 8
    local iMapSizeX = rMapPlayableArea[3] - rMapPlayableArea[1]
    local iMapSizeZ = rMapPlayableArea[4] - rMapPlayableArea[2]
    iReclaimSegmentSizeX = math.max(iMinReclaimSegmentSize, iMapSizeX / iLandZoneSegmentSize)
    iReclaimSegmentSizeZ = math.max(iMinReclaimSegmentSize, iMapSizeZ / iLandZoneSegmentSize)
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

function RecordResourcePoint(sResourceType,x,y,z,size)
    --called by hook into simInit, more reliable method of figuring out if have adaptive map
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordResourcePoint'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': sResourceType='..sResourceType..'; x='..x..'; y='..y..'; z='..z..'; size='..repru(size)..'; Mass count pre update='..table.getn(tMassPoints)..'; Hydro points pre update='..table.getn(tHydroPoints)) end

    if sResourceType == 'Mass' then
        table.insert(tMassPoints, {x,y,z})
    elseif sResourceType == 'Hydrocarbon' then
        table.insert(tHydroPoints, {x,y,z})
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of hook; Mass points post update='..table.getn(tMassPoints)..'; Hydro poitns post update='..table.getn(tHydroPoints)) end
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

function GetSegmentGroupOfLocation(sPathing, tLocation)
    return NavUtils.GetLabel(sPathing, tLocation)
end

function RecordMexForPathingGroup()
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordMexForPathingGroup'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': About to record mexes for each pathing group. MassPoints='..repru(tMassPoints)) end
    local tsPathingTypes = {refPathingTypeAmphibious, refPathingTypeNavy, refPathingTypeLand}
    local iCurResourceGroup
    local iValidCount = 0
    tMexByPathingAndGrouping = {}
    if bDebugMessages == true then
        LOG(sFunctionRef..': NavUtils test - will cycle through each mex and get land label')
        for iMex, tMex in tMassPoints do
            LOG(sFunctionRef..': tMex='..repru(tMex)..'; Label='..(NavUtils.GetLabel('Land', tMex) or 'nil'))
            if not(NavUtils.GetLabel('Land', tMex)) then
                LOG(sFunctionRef..': WARNING - dont have a land label for mex '..repru(tMex))
            else
                LOG(sFunctionRef..': Have a land label for mex '..repru(tMex)..' so will stop with warning messages as pathing apepars generated')
                break
            end
        end
    end
    for iPathingType, sPathing in tsPathingTypes do
        tMexByPathingAndGrouping[sPathing] = {}
        iValidCount = 0

        if bDebugMessages == true then
            LOG(sFunctionRef..': About to record all mexes for pathing type sPathing='..sPathing)
        end

        for iCurMex, tMexLocation in tMassPoints do
            iValidCount = iValidCount + 1
            iCurResourceGroup = NavUtils.GetLabel(sPathing, tMexLocation)
            if not(iCurResourceGroup) then
                if bDebugMessages == true then LOG('Dont have a resource group for mex location '..repru(tMexLocation)..'; This is expected if mexes are located outside the playable area or are testing water pathing for land mexes and vice versa') end
            else
                if bDebugMessages == true then
                    LOG(sFunctionRef..': iCurMex='..iCurMex..'; About to get segment group for pathing='..sPathing..'; location='..repru((tMexLocation or {'nil'}))..'; iCurResourceGroup='..(iCurResourceGroup or 'nil'))
                    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tMexLocation)
                    LOG(sFunctionRef..': Pathing segments='..(iSegmentX or 'nil')..'; iSegmentZ='..(iSegmentZ or 'nil')..'; rMapPlayableArea='..repru(rMapPlayableArea)..'; iLandZoneSegmentSize='..(iLandZoneSegmentSize or 'nil'))
                end
                if tMexByPathingAndGrouping[sPathing][iCurResourceGroup] == nil then
                    tMexByPathingAndGrouping[sPathing][iCurResourceGroup] = {}
                    iValidCount = 1
                else iValidCount = table.getn(tMexByPathingAndGrouping[sPathing][iCurResourceGroup]) + 1
                end
                tMexByPathingAndGrouping[sPathing][iCurResourceGroup][iValidCount] = tMexLocation
                if bDebugMessages == true then LOG(sFunctionRef..': iValidCount='..iValidCount..'; sPathing='..sPathing..'; iCurResourceGroup='..iCurResourceGroup..'; just added tMexLocation='..repru(tMexLocation)..' to this group') end
            end
        end
        if sPathing == refPathingTypeLand and iValidCount == 0 then M28Utilities.ErrorHandler('Dont have any mexes recording for land pathing type') end
    end
    if bDebugMessages == true then LOG(sFunctionRef..'; tMexByPathingAndGrouping='..repru(tMexByPathingAndGrouping)) end
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

function RecordAllPlateaus()
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAllPlateaus'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)
    --Records any plateaus that contain mexes, along with info on the plateau such as a rectangle that covers the entire plateau

    --tMexByPathingAndGrouping --[a][b][c]: [a] = pathing type ('Land' etc.); [b] = Segment grouping; [c] = Mex position
    --tAllPlateausWithMexes = {} --v41 - decided to take this out to see if it helps with issue where plateau number changes and all existing platoons become invalid


    local iCurPlateauMex, iMinX, iMaxX, iMinZ, iMaxZ, iSegmentCount
    local iMinSegmentX, iMinSegmentZ, iMaxSegmentX, iMaxSegmentZ, iCurSegmentGroup

    if bDebugMessages == true then LOG(sFunctionRef..': About to get max map segment X and Z based on rMapPlayableArea='..repru(rMapPlayableArea)) end
    local iMapMaxSegmentX, iMapMaxSegmentZ = GetPathingSegmentFromPosition({rMapPlayableArea[3], 0, rMapPlayableArea[4]})
    local iStartSegmentX, iStartSegmentZ
    local bSearchingForBoundary
    local iCurCount
    local tSegmentPosition
    local iReclaimSegmentStartX, iReclaimSegmentStartZ, iReclaimSegmentEndX, iReclaimSegmentEndZ
    local sPathing = refPathingTypeAmphibious




    for iSegmentGroup, tSubtable in tMexByPathingAndGrouping[sPathing] do
        if not(tAllPlateausWithMexes[iSegmentGroup]) then

            --if not(tiBasePathingGroups[iSegmentGroup]) and not(tAllPlateausWithMexes[iSegmentGroup]) then
            --Have a plateau with mexes that havent already recorded
            tAllPlateausWithMexes[iSegmentGroup] = {}
            tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMexes] = {}
            iCurPlateauMex = 0
            for iMex, tMex in tMexByPathingAndGrouping[sPathing][iSegmentGroup] do
                iCurPlateauMex = iCurPlateauMex + 1
                tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMexes][iCurPlateauMex] = tMex
            end
            tAllPlateausWithMexes[iSegmentGroup][subrefPlateauTotalMexCount] = iCurPlateauMex
            if iCurPlateauMex > 0 then
                --Record size information

                --Start from mex, and move up on map to determine top point; then move left to determine left point, and right to determine right point
                --i.e. dont want to go through every segment on map every time since could take ages if lots of plateaus and may only be dealing with small area
                iStartSegmentX, iStartSegmentZ = GetPathingSegmentFromPosition(tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMexes][1])

                --First find the smallest z (so go up)
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount > iStartSegmentZ then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments(iStartSegmentX, iStartSegmentZ - iCurCount))  --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX][iStartSegmentZ - iCurCount]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartX = 1, iMapMaxSegmentX do
                            iCurSegmentGroup = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments(iAltStartX, iStartSegmentZ - iCurCount)) --tPathingSegmentGroupBySegment[sPathing][iAltStartX][iStartSegmentZ - iCurCount]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentX = iAltStartX
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                --Will have the min Z value now
                iMinSegmentZ = iStartSegmentZ - iCurCount + 1


                --Now check for the min X value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount > iStartSegmentX then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments((iStartSegmentX - iCurCount), iStartSegmentZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX - iCurCount][iStartSegmentZ]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same X value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartZ = iMinSegmentZ, iMapMaxSegmentZ do
                            iCurSegmentGroup = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments((iStartSegmentX - iCurCount), iAltStartZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX - iCurCount][iAltStartZ]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentZ = iAltStartZ
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end

                --Will now have the min X value
                iMinSegmentX = iStartSegmentX - iCurCount + 1

                --Now get max Z value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount + iStartSegmentZ > iMapMaxSegmentZ then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments(iStartSegmentX, (iStartSegmentZ + iCurCount))) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX][iStartSegmentZ + iCurCount]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartX = iMinSegmentX, iMapMaxSegmentX do
                            iCurSegmentGroup = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments(iAltStartX, (iStartSegmentZ + iCurCount))) --tPathingSegmentGroupBySegment[sPathing][iAltStartX][iStartSegmentZ + iCurCount]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentX = iAltStartX
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                iMaxSegmentZ = iStartSegmentZ + iCurCount - 1

                --Now get the max X value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount + iStartSegmentX > iMapMaxSegmentX then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments((iStartSegmentX + iCurCount), iStartSegmentZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX + iCurCount][iStartSegmentZ]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartZ = iMinSegmentZ, iMaxSegmentZ do
                            iCurSegmentGroup = NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments((iStartSegmentX + iCurCount), iAltStartZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX + iCurCount][iAltStartZ]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentZ = iAltStartZ
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                iMaxSegmentX = iStartSegmentX + iCurCount - 1

                tSegmentPosition = GetPositionFromPathingSegments(iMinSegmentX, iMinSegmentZ)
                tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMinXZ] = {tSegmentPosition[1], tSegmentPosition[3]}
                iReclaimSegmentStartX, iReclaimSegmentStartZ = GetReclaimSegmentsFromLocation(tSegmentPosition)

                tSegmentPosition = GetPositionFromPathingSegments(iMaxSegmentX, iMaxSegmentZ)
                tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMaxXZ] = {tSegmentPosition[1], tSegmentPosition[3]}
                iReclaimSegmentEndX, iReclaimSegmentEndZ = GetReclaimSegmentsFromLocation(tSegmentPosition)


                --Record all reclaim segments that are part of the plateau
                tAllPlateausWithMexes[iSegmentGroup][subrefPlateauReclaimSegments] = {}
                for iCurReclaimSegmentX = iReclaimSegmentStartX, iReclaimSegmentEndX do
                    tAllPlateausWithMexes[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX] = {}
                    for iCurReclaimSegmentZ = iReclaimSegmentStartZ, iReclaimSegmentEndZ do
                        if iSegmentGroup == GetSegmentGroupOfLocation(sPathing, GetReclaimLocationFromSegment(iCurReclaimSegmentX, iCurReclaimSegmentZ)) then
                            tAllPlateausWithMexes[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX][iCurReclaimSegmentZ] = true
                        end
                    end
                end
                --Clear any empty values
                for iCurReclaimSegmentX = iReclaimSegmentStartX, iReclaimSegmentEndX do
                    if tAllPlateausWithMexes[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX] and M28Utilities.IsTableEmpty(tAllPlateausWithMexes[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX]) then tAllPlateausWithMexes[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX] = nil end
                end

                --Record midpoint
                local iXRadius = (tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMaxXZ][1] - tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMinXZ][1])*0.5
                local iZRadius = (tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMaxXZ][2] - tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMinXZ][2])*0.5
                tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMidpoint] = {tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMinXZ][1] + iXRadius, 0, tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMinXZ][2] + iZRadius}
                tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMidpoint][2] = GetTerrainHeight(tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMidpoint][1], tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMidpoint][3])
                --CIrcle radius will be the square/rectangle diagonal, so (square radius^2*2)^0.5 for a square, or (x^2+z^2)^0.5

                tAllPlateausWithMexes[iSegmentGroup][subrefPlateauMaxRadius] = (iXRadius^2+iZRadius^2)^0.5
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, listing tAllPlateausWithMexes='..repru(tAllPlateausWithMexes)) end
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

function AddNewLandZone(iPlateauGroup)
    --Basic variable setup - assumes that information about the zone will be added later
    if not(tAllPlateausWithMexes[iPlateauGroup][subrefLandZoneCount]) then
        tAllPlateausWithMexes[iPlateauGroup][subrefLandZoneCount] = 0
        tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones] = {}
    end
    tAllPlateausWithMexes[iPlateauGroup][subrefLandZoneCount] = (tAllPlateausWithMexes[iPlateauGroup][subrefLandZoneCount] or 0) + 1
    local iLandZone = tAllPlateausWithMexes[iPlateauGroup][subrefLandZoneCount]
    tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones][iLandZone] = {}
    tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones][iLandZone][subrefLZMexCount] = 0
    tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones][iLandZone][subrefLZMexLocations] = {}
    tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones][iLandZone][subrefLZReclaimMass] = 0
end

function AddMexToLandZone(iPlateauGroup, iOptionalLandZone, iPlateauMexRef, tTempLandZoneByMexRef)
    --Determine the land zone if it isnt specified
    local iLandZone
    if iOptionalLandZone then iLandZone = iOptionalLandZone
    else
        AddNewLandZone(iPlateauGroup)
        iLandZone = tAllPlateausWithMexes[iPlateauGroup][subrefLandZoneCount]
    end

    --Add the mex to this land zone
    tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones][iLandZone][subrefLZMexCount] = tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones][iLandZone][subrefLZMexCount] + 1
    table.insert(tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones][iLandZone][subrefLZMexLocations], tAllPlateausWithMexes[iPlateauGroup][subrefPlateauMexes][iPlateauMexRef])
    tTempLandZoneByMexRef[iPlateauMexRef] = iLandZone
    local iCurSegmentX, iCurSegmentZ = GetPathingSegmentFromPosition(tAllPlateausWithMexes[iPlateauGroup][subrefPlateauMexes][iPlateauMexRef])
    if not(tLandSegmentsAssignedZone[iCurSegmentX]) then tLandSegmentsAssignedZone[iCurSegmentX] = {} end
    tLandSegmentsAssignedZone[iCurSegmentX][iCurSegmentZ] = iLandZone
end

function AssignSegmentsNearMexesToLandZones()
    --Assigns every land pathable segment to a land zone
    local iMaxSegmentSearchDistance = math.max(4, math.ceil(50 / iLandZoneSegmentSize))
    local iDistanceCap = math.max(50, iMaxSegmentSearchDistance * iLandZoneSegmentSize)
    local iBaseSegmentX, iBaseSegmentZ
    local iPathingGroupWanted
    local tCurPosition
    local iCurZone
    local iCurTravelDist
    local tTempZoneTravelDistanceBySegment = {} --[x][z] are the segment x and z values, returns a table with a key which is the zone ID, which returns the travel distance for that zone
    local tTempSegmentsWithDistance = {}
    local iCurSegmentX, iCurSegmentZ
    for iPlateauGroup, tPlateauSubtable in tAllPlateausWithMexes do
        for iMex, tMex in tPlateauSubtable[subrefPlateauMexes] do
            iBaseSegmentX, iBaseSegmentZ = GetPathingSegmentFromPosition(tMex)
            iPathingGroupWanted = NavUtils.GetLabel(refPathingTypeLand, tMex)
            iCurZone = tLandSegmentsAssignedZone[iBaseSegmentX][iBaseSegmentZ]
            for iSegmentXAdjust = 1, iMaxSegmentSearchDistance, 1 do
                iCurSegmentX = iBaseSegmentX + iSegmentXAdjust
                if not(tLandSegmentsAssignedZone[iCurSegmentX]) then
                    tLandSegmentsAssignedZone[iCurSegmentX] = {}
                    tTempZoneTravelDistanceBySegment[iCurSegmentX] = {}
                end
                for iSegmentZAdjust = 1, iMaxSegmentSearchDistance, 1 do
                    iCurSegmentZ = iBaseSegmentZ + iSegmentZAdjust
                    tCurPosition = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                    if NavUtils.GetLabel(refPathingTypeLand, tCurPosition) == iPathingGroupWanted then
                        if not(tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ]) then
                            tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ] = {}
                        end
                        iCurTravelDist = M28Utilities.GetTravelDistanceBetweenPositions(tMex, tCurPosition)
                        if (iCurTravelDist or 100000) < iDistanceCap then
                            tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ][iCurZone] = math.min(iCurTravelDist, (tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ][iCurZone] or 100000))
                            if not(tTempSegmentsWithDistance[iCurSegmentX]) then tTempSegmentsWithDistance[iCurSegmentX] = {} end
                            tTempSegmentsWithDistance[iCurSegmentX][iCurSegmentZ] = true
                        end
                    end
                end
            end

        end
    end
    --Now go through each segment considered and pick the lowest value
    local iLowestDistance
    local iLowestZone
    for iCurSegmentX, tSubtable in tTempSegmentsWithDistance do
        if not(tLandSegmentsAssignedZone[iCurSegmentX]) then tLandSegmentsAssignedZone[iCurSegmentX] = {} end
        for iCurSegmentZ, bConsidered in tSubtable do
            iLowestDistance = 10000
            for iZone, iDistance in tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ] do
                if iDistance < iLowestDistance then
                    iLowestDistance = iDistance
                    iLowestZone = iZone
                end
            end
            tLandSegmentsAssignedZone[iCurSegmentX][iCurSegmentZ] = iLowestZone
        end
    end
    --iLandZoneSegmentSize
end


function AssignRemainingSegmentsToLandZones()
    M28Utilities.ErrorHandler('To add code')
end

function SetupLandZones()
    --Divdeds the map into land pathable zones based on mex placement
    --Intended to be called at start of game when AI is created (so after siminit and recordresourcepoints has run)

    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupLandZones'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)


    --Key config values
    local iNearbyMexRange = 40 --Initially mexes will be grouped together based on this


    if bDebugMessages == true then LOG('About to setup land zones') end

    local tiLandZoneByMexRef

    function AddNearbyMexesToLandZone(iPlateauGroup, iCurLandZone, tMex)
        local iLandGroupWanted = NavUtils.GetLabel(refPathingTypeLand, tMex)
        for iAltMex, tAltMex in tAllPlateausWithMexes[iPlateauGroup][subrefPlateauMexes] do
            if not(tiLandZoneByMexRef[iAltMex]) then
                if NavUtils.GetLabel(refPathingTypeLand, tAltMex) == iLandGroupWanted and not(IsUnderwater(tAltMex, false, 0.1)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iAltMex='..iAltMex..'; Distance straight line='..M28Utilities.GetDistanceBetweenPositions(tAltMex, tMex)..'; Travel distance='..M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex)) end
                    if M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex) <= iNearbyMexRange then
                        AddMexToLandZone(iPlateauGroup, iCurLandZone, iAltMex, tiLandZoneByMexRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Added mex '..iAltMex..' with position '..repru(tAltMex)..' to land zone, tiLandZoneByMexRef='..(tiLandZoneByMexRef[iAltMex] or 'nil')..'; Distance in straight line='..M28Utilities.GetDistanceBetweenPositions(tAltMex, tMex)..'; Travel distance='..M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex)) end
                        AddNearbyMexesToLandZone(iPlateauGroup, iCurLandZone, tAltMex) --Needs to be recursive or else can end up with 2 mees that are really close to each other not being in the same group depending on the order in which the original mexes are called
                    end
                end
            end
        end
    end
    --First assign zones to mex locations - group mexes that are near each other in the same zone
    local iCurLandZone
    for iPlateauGroup, tPlateauSubtable in tAllPlateausWithMexes do
        tiLandZoneByMexRef = {} --[x] is the mex ref from tPlateauSubtable[subrefPlateauMexes]
        tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones] = {}
        for iMex, tMex in tPlateauSubtable[subrefPlateauMexes] do
            if not(IsUnderwater(tMex, false, 0.1)) then
                if bDebugMessages == true then LOG(sFunctionRef..': Plateau='..iPlateauGroup..': Considering mex with plateau mex ref='..iMex..'; position='..repru(tMex)..'; tiLandZoneByMexRef for this ref='..(tiLandZoneByMexRef[iMex] or 'nil')) end
                if not(tiLandZoneByMexRef[iMex]) then
                    AddMexToLandZone(iPlateauGroup, nil, iMex, tiLandZoneByMexRef)
                    iCurLandZone = tiLandZoneByMexRef[iMex]
                    if bDebugMessages == true then LOG(sFunctionRef..': Added mex '..iMex..' with position '..repru(tMex)..' to land zone, tiLandZoneByMexRef='..(tiLandZoneByMexRef[iMex] or 'nil')) end



                    --Cycle through each other mex in the plateau and if it is within iNearbyMexRange then assign it to the same group if it hasnt had a group assigned already
                    AddNearbyMexesToLandZone(iPlateauGroup, iCurLandZone, tMex)
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording land zone mexes for iPlateauGroup='..iPlateauGroup..'; Size of land zones table='..table.getn(tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones])) end
    end
    bDebugMessages = true
    --Debug - draw the groupings of mexes with rectangles around them:
    if bDebugMessages == true then
        local iColour = 0
        for iPlateauGroup, tPlateauSubtable in tAllPlateausWithMexes do
            LOG(sFunctionRef..': About to draw results of land zones for iPlateauGroup='..iPlateauGroup..'; tiLandZoneByMexRef='..repru(tiLandZoneByMexRef)..'; tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones]='..repru(tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones]))
            iColour = iColour + 1
            if iColour > 7 then iColour = 1 end
            --Draw the mex groupings
            for iZone, tZone in tAllPlateausWithMexes[iPlateauGroup][subrefPlateauLandZones] do
                local iMinX = 100000
                local iMaxX = 0
                local iMinZ = 100000
                local iMaxZ = 0

                for iMex, tMex in tZone[subrefLZMexLocations] do
                    iMinX = math.min(tMex[1], iMinX)
                    iMaxX = math.max(tMex[1], iMaxX)
                    iMinZ = math.min(tMex[3], iMinZ)
                    iMaxZ = math.max(tMex[3], iMaxZ)
                end
                M28Utilities.DrawRectangle(Rect(iMinX, iMinZ, iMaxX, iMaxZ), iColour, 1000, 10)
            end
        end
    end

    AssignSegmentsNearMexesToLandZones()

    AssignRemainingSegmentsToLandZones()

    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

function IsUnderwater(tPosition, bReturnSurfaceHeightInstead, iOptionalAmountToBeUnderwater)
    --Returns true if tPosition underwater, otherwise returns false
    --bReturnSurfaceHeightInstead:: Return the actual height at which underwater, instead of true/false
    if bReturnSurfaceHeightInstead then return iMapWaterHeight
    else
        if M28Utilities.IsTableEmpty(tPosition) == true then
            M28Utilities.ErrorHandler('tPosition is empty')
        else
            if iMapWaterHeight > tPosition[2] + (iOptionalAmountToBeUnderwater or 0) then
                --Check we're not just under an arch but are actually underwater
                if not(GetTerrainHeight(tPosition[1], tPosition[3]) == iMapWaterHeight) then
                    return true
                end
            end
        end
        return false
    end
end

function GetMapWaterHeight()
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetMapWaterHeight'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)
    --rMapPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2} - Set at start of the game, use instead of the scenarioinfo method
    local iWaterCount = 0
    local iWaterLevel = 10000
    local iCurTerrainHeight = 10000
    local iInterval = 1
    for iX = rMapPlayableArea[1] + iInterval, rMapPlayableArea[3], iInterval do
        for iZ = rMapPlayableArea[2] + iInterval, rMapPlayableArea[4], iInterval do
            iCurTerrainHeight =  GetTerrainHeight(iX, iZ)
            if GetSurfaceHeight(iX, iZ) > GetTerrainHeight(iX, iZ) then
                iWaterCount = iWaterCount + 1
                iWaterLevel = math.min(iWaterLevel, GetSurfaceHeight(iX, iZ))
                if bDebugMessages == true then LOG(sFunctionRef..': Found water at position X-Z='..iX..'-'..iZ..'; Surface height='..GetSurfaceHeight(iX, iZ)..'; Terrain height='..GetTerrainHeight(iX, iZ)) end
                if iWaterCount >= 3 then
                    break
                end
            else
                --Backup for maps like theta passage arch - have commented out as running on theta passage with interval of 1 it never triggers a water count in the first place, but could remove comments if do come across this issue
                --if bDebugMessages == true and iWaterCount > 0 and GetTerrainHeight(iX, iZ) < iWaterLevel and iWaterLevel < 10000 then LOG(sFunctionRef..': Have suspected arch previously so will adjust water level to terrain height='..GetTerrainHeight(iX, iZ)..'; for iX-Z='..iX..'-'..iZ..'; prev iWaterLevel='..iWaterLevel) end
                --iWaterLevel = math.min(iWaterLevel, GetTerrainHeight(iX, iZ))
            end
        end
        if iWaterCount >= 3 then break end
    end
    if iWaterCount == 0 then iMapWaterHeight = 0
    else
        iMapWaterHeight = iWaterLevel
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iWaterCount='..iWaterCount..'; iMapWaterHeight='..iMapWaterHeight) end
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end





function TempTest()

    --Open palms - draw line between 2 of the mexes in the bottom left part of the main (land pathable fro mbase) area:
    local tStart = {180.5, 15.001953125, 429.5}
    local tEnd = {199.5, 14.314453125, 459.5}
    M28Utilities.DrawLocation(tStart, 2)
    M28Utilities.DrawLocation(tEnd, 3)
    local tFullPath, iPathSize, iDistance = NavUtils.PathTo('Land', tStart, tEnd, nil)
    M28Utilities.DrawPath(tFullPath, 1, nil)

end

function SetupMap()
    --Sets up non-brain specific info on the map
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupMap'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)

    SetupPlayableAreaAndSegmentSizes()

    --Generate pathing
    if not(NavUtils.IsGenerated()) then
        local NavGen = import("/lua/sim/navgenerator.lua")
        NavGen.Generate()
    end

    GetMapWaterHeight()

    RecordMexForPathingGroup()

    RecordAllPlateaus() --Needed first since will organise land zones by plateau

    --TempTest()
    SetupLandZones()

    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end
