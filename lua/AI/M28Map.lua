---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 16/11/2022 07:22
---

local M28Profiler = import('/mods/M28AI/lua/AI/M28Profiler.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local M28Conditions = import('/mods/M28AI/lua/AI/M28Conditions.lua')
local M28Team = import('/mods/M28AI/lua/AI/M28Team.lua')
local M28Logic = import('/mods/M28AI/lua/AI/M28Logic.lua')
local M28Overseer = import('/mods/M28AI/lua/AI/M28Overseer.lua')
local M28Chat = import('/mods/M28AI/lua/AI/M28Chat.lua')
local M28Land = import('/mods/M28AI/lua/AI/M28Land.lua')
local M28UnitInfo = import('/mods/M28AI/lua/AI/M28UnitInfo.lua')

bMapSetupComplete = false --set to true once have finished setting up map (used to decide how long to wait before starting main aibrain logic)

--Pathing types
--NavLayers 'Land' | 'Water' | 'Amphibious' | 'Hover' | 'Air'
refPathingTypeAmphibious = 'Amphibious'
refPathingTypeNavy = 'Water'
refPathingTypeAir = 'Air'
refPathingTypeLand = 'Land'
refPathingTypeNone = 'None'
refPathingTypeAll = {refPathingTypeAmphibious, refPathingTypeNavy, refPathingTypeAir, refPathingTypeLand}

--Map size
rMapPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2} - Set at start of the game, use instead of the scenarioinfo method; note that x0 z0 is the top-left corner of the map
iMaxLandSegmentX = 1
iMaxLandSegmentZ = 1

iMapWaterHeight = 0 --Surface height of water on the map

--Resource information
tMassPoints = {} --[x] is an integer count, returns the location of a mass point; stores all mexes on the map
tHydroPoints = {} --[x] is an integer count, returns the location of a hydro point; stores all hydro points on the map
tMexByPathingAndGrouping = {} --Stores position of each mex based on the pathing group that it's part of; [a][b][c]: [a] = pathing type ('Land' etc.); [b] = Segment grouping; [c] = Mex position
tHydroByPathingAndGrouping = {} --as above but for hydros

--Player start points
PlayerStartPoints = {} --[x] is aiBrain army index, returns the start position {x,y,z}; Will be updated whenever a brain is created, index is the army index, i.e. do PlayerStartPoints[aiBrain:GetArmyIndex()] to get a table {x,y,z} that is the army's start position; more convenient than aiBrain:GetArmyStartPos() which returns x and z values but not as a table


--Reclaim info (non-LZ/plateau specific):
bReclaimManagerActive = false --used to spread updates of reclaim areas over each second
tReclaimSegmentsToUpdate = {} --[n] where n is the count, returns {segmentX,segmentZ} as value; i.e. update by using table.insert
tReclaimAreas = {} --Stores reclaim info for each segment: tReclaimAreas[iSegmentX][iSegmentZ][x]; if x=1 returns total mass in area; if x=2 then returns position of largest reclaim in the area, if x=3 returns how many platoons have been sent here since the game started
    refReclaimTotalMass = 1
    refReclaimSegmentMidpoint = 2
    --refReclaimHighestIndividualReclaim = 3
    --reftReclaimTimeOfLastEngineerDeathByArmyIndex = 4 --Table: [a] where a is the army index, and it returns the time the last engineer died
    --refReclaimTimeLastEnemySightedByArmyIndex = 5
    --refsSegmentMidpointLocationRef = 6
    --refiReclaimTotalPrev = 7 --Previous total reclaim mass in a segment
    refReclaimTotalEnergy = 8
--tLastReclaimRefreshByGroup = {} --time that last refreshed reclaim positions for [x] group
--iLastReclaimRefresh = 0 --stores time that last refreshed reclaim positions
--refiLastRefreshOfReclaimAreasOfInterest = 'M28MapLastRefreshOfReclaim'
--refiTotalReclaimAreasOfInterestByPriority = 'M28MapReclaimAreasOfInterestCount' --[1] = total for priority 1, etc.; up to 4 priority
--reftReclaimAreasOfInterest = 'M28MapReclaimAreasOfInterest' --assigned to aiBrain, [1] = priority (1, 2, 3); [2] = {segmentx, segmentz}
--reftReclaimAreaPriorityByLocationRef = 'M28MapReclaimAreaPriorityByLocationRef' --key is location ref
iReclaimSegmentSizeX = 0 --Updated separately
iReclaimSegmentSizeZ = 0 --Updated separately
--iReclaimAreaOfInterestTickCount = 0 --Updated as part of may reclaim update loop, used to avoid excessive load on an individual tick
--bReclaimRefreshActive = false --Used to avoid duplciating reclaim update logic



--Plateaus - core (NOTE: Some of these variables wont work for a plateau that has no mexes)
tPathingPlateauAndLZOverride = {} --Global, Pathing override where no plateau recognised; key is [math.floor(x)][math.floor(z)] and returns {iPlateau, iLandZone}
tbTempConsideredLandPathingForLZ = {} --Global, used to track if we have considered land pathing for this LZ as part of the initial LZ setup

tAllPlateaus = {} --[x] = AmphibiousPathingGroup, [y]: subrefs, e.g. subrefPlateauMexes;
--aibrain variables for plateaus (not currently incorporated):
reftPlateausOfInterest = 'M28PlateausOfInterest' --[x] = Amphibious pathing group; will record a table of the pathing groups we're interested in expanding to, returns the location of then earest mex
--refiLastPlateausUpdate = 'M28LastTimeUpdatedPlateau' --gametime that we last updated the plateaus
--reftOurPlateauInformation = 'M28OurPlateauInformation' --[x] = AmphibiousPathingGroup; [y] = subref, e.g. subrefPlateauLandFactories; Used to store details such as factories on the plateau
--refiOurBasePlateauGroup = 'M28PlateausOurBaseGroup' --Segment group of our base (so can easily check somewhere is in a dif plateau)

--subrefs for tables
--tAllPlateaus[iPlateau] subrefs
    subrefPlateauMexes = 'M28PlateauMex' --[x] = mex count, returns mex position
    subrefPlateauMinXZ = 'M28PlateauMinXZ' --{x,z} min values
    subrefPlateauMaxXZ = 'M28PlateauMaxXZ' --{x,z} max values - i.e. can create a rectangle covering entire plateau using min and max xz values
    subrefPlateauTotalMexCount = 'M28PlateauMexCount' --Number of mexes on the plateau
    subrefPlateauReclaimSegments = 'M28PlateauReclaimSegments' --[x] = reclaim segment x, [z] = reclaim segment z, returns true if part of plateau
    subrefPlateauMidpoint = 'M28PlateauMidpoint' --Location of the midpoint of the plateau
    subrefPlateauMaxRadius = 'M28PlateauMaxRadius' --Radius to use to ensure the circle coveres the square of the plateau

    subrefPlateauEngineers = 'M28PlateauEngineers' --[x] is engineer unique ref (per m28engineer), returns engineer object
    --Plateaus: Island variables (against tAllPlateaus[iPlateau])
    subrefPlateauIslandLandZones = 'M28PlateauIslands' --[x] is the island, returns a table of land zones in that island for this plateau
    subrefPlateauIslandMexCount = 'M28IslandMexCount' --[x] is the island, returns the number of mexes in the island

--Plateaus - Land zone variables (still against tAllPlateaus[iPlateau]
    subrefLandZoneCount = 'M28PlateauZoneCount' --against the main plateau table, records how many land zones there are (alternative to table.getn on the land zones)
    subrefPlateauLandZones = 'M28PlateauLandZones' --against the main plateau table, stores info on land zones for that plateau

iLandZoneSegmentSize = 5 --Gets updated by the SetupLandZones - the size of one side of the square that is the lowest resolution land zones go to; each segment that is land pathable gets assigned to a land zone
    --Land zone subrefs (against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]):
        subrefLZMexCount = 'MexCount' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns number of mexes in the LZ
        subrefLZMexLocations = 'MexLoc' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns table of mex locations in the LZ, e.g. get with tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefLZMexLocations]
        subrefLZMexUnbuiltLocations = 'MexAvailLoc' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns table of mex locations in the LZ, e.g. get with tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefLZMexLocations]
        subrefLZMidpoint = 'Midpoint' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns the midpoint of the land zone, e.g. get with tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefLZMidpoint]
        subrefLZHydroLocations = 'HydroLoc' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns table of hydro locations in the LZ
        subrefLZHydroUnbuiltLocations = 'HydroAvailLoc' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], returns table of hydro locations in the LZ that dont have buildings on them
        subrefLZBuildLocationsBySize = 'BuildLoc' --contains a table, with the index being the unit's highest footprint size, which returns a location that should be buildable in this zone;  only populated on demand (i.e. if we want to try and build something there by references to the predefined location), e.g. tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZBuildLocationsBySize][iSize]
        subrefLZBuildLocationSegmentCountBySize = 'BuildSegment' --[x] is the building size considered, returns Number of segments that we have considered when identifying segment build locations for the land zone for that particular size
        subrefLZMassStorageLocationsAvailable = 'MassStorageLocations' --Against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], Returns table of locations which should be valid to build on for mass storage
        subrefLZSegments = 'Segments' --Contains a table which returns the X and Z segment values for every segment assigned to this land zone
        subrefLZTotalSegmentCount = 'SegCount' --Number of segments in a land zone, against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
        subrefLZAdjacentLandZones = 'AdjLZ' --table containing all adjacent land zone references for the plateau in question, against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], i.e. ordered 1,2,3,...; and returns the LZ ref (based on the order it was added)
        subrefLZPathingToOtherLandZones = 'PathLZ' --table containing the land zone ref of some (but not all) other LZs where have recorded the paths and time taken, sorted by closest LZ first
            subrefLZNumber = 1 --Land zone reference number
            subrefLZPath = 2 --against subrefLZPathingToOtherLandZones subtable
            subrefLZTravelDist = 3 --against subrefLZPathingToOtherLandZones subtable
        subrefLZPathingToOtherLZEntryRef = 'PathRfLZ' --[x] is the target LZ reference; will return the entry in subrefLZPathingToOtherLandZones containing this path, if there is one
        subrefLZTravelDistToOtherLandZones = 'TravelLZ' --table used to store all land travel distance calculations to get from one LZ to another LZ; similar to subrefLZPathingToOtherLandZones, but intended to allow for all land zones to be recorded
        subrefLZPathingToOtherIslands = 'PathIsl' --array, [x] = (1, 2...); Ordered based on shortest travel distance
            subrefIslandNumber = 1 --Island reference number
            subrefIslandClosestLZRef = 2 --LZ ref of the LZ closest to us in this island
            subrefIslandTravelDist = 3 --Amphibious travel distance from the land zone to the closestLZRef in the IslandNumber
            subrefIslandLZPath = 4 --table of the land zones that an amphibious unit would go through to get from this LZ to the ClosestLZRef

        subrefLZFurthestAdjacentLandZoneTravelDist = 'FurthestAdjLZ' --Returns the travel distance (rounded up) of the furthest immediately adjacent land zone - can combine with subrefLZPathingToOtherLandZones so can stop cycling through the prerecorded LZs once get further away than the immediately adjacent ones
        --Reclaim related:
        subrefLZReclaimSegments = 'ReclSeg' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone], table, orderd 1,2,3...; returns {iReclaimSegmentX, iReclaimSegmentZ}
        subrefLZTotalMassReclaim = 'RecMass' --total mass reclaim in the land zone
        subrefLZTotalEnergyReclaim = 'RecEn' --Total energy reclaim in the land zone
        subrefLZLastReclaimRefresh = 'RecTime' --Time that we last refreshed the reclaim in the land zone, against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
        subrefLZPlayerWallSegments = 'PlWalls' --Table of wall units that aren't owned by M28AI

        --Land scout/intel related
        subreftPatrolPath = 'PatrPth' --table of locations intended for a land scout to patrol the perimeter of the land zone

        --Island related
        subrefLZIslandRef = 'Island' --the island ref of the land zone (can also get by using NavUtils.GetLabel(refPathingTypeAmphibious) for the midpoint

        --Land zone subteam data (update M28Teams.TeamInitialisation function to include varaibles here so dont have to check if they exist each time)
        subrefLZTeamData = 'Subteam' --tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData] - Table for all the data by team for a plateau's land zone
            --Variables that are against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData]:
            subrefLZTValue = 'ZVal' --Value of the zone factoring in mass, reclaim, and allied units
            subrefLZSValue = 'ZBVal' --Value of friendly buildings in the land zone
            subrefLZTCoreBase = 'ZCore' --true if this is considered a 'core base' land zone
            subrefLZCoreExpansion = 'ZExp' --true if considered the main land zone for an expansion (e.g. on an island); nil if we havent considered yet if it is a core expansion, and false if we have considered and it isnt
            subrefLZAlliedACU = 'AACU' --table of ACU units for the land zone (so can factor into decisions on support and attack)
            subrefLZTAlliedUnits = 'Allies' --table of all allied units in the land zone, tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam][subrefLZTAlliedUnits]
            subrefLZTAlliedCombatUnits = 'AllComb' --table of allied units that are to be considered for combat orders
            subrefLZTEnemyUnits = 'Enemies' --table of all enemy units in the land zone
            reftoNearestDFEnemies = 'NearestDF' --Table of enemy DF units in this LZ, plus the nearest DF unit in each adjacnet LZ, with proximity based on unit distance and unit range (i.e. the dist until the unit is in range)
            --Ground threat values for land zones (also against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam])
            subrefLZTThreatEnemyCombatTotal = 'ECTotal'
            subrefLZTThreatAllyCombatTotal = 'ACTotal'
            subrefLZDFThreatWanted = 'DFWanted'
            subrefLZMAAThreatWanted = 'MAAThreatWanted'
            subrefLZThreatEnemyMobileDFByRange = 'EMDFByRange'
            subrefLZThreatEnemyMobileDFTotal = 'EMDFTo'
            subrefLZThreatAllyMobileDFByRange = 'AMDFByRange'
            subrefLZThreatAllyMobileDFTotal = 'ATDFT'
            subrefLZThreatEnemyMobileIndirectByRange = 'EMIFByRange'
            subrefLZThreatEnemyMobileIndirectTotal = 'EMIFTo'
            subrefLZThreatAllyMobileIndirectByRange = 'AMIFByRange'
            subrefLZThreatAllyMobileIndirectTotal = 'ATIFT'
            subrefLZThreatEnemyBestMobileDFRange = 'EBDFR'
            subrefLZThreatEnemyBestStructureDFRange = 'EBSDFR'
            subrefLZThreatEnemyBestMobileIndirectRange = 'EBIR'


            subrefLZThreatEnemyStructureDFByRange = 'ESDFByRange'
            subrefLZIndirectThreatWanted = 'IFWanted'
            subrefLZThreatAllyStructureDFByRange = 'ASDFByRange'
            subrefLZThreatEnemyStructureIndirect = 'ESITotal'
            subrefLZThreatAllyStructureIndirect = 'ASITotal'
            subrefLZThreatEnemyGroundAA = 'EAATotal'
            subrefLZThreatAllyGroundAA = 'AAATotal'
            subrefbEnemiesInThisOrAdjacentLZ = 'NearbyEnemies' --true if this LZ or adjacent LZ have nearby enemies
            subrefbDangerousEnemiesInThisLZ = 'HasDangEnemy' --true if combat units in this LZ
            subrefbLZWantsSupport = 'LZWantsSupport' --true if want DF or indirect units for the LZ
            subrefbLZWantsDFSupport = 'LZWantsDFSupport' --true if want DF units for the LZ
            subrefbLZWantsIndirectSupport = 'LZWantsIndirectSupport' --true if want indirect units for the LZ

            subreftEnemyFirebasesInRange = 'LZEnemyFirebasesInRange' --[x] is just a count (1,2,3), returns {iPlateau, iLandZone} of the firebase

            --Engineer related values
            subreftoPartBuiltMexes = 'PBMex' --If we are building a mex and the builder gets its orders cleared or dies, and it was building a mex, then the mex should be recorded in a table so it can be rebuilt
            subrefLZTbWantBP = 'WantBP' --true if we want BP at any tech level
            subrefLZTBuildPowerByTechWanted = 'BPByTechW' --{[1]=a, [2]=b, [3]=c} where a,b,c are the build power wanted wanted
            subrefLZTEngineersTravelingHere = 'EUnitsTrav' --Table of any engineer units in another LZ that have been told to move to this LZ
            subrefLZTScoutsTravelingHere = 'SUnitsTrav' --Table of any land scout units in another LZ that have been told to move to this LZ
            subrefLZSpareBPByTech = 'SpareBPByTech' --{[1]=a, [2]=b, [3]=c} where a,b,c are the build power of that tech level that we have spare
            subrefReclaimAreaAssignmentsBySegment = 'RecSegAss' --[ReclaimSegX][ReclaimZegY], returns count of how many engineers have been assigned
            subrefQueuedBuildings = 'QBByBP' --Queued buildings for a land zone
                subrefQueueRef = 1 --Unique queue reference number
                subrefBuildingID = 2 --Blueprint/UnitId of the building queued
                subrefBuildingLocation = 3 --Location the building is to be built at
                subrefBuildingRadius = 4 --Size (radius) of the building
                subrefPrimaryBuilder = 5 --Engineer given the build order
            --subrefLZTAdjacentBPByTechWanted = 'AdjBPByTechW' --{[1]=a, [2]=b, [3]=c} where a,b,c are the build power wanted wanted
            --Economy related values
            subrefActiveUpgrades = 'ActiveUpgrades' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam]
            subrefMexCountByTech = 'MexByTech' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam]
            subreftoUnitsToReclaim = 'UnitToRec' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam], table of units that we should reclaim
            --Intel related values
            refbWantLandScout = 'LandScout'
            refiRadarCoverage = 'RadCov' --Radar coverage of the centre of the land zone midpoint
            refoBestRadar = 'BestRad' --Radar providing the best Radar Coverage for the land zone midpoint
            --Enemy air
            reftLZEnemyAirUnits = 'EnAir' --All enemy air units that are currently in the land zone
            refiLZEnemyAirToGroundThreat = 'EnA2GT' --Air to ground threat of enemy air units in the LZ
            refiLZEnemyAirOtherThreat = 'EnAirOT' --mass value of AirAA, air scouts and transports in the LZ
            --Shield, stealth and tmd
            refbLZWantsMobileShield = 'MobSh' --true if LZ wants mobile shields
            reftoLZUnitsWantingMobileShield = 'UMobSh' --table of units in the LZ that want mobile shield
            reftoLZUnitWantingFixedShield = 'UFixSh' --table of untis in the LZ taht want a fixed shield
            reftPriorityShieldsToAssist = 'FShAss' --Table of fixed shields that want to assist
            refiTimeOfLastShieldPriorityRefresh = 'FSTimC' --Time that we last updated the list of priority shields to be assisted
            refbLZWantsMobileStealth = 'MobSt' --true if LZ wants mobile stealth
            reftoLZUnitsWantingMobileStealth = 'UMobSt' --table of units in the LZ that want mobile stealth
            reftUnitsWantingTMD = 'TMDW' --table of units in the LZ that want TMD coverage
            --Misc
            reftClosestFriendlyBase = 'ClosestFB' --Position of the closest friendly start position
            reftClosestEnemyBase = 'ClosestEB' --Closest enemy start position
            refiModDistancePercent = 'ModDPC' --against tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTeamData][iTeam], mod dist based on closest friendly start position to closest enemy start position
            refbIslandBeachhead = 'IslBeachd' --true if we are sending units to a closest island LZ to try and attack enemy - means will check for nearby untis vs enemy nearby units when deciding whether to attack or not




--Land pathing segment data
tLandZoneBySegment = {} --[x][z] should be the x and z segments baed on iLandZoneSegmentSize, and should return the land zone number, or nil if there is none
tTempZoneTravelDistanceBySegment = {} --[x][z][LZ] should be the x and z segments, used to temporarily store the distance values for segments at start of the game when setting up land zones
tTempZonePlateauBySegment = {} --[x][z][LZ] shoudl be the plateau; used as a backup where we could find a LZ nearby but not a plateau


--General aiBrain variables
reftPrimaryEnemyBaseLocation = 'M28PrimaryEnemyBase' --against aiBrain, returns location of the nearest enemy base
refiLastTimeCheckedEnemyBaseLocation = 'M28MapLastTimeCheckedEnemyBase' --against aiBrain, gametimeseconds that last checked the enemy base location
reftMidpointToPrimaryEnemyBase = 'M28MapMidpointToPrimaryEnemy' --against aiBrain, midpoint between the start position and the nearest enemy start position
refbCanPathToEnemyBaseWithLand = 'M28MapCanPathToEnemyWithLand'
refbCanPathToEnemyBaseWithAmphibious = 'M28MapCanPathToEnemyWithAmphibious'

---@param tPosition table
---@return number, number
function GetPathingSegmentFromPosition(tPosition)
    --The map is divided into equal sized square segments with each segment allocated to a land zone; this can be used to get the segment X and Z references
    --tPosition shoudl be {x,y,z} format, although y value is ignored)
    return math.floor( (tPosition[1] - rMapPlayableArea[1]) / iLandZoneSegmentSize) + 1, math.floor((tPosition[3] - rMapPlayableArea[2]) / iLandZoneSegmentSize) + 1
end

---@param iSegmentX number
---@param iSegmentZ number
---@return table
function GetPositionFromPathingSegments(iSegmentX, iSegmentZ)
    --Returns the position/location of land segment X and Z references iSegmentX and iSegmentZ (i.e. the map is divided into equal sized square segments, with each segment allocated to a land zone)
    local x = iSegmentX * iLandZoneSegmentSize - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[1]
    local z = iSegmentZ * iLandZoneSegmentSize - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[2] --If changing this, then also update AssignRemainingSegmentsToLandZone which manually does this for performance
    return {x, GetTerrainHeight(x, z), z}
end

function GetPathingOverridePlateauAndLandZone(tPosition, bOptionalShouldBePathable, oOptionalPathingUnit)
    local iX = math.floor(tPosition[1])
    --LOG('GetPathingOverridePlateauAndLandZone: iPlateau is nil or 0, tPosition='..repru(tPosition)..'; tPathingPlateauAndLZOverride[ix]='..repru(tPathingPlateauAndLZOverride[iX])..'; bOptionalShouldBePathable='..tostring(bOptionalShouldBePathable or false)..'; Is oOptionalPathingUnit valid='..tostring(M28UnitInfo.IsUnitValid(oOptionalPathingUnit)))
    if tPathingPlateauAndLZOverride[iX] then
        local iZ = math.floor(tPosition[3])
        if tPathingPlateauAndLZOverride[iX][iZ] then
            --LOG('GetPathingOverridePlateauAndLandZone: Have a valid override so will return this, override='..repru(tPathingPlateauAndLZOverride[iX][iZ]))
            return tPathingPlateauAndLZOverride[iX][iZ][1], tPathingPlateauAndLZOverride[iX][iZ][2]
        end
    end
    --Dont have an override for here - if we think it shoudl be pathable then create an override
    if bOptionalShouldBePathable and oOptionalPathingUnit then
        --LOG('GetPathingOverridePlateauAndLandZone: No plateau for a unit that should be pathable, tPosition='..repru(tPosition)..'; bOptionalShouldBePathable='..tostring(bOptionalShouldBePathable)..'; oOptionalPathingUnit='..oOptionalPathingUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oOptionalPathingUnit)..'; oOptionalPathingUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam]='..repru(oOptionalPathingUnit[M28UnitInfo.reftAssignedPlateauAndLandZoneByTeam])..'; Unit state='..M28UnitInfo.GetUnitState(oOptionalPathingUnit)..'; iMapWaterHeight='..iMapWaterHeight)
        if M28Land.ConsiderAddingPlateauOverrideForUnit(oOptionalPathingUnit) then
            if tPathingPlateauAndLZOverride[iX] then
                local iZ = math.floor(tPosition[3])
                if tPathingPlateauAndLZOverride[iX][iZ] then
                    --LOG('GetPathingOverridePlateauAndLandZone: Have a valid override after considering plateau override for unit, override='..repru(tPathingPlateauAndLZOverride[iX][iZ]))
                    return tPathingPlateauAndLZOverride[iX][iZ][1], tPathingPlateauAndLZOverride[iX][iZ][2]
                end
            end
        end
    end
    return nil, nil
end

---@param tPosition table
---@param bOptionalShouldBePathable boolean
---@return number, number
function GetPlateauAndLandZoneReferenceFromPosition(tPosition, bOptionalShouldBePathable, oOptionalPathingUnit)
    --Returns the plateau reference of tPosition (where tPosition is {x,y,z}), and the Land zone reference for that position
    --returns nil if cant find valid plateau or land zone
    --bOptionalShouldBePathable - if e.g. have a unit at tPosition, then set this to true as it means somehow a unit could path in this area, and the code will then try backup options and give error messages

    --Get the plateau reference and the land segment X and Z references:
    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tPosition)
    local iPlateau = NavUtils.GetLabel(refPathingTypeAmphibious, GetPositionFromPathingSegments(iSegmentX, iSegmentZ))
    local iLandZone

    if (iPlateau or 0) <= 0 or not(tAllPlateaus[iPlateau]) then
        --Check if we have previously recorded this location with a pathing override
        iPlateau, iLandZone = GetPathingOverridePlateauAndLandZone(tPosition, bOptionalShouldBePathable, oOptionalPathingUnit)
        if not(tAllPlateaus[iPlateau]) then
            --Potential error - see if there is a plateau for the preicse position if it shoudl be pathable

            --LOG('GetPlateauAndLandZoneReferenceFromPosition: tAllPlateaus is nil for iPlateau='..(iPlateau or 'nil')..'; if should be pathable will check the segment we are in/ bOptionalShouldBePathable='..tostring(bOptionalShouldBePathable or false))
            if bOptionalShouldBePathable then
                iPlateau = NavUtils.GetLabel(refPathingTypeAmphibious, tPosition)

                if not(tAllPlateaus[iPlateau]) then
                    if bOptionalShouldBePathable then
                        --If get this error, then refer to GetUnitPlateauAndLandZoneOverride
                        M28Utilities.ErrorHandler('No plateau group for iSegmentX='..iSegmentX..'; iSegmentZ='..iSegmentZ..'; Plateau group of segment midpoint='..(NavUtils.GetLabel(refPathingTypeAmphibious, GetPositionFromPathingSegments(iSegmentX, iSegmentZ)) or 'nil')..'; Plateau Group of tPosition='..(NavUtils.GetLabel(refPathingTypeAmphibious, tPosition) or 'nil')..'; Pathing unit='..(oOptionalPathingUnit.UnitId or 'nil')..(M28UnitInfo.GetUnitLifetimeCount(oOptionalPathingUnit) or 'nil')..'; Enable logs in the function GetUnitPlateauAndLandZoneOverride for more details')
                    end
                    return nil
                else
                    if tAllPlateaus[iPlateau][subrefPlateauTotalMexCount] == 0 then
                        iLandZone = 1
                    else
                        --more than 1 land zone so return nil
                        iLandZone = nil
                    end
                end
            else
                return nil
            end
        end
        return iPlateau, iLandZone
    else
        --Have a valid plateau, get the land zone reference:
        --local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tPosition)
        iLandZone = tLandZoneBySegment[iSegmentX][iSegmentZ]

        if not(iLandZone) then
            --Are we above water in height? If so check for override
            if tPosition[2] > iMapWaterHeight then
                iPlateau, iLandZone = GetPathingOverridePlateauAndLandZone(tPosition, bOptionalShouldBePathable, oOptionalPathingUnit)
                if not(iLandZone) and bOptionalShouldBePathable then
                    --Possible explanation - engineer has traveled across water and reached a cliff
                    if EntityCategoryContains(categories.HOVER + categories.AMPHIBIOUS, oOptionalPathingUnit.UnitId) then
                        --Do nothing - hopefully unit has orders that it will follow that will resolve this on its own
                    else
                        M28Utilities.ErrorHandler('Unable to find valid land zone, tPosition[1-3]='..tPosition[1]..'-'..tPosition[2]..'-'..tPosition[3]..'; oOptionalPathingUnit='..(oOptionalPathingUnit.UnitId or 'nil')..' with LC='.. M28UnitInfo.GetUnitLifetimeCount(oOptionalPathingUnit))
                        --M28Utilities.DrawLocation(tPosition)
                    end
                end
            end
        end
    end


    return iPlateau, iLandZone
end

---@param tLocation table
---@return number, number
function GetReclaimSegmentsFromLocation(tLocation)
    --Returns the reclaim segment X and Z values for a given location on the map (i.e. map is divided into reclaim segment squares which are a different size to land zone segments)
    --tLocation should be in the {x,y,z} format, although y value is ignored
    return math.ceil(tLocation[1] / iReclaimSegmentSizeX), math.ceil(tLocation[3] / iReclaimSegmentSizeZ)
end

---@param iReclaimSegmentX number
---@param iReclaimSegmentZ number
---@return table
function GetReclaimLocationFromSegment(iReclaimSegmentX, iReclaimSegmentZ)
    --If given the reclaim segment X and Z values, then will convert this into an {x,y,z} position
    --e.g. segment (1,1) will be 0 to ReclaimSegmentSizeX and 0 to ReclaimSegmentSizeZ in size
    --This will return the midpoint of the reclaim segment
    if tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint] then return tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint]
    else
        local iX = math.max(rMapPlayableArea[1], math.min(rMapPlayableArea[3], (iReclaimSegmentX - 0.5) * iReclaimSegmentSizeX))
        local iZ = math.max(rMapPlayableArea[2], math.min(rMapPlayableArea[4], (iReclaimSegmentZ - 0.5) * iReclaimSegmentSizeZ))
        return {iX, GetSurfaceHeight(iX, iZ), iZ}
    end
end

local function SetupPlayableAreaAndSegmentSizes()
    --Sets up key values needed to divide the map up into segments (small squares) for both land zone segments and reclaim segments - should be called as one of the first pieces of code
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DetermineReclaimAndLandSegmentSizes'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if ScenarioInfo.MapData.PlayableRect then
        rMapPlayableArea = ScenarioInfo.MapData.PlayableRect
    else
        rMapPlayableArea = {0, 0, ScenarioInfo.size[1], ScenarioInfo.size[2]}
    end


    --Decide on land zone segment sizes
    local iHighestSize = math.max(rMapPlayableArea[3] - rMapPlayableArea[1], rMapPlayableArea[4] - rMapPlayableArea[2])
    local iTableSizeCap = 25000 --tried with 50k but on a 10km map it took too long to do the initial setup

    --iTableSizeCap = SegmentCount^2; SegmentCount = iTotalSize / SegmentSize; (TotalSize/SegmentSize)^2 = iTableSizeCap; SemgentSize = TotalSize/Sqrt(iTableSizeCap)
    iLandZoneSegmentSize = math.ceil(iHighestSize / math.sqrt(iTableSizeCap))

    --Record the max values
    iMaxLandSegmentX, iMaxLandSegmentZ = GetPathingSegmentFromPosition({rMapPlayableArea[3], 0, rMapPlayableArea[4]})

    if bDebugMessages == true then LOG(sFunctionRef..': iHighestSize='..iHighestSize..'; iTableSizeCap='..iTableSizeCap..'; iLandZoneSegmentSize='..iLandZoneSegmentSize..'; Max Segment X-Z='..iMaxLandSegmentX..'-'..iMaxLandSegmentZ) end


    local iMinReclaimSegmentSize = 8.5 --Engineer build range is 6; means that a square of about 4.2 will fit inside this circle; If have 2 separate engineers assigned to adjacent reclaim segments, and want their build range to cover the two areas, then would want a gap twice this, so 8.4; will therefore go with min size of 8
    local iMapSizeX = rMapPlayableArea[3] - rMapPlayableArea[1]
    local iMapSizeZ = rMapPlayableArea[4] - rMapPlayableArea[2]
    iReclaimSegmentSizeX = math.max(iMinReclaimSegmentSize, iLandZoneSegmentSize)
    iReclaimSegmentSizeZ = math.max(iMinReclaimSegmentSize, iLandZoneSegmentSize)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param sResourceType string
---@param x number
---@param y number
---@param z number
function RecordResourcePoint(sResourceType,x,y,z,size)
    --called by hook into simInit, more reliable method of figuring out if have adaptive map than using markers, as not all mass markers may have mexes generated on an adaptive map
    --Whenever a resource location is created in the map, this is called, and will record the resource location into a table of mex points (tMassPoints) and hydro points (tHydroPoints) for referencing in later code
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordResourcePoint'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': sResourceType='..sResourceType..'; x='..x..'; y='..y..'; z='..z..'; size='..repru(size)..'; Mass count pre update='..table.getn(tMassPoints)..'; Hydro points pre update='..table.getn(tHydroPoints)) end

    if sResourceType == 'Mass' then
        table.insert(tMassPoints, {x,y,z})
    elseif sResourceType == 'Hydrocarbon' then
        table.insert(tHydroPoints, {x,y,z})
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of hook; Mass points post update='..table.getn(tMassPoints)..'; Hydro poitns post update='..table.getn(tHydroPoints)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param sPathing string
---@param tLocation table
---@return number
function GetSegmentGroupOfLocation(sPathing, tLocation)
    --Included for backwards compatibility with M27 logic; better to use the below line directly
    --Returns a reference number based on sPathing that groups areas based on whether they can path to each other (so if two locations have the same reference, they can path to each other)
    --sPathing should be one of the refPathingType variables defined at the top of this file; tLocation is {x,y,z} format
    return NavUtils.GetLabel(sPathing, tLocation)
end

local function RecordMexForPathingGroup()
    --Cycles through every mex on the map, and includes it in a table of mexes that is grouped by pathing type, so in future we can easily cycle through mexes for a particular pathing type
    --e.g. after running this, can use tMexByPathingAndGrouping[sPathing][iPathingGroup] where sPathing is the refPathingType variable, and ipathingGroup is the NavUtils.GetLabel(sPathing, tLocation) reference
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordMexForPathingGroup'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': About to record mexes for each pathing group. MassPoints='..repru(tMassPoints)) end
    local tsPathingTypes = {refPathingTypeAmphibious, refPathingTypeNavy, refPathingTypeLand}
    local iCurResourceGroup
    local iValidCount = 0
    tMexByPathingAndGrouping = {}
    if bDebugMessages == true then
        LOG(sFunctionRef..': NavUtils test - will cycle through each mex and get land label')
        for iMex, tMex in tMassPoints do
            LOG(sFunctionRef..': tMex='..repru(tMex)..'; Label='..(NavUtils.GetLabel('Land', tMex) or 'nil'))
            if not(NavUtils.GetLabel('Land', tMex)) then
                LOG(sFunctionRef..': WARNING - dont have a land label for mex '..repru(tMex))
            else
                LOG(sFunctionRef..': Have a land label for mex '..repru(tMex)..' so will stop with warning messages as pathing apepars generated')
                break
            end
        end
    end
    for iPathingType, sPathing in tsPathingTypes do
        tMexByPathingAndGrouping[sPathing] = {}
        iValidCount = 0

        if bDebugMessages == true then LOG(sFunctionRef..': About to record all mexes for pathing type sPathing='..sPathing) end

        for iCurMex, tMexLocation in tMassPoints do
            iValidCount = iValidCount + 1
            iCurResourceGroup = NavUtils.GetLabel(sPathing, tMexLocation)
            if not(iCurResourceGroup) then
                if bDebugMessages == true then LOG('Dont have a resource group for mex location '..repru(tMexLocation)..'; This is expected if mexes are located outside the playable area or are testing water pathing for land mexes and vice versa') end
            else
                if bDebugMessages == true then
                    LOG(sFunctionRef..': iCurMex='..iCurMex..'; About to get segment group for pathing='..sPathing..'; location='..repru((tMexLocation or {'nil'}))..'; iCurResourceGroup='..(iCurResourceGroup or 'nil'))
                    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tMexLocation)
                    LOG(sFunctionRef..': Pathing segments='..(iSegmentX or 'nil')..'; iSegmentZ='..(iSegmentZ or 'nil')..'; rMapPlayableArea='..repru(rMapPlayableArea)..'; iLandZoneSegmentSize='..(iLandZoneSegmentSize or 'nil'))
                end
                if tMexByPathingAndGrouping[sPathing][iCurResourceGroup] == nil then
                    tMexByPathingAndGrouping[sPathing][iCurResourceGroup] = {}
                    iValidCount = 1
                else iValidCount = table.getn(tMexByPathingAndGrouping[sPathing][iCurResourceGroup]) + 1
                end
                tMexByPathingAndGrouping[sPathing][iCurResourceGroup][iValidCount] = tMexLocation
                if bDebugMessages == true then LOG(sFunctionRef..': iValidCount='..iValidCount..'; sPathing='..sPathing..'; iCurResourceGroup='..iCurResourceGroup..'; just added tMexLocation='..repru(tMexLocation)..' to this group') end
            end
        end
        if sPathing == refPathingTypeLand and iValidCount == 0 then M28Utilities.ErrorHandler('Dont have any mexes recording for land pathing type') end
    end
    if bDebugMessages == true then LOG(sFunctionRef..'; tMexByPathingAndGrouping='..repru(tMexByPathingAndGrouping)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordMexlessPlateau(iPlateau)
    tAllPlateaus[iPlateau] = {}
    tAllPlateaus[iPlateau][subrefPlateauTotalMexCount] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones] = {}
    tAllPlateaus[iPlateau][subrefLandZoneCount] = 0
end

local function RecordAllPlateaus()
    --Records any plateaus that contain mexes, along with info on the plateau
    --tAllPlateaus[iSegmentGroup] can be used to then reference subtables with further information on the plateau, where iSegmentGroup is the result of NavUtils.GetLabel(refPathingTypeAmphibious, {x,y,z})

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAllPlateaus'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iCurPlateauMex
    local iMinSegmentX, iMinSegmentZ, iMaxSegmentX, iMaxSegmentZ, iCurSegmentGroup

    if bDebugMessages == true then LOG(sFunctionRef..': About to get max map segment X and Z based on rMapPlayableArea='..repru(rMapPlayableArea)) end
    local iMapMaxSegmentX, iMapMaxSegmentZ = GetPathingSegmentFromPosition({rMapPlayableArea[3], 0, rMapPlayableArea[4]})
    local iStartSegmentX, iStartSegmentZ
    local bSearchingForBoundary
    local iCurCount
    local tSegmentPosition
    local iReclaimSegmentStartX, iReclaimSegmentStartZ, iReclaimSegmentEndX, iReclaimSegmentEndZ
    local sPathing = refPathingTypeAmphibious


    --Cycle through every amphibious pathing group that has mexes in it:
    for iSegmentGroup, tSubtable in tMexByPathingAndGrouping[sPathing] do
        --If we dont already have a plateau setup then create one:
        if not(tAllPlateaus[iSegmentGroup]) then
            --Have a plateau with mexes that havent already recorded
            tAllPlateaus[iSegmentGroup] = {}
            tAllPlateaus[iSegmentGroup][subrefPlateauMexes] = {}
            iCurPlateauMex = 0
            --Record every mex against the PlateausWithMexes table:
            for iMex, tMex in tMexByPathingAndGrouping[sPathing][iSegmentGroup] do
                iCurPlateauMex = iCurPlateauMex + 1
                tAllPlateaus[iSegmentGroup][subrefPlateauMexes][iCurPlateauMex] = tMex
            end
            tAllPlateaus[iSegmentGroup][subrefPlateauTotalMexCount] = iCurPlateauMex
            --Record additional information if the plateau has mexes:
            if iCurPlateauMex > 0 then
                --Record information on the size of the plateau:
                    --Start from mex, and move up on map to determine top point; then move left to determine left point, and right to determine right point etc.
                    --i.e. dont want to go through every segment on map since could take ages if lots of plateaus and may only be dealing with small area
                iStartSegmentX, iStartSegmentZ = GetPathingSegmentFromPosition(tAllPlateaus[iSegmentGroup][subrefPlateauMexes][1])

                --First find the smallest z (so go up)
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount > iStartSegmentZ then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments(iStartSegmentX, iStartSegmentZ - iCurCount))  --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX][iStartSegmentZ - iCurCount]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartX = 1, iMapMaxSegmentX do
                            iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments(iAltStartX, iStartSegmentZ - iCurCount)) --tPathingSegmentGroupBySegment[sPathing][iAltStartX][iStartSegmentZ - iCurCount]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentX = iAltStartX
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                --Will have the min Z value now
                iMinSegmentZ = iStartSegmentZ - iCurCount + 1


                --Now check for the min X value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount > iStartSegmentX then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments((iStartSegmentX - iCurCount), iStartSegmentZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX - iCurCount][iStartSegmentZ]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same X value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartZ = iMinSegmentZ, iMapMaxSegmentZ do
                            iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments((iStartSegmentX - iCurCount), iAltStartZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX - iCurCount][iAltStartZ]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentZ = iAltStartZ
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end

                --Will now have the min X value
                iMinSegmentX = iStartSegmentX - iCurCount + 1

                --Now get max Z value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount + iStartSegmentZ > iMapMaxSegmentZ then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments(iStartSegmentX, (iStartSegmentZ + iCurCount))) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX][iStartSegmentZ + iCurCount]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartX = iMinSegmentX, iMapMaxSegmentX do
                            iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments(iAltStartX, (iStartSegmentZ + iCurCount))) --tPathingSegmentGroupBySegment[sPathing][iAltStartX][iStartSegmentZ + iCurCount]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentX = iAltStartX
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                iMaxSegmentZ = iStartSegmentZ + iCurCount - 1

                --Now get the max X value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount + iStartSegmentX > iMapMaxSegmentX then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments((iStartSegmentX + iCurCount), iStartSegmentZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX + iCurCount][iStartSegmentZ]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartZ = iMinSegmentZ, iMaxSegmentZ do
                            iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments((iStartSegmentX + iCurCount), iAltStartZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX + iCurCount][iAltStartZ]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentZ = iAltStartZ
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                iMaxSegmentX = iStartSegmentX + iCurCount - 1

                --Have now got the min and max land segment X and Z values for the plateau
                tSegmentPosition = GetPositionFromPathingSegments(iMinSegmentX, iMinSegmentZ)
                tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ] = {tSegmentPosition[1], tSegmentPosition[3]}
                iReclaimSegmentStartX, iReclaimSegmentStartZ = GetReclaimSegmentsFromLocation(tSegmentPosition)

                tSegmentPosition = GetPositionFromPathingSegments(iMaxSegmentX, iMaxSegmentZ)
                tAllPlateaus[iSegmentGroup][subrefPlateauMaxXZ] = {tSegmentPosition[1], tSegmentPosition[3]}
                iReclaimSegmentEndX, iReclaimSegmentEndZ = GetReclaimSegmentsFromLocation(tSegmentPosition)


                --Record all reclaim segments that are part of the plateau
                tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments] = {}
                for iCurReclaimSegmentX = iReclaimSegmentStartX, iReclaimSegmentEndX do
                    tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX] = {}
                    for iCurReclaimSegmentZ = iReclaimSegmentStartZ, iReclaimSegmentEndZ do
                        if iSegmentGroup == GetSegmentGroupOfLocation(sPathing, GetReclaimLocationFromSegment(iCurReclaimSegmentX, iCurReclaimSegmentZ)) then
                            tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX][iCurReclaimSegmentZ] = true
                        end
                    end
                end
                --Clear any empty values
                for iCurReclaimSegmentX = iReclaimSegmentStartX, iReclaimSegmentEndX do
                    if tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX] and M28Utilities.IsTableEmpty(tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX]) then tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX] = nil end
                end

                --Record midpoint of the plateau
                local iXRadius = (tAllPlateaus[iSegmentGroup][subrefPlateauMaxXZ][1] - tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ][1])*0.5
                local iZRadius = (tAllPlateaus[iSegmentGroup][subrefPlateauMaxXZ][2] - tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ][2])*0.5
                tAllPlateaus[iSegmentGroup][subrefPlateauMidpoint] = {tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ][1] + iXRadius, 0, tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ][2] + iZRadius}
                tAllPlateaus[iSegmentGroup][subrefPlateauMidpoint][2] = GetTerrainHeight(tAllPlateaus[iSegmentGroup][subrefPlateauMidpoint][1], tAllPlateaus[iSegmentGroup][subrefPlateauMidpoint][3])
                --CIrcle radius will be the square/rectangle diagonal, so (square radius^2*2)^0.5 for a square, or (x^2+z^2)^0.5

                tAllPlateaus[iSegmentGroup][subrefPlateauMaxRadius] = (iXRadius^2+iZRadius^2)^0.5
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, listing tAllPlateaus='..repru(tAllPlateaus)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param iPlateau number
local function AddNewLandZoneReferenceToPlateau(iPlateau)
    --Adds a new land zone reference number to iPlateau, assumes that information about the zone will be added later
    --Intended to be called as part of wider code for recording a land zone, e.g. from CreateNewLandZoneAtSegment and similar functions
    --iPlateau is the result of NavUtils.GetLabel(refPathingTypeAmphibious, tLocation)
    --To get the land zone created by this immediately after it is created, use iLandZone = tAllPlateaus[iPlateau][subrefLandZoneCount]
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddNewLandZoneReferenceToPlateau'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    if not(tAllPlateaus[iPlateau]) then
        --Presumably we have a plateau with no mexes so add this plateau to the table of plateaus
        tAllPlateaus[iPlateau] = {}
        tAllPlateaus[iPlateau][subrefPlateauTotalMexCount] = 0
    end
    if not(tAllPlateaus[iPlateau][subrefLandZoneCount]) then
        tAllPlateaus[iPlateau][subrefLandZoneCount] = 0
        tAllPlateaus[iPlateau][subrefPlateauLandZones] = {}
    end
    tAllPlateaus[iPlateau][subrefLandZoneCount] = (tAllPlateaus[iPlateau][subrefLandZoneCount] or 0) + 1
    local iLandZone = tAllPlateaus[iPlateau][subrefLandZoneCount]
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexCount] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexLocations] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexUnbuiltLocations] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZHydroLocations] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZHydroUnbuiltLocations] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTotalMassReclaim] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZBuildLocationsBySize] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZBuildLocationSegmentCountBySize] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTotalSegmentCount] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTotalMassReclaim] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTotalEnergyReclaim] = 0
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTravelDistToOtherLandZones] = {}
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZPlayerWallSegments] = {}

    if bDebugMessages == true then LOG('Finished setting up variables for iPlateau='..iPlateau..'; iLandZone='..iLandZone) end


    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end



function RecordSegmentLandZone(iSegmentX, iSegmentZ, iPlateau, iLandZone)
    if not(tLandZoneBySegment[iSegmentX]) then tLandZoneBySegment[iSegmentX] = {} end
    tLandZoneBySegment[iSegmentX][iSegmentZ] = iLandZone
    if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments]) then
        if not(tAllPlateaus[iPlateau]) then RecordMexlessPlateau(iPlateau) end
        if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]) then
            AddNewLandZoneReferenceToPlateau(iPlateau)
            iLandZone = tAllPlateaus[iPlateau][subrefLandZoneCount]
        end

    end
    if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments]) then
        LOG('ERROR - RecordSegmentLandZoneTempLog: iSegmentX='..(iSegmentX or 'nil')..'; iSegmentZ='..(iSegmentZ or 'nil')..'; iLandZone='..(iLandZone or 'nil')..'; iPlateau='..(iPlateau or 'nil')..'; tAllPlateaus[iPlateau][subrefPlateauLandZones]='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones]))
        M28Utilities.DrawLocation(GetPositionFromPathingSegments(iSegmentX, iSegmentZ), 1, 200, 3)
    else
        table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments], {iSegmentX, iSegmentZ})
        tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTotalSegmentCount] = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTotalSegmentCount] + 1
    end
end

local function ReorderLandZoneSegmentsForEachPlateau()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReorderLandZoneSegmentsForEachPlateau'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Updates tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments] so it is sorted based on the distance to the middle of the zone
    local iMidSegmentX, iMidSegmentZ
    local tiSegmentsByDistance
    local tiSortedSegmentsByDistance
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLZSubtable in tPlateauSubtable[subrefPlateauLandZones] do
            tiSegmentsByDistance = {}
            tiSortedSegmentsByDistance = {}
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Midpoint='..repru(tLZSubtable[subrefLZMidpoint])) end
            iMidSegmentX, iMidSegmentZ = GetPathingSegmentFromPosition(tLZSubtable[subrefLZMidpoint])
            if bDebugMessages == true then LOG(sFunctionRef..': About to reorder the segments in iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Segments before sorting='..repru(tLZSubtable[subrefLZSegments])) end
            for iSegmentRef, tSegmentXZ in tLZSubtable[subrefLZSegments] do
                table.insert(tiSegmentsByDistance, {['Segments']={tSegmentXZ[1], tSegmentXZ[2]}, ['Distance']=(math.abs(tSegmentXZ[1] - iMidSegmentX) + math.abs(tSegmentXZ[2] - iMidSegmentZ))})
            end
            --Now sort by distance
            tLZSubtable[subrefLZSegments] = {}
            if bDebugMessages == true then LOG(sFunctionRef..': tiSegmentsByDistance='..repru(tiSegmentsByDistance)) end
            for iEntry, tValue in M28Utilities.SortTableBySubtable(tiSegmentsByDistance, 'Distance', true) do
                if bDebugMessages == true then LOG(sFunctionRef..': iEntry='..iEntry..';tValue='..repru(tValue)..'; Inserting value '..repru(tValue['Segments'])..' into the main LZSubtable') end
                table.insert(tLZSubtable[subrefLZSegments], tValue['Segments'])
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished sorting for iPlateau='..iPlateau..'; iLandZone='..iLandZone..'; Segments after sorting='..repru(tLZSubtable[subrefLZSegments])) end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


---@param iBaseSegmentX number
---@param iBaseSegmentZ number
local function CreateNewLandZoneAtSegment(iBaseSegmentX, iBaseSegmentZ)
    --Creates a new land zone reference at the land segment given by iBaseSegmentX-iBaseSegmentZ (includes adding new land zone reference to the plateau group that these segments are part of)
    --iBaseSegmentX and Z are the land segment X and Z references
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CreateNewLandZoneAtSegment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --First check we dont have a zone assigned already (redundancy)
    if not(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]) then
        --PlateauGroup ref will be the amphibious pathing ref from navutils.getlabel (since that's what is used to define mexes by amphibious pathing group, and plateau recognition then uses the same reference)
        local tMidpoint = GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
        local iPlateau = NavUtils.GetLabel(refPathingTypeAmphibious, tMidpoint)
        AddNewLandZoneReferenceToPlateau(iPlateau)
        --LOG('Have just created a new land zone reference for base segment XZ='..iBaseSegmentX..'-'..iBaseSegmentZ..' in the iPlateau='..iPlateau)
        RecordSegmentLandZone(iBaseSegmentX, iBaseSegmentZ, iPlateau, tAllPlateaus[iPlateau][subrefLandZoneCount])

    else
        M28Utilities.ErrorHandler('Trying to create a new zone for base segment '..iBaseSegmentX..'-'..iBaseSegmentZ..' when it already has a land zone assigned '..tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ])
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param iPlateau number
---@param iOptionalLandZone number
---@param iPlateauMexRef number
---@param tTempPlateauLandZoneByMexRef table
local function AddMexToLandZone(iPlateau, iOptionalLandZone, iPlateauMexRef, tTempPlateauLandZoneByMexRef)
    --Determine the land zone if it isnt specified
        --iPlateau is the result of NavUtils.GetLabel(refPathingTypeAmphibious, tLocation)
        --iOptionalLandZone - if not specified, then this will create a new land zone for iPlateau and use htis reference
        --iPlateauMexRef - the reference key in the table tAllPlateaus[iPlateau][subrefPlateauMexes], which should return the location of the mex
        --tTempPlateauLandZoneByMexRef - temporary table used to store information for purposes of creating the land zones

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddMexToLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Get the land zone that we are using (/create a new land zone if we haven't had one specified to be used):
    local iLandZone
    if iOptionalLandZone then iLandZone = iOptionalLandZone
    else
        AddNewLandZoneReferenceToPlateau(iPlateau)
        iLandZone = tAllPlateaus[iPlateau][subrefLandZoneCount]
    end

    --Add the mex to this land zone
    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexCount] = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexCount] + 1
    table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZMexLocations], tAllPlateaus[iPlateau][subrefPlateauMexes][iPlateauMexRef])
    tTempPlateauLandZoneByMexRef[iPlateau][iPlateauMexRef] = iLandZone
    local iCurSegmentX, iCurSegmentZ = GetPathingSegmentFromPosition(tAllPlateaus[iPlateau][subrefPlateauMexes][iPlateauMexRef])
    RecordSegmentLandZone(iCurSegmentX, iCurSegmentZ, iPlateau, iLandZone)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function AssignTempSegmentsWithDistance()
    --Used to go through the temporary table tTempZoneTravelDistanceBySegment and assign any segments within here to the nearest land zone
    --i.e. Assumes tTempZoneTravelDistanceBySegment has been setup and is a table that has [SegmentX][SegmentZ] values that returns a table with [zone] as the key, which in turn returns the pathing distance from SegmentX-SegmentZ for each zone
    --Goes through all the distance values in tTempZoneTravelDistanceBySegment and picks the lowest distance, and then assigns the X+Z segment to land zone that corresponds to that distance, then clears the table tTempZoneTravelDistanceBySegment


    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignTempSegmentsWithDistance'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iLowestDistance
    local iLowestZone
    local iCurPlateau
    --Cycle through every entry
    if M28Utilities.IsTableEmpty(tTempZoneTravelDistanceBySegment) == false then
        for iCurSegmentX, tSubtable in tTempZoneTravelDistanceBySegment do
            if not(tLandZoneBySegment[iCurSegmentX]) then tLandZoneBySegment[iCurSegmentX] = {} end
            for iCurSegmentZ, tDistanceByZone in tSubtable do
                --Have we not recorded a zone for this segment?
                if not(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]) then
                    iLowestDistance = 10000
                    iLowestZone = nil
                    --Cycle through every distance that has been recorded for this segment, and record the lowest distance and the zone that corresponds to this distance
                    if M28Utilities.IsTableEmpty(tDistanceByZone) == false then
                        for iZone, iDistance in tDistanceByZone do
                            if iDistance < iLowestDistance then
                                iLowestDistance = iDistance
                                iLowestZone = iZone
                            end
                        end
                        --if bDebugMessages == true then LOG(sFunctionRef..': iCurSegmentX='..iCurSegmentX..'; iCurSegmentZ='..iCurSegmentZ..'; Position from pathing segments='..repru(GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ))..'; iLowestZone='..(iLowestZone or 'nil')..'; plateau group='..(NavUtils.GetLabel(refPathingTypeAmphibious, GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)) or 'nil')) end
                        iCurPlateau = NavUtils.GetLabel(refPathingTypeAmphibious, GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ))
                        if not(iCurPlateau) then
                            --We have a land zone, so presumably this segment in isolation isn't in somewhere we recognise, but it is near somewhere suitable; keep searching nearby segments to try and find this land zone
                            iCurPlateau = tTempZonePlateauBySegment[iCurSegmentX][iCurSegmentZ][iLowestZone]

                        end
                        RecordSegmentLandZone(iCurSegmentX, iCurSegmentZ, iCurPlateau, iLowestZone)
                    end
                end
                tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ] = nil --Clear the value so when we cycle through in the future we dont reconsider this
                tTempZonePlateauBySegment[iCurSegmentX][iCurSegmentZ] = nil
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function AssignSegmentsNearMexesToLandZones()
    --Assigns every land pathable segment near a mex to that mex's land zone (where mexes from multiple zones are nearby then it picks the closest one)

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignSegmentsNearMexesToLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    local iMaxSegmentSearchDistance = math.max(10, math.ceil(85 / iLandZoneSegmentSize)) --NOTE: If changing this consider if also want to change the value for AssignRemainingSegmentsToLandZones
    local iDistanceCap = math.max(100, iMaxSegmentSearchDistance * iLandZoneSegmentSize + 15)

    local iBaseSegmentX, iBaseSegmentZ
    local iPathingGroupWanted
    local tCurPosition
    local iCurZone
    local iCurTravelDist
    tTempZoneTravelDistanceBySegment = {} --[x][z] are the segment x and z values, returns a table with a key which is the zone ID, which returns the travel distance for that zone
    tTempZonePlateauBySegment = {}
    local iCurSegmentX, iCurSegmentZ
    local iMaxAdjustedX,iMaxAdjustedZ, iMinAdjustedX, iMinAdjustedZ
    if bDebugMessages == true then LOG(sFunctionRef..': Will record areas around mexes, iMaxSegmentSearchDistance='..iMaxSegmentSearchDistance..'; iDistanceCap='..iDistanceCap..'; iLandZoneSegmentSize='..iLandZoneSegmentSize) end

    --Cycle through every plateau, and then every mex within every plateau
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iMex, tMex in tPlateauSubtable[subrefPlateauMexes] do
            iBaseSegmentX, iBaseSegmentZ = GetPathingSegmentFromPosition(tMex)
            iPathingGroupWanted = NavUtils.GetLabel(refPathingTypeLand, tMex)
            iCurZone = tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]
            iMaxAdjustedX = math.min(iMaxSegmentSearchDistance + iBaseSegmentX, iMaxLandSegmentX)
            iMaxAdjustedZ = math.min(iMaxSegmentSearchDistance + iBaseSegmentZ, iMaxLandSegmentZ)
            iMinAdjustedX = math.max(1, iBaseSegmentX-iMaxSegmentSearchDistance)
            iMinAdjustedZ = math.max(1, iBaseSegmentZ-iMaxSegmentSearchDistance)

            --Cycle through the segments around this mex:
            for iCurSegmentX = iMinAdjustedX, iMaxAdjustedX, 1 do
                --iCurSegmentX = iBaseSegmentX + iSegmentXAdjust
                if not(tLandZoneBySegment[iCurSegmentX]) then
                    tLandZoneBySegment[iCurSegmentX] = {}
                    tTempZoneTravelDistanceBySegment[iCurSegmentX] = {}
                    tTempZonePlateauBySegment[iCurSegmentX] = {}
                end
                for iCurSegmentZ = iMinAdjustedZ, iMaxAdjustedZ, 1 do

                    --Check we can path to this segment from the mex with land units:
                    tCurPosition = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                    if NavUtils.GetLabel(refPathingTypeLand, tCurPosition) == iPathingGroupWanted then
                        if not(tTempZoneTravelDistanceBySegment[iCurSegmentX]) then
                            tTempZoneTravelDistanceBySegment[iCurSegmentX] = {}
                            tTempZonePlateauBySegment[iCurSegmentX] = {}
                        end
                        if not(tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ]) then
                            tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ] = {}
                            tTempZonePlateauBySegment[iCurSegmentX][iCurSegmentZ] = {}
                        end
                        --Record how long it will take to travel from this position to the mex in a temporary table (that we will then consider later after recording all such values, so we can pick the closest mex zone)
                        iCurTravelDist = M28Utilities.GetTravelDistanceBetweenPositions(tMex, tCurPosition)
                        if (iCurTravelDist or 100000) < iDistanceCap then
                            tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ][iCurZone] = math.min(iCurTravelDist, (tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ][iCurZone] or 100000))
                            tTempZonePlateauBySegment[iCurSegmentX][iCurSegmentZ][iCurZone] = iPlateau
                        end
                    end
                end
            end

        end
    end
    --Now go through each segment in tTempZoneTravelDistanceBySegment and pick the lowest value
    AssignTempSegmentsWithDistance()

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param iBaseSegmentX number
---@param iBaseSegmentZ number
---@param iLandPathingGroupWanted number
---@param tBasePosition table
---@param iMaxSegmentSearchDistance number
---@param iDistanceCap number
---@param bUseRoughPathingDistance boolean
local function RecordTemporaryTravelDistanceForBaseSegment(iBaseSegmentX, iBaseSegmentZ, iLandPathingGroupWanted, tBasePosition, iMaxSegmentSearchDistance, iDistanceCap, bUseRoughPathingDistance)
    --Cycle through segments adjacent to the base segment to see if they have a land zone assigned; if they do, check how far it takes to path to the base segment, and record in the tTempZoneTravelDistanceBySegment any zones that are within the distance cap
    --iMaxSegmentSearchDistance - number of segments to search (will do +/- this)
    --iDistanceCap - will ignore any segment zones further away than this
    --bUseRoughPathingDistance - will rely on the default FAF pathfinding distance rather than manually recalculating all the distance values (runs quicker, but less accurate)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordTemporaryTravelDistanceForBaseSegment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tCurPosition
    local iCurZone, iCurTravelDist
    local bAbort = false --if we find a really close location then will stop looking for better ones

    if bDebugMessages == true then LOG(sFunctionRef..': About to look for segments near base segment '..iBaseSegmentX..'-'..iBaseSegmentZ..'; iMaxSegmentSearchDistance='..iMaxSegmentSearchDistance..'; iDistanceCap='..iDistanceCap..'; iLandPathingGroupWanted='..(iLandPathingGroupWanted or 'nil')) end

    local iAbortThreshold --This is used so we can stop looking through nearby segments if we find one that is likely to be the closest we will find

    --Below sub-function will consider the segment iCurSegmentX-iCurSegmentZ, if it has a land zone assigned then will check how far it is to the base segment and if it satisfies the requirements then will record in the temporary table of distances
    function CheckAndRecordTemporaryDistanceForCurSegment(iCurSegmentX, iCurSegmentZ)
        --Does the segment have a land zone assigned, and we haven't just assigned it in this loop?
        if bDebugMessages == true then
            LOG(sFunctionRef..': Considering curSegmentX-z='..iCurSegmentX..'-'..iCurSegmentZ..'; Will note if we have a landzone for this')
            if tLandZoneBySegment[iCurSegmentX] then LOG('tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]='..repru(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]))
            else
                LOG('Dont have any land zone for anything with semgnet X='..iCurSegmentX)
            end
        end
        if tLandZoneBySegment[iCurSegmentX] and tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] then --and (not(tTempZoneTravelDistanceBySegment[iCurSegmentX]) or not(tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ])) then
            tCurPosition = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
            if bDebugMessages == true then LOG(sFunctionRef..': Have a land zone for CurSegmentX-Z'..iCurSegmentX..'-'..iCurSegmentZ..'; Pathing label of this segment='..NavUtils.GetLabel(refPathingTypeLand, tCurPosition)..'; iLandPathingGroupWanted='..iLandPathingGroupWanted) end
            if NavUtils.GetLabel(refPathingTypeLand, tCurPosition) == iLandPathingGroupWanted then

                if bUseRoughPathingDistance then
                    iCurTravelDist = M28Utilities.GetApproxTravelDistanceBetweenPositions(tBasePosition, tCurPosition)
                else
                    iCurTravelDist = M28Utilities.GetTravelDistanceBetweenPositions(tBasePosition, tCurPosition)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iCurTravelDist='..iCurTravelDist) end
                if (iCurTravelDist or 100000) < iDistanceCap then

                    --Update the distance between the bsae segment and a segment in iCurZone to the lower of the current distance and any previously recorded distance
                    iCurZone = tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]
                    if bDebugMessages == true then LOG(sFunctionRef..': We have a segment nearby with a land zone, iCurZone='..iCurZone..'; will record iCurTravelDist of '..iCurTravelDist..'; against the base segment') end
                    tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ][iCurZone] = math.min(iCurTravelDist, (tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ][iCurZone] or 100000))
                    if not(tTempZonePlateauBySegment[iBaseSegmentX][iBaseSegmentZ][iCurZone]) then tTempZonePlateauBySegment[iBaseSegmentX][iBaseSegmentZ][iCurZone] = NavUtils.GetLabel(refPathingTypeAmphibious, tCurPosition) end
                    if iCurTravelDist <= iAbortThreshold then
                        if bDebugMessages == true then LOG(sFunctionRef..': Found a really close segment so will stop looking for more') end
                        bAbort = true
                    end
                end
            end
        end
    end

    local iMaxAdjustedX, iMaxAdjustedZ, iMinAdjustedX, iMinAdjustedZ, iZInterval

    --Cycle through each segment, starting with those closest to the base position
    for iAdjustmentSize = 1, iMaxSegmentSearchDistance do
        iAbortThreshold = iLandZoneSegmentSize * (iAdjustmentSize * 1.3 + 1)
        iMaxAdjustedX = math.min(iAdjustmentSize + iBaseSegmentX, iMaxLandSegmentX)
        iMaxAdjustedZ = math.min(iAdjustmentSize + iBaseSegmentZ, iMaxLandSegmentZ)
        iMinAdjustedX = math.max(1, iBaseSegmentX-iAdjustmentSize)
        iMinAdjustedZ = math.max(1, iBaseSegmentZ-iAdjustmentSize)
        iZInterval = math.max(1, iMaxAdjustedZ - iMinAdjustedZ)



        for iCurSegmentX = iMinAdjustedX, iMaxAdjustedX, 1 do
            --Since we are starting from the closest segments and moving out, we effectively want to cycle through a hollow square of segments with each change in iAdjustmentSize:
            if iCurSegmentX == iMinAdjustedX or iCurSegmentX == iMaxAdjustedX then
                for iCurSegmentZ = iMinAdjustedZ, iMaxAdjustedZ, 1 do
                    CheckAndRecordTemporaryDistanceForCurSegment(iCurSegmentX, iCurSegmentZ)
                    if bAbort then break end
                end
            else
                for iCurSegmentZ = iMinAdjustedZ, iMaxAdjustedZ, iZInterval do
                    CheckAndRecordTemporaryDistanceForCurSegment(iCurSegmentX, iCurSegmentZ)
                    if bAbort then break end
                end
            end
            if bAbort then break end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Finsihed recording if we have any nearby zones that can path here, tTempZoneTravelDistanceBySegment for base segment '..iBaseSegmentX..'-'..iBaseSegmentZ..'='..repru(tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ])..'; bAbort='..tostring(bAbort)) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param iBaseSegmentX number
---@param iBaseSegmentZ number
---@param iLandZone number
---@param iSegmentSearchRange number
---@param iDistanceCap number
local function AssignNearbySegmentsToSameLandZone(iBaseSegmentX, iBaseSegmentZ, iSegmentSearchRange, iDistanceCap)
    --Cycles through every segment within iSegmentSearchRange of the base segment X-Z value, and if the pathing distance is within the distance cap iDistanceCap then will assign it to the same land zone as the base segment X and Z
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignNearbySegmentsToSameLandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iLandZone = tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]
    local iCurTravelDist
    local tBaseMidpoint = GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
    local iPlateau = NavUtils.GetLabel(refPathingTypeAmphibious, tBaseMidpoint)
    for iCurSegmentX = math.max(1, iBaseSegmentX - iSegmentSearchRange), math.min(iBaseSegmentX + iSegmentSearchRange, iMaxLandSegmentX), 1 do
        for iCurSegmentZ = math.max(1, iBaseSegmentZ - iSegmentSearchRange), math.min(iBaseSegmentZ + iSegmentSearchRange, iMaxLandSegmentZ), 1 do
            if not(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]) then
                iCurTravelDist = M28Utilities.GetTravelDistanceBetweenPositions(GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ), tBaseMidpoint)
                if (iCurTravelDist or 100000) <= iDistanceCap then
                    if not(tLandZoneBySegment[iCurSegmentX]) then tLandZoneBySegment[iCurSegmentX] = {} end
                    RecordSegmentLandZone(iCurSegmentX, iCurSegmentZ, iPlateau, iLandZone)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end


local function AssignRemainingSegmentsToLandZones()
    --Cycles through key points on the map and if they ahve no nearby land zone then creates a new land zone
    --then cycles through every segment on the map and if it has no land zone assigns it to the nearest existing land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignRemainingSegmentsToLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --rMapPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2}
    local iLandPathingGroupWanted
    local iPlateauGroup

    local iMaxSegmentSearchDistance = math.max(3, math.ceil(40 / iLandZoneSegmentSize)) --NOTE: If changing this consider if also want to change the value for AssignSegmentsNearMexesToLandZones; for first draft have this as slightly lower
    local iDistanceCap = math.max(40, iMaxSegmentSearchDistance * iLandZoneSegmentSize)

    local tBasePosition

    --Create a new zone for any locations with no nearby pathable zones
    local iNewZoneCount = 0
    local iBasePositionX = - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[1]
    local iBasePositionZ
    local iNearbyAssignmentSegmentRange = math.min(iMaxSegmentSearchDistance, math.ceil(iMaxSegmentSearchDistance * 0.5) + 1)
    local tiLZEntryByNavUtilsRef = {}

    --Subfunction that checks nearby segments that we can path to with a land zone already assigned, and if there are none then creates a new land zone for the base position and assigns segments near it to the same land zone
    function CheckForNearbyZonesAndCreateNewZoneIfNeeded(iBaseSegmentX, iBaseSegmentZ, iBasePositionX, iBasePositionZ, bUseRoughPathingDistance)
        if not(tLandZoneBySegment[iBaseSegmentX] and tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]) then
            tBasePosition = {iBasePositionX, 0, iBasePositionZ} --GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
            iLandPathingGroupWanted = NavUtils.GetLabel(refPathingTypeLand, tBasePosition)
            if (iLandPathingGroupWanted or 0) > 0 then
                --Are we from a plateau that has mexes?
                iPlateauGroup = NavUtils.GetLabel(refPathingTypeAmphibious, tBasePosition)
                if not(iPlateauGroup) then
                    local tiAdjust = {{-1,0}, {-1, -1}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1,1}}
                    for iEntry, tXZAdjust in tiAdjust do
                        iPlateauGroup = NavUtils.GetLabel(refPathingTypeAmphibious, { tBasePosition[1] + tXZAdjust[1], tBasePosition[2], tBasePosition[3] + tXZAdjust[2] })
                        if iPlateauGroup then break end
                    end
                end
                if tAllPlateaus[iPlateauGroup][subrefPlateauTotalMexCount] > 0 then


                    --Dont create a new zone if we have a nearby zone
                    if not(tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ]) then
                        if not(tTempZoneTravelDistanceBySegment[iBaseSegmentX]) then
                            tTempZoneTravelDistanceBySegment[iBaseSegmentX] = {}
                            tTempZonePlateauBySegment[iBaseSegmentX] = {}
                        end
                        tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ] = {}
                        tTempZonePlateauBySegment[iBaseSegmentX][iBaseSegmentZ] = {}
                    end

                    --Cycle through adjacent segments to see if they have a zone, and if so check how far away the segment is from the base segment
                    RecordTemporaryTravelDistanceForBaseSegment(iBaseSegmentX, iBaseSegmentZ, iLandPathingGroupWanted, tBasePosition, iMaxSegmentSearchDistance, iDistanceCap, bUseRoughPathingDistance)

                    --Create a new zone if no segments nearby that already have a land zone that we can path to
                    if M28Utilities.IsTableEmpty(tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ]) then
                        if bDebugMessages == true then
                            LOG(sFunctionRef..': Have no temp travel distance recorded so have created a new land zone for segmentX-Z='..iBaseSegmentX..'-'..iBaseSegmentZ..'; Position from segments='..repru(GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ))..'; tBasePosition (should be the same)='..repru(tBasePosition)..'; will draw midpoint in red.  iNewZoneCount before increasing by 1='..iNewZoneCount..'; Plateau group of the segment midpoint='..(NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)) or 'nil'))
                            M28Utilities.DrawLocation(GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ))
                        end
                        CreateNewLandZoneAtSegment(iBaseSegmentX, iBaseSegmentZ)
                        iNewZoneCount = iNewZoneCount + 1

                        --Assign very nearby segments to this
                        AssignNearbySegmentsToSameLandZone(iBaseSegmentX, iBaseSegmentZ, iNewZoneCount, iNearbyAssignmentSegmentRange, iDistanceCap)
                    end
                elseif iPlateauGroup > 0 then
                    --Plateau has no mexes so just create one large group based on the land pathing, if we havent already
                    if not(tiLZEntryByNavUtilsRef[iPlateauGroup][iLandPathingGroupWanted]) then
                        --We haven't created this LZ yet; have we created the plateau?
                        if not(tAllPlateaus[iPlateauGroup]) then
                            RecordMexlessPlateau(iPlateauGroup)
                        end

                        if not(tiLZEntryByNavUtilsRef[iPlateauGroup]) then
                            tiLZEntryByNavUtilsRef[iPlateauGroup] = {}
                        end

                        --Need to add land zone reference to this plateau
                        AddNewLandZoneReferenceToPlateau(iPlateauGroup)
                        tiLZEntryByNavUtilsRef[iPlateauGroup][iLandPathingGroupWanted] = tAllPlateaus[iPlateauGroup][subrefLandZoneCount]
                        RecordSegmentLandZone(iBaseSegmentX, iBaseSegmentZ, iPlateauGroup, tAllPlateaus[iPlateauGroup][subrefLandZoneCount])
                    else
                        RecordSegmentLandZone(iBaseSegmentX, iBaseSegmentZ, iPlateauGroup, tiLZEntryByNavUtilsRef[iPlateauGroup][iLandPathingGroupWanted])
                    end
                else
                    M28Utilities.ErrorHandler('somehow have a land zone but not a plateau group; Refer to log for base position and other details if logs are enabled')
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Base position='..repru(tBasePosition)..'; Land nav='..(NavUtils.GetLabel(refPathingTypeLand, tBasePosition) or 'nil')..'; Plateau nav='..(NavUtils.GetLabel(refPathingTypeAmphibious, tBasePosition) or 'nil'))
                        M28Utilities.DrawLocation(tBasePosition)
                    end

                end
            end
        end
    end

    --Cycle through every segment on the map, but only consider every iMaxSegmentSearchDistance 'th segment (for performance reasons), and check if it has nearby land zones, and if not then create a new land zone at this position
    for iBaseSegmentX = iMaxSegmentSearchDistance, iMaxLandSegmentX, iMaxSegmentSearchDistance do
        iBasePositionX = iBasePositionX + iLandZoneSegmentSize * iMaxSegmentSearchDistance --Manually done instead of GetPositionFromPathingSegments for performance
        iBasePositionZ = - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[2]

        if not(tLandZoneBySegment[iBaseSegmentX]) then tLandZoneBySegment[iBaseSegmentX] = {} end
        if not(tTempZoneTravelDistanceBySegment[iBaseSegmentX]) then
            tTempZoneTravelDistanceBySegment[iBaseSegmentX] = {}
            tTempZonePlateauBySegment[iBaseSegmentX] = {}
        end
        for iBaseSegmentZ = iMaxSegmentSearchDistance, iMaxLandSegmentZ, iMaxSegmentSearchDistance do
            iBasePositionZ = iBasePositionZ + iLandZoneSegmentSize * iMaxSegmentSearchDistance
            --Check we dont already have a zone assigned
            CheckForNearbyZonesAndCreateNewZoneIfNeeded(iBaseSegmentX, iBaseSegmentZ, iBasePositionX, iBasePositionZ)
        end
        --WaitTicks(1)
        if bDebugMessages == true then LOG(sFunctionRef..': Finished all iBaseSegmentX='..iBaseSegmentX..'; moving to next X segments, systemtime='..GetSystemTimeSecondsOnlyForProfileUse()) end
    end
    --Now go through each segment considered and pick the lowest value distance as the assigned land zone
    AssignTempSegmentsWithDistance()
    if bDebugMessages == true then LOG(sFunctionRef..': Finished assigning land zones for locations with no nearby zones, systemtime='..GetSystemTimeSecondsOnlyForProfileUse()) end

    --Now cycle through every segment on the map, and assign to a land zone (or create a new land zone if none nearby, but hopefully after the above code this will be rare)
    iBasePositionX = - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[1] --Calculate the position manually (instead of using the function GetPositionFromPathingSegments) for performance
    for iBaseSegmentX = 1, iMaxLandSegmentX do
        iBasePositionX = iBasePositionX + iLandZoneSegmentSize --(i.e. as per GetPositionFromPathingSegments)
        iBasePositionZ = - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[2]
        for iBaseSegmentZ = 1, iMaxLandSegmentZ do
            iBasePositionZ = iBasePositionZ + iLandZoneSegmentSize
            CheckForNearbyZonesAndCreateNewZoneIfNeeded(iBaseSegmentX, iBaseSegmentZ, iBasePositionX, iBasePositionZ, true)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finsihed creating land zones for any remaining locations with no nearby land zone, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    --The above will have updated the temporary table with details of how long to path to each zone; now go through and assign each segment to the closest zone to it
    AssignTempSegmentsWithDistance()
    if bDebugMessages == true then LOG(sFunctionRef..': Finsihed assigning zones for any temporary distances for the zones created in the previous step, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end


    --Redundancy - cycle through any zones that dont have a segment and create new zones for them - hopefully this shouldnt be possible provided we have setup the segment search ranges correctly above
    for iBaseSegmentX = 1, iMaxLandSegmentX do
        for iBaseSegmentZ = 1, iMaxLandSegmentZ do
            if not(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]) then
                tBasePosition = GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
                iLandPathingGroupWanted = NavUtils.GetLabel(refPathingTypeLand, tBasePosition)
                if (iLandPathingGroupWanted or 0) > 1 and (NavUtils.GetLabel(refPathingTypeAmphibious, tBasePosition) or 0) > 0 then
                    M28Utilities.ErrorHandler('Have an unassigned land zone='..iBaseSegmentX..'-'..iBaseSegmentZ)
                    CreateNewLandZoneAtSegment(iBaseSegmentX, iBaseSegmentZ)
                    RecordTemporaryTravelDistanceForBaseSegment(iBaseSegmentX, iBaseSegmentZ, iLandPathingGroupWanted, tBasePosition, iMaxSegmentSearchDistance, iDistanceCap)
                    AssignTempSegmentsWithDistance()
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished redundancy of checking every segment has a land zone if it is land pathable, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function AssignMexesALandZone()
    --Cycles through every mex and assigns it to a new land zone, unless it is near another mex in which case they should both use the same land zone

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignMexesALandZone'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Key config values
    local iNearbyMexRange --Initially mexes will be grouped together based on this, i.e. will assign mexes within this distance of each other to the same land zone
    local iRecursiveFactor
    --rMapPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2}
    local iMaxMapSize = math.max(rMapPlayableArea[3] - rMapPlayableArea[1], rMapPlayableArea[4] - rMapPlayableArea[2])
    if iMaxMapSize > 1024 then --1024 is 20k, so this is 40k or 80k
        iNearbyMexRange = 54
        iRecursiveFactor = 4
    elseif iMaxMapSize > 512 then --i.e. 20k
        iNearbyMexRange = 46
        iRecursiveFactor = 3.5
    elseif iMaxMapSize > 256 then
        iNearbyMexRange = 42
        iRecursiveFactor = 3
    else
        iNearbyMexRange = 35
        iRecursiveFactor = 2
    end


    if bDebugMessages == true then LOG('About to setup land zones') end

    local tiPlateauLandZoneByMexRef = {} --[x] is plateau ref, [y] is mex number, returns the LZ
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        tiPlateauLandZoneByMexRef[iPlateau] = {}
    end

    --Subfunction - if we have a mex to assign to a land zone then this subfunction should be called to check for any nearby mexes without a zone and assign these to the same zone
    function AddNearbyMexesToLandZone(iPlateau, iCurLandZone, tMex, iRecursiveCount)
        local iLandGroupWanted = NavUtils.GetLabel(refPathingTypeLand, tMex)
        local iMaxRange
        if iRecursiveCount <= 1 then iMaxRange = math.max(15, iNearbyMexRange)
        else iMaxRange = math.max(15, iNearbyMexRange - iRecursiveCount * iRecursiveFactor)
        end
        for iAltMex, tAltMex in tAllPlateaus[iPlateau][subrefPlateauMexes] do
            if not(tiPlateauLandZoneByMexRef[iPlateau][iAltMex]) then
                if NavUtils.GetLabel(refPathingTypeLand, tAltMex) == iLandGroupWanted and not(IsUnderwater(tAltMex, false, 0.1)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iAltMex='..iAltMex..'; Distance straight line='..M28Utilities.GetDistanceBetweenPositions(tAltMex, tMex)..'; Travel distance='..M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex)) end
                    if M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex) <= iMaxRange then
                        AddMexToLandZone(iPlateau, iCurLandZone, iAltMex, tiPlateauLandZoneByMexRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Added mex '..iAltMex..' with position '..repru(tAltMex)..' to land zone, tiPlateauLandZoneByMexRef='..(tiPlateauLandZoneByMexRef[iAltMex] or 'nil')..'; Distance in straight line='..M28Utilities.GetDistanceBetweenPositions(tAltMex, tMex)..'; Travel distance='..M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex)) end
                        AddNearbyMexesToLandZone(iPlateau, iCurLandZone, tAltMex, iRecursiveCount + 1) --Needs to be recursive or else can end up with 2 mees that are really close to each other not being in the same group depending on the order in which the original mexes are called
                    end
                end
            end
        end
    end

    --First setup core base land zones, including merging core bases if they are close to each other into a single land zone - have the size of the core base impacted by if there is a hydro nearby

    --Get the start points to actually consider
    local tRelevantStartPointsByIndex = {}
    for iBrain, oBrain in ArmyBrains do
        if not(M28Conditions.IsCivilianBrain(oBrain)) then
            local iStartPositionX, iStartPositionZ = oBrain:GetArmyStartPos()
            tRelevantStartPointsByIndex[oBrain:GetArmyIndex()] = {iStartPositionX, GetSurfaceHeight(iStartPositionX, iStartPositionZ), iStartPositionZ}
        end
    end

    local tiStartIndexPlateauAndLZ = {} --[x] is the player index, returns the land zone to use
    local iLZToUse
    local iCurPlateau
    --Create a table of the start locations that have their own unique land zone (as we want to combine those that are close together):
    for iIndex, tStartPosition in tRelevantStartPointsByIndex do
        iLZToUse = nil
        iCurPlateau = NavUtils.GetLabel(refPathingTypeAmphibious, tStartPosition)
        --Are we close to an existing start position such that we should use the same LZ for both positions?
        if M28Utilities.IsTableEmpty(tiStartIndexPlateauAndLZ) == false then
            for iExistingIndex, tExistingPlateauAndLZ in tiStartIndexPlateauAndLZ do
                if tExistingPlateauAndLZ[1] == iCurPlateau and M28Utilities.GetDistanceBetweenPositions(tStartPosition, tRelevantStartPointsByIndex[iExistingIndex]) <= 40 then
                    iLZToUse = tExistingPlateauAndLZ[2]
                    break
                end
            end
        end
        if not(iLZToUse) then
            if bDebugMessages == true then LOG(sFunctionRef..': About to add a new LZ reference to iCurPlateau '..(iCurPlateau or 'nil')..' for start position '..repru(tStartPosition)) end
            AddNewLandZoneReferenceToPlateau(iCurPlateau)
            iLZToUse = tAllPlateaus[iCurPlateau][subrefLandZoneCount]
            if bDebugMessages == true then LOG(sFunctionRef..': Just added iLZToUse='..iLZToUse..'; tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]='..reprs(tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iLZToUse])) end
        end
        tiStartIndexPlateauAndLZ[iIndex] = {iCurPlateau, iLZToUse}
        local iCurSegmentX, iCurSegmentZ = GetPathingSegmentFromPosition(tStartPosition)
        RecordSegmentLandZone(iCurSegmentX, iCurSegmentZ, iCurPlateau, iLZToUse)
        if bDebugMessages == true then LOG(sFunctionRef..': Have just recorded iLZToUse='..iLZToUse..' for iCurPlateau='..iCurPlateau..'; iCurSegmentX-Z='..iCurSegmentX..'-'..iCurSegmentZ..'; Start position='..repru(tStartPosition)..'; Brain index='..iIndex) end
    end

    --Now find any mexes within the desired travel distance and assign them to the nearest start position - first exclude based on distance, and if they meet the straight line distance check then consider travel distance
    local iCurDistStraightLine
    local iCurDistTravel
    local iClosestDistTravel
    local iClosestBrainIndex

    local tiStartResourcesByBrainIndex = {}

    local iStraightLineThreshold = 70 --Ignore locations that are more than this distance away
    local iTravelDistThreshold = 75 --Ignore locations that are more than this land travel distance away


    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iMex, tMex in tPlateauSubtable[subrefPlateauMexes] do
            --Find the closest start point
            iClosestDistTravel = iTravelDistThreshold --Ignore points whose travel distance is further away than this
            iClosestBrainIndex = nil
            for iBrainIndex, tStartPoint in tRelevantStartPointsByIndex do
                iCurDistStraightLine = M28Utilities.GetDistanceBetweenPositions(tMex, tStartPoint)
                if iCurDistStraightLine <= iStraightLineThreshold then
                    --Get the land pathing distance
                    iCurDistTravel = M28Utilities.GetTravelDistanceBetweenPositions(tMex, tStartPoint, refPathingTypeLand)
                    if iCurDistTravel < iClosestDistTravel then
                        iClosestDistTravel = iCurDistTravel
                        iClosestBrainIndex = iBrainIndex
                    end
                end
            end
            if iClosestBrainIndex then
                if not(tiStartResourcesByBrainIndex[iClosestBrainIndex]) then tiStartResourcesByBrainIndex[iClosestBrainIndex] = {} end
                table.insert(tiStartResourcesByBrainIndex[iClosestBrainIndex], tMex)
                AddMexToLandZone(iPlateau, tiStartIndexPlateauAndLZ[iClosestBrainIndex][2], iMex, tiPlateauLandZoneByMexRef)
                if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLandZone='..tiStartIndexPlateauAndLZ[iClosestBrainIndex][2]..'; Adding iMex='..iMex..'; at position '..repru(tMex)..'; to the start position for aiBrain index='..iClosestBrainIndex..' which is at '..repru(tRelevantStartPointsByIndex[iClosestBrainIndex])) end
            end
        end
    end

    --Debug - draw the groupings of mexes with rectangles around them to show how they've been grouped, with a different colour for each plateau group:
    if bDebugMessages == true then
        local iColour = 0
        for iPlateau, tPlateauSubtable in tAllPlateaus do
            LOG(sFunctionRef..': About to draw results of land zones for iPlateau='..iPlateau..'; tiPlateauLandZoneByMexRef[iPlateau]='..repru(tiPlateauLandZoneByMexRef[iPlateau])..'; tAllPlateaus[iPlateau][subrefPlateauLandZones]='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones]))
            iColour = 3
            --Draw the mex groupings
            for iZone, tZone in tAllPlateaus[iPlateau][subrefPlateauLandZones] do
                local iMinX = 100000
                local iMaxX = 0
                local iMinZ = 100000
                local iMaxZ = 0

                for iMex, tMex in tZone[subrefLZMexLocations] do
                    iMinX = math.min(tMex[1], iMinX)
                    iMaxX = math.max(tMex[1], iMaxX)
                    iMinZ = math.min(tMex[3], iMinZ)
                    iMaxZ = math.max(tMex[3], iMaxZ)
                end
                M28Utilities.DrawRectangle(Rect(iMinX, iMinZ, iMaxX, iMaxZ), iColour, 1000, 10)
            end
        end
    end

    --Now add any mexes near these resource locations to the same land zone
    if bDebugMessages == true then LOG(sFunctionRef..': Will now add mexes near the start position resources to the same land zone, tiStartResourcesByBrainIndex='..repru(tiStartResourcesByBrainIndex)) end
    for iBrainIndex, tResources in tiStartResourcesByBrainIndex do
        for iResource, tResourceLocation in tResources do
            AddNearbyMexesToLandZone(tiStartIndexPlateauAndLZ[iBrainIndex][1], tiStartIndexPlateauAndLZ[iBrainIndex][2], tResourceLocation, 1)
        end
    end



    --Assign assign zones to mex locations - group mexes that are near each other in the same zone
    local iCurLandZone
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        if not(tAllPlateaus[iPlateau][subrefPlateauLandZones]) then tAllPlateaus[iPlateau][subrefPlateauLandZones] = {} end
        if bDebugMessages == true then LOG(sFunctionRef..': tPlateauSubtable[subrefPlateauMexes]='..repru(tPlateauSubtable[subrefPlateauMexes])) end
        for iMex, tMex in tPlateauSubtable[subrefPlateauMexes] do
            if bDebugMessages == true then LOG(sFunctionRef..': iMex='..iMex..'; tMex='..repru(tMex)) end
            if not(IsUnderwater(tMex, false, 0.1)) then
                if bDebugMessages == true then LOG(sFunctionRef..': Plateau='..iPlateau..': Considering mex with plateau mex ref='..iMex..'; position='..repru(tMex)..'; tiPlateauLandZoneByMexRef for this ref='..(tiPlateauLandZoneByMexRef[iPlateau][iMex] or 'nil')) end
                if not(tiPlateauLandZoneByMexRef[iPlateau][iMex]) then
                    AddMexToLandZone(iPlateau, nil, iMex, tiPlateauLandZoneByMexRef)
                    iCurLandZone = tiPlateauLandZoneByMexRef[iPlateau][iMex]
                    if bDebugMessages == true then LOG(sFunctionRef..': Added mex '..iMex..' with position '..repru(tMex)..' to land zone, tiPlateauLandZoneByMexRef='..(tiPlateauLandZoneByMexRef[iPlateau][iMex] or 'nil')) end

                    --Cycle through each other mex in the plateau and if it is within iNearbyMexRange then assign it to the same group if it hasnt had a group assigned already
                    AddNearbyMexesToLandZone(iPlateau, iCurLandZone, tMex, 0)
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording land zone mexes for iPlateau='..iPlateau..'; Size of land zones table='..table.getn(tAllPlateaus[iPlateau][subrefPlateauLandZones])) end
    end

    --Debug - draw the groupings of mexes with rectangles around them to show how they've been grouped, with a different colour for each plateau group:
    if bDebugMessages == true then
        local iColour = 0
        for iPlateau, tPlateauSubtable in tAllPlateaus do
            LOG(sFunctionRef..': About to draw results of land zones for iPlateau='..iPlateau..'; tiPlateauLandZoneByMexRef[iPlateau]='..repru(tiPlateauLandZoneByMexRef[iPlateau])..'; tAllPlateaus[iPlateau][subrefPlateauLandZones]='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones]))
            iColour = iColour + 1
            if iColour > 7 then iColour = 1 end
            --Draw the mex groupings
            for iZone, tZone in tAllPlateaus[iPlateau][subrefPlateauLandZones] do
                local iMinX = 100000
                local iMaxX = 0
                local iMinZ = 100000
                local iMaxZ = 0

                for iMex, tMex in tZone[subrefLZMexLocations] do
                    iMinX = math.min(tMex[1], iMinX)
                    iMaxX = math.max(tMex[1], iMaxX)
                    iMinZ = math.min(tMex[3], iMinZ)
                    iMaxZ = math.max(tMex[3], iMaxZ)
                end
                M28Utilities.DrawRectangle(Rect(iMinX, iMinZ, iMaxX, iMaxZ), iColour, 1000, 10)
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function DrawSpecificLandZone(iPlateau, iLandZone, iColour)
    local tLocation
    for iSegmentRef, tSegmentXZ in tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZSegments] do
        tLocation = GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])
        M28Utilities.DrawLocation(tLocation, iColour, nil, iLandZoneSegmentSize - 0.1)
    end
end

local function DrawLandZones()
    --For debug use - will draw each land zone in a plateau in a different colour to allow a visual check of how land zones have been created.  Can be called part-way through the process (e.g. to show land zones after the initial mex creation and nearby areas)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DrawLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Create fixed colours per ref
    local iUniqueColourCount = 30
    local tColourTable = M28Utilities.GenerateUniqueColourTable(iUniqueColourCount)

    --Subfunction which assigns a unique colour to each land zone
    function GetColourFromLandZoneNumber(iLandZoneRef)
        local iColour = iLandZoneRef
        while iColour >= iUniqueColourCount do
            iColour = iColour - iUniqueColourCount
        end

        return tColourTable[iColour]
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Will now draw every land zone in every plateau, cycling the colour used') end
    local tLocation, iLandZoneRef
    --Cycle through every segment on the map and draw a colour for it based on the land zone that it's part of
    for iCurSegmentX = 1, iMaxLandSegmentX do
        for iCurSegmentZ = 1, iMaxLandSegmentZ do
            iLandZoneRef = tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]
            if (iLandZoneRef or 0) > 0 then
                tLocation = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                if bDebugMessages == true then LOG(sFunctionRef..': Land zone ref for segments X-Z='..iCurSegmentX..'-'..iCurSegmentZ..' = '..iLandZoneRef..'; Plataeu ref based on navutils='..NavUtils.GetLabel(refPathingTypeAmphibious, tLocation)) end
                --M28Utilities.DrawLocation(tLocation, GetColourFromLandZoneNumber(iLandZoneRef), nil, iLandZoneSegmentSize - 0.1)
                M28Utilities.DrawLocation(tLocation, GetColourFromLandZoneNumber(iLandZoneRef), nil, iLandZoneSegmentSize - 0.1)
            end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function RecordLandZoneMidpointAndUnbuiltMexes()
    --Cycles through each land zone, and calculates the average positio nof the mexes.  If this is in the asme land zone then records this as the midpoint, toehrwise records the first mex as the midpoint
    --Also records which mexes can be built on initially
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordLandZoneMidpointAndUnbuiltMexes'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tAverage, iAveragePlateau, iAverageLandZone
    local tCurPosition


    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iZone, tZone in tAllPlateaus[iPlateau][subrefPlateauLandZones] do

            if bDebugMessages == true then LOG(sFunctionRef..': Considering iPlateau='..iPlateau..'; iZone='..iZone..'; Is table of mex locations empty='..tostring(M28Utilities.IsTableEmpty(tZone[subrefLZMexLocations]))) end
            local iMinX = 100000
            local iMaxX = 0
            local iMinZ = 100000
            local iMaxZ = 0

            if M28Utilities.IsTableEmpty(tZone[subrefLZMexLocations]) == false then
                for iMex, tMex in tZone[subrefLZMexLocations] do
                    --Get min and max values for midpoint:
                    iMinX = math.min(tMex[1], iMinX)
                    iMaxX = math.max(tMex[1], iMaxX)
                    iMinZ = math.min(tMex[3], iMinZ)
                    iMaxZ = math.max(tMex[3], iMaxZ)
                    --Record if can build on it:
                    if bDebugMessages == true then LOG(sFunctionRef..': About to check if can build on iMex='..iMex..'; tMex='..repru(tMex)) end
                    if M28Conditions.CanBuildOnMexLocation(tMex) then
                        table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iZone][subrefLZMexUnbuiltLocations], tMex)
                    end
                end
            else
                --No mexes for the plateau, so cycle through every zone and record the lowest and largest X and Z values
                for iSegment, tSegmentXZ in tZone[subrefLZSegments] do
                    tCurPosition = GetPositionFromPathingSegments(tSegmentXZ[1], tSegmentXZ[2])
                    iMinX = math.min(iMinX, tCurPosition[1])
                    iMinZ = math.min(iMinZ, tCurPosition[3])
                    iMaxX = math.max(iMaxX, tCurPosition[1])
                    iMaxZ = math.max(iMaxZ, tCurPosition[3])
                end
                if bDebugMessages == true then LOG(sFunctionRef..': Min and max position after cycling through each segment: iMinX='..iMinX..'; iMaxX='..iMaxX..'; iMinZ='..iMinZ..'; iMaxZ='..iMaxZ) end
            end
            tAverage = {(iMinX + iMaxX)*0.5, 0, (iMinZ + iMaxZ) * 0.5}
            iAveragePlateau, iAverageLandZone = GetPlateauAndLandZoneReferenceFromPosition(tAverage, false)
            if (iAveragePlateau == iPlateau and iAverageLandZone == iZone) or M28Utilities.IsTableEmpty(tZone[subrefLZMexLocations]) then
                tZone[subrefLZMidpoint] = {tAverage[1], GetSurfaceHeight(tAverage[1], tAverage[3]), tAverage[3]}
            else
                tZone[subrefLZMidpoint] = {tZone[subrefLZMexLocations][1][1], tZone[subrefLZMexLocations][1][2], tZone[subrefLZMexLocations][1][3]}
            end
            if bDebugMessages == true then
                local iColour = iPlateau
                while iColour > 8 do
                    iColour = iColour - 8
                end
                M28Utilities.DrawRectangle(Rect(iMinX, iMinZ, iMaxX, iMaxZ), iColour, 1000, 10)
                if bDebugMessages == true then LOG(sFunctionRef..': Midpoint for iPlateau='..iPlateau..' and zone='..iZone..' = '..repru(tZone[subrefLZMidpoint])) end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end



local function RecordHydroInLandZones()
    --Updates land zone data to include details of any hydro locations in the land zone
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordHydroInLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if M28Utilities.IsTableEmpty(tHydroPoints) == false then
        local iPlateau, iLandZone

        for iHydro, tHydro in tHydroPoints do
            iPlateau, iLandZone = GetPlateauAndLandZoneReferenceFromPosition(tHydro)
            if bDebugMessages == true then LOG(sFunctionRef..': Considering iHydro='..iHydro..'; tHydro='..repru(tHydro)..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
            if iLandZone > 0 then
                if bDebugMessages == true then LOG(sFunctionRef..': Have a hydro location, CanBuildOnHydro='..tostring(M28Conditions.CanBuildOnHydroLocation(tHydro))) end
                table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZHydroLocations], tHydro)
                if M28Conditions.CanBuildOnHydroLocation(tHydro) then
                    table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZHydroUnbuiltLocations], tHydro)
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordAdjacentLandZones()
    --Cycles through each land zone and identifies adjacent land zones
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAdjacentLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local tiSegmentAdjust = {{-1,0}, {-1, -1}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1,1}}
    local iAltLandZone
    local iAltSegX, iAltSegZ
    local tRecordedAdjacentZones
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
            tLandZoneInfo[subrefLZAdjacentLandZones] = {}
            tRecordedAdjacentZones = {}
            for iSegmentRef, tSegmentXZ in tLandZoneInfo[subrefLZSegments] do
                for iSegAdjust, tSegAdjXZ in tiSegmentAdjust do
                    iAltSegX = tSegmentXZ[1] + tSegAdjXZ[1]
                    iAltSegZ = tSegmentXZ[2] + tSegAdjXZ[2]
                    iAltLandZone = tLandZoneBySegment[iAltSegX][iAltSegZ]
                    if iAltLandZone and not(iAltLandZone == iLandZone) and not(tRecordedAdjacentZones[iAltLandZone]) then
                        if NavUtils.GetLabel(refPathingTypeAmphibious, GetPositionFromPathingSegments(iAltSegX, iAltSegZ)) == iPlateau then
                            tRecordedAdjacentZones[iAltLandZone] = true
                            table.insert(tLandZoneInfo[subrefLZAdjacentLandZones], iAltLandZone)
                        end
                    end
                end
            end

            if bDebugMessages == true then
                LOG(sFunctionRef..': Finished considering Plateau '..iPlateau..' LZ '..iLandZone..': subrefLZAdjacentLandZones='..repru(tLandZoneInfo[subrefLZAdjacentLandZones]))
                local iColour = 1
                DrawSpecificLandZone(iPlateau, iLandZone, iColour)
                if M28Utilities.IsTableEmpty(tLandZoneInfo[subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLandZoneInfo[subrefLZAdjacentLandZones] do
                        iColour = iColour + 1
                        if iColour > 8 then iColour = 2 end
                        DrawSpecificLandZone(iPlateau, iAdjLZ, iColour)
                    end
                end

            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iPlateau, iStartLandZone, iTargetLandZone, tStart, bWillUpdateLZEntryRefLater)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ConsiderAddingTargetLandZoneToDistanceFromBaseTable'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Have we not already considered this?
    if not(tbTempConsideredLandPathingForLZ[iPlateau][iStartLandZone][iTargetLandZone]) then

        local tEnd = tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZMidpoint]
        local tFullPath, iPathSize, iDistance = NavUtils.PathTo(refPathingTypeLand, tStart, tEnd, nil)
        if bDebugMessages == true then LOG(sFunctionRef..': Have just tried to get amphibious path from tStart='..repru(tStart)..' to tEnd='..repru(tEnd)..'; iStartLandZone='..iStartLandZone..'; iTargetLandZone='..iTargetLandZone..'; tFullPath='..repru(tFullPath)..'; iPathSize='..iPathSize) end

        if tFullPath then
            local iPathingPlateau, iPathingLandZone
            local tPathingLZConsidered = {}
            local tPathingLZFromStartToTarget = {}


            local iTravelDistance = 0
            tFullPath[0] = tStart
            tFullPath[iPathSize + 1] = tEnd
            for iPath = 1, iPathSize + 1 do
                iTravelDistance = iTravelDistance + VDist2(tFullPath[iPath - 1][1], tFullPath[iPath - 1][3], tFullPath[iPath][1], tFullPath[iPath][3])
                iPathingPlateau, iPathingLandZone = GetPlateauAndLandZoneReferenceFromPosition(tFullPath[iPath])
                if iPathingLandZone > 0 then
                    if not(tPathingLZConsidered[iPathingLandZone]) and not(iStartLandZone == iPathingLandZone) then
                        tPathingLZConsidered[iPathingLandZone] = true
                        table.insert(tPathingLZFromStartToTarget, iPathingLandZone)
                    end
                end
            end
            if not(tPathingLZConsidered[iTargetLandZone]) then
                table.insert(tPathingLZFromStartToTarget, iPathingLandZone)
                tPathingLZConsidered[iTargetLandZone] = true
            end
            --Record the travel distance
            if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZTravelDistToOtherLandZones][iPlateau]) then tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZTravelDistToOtherLandZones][iPlateau] = {} end
            tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZTravelDistToOtherLandZones][iPlateau][iStartLandZone] = iTravelDistance
            if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZTravelDistToOtherLandZones][iPlateau]) then tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZTravelDistToOtherLandZones][iPlateau] = {} end
            tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZTravelDistToOtherLandZones][iPlateau][iTargetLandZone] = iTravelDistance

            if bDebugMessages == true then
                LOG(sFunctionRef..': Travel distance to iTargetLandZone '..iTargetLandZone..' from '..iStartLandZone..' = '..iTravelDistance..'; tPathingLZConsidered='..repru(tPathingLZConsidered)..'; will draw path between LZs')
                M28Utilities.DrawPath(tFullPath, 1)
            end

            --Get position in new table
            local iPosition = 1
            if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones]) then
                tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones] = {}
                tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLZEntryRef] = {}
                iPosition = 1
            else
                for iExistingLandZone, tExistingSubtable in tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones] do
                    if tExistingSubtable[subrefLZTravelDist] <  iTravelDistance then
                        iPosition = iPosition + 1
                    else
                        break
                    end
                end
            end

            local iOppositePosition = 1
            if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones]) then
                tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones] = {}
                tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLZEntryRef] = {}
                iOppositePosition = 1
            else
                for iExistingLandZone, tExistingSubtable in tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones] do
                    if tExistingSubtable[subrefLZTravelDist] <  iTravelDistance then
                        iOppositePosition = iOppositePosition + 1
                    else
                        break
                    end
                end
            end

            table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones], iPosition, {[subrefLZNumber] = iTargetLandZone, [subrefLZPath] = {}, [subrefLZTravelDist] = iTravelDistance})
            table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones], iOppositePosition, {[subrefLZNumber] = iStartLandZone, [subrefLZPath] = {}, [subrefLZTravelDist] = iTravelDistance})

            --Will update subrefLZPathingToOtherLZEntryRef in UpdateLZPathingEntryReferences, as we need to do this for iOppositePositon once we have finished adding all oppositepositions or it will end up out of order

            --Record the land zone path from start to target
            for iEntry, iLZ in tPathingLZFromStartToTarget do
                table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones][iPosition][subrefLZPath], iLZ)
            end
            --Record the land zone path from target to start (adding in the start as the final point)
            local iTotalEntries = table.getn(tPathingLZFromStartToTarget)
            for iEntry = iTotalEntries, 1, -1 do
                if not(tPathingLZFromStartToTarget[iEntry] == iTargetLandZone) then
                    table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones][iOppositePosition][subrefLZPath], tPathingLZFromStartToTarget[iEntry])
                end
            end
            if not(tPathingLZFromStartToTarget[1] == iStartLandZone) then
                table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones][iOppositePosition][subrefLZPath], iStartLandZone)
            end

            --Record that we have considered the pathing between these two points
            if not(tbTempConsideredLandPathingForLZ[iPlateau]) then tbTempConsideredLandPathingForLZ[iPlateau] = {} end
            if not(tbTempConsideredLandPathingForLZ[iPlateau][iStartLandZone]) then tbTempConsideredLandPathingForLZ[iPlateau][iStartLandZone] = {} end
            if not(tbTempConsideredLandPathingForLZ[iPlateau][iTargetLandZone]) then tbTempConsideredLandPathingForLZ[iPlateau][iTargetLandZone] = {} end
            tbTempConsideredLandPathingForLZ[iPlateau][iStartLandZone][iTargetLandZone] = true
            tbTempConsideredLandPathingForLZ[iPlateau][iTargetLandZone][iStartLandZone] = true

            if bDebugMessages == true then LOG(sFunctionRef..': Path for goign the opposite direction='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones][iOppositePosition][subrefLZPath])..'; path for going the normal direction='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones][iPosition][subrefLZPath])..'; iPosition='..iPosition..'; iOppositePosition='..iOppositePosition) end

        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finsihed recording for iPlateau='..iPlateau..'; iStartLandZone='..iStartLandZone..'; subrefLZPathingToOtherLandZones='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLandZone][subrefLZPathingToOtherLandZones])..'; will now do repru of the target land zone pathing to other land zones='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iTargetLandZone][subrefLZPathingToOtherLandZones])) end
        if not(bWillUpdateLZEntryRefLater) then
            UpdateLZPathingEntryReferences(iPlateau, iStartLandZone)
            UpdateLZPathingEntryReferences(iPlateau, iTargetLandZone)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function RecordMaxAdjacencyTravelDistance()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordMaxAdjacencyTravelDistance'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local iMaxAdjacentDistance
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
            if M28Utilities.IsTableEmpty(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZAdjacentLandZones]) == false then
                iMaxAdjacentDistance = 0
                for _, iAdjLZ in tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZAdjacentLandZones] do
                    iMaxAdjacentDistance = math.max(iMaxAdjacentDistance, (tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZTravelDistToOtherLandZones][iPlateau][iAdjLZ] or 0))
                end

                tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZFurthestAdjacentLandZoneTravelDist] = iMaxAdjacentDistance
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdateLZPathingEntryReferences(iPlateau, iLandZone)
    local tLZData = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
    if M28Utilities.IsTableEmpty(tLZData[subrefLZPathingToOtherLandZones]) == false then
        local iCurCount = 0
        for iEntry, tPathData in tLZData[subrefLZPathingToOtherLandZones] do
            iCurCount = iCurCount + 1
            tLZData[subrefLZPathingToOtherLZEntryRef][tPathData[subrefLZNumber]] = iCurCount
        end
    end
end

local function RecordPathingBetweenZones()
    --For each zone that is where a player starts, record pathing to every other zone; for other zones, record pathing to up to 3 layers of adjacency
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordPathingBetweenZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    WaitTicks(1) --To ensure all brains will be setup
    for iCurPlateau, tPlateauSubtable in tAllPlateaus do
        for iCurLandZone, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
            local tStartPoint = tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iCurLandZone][subrefLZMidpoint]
            for iTargetLandZone, tTargetLZInfo in tPlateauSubtable[subrefPlateauLandZones] do
                if not(iTargetLandZone == iCurLandZone) then
                    ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iCurPlateau, iCurLandZone, iTargetLandZone, tStartPoint, true)
                end
            end
        end
        --Now record the entry refs
        local iCurCount
        for iCurLandZone, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
            UpdateLZPathingEntryReferences(iCurPlateau, iCurLandZone)
        end
    end
    --Record max adjacency distance
    RecordMaxAdjacencyTravelDistance()


    --[[
    local tiPlateauLandZoneStartPoints = {}
    local iCurPlateau, iCurLandZone
    for iStart, tPlayerStart in PlayerStartPoints do
        iCurPlateau, iCurLandZone = GetPlateauAndLandZoneReferenceFromPosition(tPlayerStart)
        if (iCurLandZone or 0) > 0 then
            if not(tiPlateauLandZoneStartPoints[iCurPlateau]) then tiPlateauLandZoneStartPoints[iCurPlateau] = {} end
            tiPlateauLandZoneStartPoints[iCurPlateau][iCurLandZone] = true
            local tStartPoint = tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iCurLandZone][subrefLZMidpoint]

            --Consider all land zones in this plateau for start positions
            for iTargetLandZone, tTargetLandZoneInfo in tAllPlateaus[iCurPlateau][subrefPlateauLandZones] do
                if not(iTargetLandZone == iCurLandZone) then
                    ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iCurPlateau, iCurLandZone, iTargetLandZone, tStartPoint)
                end
            end
        end
    end

    --Consider adjacent locations for non-core
    for iCurPlateau, tPlateauSubtable in tAllPlateaus do
        for iCurLandZone, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
            if not(tiPlateauLandZoneStartPoints[iCurPlateau][iCurLandZone]) then
                local tiAdjacentLandZonesToConsider = {}
                if M28Utilities.IsTableEmpty(tLandZoneInfo[subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ1 in tLandZoneInfo[subrefLZAdjacentLandZones] do
                        if M28Utilities.IsTableEmpty(tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iAdjLZ1][subrefLZAdjacentLandZones]) == false then
                            for _, iAdjLZ2 in tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iAdjLZ1][subrefLZAdjacentLandZones] do
                                if M28Utilities.IsTableEmpty(tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iAdjLZ2][subrefLZAdjacentLandZones]) == false then
                                    for _, iAdjLZ3 in tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iAdjLZ2][subrefLZAdjacentLandZones] do
                                        if not(tiAdjacentLandZonesToConsider[iAdjLZ3]) then tiAdjacentLandZonesToConsider[iAdjLZ3] = true end
                                    end
                                end
                                if not(tiAdjacentLandZonesToConsider[iAdjLZ2]) then tiAdjacentLandZonesToConsider[iAdjLZ2] = true end
                            end
                        end
                        if not(tiAdjacentLandZonesToConsider[iAdjLZ1]) then tiAdjacentLandZonesToConsider[iAdjLZ1] = true end
                    end
                    local tStartPoint = tAllPlateaus[iCurPlateau][subrefPlateauLandZones][iCurLandZone][subrefLZMidpoint]
                    for iAdjLandZone, _ in tiAdjacentLandZonesToConsider do
                        if not(iAdjLandZone == iCurLandZone) then
                            ConsiderAddingTargetLandZoneToDistanceFromBaseTable(iCurPlateau, iCurLandZone, iAdjLandZone, tStartPoint)
                        end
                    end
                end
            end
        end
    end--]]
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function RecordTravelDistBetweenZonesOverTime()
    --Record how  long it would take to travel between each other land zone upfront so dont have to calculate on the fly
    WaitTicks(1)
    local iCurCount = 0
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iStartLZ, tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
            for iEndLZ,  tLandZoneInfo in tPlateauSubtable[subrefPlateauLandZones] do
                if not(iStartLZ == iEndLZ) then
                    iCurCount = iCurCount + 1
                    if iCurCount >= 10 then
                        iCurCount = 0
                        WaitTicks(1)
                    end

                    GetTravelDistanceBetweenLandZones(iPlateau, iStartLZ, iEndLZ)
                end
            end
        end
    end
end

function RecordClosestAllyAndEnemyBaseForEachLandZone(iTeam)
    local tEnemyBases = {}
    local tAllyBases = {}
    local tBrainsByIndex = {}

    if M28Utilities.IsTableEmpty(M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains]) == false then
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoEnemyBrains] do
            tEnemyBases[oBrain:GetArmyIndex()] = PlayerStartPoints[oBrain:GetArmyIndex()]
            tBrainsByIndex[oBrain:GetArmyIndex()] = oBrain
        end
    end
    for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveBrains] do
        tAllyBases[oBrain:GetArmyIndex()] = PlayerStartPoints[oBrain:GetArmyIndex()]
        tBrainsByIndex[oBrain:GetArmyIndex()] = oBrain
    end

    if M28Utilities.IsTableEmpty(tEnemyBases) then
        local aiBrain
        for iBrain, oBrain in M28Team.tTeamData[iTeam][M28Team.subreftoFriendlyActiveM28Brains] do
            aiBrain = oBrain
            break
        end
        table.insert(tEnemyBases, GetPrimaryEnemyBaseLocation(aiBrain))
    end

    local iCurBrainDist
    local iClosestBrainDist
    local iClosestBrainRef
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLZData in tPlateauSubtable[subrefPlateauLandZones] do
            iClosestBrainDist = 100000
            for iBrain, tStartPoint in tAllyBases do
                iCurBrainDist = M28Utilities.GetDistanceBetweenPositions(tLZData[subrefLZMidpoint], tStartPoint)
                if iCurBrainDist < iClosestBrainDist then
                    iClosestBrainRef = iBrain
                    iClosestBrainDist = iCurBrainDist
                end
            end
            local tLZTeamData = tLZData[subrefLZTeamData][iTeam]
            tLZTeamData[reftClosestFriendlyBase] = {PlayerStartPoints[iClosestBrainRef][1], PlayerStartPoints[iClosestBrainRef][2], PlayerStartPoints[iClosestBrainRef][3]}
            tLZTeamData[reftClosestEnemyBase] = GetPrimaryEnemyBaseLocation(tBrainsByIndex[iClosestBrainRef])
            tLZTeamData[refiModDistancePercent] = GetModDistanceFromStart(tBrainsByIndex[iClosestBrainRef], tLZData[subrefLZMidpoint], false)
        end
    end
end

function ReturnNthValidLocationInSameLandZoneClosestToTarget(iPlateau, iLandZoneWanted, tStartLZData, tTargetDestination, iDistanceInterval, iNthEntryWanted, iMaxDistance)
    local iSearchDistance = 0
    local tValidLocations = {}
    local iValidLocationCount = 0
    local iAngleToTarget = M28Utilities.GetAngleFromAToB(tStartLZData[subrefLZMidpoint], tTargetDestination)
    local iFailureCount = 0 --After 5 failures in a row will abort
    local iCurPlateau, iCurLandZone
    if iDistanceInterval < 0 then M28Utilities.ErrorHandler('Likely infinite loop as have negative distance interval') end

    while iSearchDistance <= (iMaxDistance or 150) do
        iSearchDistance = iSearchDistance + iDistanceInterval
        local tPotentialLocation = M28Utilities.MoveInDirection(tStartLZData[subrefLZMidpoint], iAngleToTarget, iSearchDistance, true, false)
        iCurPlateau, iCurLandZone = GetPlateauAndLandZoneReferenceFromPosition(tPotentialLocation)
        if iCurPlateau == iPlateau and iCurLandZone == iLandZoneWanted then
            iValidLocationCount = iValidLocationCount + 1
            tValidLocations[iValidLocationCount] = {tPotentialLocation[1], tPotentialLocation[2], tPotentialLocation[3]}
            iFailureCount = 0
        else
            iFailureCount = iFailureCount + 1
            if iFailureCount >= 5 then break end
        end
    end
    if iValidLocationCount > 0 then
        if iValidLocationCount <= iNthEntryWanted then return tValidLocations[iValidLocationCount]
        else return tValidLocations[iValidLocationCount - iNthEntryWanted]
        end
    else
        return nil
    end
end

function ReorderPathBasedOnAngleToFirstEntry(tUnorderedPatrolPaths, tFirstPointInPath, bAddFirstPoint)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReorderPathBasedOnDistanceToFirstEntry'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tReorderedPositions = {}
    if bAddFirstPoint then
        table.insert(tReorderedPositions, {tFirstPointInPath[1], tFirstPointInPath[2], tFirstPointInPath[3]})
    end
    if M28Utilities.IsTableEmpty(tUnorderedPatrolPaths) == false then

        local iCurAngleFromFirstPosition
        local iClosestAngleDifFromLast
        local iClosestDistRef
        local tCurStartPoint = {tFirstPointInPath[1], tFirstPointInPath[2], tFirstPointInPath[3]}
        local iLoopCount = 0

        local iMaxLoop = table.getn(tUnorderedPatrolPaths) + 2
        if bDebugMessages == true then LOG(sFunctionRef..': About to order paths, tUnorderedPatrolPaths='..repru(tUnorderedPatrolPaths)..'; tFirstPointInPath='..repru(tFirstPointInPath)..'; bAddFirstPoint='..tostring(bAddFirstPoint or false)) end

        --First get closest point to the start
        local iClosestDistToStart = 10000
        local iCurDistToStart
        local iCurAngleDif
        for iEntry, tPosition in tUnorderedPatrolPaths do
            iCurDistToStart = M28Utilities.GetDistanceBetweenPositions(tCurStartPoint, tPosition)
            if iCurDistToStart < iClosestDistToStart then
                iClosestDistToStart = iCurDistToStart
                iClosestDistRef = iEntry
            end
        end
        local iLastAngleUsed = M28Utilities.GetAngleFromAToB(tCurStartPoint, tUnorderedPatrolPaths[iClosestDistRef])
        table.insert(tReorderedPositions, {tUnorderedPatrolPaths[iClosestDistRef][1], tUnorderedPatrolPaths[iClosestDistRef][2], tUnorderedPatrolPaths[iClosestDistRef][3]})
        if bDebugMessages == true then LOG(sFunctionRef..': Angle from tCurStartPoint '..repru(tCurStartPoint)..' to first point after this, '..repru(tUnorderedPatrolPaths[iClosestDistRef])..' is '..iLastAngleUsed) end
        table.remove(tUnorderedPatrolPaths, iClosestDistRef)


        while M28Utilities.IsTableEmpty(tUnorderedPatrolPaths) == false do
            iLoopCount = 1
            iClosestAngleDifFromLast = 10000
            for iEntry, tPosition in tUnorderedPatrolPaths do
                iCurAngleFromFirstPosition = M28Utilities.GetAngleFromAToB(tCurStartPoint, tPosition)
                iCurAngleDif = M28Utilities.GetAngleDifference(iCurAngleFromFirstPosition, iLastAngleUsed)
                if bDebugMessages == true then LOG(sFunctionRef..': Considering tPosition='..repru(tPosition)..'; Angle from start to here='..iCurAngleFromFirstPosition..'; Angle dif to last angle='..M28Utilities.GetAngleDifference(iCurAngleFromFirstPosition, iLastAngleUsed)) end
                if iCurAngleDif < iClosestAngleDifFromLast then
                    iClosestAngleDifFromLast = iCurAngleDif
                    iClosestDistRef = iEntry
                end
            end
            iLastAngleUsed = M28Utilities.GetAngleFromAToB(tCurStartPoint, tUnorderedPatrolPaths[iClosestDistRef])
            table.insert(tReorderedPositions, {tUnorderedPatrolPaths[iClosestDistRef][1], tUnorderedPatrolPaths[iClosestDistRef][2], tUnorderedPatrolPaths[iClosestDistRef][3]})
            if bDebugMessages == true then LOG(sFunctionRef..': Best location='..repru(tUnorderedPatrolPaths[iClosestDistRef])..'; iLastAngleUsed='..iLastAngleUsed) end
            table.remove(tUnorderedPatrolPaths, iClosestDistRef)
            if iLoopCount > iMaxLoop then M28Utilities.ErrorHandler('Infinite loop') break end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished reordering path, tReorderedPositions='..repru(tReorderedPositions)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tReorderedPositions
end

function ReorderPathBasedOnDistanceToFirstEntry(tUnorderedPatrolPaths, tFirstPointInPath, bAddFirstPoint)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'ReorderPathBasedOnDistanceToFirstEntry'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)



    local tReorderedPositions = {}
    if bAddFirstPoint then
        table.insert(tReorderedPositions, {tFirstPointInPath[1], tFirstPointInPath[2], tFirstPointInPath[3]})
    end

    local iCurDistToStart
    local iClosestDistToStart
    local iClosestDistRef
    local tCurStartPoint = {tFirstPointInPath[1], tFirstPointInPath[2], tFirstPointInPath[3]}
    local iLoopCount = 0
    local iMaxLoop = table.getn(tUnorderedPatrolPaths) + 2
    if bDebugMessages == true then LOG(sFunctionRef..': About to order paths, tUnorderedPatrolPaths='..repru(tUnorderedPatrolPaths)..'; tFirstPointInPath='..repru(tFirstPointInPath)..'; bAddFirstPoint='..tostring(bAddFirstPoint or false)) end

    while M28Utilities.IsTableEmpty(tUnorderedPatrolPaths) == false do
        iLoopCount = 1
        iClosestDistToStart = 10000
        for iEntry, tPosition in tUnorderedPatrolPaths do
            iCurDistToStart = M28Utilities.GetDistanceBetweenPositions(tCurStartPoint, tPosition)
            if iCurDistToStart < iClosestDistToStart then
                iClosestDistToStart = iCurDistToStart
                iClosestDistRef = iEntry
            end
        end
        table.insert(tReorderedPositions, {tUnorderedPatrolPaths[iClosestDistRef][1], tUnorderedPatrolPaths[iClosestDistRef][2], tUnorderedPatrolPaths[iClosestDistRef][3]})
        tCurStartPoint = {tUnorderedPatrolPaths[iClosestDistRef][1], tUnorderedPatrolPaths[iClosestDistRef][2], tUnorderedPatrolPaths[iClosestDistRef][3]}
        table.remove(tUnorderedPatrolPaths, iClosestDistRef)
        if iLoopCount > iMaxLoop then M28Utilities.ErrorHandler('Infinite loop') break end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished reordering path, tReorderedPositions='..repru(tReorderedPositions)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tReorderedPositions
end

function RecordLandZonePatrolPaths()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordLandZonePatrolPaths'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLZSubtable in tPlateauSubtable[subrefPlateauLandZones] do
            --Are we interested in patrolling this land zone? Want to ignore very small land zones
            if tLZSubtable[subrefLZMexCount] > 0 or tLZSubtable[subrefLZTotalSegmentCount] >= 40 then

                --First travel towards adjacent locations an add these
                local tUnorderedPatrolPaths = {}
                local tAnglesCovered = {}

                if M28Utilities.IsTableEmpty(tLZSubtable[subrefLZAdjacentLandZones]) == false then
                    for _, iAdjLZ in tLZSubtable[subrefLZAdjacentLandZones] do
                        local tPotentialLocation = ReturnNthValidLocationInSameLandZoneClosestToTarget(iPlateau, iLandZone, tLZSubtable, tAllPlateaus[iPlateau][subrefPlateauLandZones][iAdjLZ][subrefLZMidpoint], 4, 3, 100)
                        if tPotentialLocation then
                            table.insert(tUnorderedPatrolPaths, tPotentialLocation)
                            table.insert(tAnglesCovered, M28Utilities.GetAngleFromAToB(tLZSubtable[subrefLZMidpoint], tPotentialLocation))
                        end
                    end
                end
                --Identify any gaps in the path if we arent near the edge of the map
                local tNewAnglesToUse = {}
                local tbBaseAngleCovered = {}
                local iDistThreshold = 90
                if tLZSubtable[subrefLZMidpoint][3] >= rMapPlayableArea[2] + iDistThreshold then
                    --Arent close to the top of the map so can look north
                    tbBaseAngleCovered[0] = false
                end
                if tLZSubtable[subrefLZMidpoint][1] <= rMapPlayableArea[3] - iDistThreshold then
                    --Arent close to the rh of the map so can look east
                    tbBaseAngleCovered[90] = false
                end
                if tLZSubtable[subrefLZMidpoint][3] <= rMapPlayableArea[4] - iDistThreshold then
                    --Arent close to the bottom of the map so can look south
                    tbBaseAngleCovered[180] = false
                end
                if tLZSubtable[subrefLZMidpoint][1] >= rMapPlayableArea[1] + iDistThreshold then
                    --Aren't close to left hand part of map so can look west
                    tbBaseAngleCovered[270] = false
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iPlateau='..iPlateau..'; iLZ='..iLandZone..'; tAnglesCovered='..repru(tAnglesCovered)..'; Midpoint='..repru(tLZSubtable[subrefLZMidpoint])..'; playable area='..repru(rMapPlayableArea)..'; iDistThreshold='..iDistThreshold..'; tbBaseAngleCovered before factoring in angles covered='..repru(tbBaseAngleCovered)) end

                if M28Utilities.IsTableEmpty(tAnglesCovered) == false then

                    for _, iAngle in tAnglesCovered do
                        for iBaseAngle, bCovered in tbBaseAngleCovered do
                            if not(bCovered) then
                                if M28Utilities.GetAngleDifference(iBaseAngle, iAngle) <= 45 then
                                    tbBaseAngleCovered[iBaseAngle] = true
                                end
                            end
                        end
                    end
                end
                if bDebugMessages == true then LOG(sFunctionRef..': tbBaseAngleCovered='..repru(tbBaseAngleCovered)) end
                for iBaseAngle, bCovered in tbBaseAngleCovered do
                    if not(bCovered) then
                        local tPotentialLocation = ReturnNthValidLocationInSameLandZoneClosestToTarget(iPlateau, iLandZone, tLZSubtable, M28Utilities.MoveInDirection(tLZSubtable[subrefLZMidpoint], iBaseAngle, iDistThreshold, false, false), 4, 3, 70)
                        if tPotentialLocation then
                            table.insert(tUnorderedPatrolPaths, tPotentialLocation)
                        end
                    end
                end


                --Order the path based on distance, and add the midpoint of the land zone
                --Originally did based on distance, but based on angle looks slightly better
                --tLZSubtable[subreftPatrolPath] = ReorderPathBasedOnDistanceToFirstEntry(tUnorderedPatrolPaths, {tLZSubtable[subrefLZMidpoint][1] + 3, tLZSubtable[subrefLZMidpoint][2], tLZSubtable[subrefLZMidpoint][3] + 3}, true)
                tLZSubtable[subreftPatrolPath] = ReorderPathBasedOnAngleToFirstEntry(tUnorderedPatrolPaths, {tLZSubtable[subrefLZMidpoint][1] + 3, tLZSubtable[subrefLZMidpoint][2], tLZSubtable[subrefLZMidpoint][3] + 3}, true)

                if bDebugMessages == true then
                    LOG(sFunctionRef..': Finished recording patrol path for plateau '..iPlateau..'; Land zone ='..iLandZone..'; Patrol path='..repru(tLZSubtable[subreftPatrolPath]))
                    M28Utilities.DrawLocation(tLZSubtable[subrefLZMidpoint])
                    if M28Utilities.IsTableEmpty(tLZSubtable[subreftPatrolPath]) == false then
                        M28Utilities.DrawPath(tLZSubtable[subreftPatrolPath], 5, nil)
                    end

                end
            end

        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

local function SetupLandZones()
    --Divides the map into 'land zones' based on mex placement and plateau groups, which is to form the basis for managing land units.  Land zones are areas that can be pathed by land units and are intended to group the map based on how long it takes to travel
    --Intended to be called at start of game when AI is created (so after siminit and recordresourcepoints has run), and after plateaus have been generated
    --Broadly, will group nearby mexes together in the same land zone, along with the nearby area; then will look for any places on the map with no nearby land zone and create a zone for these, and then go through the whole map and ensure every land pathable area has an assigned land zone
    --To avoid too much of a CPU load, the map is first divided into small 'segment' squares, the size of which varies based on the size of a map (1x1 for a 5km map, 2x2 for a 10km map, etc.), with it assumed that any location within a segment square has the same pathing as the midpoint of that segment
    --i.e. there will inevitably be cases where units go near a cliff where the land pathing zone is inconsistent with where the unit can path to

    --Using land zones:
    --To return both the plateau reference, and the land zone reference, of a position tPosiiton, use the function GetPlateauAndLandZoneReferenceFromPosition(tPosition) (which will return nil if it doesnt have a value)


    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupLandZones'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of land zone generation, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end

    --First go through every mex on the map, and assign it a land zone (grouping mexes near each other together):
    AssignMexesALandZone()
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1)
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Now add any areas that can easily be pathed to each mex to the same land zone as that mex:
    if bDebugMessages == true then LOG(sFunctionRef..': Finished assining mexes to a land zone, will now assign the area near mexes') end
    AssignSegmentsNearMexesToLandZones()
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1)
    if bDebugMessages == true then
        LOG(sFunctionRef..': Finished assining area aound mexes, will now draw resulting land zones')
        DrawLandZones()
        WaitTicks(5)
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Now look for empty spots on the map without land zones and assign them a land zone, creating new ones (that have no mexes in them) where they are far from any existing land zone:
    AssignRemainingSegmentsToLandZones()
    if bDebugMessages == true then LOG(sFunctionRef..': Added remaining segments to land zones') end

    --Clear variables that we no longer need:
    tTempZoneTravelDistanceBySegment =  nil
    tTempZonePlateauBySegment = nil

    RecordLandZoneMidpointAndUnbuiltMexes()
    RecordHydroInLandZones()
    ReorderLandZoneSegmentsForEachPlateau()
    RecordAdjacentLandZones()
    RecordMassStorageLocationsForEachLandZone()
    RecordLandZonePatrolPaths()

    if bDebugMessages == true then LOG(sFunctionRef..': Finished LZ patrol paths') end

    RecordPathingBetweenZones() --Includes a waitticks(1)

    --Map out how long it will take each LZ to path to each other LZ
    ForkThread(RecordTravelDistBetweenZonesOverTime)

    --If debug is enabled, draw land zones (different colour for each land zone on a plateau)
    if bDebugMessages == true then
        LOG(sFunctionRef..': Finished generating all land zones, will now draw them. System time='..GetSystemTimeSecondsOnlyForProfileUse())
        DrawLandZones()
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordIslands()
    --Assumes have already setup every land zone on the map - will now record details of islands
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordIslands'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --First record every island
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        if tPlateauSubtable[subrefPlateauTotalMexCount] > 0 then
            tPlateauSubtable[subrefPlateauIslandLandZones] = {}
            tPlateauSubtable[subrefPlateauIslandMexCount] = { }
            for iLandZone, tLZData in tPlateauSubtable[subrefPlateauLandZones] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering iLandZone='..iLandZone..'; in Plateau '..iPlateau..'; Amphibious label='..(NavUtils.GetLabel(refPathingTypeLand, tLZData[subrefLZMidpoint]) or 'nil')) end
                tLZData[subrefLZIslandRef] = NavUtils.GetLabel(refPathingTypeLand, tLZData[subrefLZMidpoint])
                if tLZData[subrefLZIslandRef] > 0 then
                    if not(tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]]) then tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]] = {} end
                    table.insert(tPlateauSubtable[subrefPlateauIslandLandZones][tLZData[subrefLZIslandRef]], iLandZone)
                    tPlateauSubtable[subrefPlateauIslandMexCount][tLZData[subrefLZIslandRef]] = (tPlateauSubtable[subrefPlateauIslandMexCount][tLZData[subrefLZIslandRef]] or 0) + tLZData[subrefLZMexCount]
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished recording all islands in plateau '..iPlateau..'; Mex count by island='..repru(tPlateauSubtable[subrefPlateauIslandMexCount])..'; LZs by island='..repru(tPlateauSubtable[subrefPlateauIslandLandZones])) end


            for iLandZone, tLZData in tPlateauSubtable[subrefPlateauLandZones] do
                --Cycle through each island in this plateau and consider pathing for it
                if bDebugMessages == true then LOG(sFunctionRef..': Will record the pathing to every island from iLandZone='..iLandZone..'; ') end
                for iIsland, tLandZonesInIsland in tPlateauSubtable[subrefPlateauIslandLandZones] do
                    --Only consider islands with mexes (for performance reasons)
                    if tPlateauSubtable[subrefPlateauIslandMexCount][iIsland] > 0 and not(iIsland == tLZData[subrefLZIslandRef]) then
                        --Get the land zone in this island that is closest to our current land zone
                        local iClosestTravelDist = 100000
                        local iCurTravelDistance
                        local iClosestLZRef


                        for iEntry, iIslandLZ in tLandZonesInIsland do
                            iCurTravelDistance = M28Utilities.GetTravelDistanceBetweenPositions(tLZData[subrefLZMidpoint], tPlateauSubtable[subrefPlateauLandZones][iIslandLZ][subrefLZMidpoint], refPathingTypeAmphibious)
                            if bDebugMessages == true then LOG(sFunctionRef..': iCurTravelDistance='..repru(iCurTravelDistance)..'; iClosestTravelDist='..repru(iClosestTravelDist)) end
                            if iCurTravelDistance and iCurTravelDistance < iClosestTravelDist then
                                iClosestTravelDist = iCurTravelDistance
                                iClosestLZRef = iIslandLZ
                            end
                        end

                        --Get the position in the current table
                        local iPosition = 1
                        if not(tLZData[subrefLZPathingToOtherIslands]) then
                            tLZData[subrefLZPathingToOtherIslands] = {}
                            iPosition = 1
                        else
                            for iExistingIsland, tExistingSubtable in tLZData[subrefLZPathingToOtherIslands] do
                                if tExistingSubtable[subrefIslandTravelDist] < iClosestTravelDist then
                                    iPosition = iPosition + 1
                                else
                                    break
                                end
                            end
                        end
                        local tFullPath, iPathSize, iDistance = NavUtils.PathTo(refPathingTypeAmphibious, tLZData[subrefLZMidpoint], tPlateauSubtable[subrefPlateauLandZones][iClosestLZRef][subrefLZMidpoint], nil)

                        --Reduce tFullPath to a table of land zones
                        if tFullPath then
                            local iPathingPlateau, iPathingLandZone
                            local tPathingLZConsidered = {}
                            local tPathingLZFromStartToTarget = {}


                            local iTravelDistance = 0
                            local tStart = {tLZData[subrefLZMidpoint][1], tLZData[subrefLZMidpoint][2], tLZData[subrefLZMidpoint][3]}
                            local tEnd = {tPlateauSubtable[subrefPlateauLandZones][iClosestLZRef][subrefLZMidpoint][1], tPlateauSubtable[subrefPlateauLandZones][iClosestLZRef][subrefLZMidpoint][2], tPlateauSubtable[subrefPlateauLandZones][iClosestLZRef][subrefLZMidpoint][3]}
                            tFullPath[0] = tStart
                            tFullPath[iPathSize + 1] = tEnd
                            for iPath = 1, iPathSize + 1 do
                                iTravelDistance = iTravelDistance + VDist2(tFullPath[iPath - 1][1], tFullPath[iPath - 1][3], tFullPath[iPath][1], tFullPath[iPath][3])
                                iPathingPlateau, iPathingLandZone = GetPlateauAndLandZoneReferenceFromPosition(tFullPath[iPath])
                                if iPathingLandZone > 0 then
                                    if not(tPathingLZConsidered[iPathingLandZone]) and not(iLandZone == iPathingLandZone) then
                                        tPathingLZConsidered[iPathingLandZone] = true
                                        table.insert(tPathingLZFromStartToTarget, iPathingLandZone)
                                    end
                                end
                            end
                            if not(tPathingLZConsidered[iClosestLZRef]) then
                                table.insert(tPathingLZFromStartToTarget, iPathingLandZone)
                                tPathingLZConsidered[iClosestLZRef] = true
                            end
                            table.insert(tLZData[subrefLZPathingToOtherIslands], iPosition, {[subrefIslandNumber] = iIsland, [subrefIslandClosestLZRef] = iClosestLZRef, [subrefLZTravelDist] = iClosestTravelDist, [subrefIslandLZPath] = { } })
                            --Add in the LZ path
                            for iEntry, iLZ in tPathingLZFromStartToTarget do
                                table.insert(tLZData[subrefLZPathingToOtherIslands][iPosition][subrefIslandLZPath], iLZ)
                            end
                        end
                        if bDebugMessages == true then LOG(sFunctionRef..': Plateau '..iPlateau..': Finished recording pathing to get from iLandZone='..iLandZone..' to iClosestLZRef='..(iClosestLZRef or 'nil')..' in island '..iIsland..'; tLZData[subrefLZPathingToOtherIslands]='..repru(tLZData[subrefLZPathingToOtherIslands])) end
                    end
                end
            end
            if bDebugMessages == true then LOG(sFunctionRef..': Finished recording for iPlateau='..iPlateau) end
        end
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

---@param tPosition table
---@param bReturnSufaceHeightInstead boolean
---@param iOptionalAmountToBeUnderwatner number
---@return boolean
function IsUnderwater(tPosition, bReturnSurfaceHeightInstead, iOptionalAmountToBeUnderwater)
    --Returns true if tPosition underwater, otherwise returns false
    --bReturnSurfaceHeightInstead:: Return the actual height at which underwater, instead of true/false
    if bReturnSurfaceHeightInstead then return iMapWaterHeight
    else
        --LOG('IsUnderwater: tPosition='..repru(tPosition))
        if M28Utilities.IsTableEmpty(tPosition) then
            M28Utilities.ErrorHandler('tPosition is empty')
        else
            if iMapWaterHeight > tPosition[2] + (iOptionalAmountToBeUnderwater or 0) then
                --Check we're not just under an arch but are actually underwater
                if not(GetTerrainHeight(tPosition[1], tPosition[3]) == iMapWaterHeight) then
                    return true
                end
            end
        end
        return false
    end
end

local function GetMapWaterHeight()
    --Updates iMapWaterHeight to the water height on the map (if the map has water)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetMapWaterHeight'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    --rMapPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2} - Set at start of the game, use instead of the scenarioinfo method
    local iWaterCount = 0
    local iWaterLevel = 10000
    local iCurTerrainHeight = 10000
    local iInterval = 1

    --Cycle through the map in iInterval sizes, until we come to a point where the surface height exceeds the terrain height, which suggests it is water:
    for iX = rMapPlayableArea[1] + iInterval, rMapPlayableArea[3], iInterval do
        for iZ = rMapPlayableArea[2] + iInterval, rMapPlayableArea[4], iInterval do
            iCurTerrainHeight =  GetTerrainHeight(iX, iZ)
            if GetSurfaceHeight(iX, iZ) > GetTerrainHeight(iX, iZ) then
                iWaterCount = iWaterCount + 1
                iWaterLevel = math.min(iWaterLevel, GetSurfaceHeight(iX, iZ))
                if bDebugMessages == true then LOG(sFunctionRef..': Found water at position X-Z='..iX..'-'..iZ..'; Surface height='..GetSurfaceHeight(iX, iZ)..'; Terrain height='..GetTerrainHeight(iX, iZ)) end
                if iWaterCount >= 3 then
                    break
                end
            else
                --Backup for maps like theta passage arch - have commented out as running on theta passage with interval of 1 it never triggers a water count in the first place, but could remove comments if do come across this issue
                --if bDebugMessages == true and iWaterCount > 0 and GetTerrainHeight(iX, iZ) < iWaterLevel and iWaterLevel < 10000 then LOG(sFunctionRef..': Have suspected arch previously so will adjust water level to terrain height='..GetTerrainHeight(iX, iZ)..'; for iX-Z='..iX..'-'..iZ..'; prev iWaterLevel='..iWaterLevel) end
                --iWaterLevel = math.min(iWaterLevel, GetTerrainHeight(iX, iZ))
            end
        end
        if iWaterCount >= 3 then break end
    end
    if iWaterCount == 0 then iMapWaterHeight = 0
    else
        iMapWaterHeight = iWaterLevel
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iWaterCount='..iWaterCount..'; iMapWaterHeight='..iMapWaterHeight) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetReclaimablesResourceValue(tReclaimables, bAlsoReturnLargestReclaimPosition, iIgnoreReclaimIfNotMoreThanThis, bAlsoReturnAmountOfHighestIndividualReclaim, bEnergyNotMass)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetReclaimablesResourceValue'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bAlsoReturnLargestReclaimPosition == nil then bAlsoReturnLargestReclaimPosition = false end
    if iIgnoreReclaimIfNotMoreThanThis == nil then iIgnoreReclaimIfNotMoreThanThis = 0 end
    if iIgnoreReclaimIfNotMoreThanThis < 0 then iIgnoreReclaimIfNotMoreThanThis = 0 end

    local sResourceRef = 'MaxMassReclaim'
    if bEnergyNotMass then sResourceRef = 'MaxEnergyReclaim' end

    local tWreckPos = {}
    local iTotalResourceValue = 0
    local iLargestCurReclaim = 0
    local tReclaimPos = {}
    if tReclaimables and table.getn( tReclaimables ) > 0 then
        for _, v in tReclaimables do
            tWreckPos = v.CachePosition
            if tWreckPos[1] then
                if v[sResourceRef] > iIgnoreReclaimIfNotMoreThanThis then
                    if not(v:BeenDestroyed()) then
                        iTotalResourceValue = iTotalResourceValue + v[sResourceRef]
                        if bAlsoReturnLargestReclaimPosition and v.MaxMassReclaim > iLargestCurReclaim then
                            iLargestCurReclaim = v.MaxMassReclaim
                            tReclaimPos = {tWreckPos[1], tWreckPos[2], tWreckPos[3]}
                        end
                    end
                end
            else
                if not(v.MaxMassReclaim == nil) then
                    if v.MaxMassReclaim > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Warning - have ignored wreck location despite it having a mass reclaim value') end
                    end
                end
            end
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if bAlsoReturnLargestReclaimPosition then
        if bAlsoReturnAmountOfHighestIndividualReclaim then return iTotalResourceValue, tReclaimPos, iLargestCurReclaim
        else return iTotalResourceValue, tReclaimPos end
    else
        if bAlsoReturnAmountOfHighestIndividualReclaim then return iTotalResourceValue, iLargestCurReclaim
        else return iTotalResourceValue end
    end
end

function GetReclaimInRectangle(iReturnType, rRectangleToSearch, bForceDebug)
    --iReturnType: 1 = true/false; 2 = number of wrecks; 3 = total mass, 4 = valid wrecks, 5 = energy
    local sFunctionRef = 'GetReclaimInRectangle'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    local bDebugMessages = bForceDebug if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    --NOTE: Best to try and debug via forcedebug, as dont want to run for everything due to how intensive the log of reclaim is
    --Have also commented out one of the logs to help with performance

    local tReclaimables = GetReclaimablesInRect(rRectangleToSearch)
    local iWreckCount = 0
    local iTotalResourceValue
    local bHaveReclaim = false
    local tValidWrecks = {}
    if M28Utilities.IsTableEmpty(tReclaimables) == false then
        if bDebugMessages == true then LOG(sFunctionRef..': iReturnType='..iReturnType..'; rRectangleToSearch='..repru(rRectangleToSearch)) end
        if iReturnType == 3 or iReturnType == 5 then
            if iReturnType == 3 then iTotalResourceValue = GetReclaimablesResourceValue(tReclaimables, false, 0, false, false)
            else iTotalResourceValue = GetReclaimablesResourceValue(tReclaimables, false, 0, false, true)
            end
            if bDebugMessages == true then LOG(sFunctionRef..': iTotalResourceValue='..iTotalResourceValue) end
        else
            for _, v in tReclaimables do
                --if bDebugMessages == true then LOG(sFunctionRef..': _='.._..'; repr of reclaimable='..repru(tReclaimables)) end
                local WreckPos = v.CachePosition
                if not(WreckPos[1]==nil) then
                    if bDebugMessages == true then LOG(sFunctionRef..': _='.._..'; Cur mass value='..(v.MaxMassReclaim or 0)..'; Energy value='..(v.MaxEnergyReclaim or 0)) end
                    if (v.MaxMassReclaim or 0) > 0 or (v.MaxEnergyReclaim or 0) > 0 then
                        if bDebugMessages == true then LOG('Been destroyed='..tostring(v:BeenDestroyed())) end
                        if not(v:BeenDestroyed()) then
                            iWreckCount = iWreckCount + 1
                            bHaveReclaim = true
                            if iReturnType == 1 then break
                            elseif iReturnType == 4 then tValidWrecks[iWreckCount] = v end
                        end
                    end
                end
            end
        end
    elseif bDebugMessages == true then LOG(sFunctionRef..': tReclaimables is empty')
    end
    if bDebugMessages == true then LOG(sFunctionRef..': rRectangleToSearch='..repru(rRectangleToSearch)..'; bHaveReclaim='..tostring(bHaveReclaim)..'; iWreckCount='..iWreckCount) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    if iReturnType == 1 then return bHaveReclaim
    elseif iReturnType == 2 then return iWreckCount
    elseif iReturnType == 3 or iReturnType == 5 then return iTotalResourceValue
    elseif iReturnType == 4 then return tValidWrecks
    else M28Utilities.ErrorHandler('Invalid return type')
    end
end

function SetWhetherCanPathToEnemy(aiBrain)
    --Set flag for whether AI can path to enemy base
    --Also updates other values that are based on the nearest enemy

    local sFunctionRef = 'SetWhetherCanPathToEnemy'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if not(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated]) then
        local tEnemyStartPosition = GetPrimaryEnemyBaseLocation(aiBrain)
        local tOurBase = PlayerStartPoints[aiBrain:GetArmyIndex()]

        if NavUtils.GetLabel(refPathingTypeLand, tOurBase) == NavUtils.GetLabel(refPathingTypeLand, tEnemyStartPosition) and not(IsUnderwater({tOurBase[1], GetTerrainHeight(tOurBase[1], tOurBase[3]), tOurBase[3]})) then
            aiBrain[refbCanPathToEnemyBaseWithLand] = true
        else aiBrain[refbCanPathToEnemyBaseWithLand] = false
        end

        if NavUtils.GetLabel(refPathingTypeAmphibious, tOurBase) == NavUtils.GetLabel(refPathingTypeAmphibious, tEnemyStartPosition) then
            aiBrain[refbCanPathToEnemyBaseWithAmphibious] = true
        else aiBrain[refbCanPathToEnemyBaseWithAmphibious] = false end

        aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] = M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[aiBrain:GetArmyIndex()], tEnemyStartPosition)
        M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.subrefiMaxScoutRadius] = math.max(1500, (M28Team.tAirSubteamData[aiBrain.M28AirSubteam][M28Team.subrefiMaxScoutRadius] or 1500), aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] * 1.5)

        --Record mitpoint between base (makes it easier to calc mod distance
        aiBrain[reftMidpointToPrimaryEnemyBase] = M28Utilities.MoveInDirection(PlayerStartPoints[aiBrain:GetArmyIndex()], M28Utilities.GetAngleFromAToB(PlayerStartPoints[aiBrain:GetArmyIndex()], tEnemyStartPosition), aiBrain[M28Overseer.refiDistanceToNearestEnemyBase], false)
    end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetOppositeLocation(tLocation)
    --Returns a point on the opposite side of the map to tLocation
    local tOpposite = {rMapPlayableArea[3] - tLocation[1] + rMapPlayableArea[1], 0, rMapPlayableArea[4] - tLocation[3] + rMapPlayableArea[2]}
    tOpposite[2] = GetSurfaceHeight(tOpposite[1], tOpposite[3])
    return tOpposite
end

function UpdateNewPrimaryBaseLocation(aiBrain)
    --Updates reftPrimaryEnemyBaseLocation to the nearest enemy start position (unless there are no structures there in which case it searches for a better start position)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'UpdateNewPrimaryBaseLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    --LOG(sFunctionRef..': aiBrain='..aiBrain:GetArmyIndex()..'; Start position='..(aiBrain:GetArmyIndex() or 'nil'))
    if bDebugMessages == true then LOG(sFunctionRef..': About to get new primary base location for brain '..aiBrain.Nickname..' unless it is civilian or defeated. IsCivilian='..tostring(M28Conditions.IsCivilianBrain(aiBrain))..'; .M28IsDefeated='..tostring((aiBrain.M28IsDefeated or false))) end
    if not(M28Conditions.IsCivilianBrain(aiBrain)) and not(aiBrain.M28IsDefeated) and not(aiBrain:IsDefeated()) then
        local tPrevPosition
        if aiBrain[reftPrimaryEnemyBaseLocation] then tPrevPosition = {aiBrain[reftPrimaryEnemyBaseLocation][1], aiBrain[reftPrimaryEnemyBaseLocation][2], aiBrain[reftPrimaryEnemyBaseLocation][3]} end
        if bDebugMessages == true then LOG(sFunctionRef..': Team='..(aiBrain.M28Team or 'nil')..'; Are all enemies defated for this team='..tostring(M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated] or false)) end
        if M28Team.tTeamData[aiBrain.M28Team][M28Team.subrefbAllEnemiesDefeated] then
            local tFriendlyBrainStartPoints = {}
            local iFriendlyBrainCount = 0
            tFriendlyBrainStartPoints[iFriendlyBrainCount] = {PlayerStartPoints[aiBrain:GetArmyIndex()][1], PlayerStartPoints[aiBrain:GetArmyIndex()][2], PlayerStartPoints[aiBrain:GetArmyIndex()][3]}
            if bDebugMessages == true then LOG(sFunctionRef..': Have no enemies, so will get average of friendly brain start points provided not the centre of the map. Is table of friendly ally active brains empty='..tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyActiveBrains]))) end

            for iBrain, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoFriendlyActiveBrains] do
                if bDebugMessages == true then LOG(sFunctionRef..': Considering ally brain index='..oBrain:GetArmyIndex()..'; Nickname='..(oBrain.Nickname or 'nil')..'; Start point='..repru((PlayerStartPoints[oBrain:GetArmyIndex()] or {'nil'}))) end
                --if not(oBrain == aiBrain) then
                iFriendlyBrainCount = iFriendlyBrainCount + 1
                tFriendlyBrainStartPoints[iFriendlyBrainCount] = {PlayerStartPoints[oBrain:GetArmyIndex()][1], PlayerStartPoints[oBrain:GetArmyIndex()][2], PlayerStartPoints[oBrain:GetArmyIndex()][3]}
                --end
            end
            local tAverageTeamPosition
            if iFriendlyBrainCount == 1 then tAverageTeamPosition = tFriendlyBrainStartPoints[iFriendlyBrainCount]
            else tAverageTeamPosition = M28Utilities.GetAverageOfLocations(tFriendlyBrainStartPoints)
            end

            if bDebugMessages == true then LOG(sFunctionRef..': iFriendlyBrainCount='..iFriendlyBrainCount..'; Friendly brain start points='..repru((tFriendlyBrainStartPoints or {'nil'}))..'; tAverageTeamPosition='..repru(tAverageTeamPosition)..'; rMapPlayableArea='..repru(rMapPlayableArea)) end

            if M28Utilities.GetDistanceBetweenPositions(tAverageTeamPosition, {rMapPlayableArea[1] + (rMapPlayableArea[3] - rMapPlayableArea[1])*0.5, 0, rMapPlayableArea[2] + (rMapPlayableArea[4] - rMapPlayableArea[2])*0.5}) <= 50 then
                --Average is really close to middle of the map, so just  assume enemy base is in the opposite direction to us
                aiBrain[reftPrimaryEnemyBaseLocation] = GetOppositeLocation(PlayerStartPoints[aiBrain:GetArmyIndex()])
            else
                --Average isnt really close to mid of map, so assume enemy base is in opposite directino to average
                aiBrain[reftPrimaryEnemyBaseLocation] = GetOppositeLocation(tAverageTeamPosition)
            end
        else --Still have enemies that are alive
            local tEnemyBase = PlayerStartPoints[M28Logic.GetNearestEnemyIndex(aiBrain)]
            if bDebugMessages == true then LOG(sFunctionRef..': Nearest enemy index='..(M28Logic.GetNearestEnemyIndex(aiBrain) or 'nil')..'; tEnemyBase='..repru(tEnemyBase)) end
            --Is this different from the current location we are using?
            if not(tEnemyBase[1] == aiBrain[reftPrimaryEnemyBaseLocation][1]) or not(tEnemyBase[3] == aiBrain[reftPrimaryEnemyBaseLocation][3]) then
                aiBrain[refiLastTimeCheckedEnemyBaseLocation] = GetGameTimeSeconds()
                aiBrain[reftPrimaryEnemyBaseLocation] = {tEnemyBase[1], tEnemyBase[2], tEnemyBase[3]}
            end
            --Below is from M27 - not sure if still need it; it is also based in part on how long since we last scouted the location with an air scout and whether there were any enemy buildings there, but land zone logic should give an alternative way of checking if any buildings there
            --[[if aiBrain.M28AI then
                --Consider if we want to check for alternative locations to the actual enemy start:
                --Have we recently checked for a base location; --Do we have at least T2 (as a basic guide that this isn't the start of the game), has at least 3m of gametime elapsed, and have scouted the enemy base location recently, and have built at least 1 air scout this game?
                if GetGameTimeSeconds() - (aiBrain[refiLastTimeCheckedEnemyBaseLocation] or -1000) >= 10 and GetGameTimeSeconds() >= 180 then
                    --(below includes alternative condition just in case there are strange unit restrictions)
                    if M28Utilities.IsTableEmpty(ScenarioInfo.Options.RestrictedCategories) or (GetGameTimeSeconds() >= 600 or (aiBrain[M28Economy.refiOurHighestFactoryTechLevel] >= 2 and not(M28Conditions.GetLifetimeBuildCount(aiBrain, M28UnitInfo.refCategoryAirScout) < 2))) then
                        if not(IsEnemyStartPositionValid(aiBrain, tEnemyBase)) then
                            aiBrain[reftPrimaryEnemyBaseLocation] = nil
                            local iNearestEnemyBase = 10000
                            local tNearestEnemyBase
                            --Cycle through every valid enemy brain and pick the nearest one, if there is one
                            if bDebugMessages == true then LOG(sFunctionRef..': Will cycle through each brain to identify nearest enemy base') end
                            for iCurBrain, brain in ArmyBrains do
                                if not(brain == aiBrain) and not(M28Logic.IsCivilianBrain(brain)) and IsEnemy(brain:GetArmyIndex(), aiBrain:GetArmyIndex()) and (not(brain:IsDefeated() and not(brain.M27IsDefeated)) or not(ScenarioInfo.Options.Victory == "demoralization")) then
                                    if M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[brain:GetArmyIndex()], PlayerStartPoints[aiBrain:GetArmyIndex()]) < iNearestEnemyBase then
                                        if IsEnemyStartPositionValid(aiBrain, PlayerStartPoints[brain:GetArmyIndex()]) then
                                            iNearestEnemyBase = M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[brain:GetArmyIndex()], PlayerStartPoints[aiBrain:GetArmyIndex()])
                                            tNearestEnemyBase = {PlayerStartPoints[brain:GetArmyIndex()][1], PlayerStartPoints[brain:GetArmyIndex()][2], PlayerStartPoints[brain:GetArmyIndex()][3]}
                                        end
                                    end
                                end
                            end
                            aiBrain[reftPrimaryEnemyBaseLocation] = tNearestEnemyBase
                            if not(aiBrain[reftPrimaryEnemyBaseLocation]) then
                                local tiCategoriesToConsider = {M28UnitInfo.refCategoryExperimentalStructure + M28UnitInfo.refCategorySML + M28UnitInfo.refCategoryFixedT3Arti, M28UnitInfo.refCategoryT3Mex, M28UnitInfo.refCategoryT2Mex, M28UnitInfo.refCategoryAirFactory + M28UnitInfo.refCategoryLandFactory}
                                local tEnemyUnits
                                tNearestEnemyBase = nil
                                for iRef, iCategory in tiCategoriesToConsider do
                                    tEnemyUnits = aiBrain:GetUnitsAroundPoint(iCategory, PlayerStartPoints[aiBrain:GetArmyIndex()], 10000, 'Enemy')
                                    if M28Utilities.IsTableEmpty(tEnemyUnits) == false then
                                        tNearestEnemyBase = M28Utilities.GetNearestUnit(tEnemyUnits, PlayerStartPoints[aiBrain:GetArmyIndex()], aiBrain, nil, nil):GetPosition()
                                        break
                                    end
                                end
                                if tNearestEnemyBase then aiBrain[reftPrimaryEnemyBaseLocation] = tNearestEnemyBase
                                else
                                    --Cant find anywhere so just pick the furthest away enemy start location
                                    iNearestEnemyBase = 10000
                                    for iCurBrain, brain in ArmyBrains do
                                        if not(brain == aiBrain) and not(M28Logic.IsCivilianBrain(brain)) and IsEnemy(brain:GetArmyIndex(), aiBrain:GetArmyIndex()) then
                                            if M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[brain:GetArmyIndex()], PlayerStartPoints[aiBrain:GetArmyIndex()]) < iNearestEnemyBase then
                                                iNearestEnemyBase = M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[brain:GetArmyIndex()], PlayerStartPoints[aiBrain:GetArmyIndex()])
                                                tNearestEnemyBase = {PlayerStartPoints[brain:GetArmyIndex()][1], PlayerStartPoints[brain:GetArmyIndex()][2], PlayerStartPoints[brain:GetArmyIndex()][3]}
                                            end
                                        end
                                    end
                                    aiBrain[reftPrimaryEnemyBaseLocation] = tNearestEnemyBase
                                end
                            end
                        end
                    end
                end
            end--]]
        end
        --Have we changed position and are dealing with an M28 brain?
        if aiBrain.M28AI and not(tPrevPosition[1] == aiBrain[reftPrimaryEnemyBaseLocation][1] and tPrevPosition[3] == aiBrain[reftPrimaryEnemyBaseLocation][3]) then
            --We have changed position so update any global variables that reference this
            if bDebugMessages == true then LOG(sFunctionRef..': Will update whether we can path to enemy') end
            ForkThread(SetWhetherCanPathToEnemy, aiBrain)
        end

        aiBrain[M28Overseer.refiDistanceToNearestEnemyBase] = M28Utilities.GetDistanceBetweenPositions(PlayerStartPoints[aiBrain:GetArmyIndex()], aiBrain[reftPrimaryEnemyBaseLocation])

    elseif bDebugMessages == true then LOG(sFunctionRef..': Dealing with a civilian brain')
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, primary enemy base location='..repru(aiBrain[reftPrimaryEnemyBaseLocation])) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetPrimaryEnemyBaseLocation(aiBrain)
    --Returns a table {x,y,z} - usually this is the start position of the nearest enemy base.  However in certain cases it will be different
    --Used as the main location for the AI to evaluate things such as threats and make decisions; by default will be the nearest enemy start position

    --Done as a function so easier to adjust in the future if decide we want to
    if not(aiBrain[reftPrimaryEnemyBaseLocation]) then UpdateNewPrimaryBaseLocation(aiBrain) end
    return aiBrain[reftPrimaryEnemyBaseLocation]
end

function AddLocationToPlateauExceptions(tLocation, iPlateau, iLandZone)
    local iX = math.floor(tLocation[1])
    local iZ = math.floor(tLocation[3])
    if not(tPathingPlateauAndLZOverride[iX]) then tPathingPlateauAndLZOverride[iX] = {} end
    tPathingPlateauAndLZOverride[iX][iZ] = {iPlateau, iLandZone}
end

function ClearTemporarySetupVariables()
    --Free up memory by clearing global variables used for map setup
    WaitTicks(10) --As basicp rotection in case any functions are still running
    tbTempConsideredLandPathingForLZ = {}
end

function SetupMap()
    --Sets up non-brain specific info on the map
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupMap'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Send a message warning players this could take a while
    for iBrain, oBrain in ArmyBrains do
        if oBrain.M28AI then
            M28Chat.SendForkedMessage(oBrain, 'LoadingMap', 'Analysing map, this may take a minute...', 0, 10000, false)
        end
    end

    --Decide how accurate map related functions are to be based on the map size:
    SetupPlayableAreaAndSegmentSizes()

    --Generate pathing
    if not(NavUtils.IsGenerated()) then
        local NavGen = import("/lua/sim/navgenerator.lua")
        NavGen.Generate()
    end

    GetMapWaterHeight()

    --Create table that stores details for each pathing group (e.g. land, amphibious) each mex in that group for easy reference later
    RecordMexForPathingGroup()

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    WaitTicks(1) --want to make sure our chat message displays
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Create table with details on all plateaus (initially just those with mexes, although the land zone logic may add to this)
    RecordAllPlateaus() --Needed first since will organise land zones by plateau

    --Setup land zones
    SetupLandZones()

    RecordIslands()

    ForkThread(ClearTemporarySetupVariables)

    bMapSetupComplete = true

    ForkThread(ReclaimManager)

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function UpdatePlateausToExpandTo(aiBrain)
    M28Utilities.ErrorHandler('To add code')
end

function GetModDistanceFromStart(aiBrain, tTarget, bUseEnemyStartInstead)
    local sFunctionRef = 'GetModDistanceFromStart'
    local bDebugMessages = false
    if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
    if bDebugMessages == true then
        LOG(sFunctionRef .. ': Start of code, GameTime=' .. GetGameTimeSeconds() .. '; aiBrain army index=' .. aiBrain:GetArmyIndex() .. '; tTarget=' .. repru(tTarget) .. '; bUseEnemyStartInstead=' .. tostring((bUseEnemyStartInstead or false)) .. '; will draw the location in white')
        M28Utilities.DrawLocation(tTarget, false, 7, 20, nil)
    end

    local iEmergencyRangeToUse = 50

    local tStartPos
    local tEnemyBase
    if bUseEnemyStartInstead then
        tStartPos = GetPrimaryEnemyBaseLocation(aiBrain)
        tEnemyBase = PlayerStartPoints[aiBrain:GetArmyIndex()]
    else
        tStartPos = PlayerStartPoints[aiBrain:GetArmyIndex()]
        tEnemyBase = GetPrimaryEnemyBaseLocation(aiBrain)
    end

    local iDistStartToTarget = M28Utilities.GetDistanceBetweenPositions(tStartPos, tTarget)
    if bDebugMessages == true then LOG(sFunctionRef .. ': tStartPos=' .. repru(tStartPos) .. '; iDistStartToTarget=' .. iDistStartToTarget .. '; iEmergencyRangeToUse=' .. iEmergencyRangeToUse) end

    if iDistStartToTarget <= iEmergencyRangeToUse then
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
        if bDebugMessages == true then LOG(sFunctionRef .. ': Are within emergency range so will just return actual dist, iDistStartToTarget=' .. iDistStartToTarget .. '; if instead we only had 1 enemy and got mod dist for this the result would be ' .. math.cos(math.abs(M28Utilities.ConvertAngleToRadians(M28Utilities.GetAngleFromAToB(tStartPos, tTarget) - M28Utilities.GetAngleFromAToB(tStartPos, GetPrimaryEnemyBaseLocation(aiBrain))))) * iDistStartToTarget) end

        return iDistStartToTarget
    else
        --If only 1 enemy group then treat anywhere behind us as the emergency range
        if bUseEnemyStartInstead then
            M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
            if bDebugMessages == true then LOG(sFunctionRef .. ': will ignore multiple enemies since have flagged to use enemy start instead, will return ' .. math.cos(M28Utilities.ConvertAngleToRadians(math.abs(M28Utilities.GetAngleFromAToB(tStartPos, tTarget) - M28Utilities.GetAngleFromAToB(tStartPos, PlayerStartPoints[aiBrain:GetArmyIndex()])))) * iDistStartToTarget) end

            return iEmergencyRangeToUse, math.cos(math.abs(M28Utilities.ConvertAngleToRadians(M28Utilities.GetAngleFromAToB(tStartPos, tTarget) - M28Utilities.GetAngleFromAToB(tStartPos, tEnemyBase)))) * iDistStartToTarget
        else
            local bIsBehindUs = true
            if bDebugMessages == true then LOG(sFunctionRef .. ': Is table of enemy brains empty=' .. tostring(M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains]))) end

            if M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains]) then
                if M28Utilities.GetDistanceBetweenPositions(tTarget, tEnemyBase) < M28Utilities.GetDistanceBetweenPositions(tStartPos, tEnemyBase) or M28Utilities.GetDistanceBetweenPositions(tTarget, tStartPos) > M28Utilities.GetDistanceBetweenPositions(tStartPos, tEnemyBase) then
                    bIsBehindUs = false
                end
            else
                for iEnemyGroup, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains] do
                    if bDebugMessages == true then LOG(sFunctionRef .. ': Distance from target to start=' .. M28Utilities.GetDistanceBetweenPositions(tTarget, tStartPos) .. '; Distance from start to enemy base=' .. M28Utilities.GetDistanceBetweenPositions(tStartPos, PlayerStartPoints[oBrain:GetArmyIndex()])) end

                    if M28Utilities.GetDistanceBetweenPositions(tTarget, PlayerStartPoints[oBrain:GetArmyIndex()]) < M28Utilities.GetDistanceBetweenPositions(tStartPos, PlayerStartPoints[oBrain:GetArmyIndex()]) or M28Utilities.GetDistanceBetweenPositions(tTarget, tStartPos) > M28Utilities.GetDistanceBetweenPositions(tStartPos, PlayerStartPoints[oBrain:GetArmyIndex()]) then
                        bIsBehindUs = false
                        break
                    end
                end
            end

            if bIsBehindUs then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                if bDebugMessages == true then LOG(sFunctionRef .. ': Will return emergency range as enemy is behind us, so returning ' .. iEmergencyRangeToUse) end

                return iEmergencyRangeToUse
            else
                --Cycle through each enemy group and get lowest value, but stop if <= emergency range
                local iCurDist
                local iLowestDist = 10000
                if M28Utilities.IsTableEmpty(M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains]) then
                    iLowestDist = math.cos(M28Utilities.ConvertAngleToRadians(math.abs(M28Utilities.GetAngleFromAToB(tStartPos, tTarget) - M28Utilities.GetAngleFromAToB(tStartPos, tEnemyBase)))) * iDistStartToTarget
                else
                    for iBrain, oBrain in M28Team.tTeamData[aiBrain.M28Team][M28Team.subreftoEnemyBrains] do
                        iCurDist = math.cos(M28Utilities.ConvertAngleToRadians(math.abs(M28Utilities.GetAngleFromAToB(tStartPos, tTarget) - M28Utilities.GetAngleFromAToB(tStartPos, PlayerStartPoints[oBrain:GetArmyIndex()])))) * iDistStartToTarget
                        if bDebugMessages == true then LOG(sFunctionRef .. ': iCurDist for enemy oBrain index ' .. oBrain:GetArmyIndex() .. ' = ' .. iCurDist .. '; Enemy base=' .. repru(PlayerStartPoints[oBrain:GetArmyIndex()]) .. '; tEnemyBase=' .. repru(tEnemyBase) .. '; Angle from start to target=' .. M28Utilities.GetAngleFromAToB(tStartPos, tTarget) .. '; Angle from Start to enemy base=' .. M28Utilities.GetAngleFromAToB(tStartPos, PlayerStartPoints[oBrain:GetArmyIndex()]) .. '; iDistStartToTarget=' .. iDistStartToTarget) end

                        if iCurDist < iLowestDist then
                            iLowestDist = iCurDist
                            if iLowestDist < iEmergencyRangeToUse then
                                iLowestDist = iEmergencyRangeToUse
                                break
                            end
                        end
                    end
                end

                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                if bDebugMessages == true then LOG(sFunctionRef .. ': iLowestDist=' .. iLowestDist) end

                return iLowestDist
            end
        end
    end
end

function RecordAvailableMassStorageLocationsForLandZone(iPlateau, iLandZone)
    local tLZData = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
    tLZData[subrefLZMassStorageLocationsAvailable] = {}
    if M28Utilities.IsTableEmpty(tLZData[subrefLZMexLocations]) == false then
        local tiXZOffset = {{-2,0}, {0, -2}, {0, 2}, {2, 0}}
        local tCurPos
        for iMex, tMex in tLZData[subrefLZMexLocations] do
            for iOffset, tXZOffset in tiXZOffset do
                tCurPos = {tMex[1] + tXZOffset[1], 0, tMex[3] + tXZOffset[2]}
                tCurPos[2] = GetSurfaceHeight(tCurPos[1], tCurPos[3])
                if M28Conditions.CanBuildStorageAtLocation(tCurPos) then
                    table.insert(tLZData[subrefLZMassStorageLocationsAvailable], tCurPos)
                end
            end
        end
    end
end

function RecordMassStorageLocationsForEachLandZone()
    for iPlateau, tPlateauSubtable in tAllPlateaus do
        for iLandZone, tLZSubtable in tPlateauSubtable[subrefPlateauLandZones] do
            RecordAvailableMassStorageLocationsForLandZone(iPlateau, iLandZone)
        end
    end
end


function GetReclaimLocationFromSegment(iReclaimSegmentX, iReclaimSegmentZ)
    --e.g. segment (1,1) will be 0 to ReclaimSegmentSizeX and 0 to ReclaimSegmentSizeZ in size
    --This will return the midpoint
    local iX = math.max(rMapPlayableArea[1], math.min(rMapPlayableArea[3], (iReclaimSegmentX - 0.5) * iReclaimSegmentSizeX))
    local iZ = math.max(rMapPlayableArea[2], math.min(rMapPlayableArea[4], (iReclaimSegmentZ - 0.5) * iReclaimSegmentSizeZ))
    return {iX, GetSurfaceHeight(iX, iZ), iZ}
end

function GetReclaimSegmentsFromLocation(tLocation)
    return math.ceil(tLocation[1] / iReclaimSegmentSizeX), math.ceil(tLocation[3] / iReclaimSegmentSizeZ)
end

function ReclaimManager()
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'ReclaimManager'

    local tAreasToUpdateThisCycle
    local iUpdateCount = 0
    local iMaxUpdatesPerTick
    local iWaitCount
    local iLoopCount
    if not(bReclaimManagerActive) then
        bReclaimManagerActive = true
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart) --Want the profile coutn to reflect the number of times actually running the core code

        while bReclaimManagerActive do
            if bDebugMessages == true then LOG(sFunctionRef..': Start of main active loop') end

            tAreasToUpdateThisCycle = {}
            iUpdateCount = 0
            iWaitCount = 0
            if M28Utilities.IsTableEmpty(tReclaimSegmentsToUpdate) then
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                WaitTicks(10)
                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
            else
                --Copy table into tAreasToUpdateThisCycle
                if bDebugMessages == true then
                    LOG(sFunctionRef..': GameTime='..GetGameTimeSeconds()..'; Will list out all entries in tReclaimSegmentsToUpdate if it isnt nil')
                    if tReclaimSegmentsToUpdate then LOG(repru(tReclaimSegmentsToUpdate)) end
                end
                for iEntry, tSubtable in tReclaimSegmentsToUpdate do
                    if (tSubtable[2] or 0) > 0 and (tSubtable[1] or 0) > 0 then --Dont bother updating places right on map edge in case pathfinding issue
                        if not(tAreasToUpdateThisCycle[tSubtable[1]]) then tAreasToUpdateThisCycle[tSubtable[1]] = {} end
                        if not(tAreasToUpdateThisCycle[tSubtable[1]][tSubtable[2]]) then
                            iUpdateCount = iUpdateCount + 1
                            tAreasToUpdateThisCycle[tSubtable[1]][tSubtable[2]] = true
                        end
                    end
                end
                --Clear the table for the next cycle
                tReclaimSegmentsToUpdate = {}
                if iUpdateCount == 0 then
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                    WaitTicks(10)
                    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                else
                    iMaxUpdatesPerTick = math.max(5, math.min(20, math.ceil(iUpdateCount / 10)))
                    iLoopCount = 0
                    if bDebugMessages == true then LOG(sFunctionRef..': About to update for iUpdateCount='..iUpdateCount..' entries; max updates per tick='..iMaxUpdatesPerTick..'; tAreasToUpdateThisCycle='..repru(tAreasToUpdateThisCycle)) end
                    for iSegmentX, tSubtable1 in tAreasToUpdateThisCycle do
                        for iSegmentZ, tSubtable2 in tAreasToUpdateThisCycle[iSegmentX] do
                            iLoopCount = iLoopCount + 1
                            if iLoopCount > iMaxUpdatesPerTick then
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                                WaitTicks(1)
                                iWaitCount = iWaitCount + 1
                                M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                                iLoopCount = 1
                            end
                            if bDebugMessages == true then LOG(sFunctionRef..': About to update reclaim data for segments '..iSegmentX..'-'..iSegmentZ) end
                            UpdateReclaimDataNearSegments(iSegmentX, iSegmentZ, 0, nil)
                        end
                    end
                    if iWaitCount < 10 then
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
                        WaitTicks(10 - iWaitCount)
                        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)
                    end
                end
            end
        end
        M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    end
end

function CreateReclaimSegment(iReclaimSegmentX, iReclaimSegmentZ)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'CreateReclaimSegment'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ] = {}
    tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint] = GetReclaimLocationFromSegment(iReclaimSegmentX, iReclaimSegmentZ)
    --tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refsSegmentMidpointLocationRef] = M28Utilities.ConvertLocationToReference(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint])
    local iPlateau, iLandZone = GetPlateauAndLandZoneReferenceFromPosition(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint])
    if (iPlateau or 0) == 0 then
        --If we get the reclaim location, is it in a pathable area, or within 2 of a pathable area?
        local rRect = M28Utilities.GetRectAroundLocation(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint], iReclaimSegmentSizeX * 0.5)
        local tReclaimables = GetReclaimInRectangle(4, rRect)
        if M28Utilities.IsTableEmpty(tReclaimables) == false then
            local iCurPlateau, iCurLandZone
            local tiXZOffset = {{-2,-2}, {-2, 2}, {2, -2}, {2, 2}}
            for iReclaim, oReclaim in tReclaimables do
                iCurPlateau, iCurLandZone = GetPlateauAndLandZoneReferenceFromPosition(oReclaim.CachePosition)
                if (iCurPlateau or 0) == 0 then
                    --Search nearby
                    for _, tiXZAdjust in tiXZOffset do
                        iCurPlateau, iCurLandZone = GetPlateauAndLandZoneReferenceFromPosition({oReclaim.CachePosition[1] + tiXZAdjust[1], oReclaim.CachePosition[2], oReclaim.CachePosition[3] + tiXZAdjust[2]})
                        if (iCurPlateau or 0) > 0 then
                            if bDebugMessages == true then LOG(sFunctionRef..': Reclaim location '..repru(oReclaim.CachePosition)..' isnt pathable but if we adjust by '..repru(tiXZAdjust)..' then it becomes pathable, adjusted position='..repru({oReclaim.CachePosition[1] + tiXZAdjust[1], oReclaim.CachePosition[2], oReclaim.CachePosition[3] + tiXZAdjust[2]})..'; iCurPlateau='..iCurPlateau..'; iCurLandZone='..(iCurLandZone or 'nil')) end
                            break
                        end
                    end
                else
                    if bDebugMessages == true then LOG(sFunctionRef..': Reclaim midpoint '..repru(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint])..' isnt pathable but the reclaim position itself, '..repru(oReclaim.CachePosition)..' is pathable, iCurPlateau='..iCurPlateau..'; iCurLandZone='..(iCurLandZone or 'nil')) end
                end
                if (iCurPlateau or 0) > 0 then
                    iPlateau = iCurPlateau
                    iLandZone = iCurLandZone
                    break
                end
            end
        end

    end
    if bDebugMessages == true then LOG(sFunctionRef..': Adding iReclaimSegmentX-Z'..iReclaimSegmentX..'-'..iReclaimSegmentZ..'; iPlateau='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
    if (iLandZone or 0) > 0 then
        --Record in the land zone
        if not(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZReclaimSegments]) then tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZReclaimSegments] = {} end
        table.insert(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZReclaimSegments], {iReclaimSegmentX, iReclaimSegmentZ})
        if bDebugMessages == true then
            LOG(sFunctionRef..': Finished adding reclaim segment to LZ, all reclaim segments for this LZ='..repru(tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZReclaimSegments]))
            local rCurRect = M28Utilities.GetRectAroundLocation(tReclaimAreas[iReclaimSegmentX][iReclaimSegmentZ][refReclaimSegmentMidpoint], iReclaimSegmentSizeX * 0.5)
            M28Utilities.DrawRectangle(rCurRect, 4)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RefreshLandZoneReclaimValue(iPlateau, iLandZone)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RefreshLandZoneReclaimValue'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)


    tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZLastReclaimRefresh] = GetGameTimeSeconds()
    local tLZDetails = tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone]
    local iMassReclaim = 0
    local iEnergyReclaim = 0
    if bDebugMessages == true then LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; Considering Plateau='..iPlateau..'; iLandZone='..iLandZone..'; Is table of LZ reclaim segments empty='..tostring(M28Utilities.IsTableEmpty(tLZDetails[subrefLZReclaimSegments]))) end
    if M28Utilities.IsTableEmpty(tLZDetails[subrefLZReclaimSegments]) == false then
        for iSegmentCount, tSegmentXZ in tLZDetails[subrefLZReclaimSegments] do
            if bDebugMessages == true then LOG(sFunctionRef..': Considering tSegmentXZ='..tSegmentXZ[1]..'-'..tSegmentXZ[2]..'; total mass in this segment='..tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][refReclaimTotalMass]) end
            iMassReclaim = iMassReclaim + tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][refReclaimTotalMass]
            iEnergyReclaim = iEnergyReclaim + tReclaimAreas[tSegmentXZ[1]][tSegmentXZ[2]][refReclaimTotalEnergy]
        end
    end
    tLZDetails[subrefLZTotalMassReclaim] = iMassReclaim
    tLZDetails[subrefLZTotalEnergyReclaim] = iEnergyReclaim
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iMassReclaim='..iMassReclaim..'; LZ reclaim='..tLZDetails[subrefLZTotalMassReclaim]) end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function GetReclaimablesMassAndEnergy(tReclaimables, iMinMass, iMinEnergy)
    --Largely a copy of GetReclaimablesResourceValue, but focused specificaly on the reclaim segment update logic
    --Must have at least iMinMass or iMinEnergy to be recorded
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetReclaimablesMassAndEnergy'
    --V14 and earlier would modify total mass value to reduce it by 25% if its small, and 50% if its medium; v15 removed this
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    local sMassRef = 'MaxMassReclaim'
    local sEnergyRef = 'MaxEnergyReclaim'

    local tWreckPos = {}
    local iTotalMass = 0
    local iTotalEnergy = 0

    local iLargestCurReclaim = 0
    local iLargestReclaimRef = 0

    if tReclaimables and table.getn( tReclaimables ) > 0 then
        for iReclaimRef, v in tReclaimables do
            tWreckPos = v.CachePosition
            if tWreckPos[1] then
                --if v.MaxMassReclaim > iIgnoreReclaimIfNotMoreThanThis then
                if v[sMassRef] > iMinMass or v[sEnergyRef] > iMinEnergy then
                    if not(v:BeenDestroyed()) then
                        iTotalMass = iTotalMass + v[sMassRef]
                        iTotalEnergy = iTotalEnergy + v[sEnergyRef]
                        if v[sMassRef] > iLargestCurReclaim then
                            iLargestCurReclaim = v[sMassRef]
                            iLargestReclaimRef = iReclaimRef
                        end
                    end
                end
            else
                if not(v.MaxMassReclaim == nil) then
                    if v.MaxMassReclaim > 0 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Warning - have ignored wreck location despite it having a mass reclaim value') end
                    end
                end
            end
        end
    end
    local tReclaimPos
    if iLargestReclaimRef then tReclaimPos = {tReclaimables[iLargestReclaimRef][1], tReclaimables[iLargestReclaimRef][2], tReclaimables[iLargestReclaimRef][3]} end

    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iTotalMass, tReclaimPos, iLargestCurReclaim, iTotalEnergy
end

function UpdateReclaimDataNearSegments(iBaseSegmentX, iBaseSegmentZ, iSegmentRange)
    --Updates reclaim data for all segments within iSegmentRange of tLocation

    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'UpdateReclaimDataNearSegments'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart) --Want the profile coutn to reflect the number of times actually running the core code

    local iMinValueOfIndividualReclaim = 2.5
    local iMinEnergyValue = 15

    local iTotalMassValue, tReclaimables, iLargestCurReclaim, tReclaimPos, iTotalEnergyValue
    local iCumulativeMassValue = 0

    if bDebugMessages == true then
        LOG(sFunctionRef..': Time='..GetGameTimeSeconds()..'; About to update for iBaseSegmentX='..(iBaseSegmentX or 'nil')..'; iSegmentRange='..(iSegmentRange or 'nil')..'; iBaseSegmentZ='..(iBaseSegmentZ or 'nil'))
    end

    local iPlateau, iLandZone

    for iCurX = iBaseSegmentX - iSegmentRange, iBaseSegmentX + iSegmentRange do
        for iCurZ = iBaseSegmentZ - iSegmentRange, iBaseSegmentZ + iSegmentRange do
            iTotalMassValue = 0
            tReclaimables = GetReclaimablesInRect(Rect((iCurX - 1) * iReclaimSegmentSizeX, (iCurZ - 1) * iReclaimSegmentSizeZ, iCurX * iReclaimSegmentSizeX, iCurZ * iReclaimSegmentSizeZ))
            iLargestCurReclaim = 0

            if bDebugMessages == true then LOG(sFunctionRef..': iCurX='..iCurX..'; iCurZ='..iCurZ..'; iReclaimSegmentSizeX='..iReclaimSegmentSizeX..'; iReclaimSegmentSizeZ='..iReclaimSegmentSizeZ..'; Reclaim search rect='..repru(Rect((iCurX - 1) * iReclaimSegmentSizeX, (iCurZ - 1) * iReclaimSegmentSizeZ, iCurX * iReclaimSegmentSizeX, iCurZ * iReclaimSegmentSizeZ))..'; Is tReclaimables empty='..tostring(M28Utilities.IsTableEmpty(tReclaimables))) end

            if tReclaimables and table.getn( tReclaimables ) > 0 then
                -- local iWreckCount = 0
                --local bIsProp = nil  --only used for log/testing
                if bDebugMessages == true then LOG('Have wrecks within the segment iCurXZ='..iCurX..'-'..iCurZ) end
                iTotalMassValue, tReclaimPos, iLargestCurReclaim, iTotalEnergyValue = GetReclaimablesMassAndEnergy(tReclaimables, iMinValueOfIndividualReclaim, iMinEnergyValue)
                --Record this table:
                if tReclaimAreas[iCurX] == nil then
                    tReclaimAreas[iCurX] = {}
                    if bDebugMessages == true then LOG('Setting table to nothing as is currently nil; iCurX='..iCurX) end
                end
                if tReclaimAreas[iCurX][iCurZ] == nil then
                    CreateReclaimSegment(iCurX, iCurZ)
                end
                --tReclaimAreas[iCurX][iCurZ][refiReclaimTotalPrev] = (tReclaimAreas[iCurX][iCurZ][refReclaimTotalMass] or 0)
                tReclaimAreas[iCurX][iCurZ][refReclaimTotalMass] = iTotalMassValue
                --tReclaimAreas[iCurX][iCurZ][refReclaimHighestIndividualReclaim] = iLargestCurReclaim
                --iHighestReclaimInASegment = math.max(iHighestReclaimInASegment, iTotalMassValue)
                tReclaimAreas[iCurX][iCurZ][refReclaimTotalEnergy] = iTotalEnergyValue
                iPlateau, iLandZone = GetPlateauAndLandZoneReferenceFromPosition(tReclaimAreas[iCurX][iCurZ][refReclaimSegmentMidpoint])
                if bDebugMessages == true then LOG(sFunctionRef..': Reclaim segment midpoint='..repru(tReclaimAreas[iCurX][iCurZ][refReclaimSegmentMidpoint])..'; iPlateau for this='..(iPlateau or 'nil')..'; iLandZone='..(iLandZone or 'nil')) end
                if iLandZone > 0 then
                    if bDebugMessages == true then LOG(sFunctionRef..': Time of last refresh for land zone '..iLandZone..'='.. (tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZLastReclaimRefresh] or 0)) end
                    if GetGameTimeSeconds() - (tAllPlateaus[iPlateau][subrefPlateauLandZones][iLandZone][subrefLZLastReclaimRefresh] or 0) >= 1 then
                        if bDebugMessages == true then LOG(sFunctionRef..': Will refresh the reclaim value for land zone '..iLandZone) end
                        RefreshLandZoneReclaimValue(iPlateau, iLandZone)
                    end
                end


            end
            iCumulativeMassValue = iCumulativeMassValue + iTotalMassValue
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iCumulativeMassValue='..iCumulativeMassValue..'; SystemTime='..GetSystemTimeSecondsOnlyForProfileUse()) end

    --M28Profiler.tiProfilerEndCountByFunction[sFunctionRef] = (M28Profiler.tiProfilerStartCountByFunction[sFunctionRef] or 0) + 1 LOG(sFunctionRef..': M28Profiler.tiProfilerEndCountByFunction[sFunctionRef]='..M28Profiler.tiProfilerEndCountByFunction[sFunctionRef])
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return iCumulativeMassValue
end

function RecordThatWeWantToUpdateReclaimAtLocation(tLocation, iNearbySegmentsToUpdate)
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end --set to true for certain positions where want logs to print
    local sFunctionRef = 'RecordThatWeWantToUpdateReclaimAtLocation'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    if iReclaimSegmentSizeX == 0 then
        M28Utilities.ErrorHandler('Dont have a reclaim segment size specified, will set it to 8.5, but something else has likely gone wrong')
        iReclaimSegmentSizeX = 8.5
        iReclaimSegmentSizeZ = 8.5
    end
    local iReclaimSegmentX, iReclaimSegmentZ = GetReclaimSegmentsFromLocation(tLocation)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of code at time='..GetGameTimeSeconds()..'; tLocation='..repru(tLocation)..'; iReclaimSegmentX-Z='..iReclaimSegmentX..'-'..iReclaimSegmentZ) end
    if iReclaimSegmentX >= 10000 or iNearbySegmentsToUpdate >= 10000 or iReclaimSegmentZ >= 10000 then M28Utilities.ErrorHandler('Likely infinite loop about to start. iReclaimSegmentX='..(iReclaimSegmentX or 'nil')..'; iNearbySegmentsToUpdate='..(iNearbySegmentsToUpdate or 'nil')..'; iReclaimSegmentSizeX='..(iReclaimSegmentSizeX or 'nil')..'; iReclaimSegmentSizeZ='..(iReclaimSegmentSizeX or 'nil')..'; rMapPlayableArea='..repru(rMapPlayableArea or {'nil'})..'; iMaxSegmentInterval='..(iMaxSegmentInterval or 'nil'))
    else

        if iNearbySegmentsToUpdate then
            for iSegmentX = iReclaimSegmentX - iNearbySegmentsToUpdate, iReclaimSegmentX + iNearbySegmentsToUpdate do
                for iSegmentZ = iReclaimSegmentZ - iNearbySegmentsToUpdate, iReclaimSegmentZ + iNearbySegmentsToUpdate do
                    if bDebugMessages == true then LOG(sFunctionRef..': Will record that we want to update the reclaim segment XZ='..iSegmentX..'-'..iSegmentZ) end
                    RecordThatWeWantToUpdateReclaimSegment(iSegmentX, iSegmentZ)
                end
            end
        else
            if bDebugMessages == true then LOG(sFunctionRef..': Will record that we want to update the base reclaim segment XZ='..iReclaimSegmentX..'-'..iReclaimSegmentZ) end
            RecordThatWeWantToUpdateReclaimSegment(iReclaimSegmentX, iReclaimSegmentZ)
        end
    end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
end

function RecordThatWeWantToUpdateReclaimSegment(iReclaimSegmentX, iReclaimSegmentZ)
    if iReclaimSegmentX >= 0 and iReclaimSegmentZ >= 0 then table.insert(tReclaimSegmentsToUpdate, {iReclaimSegmentX, iReclaimSegmentZ}) end
end


function GetTravelDistanceBetweenLandZones(iPlateau, iStartLZ, iEndLZ)
    local tStartLZData = tAllPlateaus[iPlateau][subrefPlateauLandZones][iStartLZ]
    if not(tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau][iEndLZ]) then
        if not(tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau]) then tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau] = {} end
        tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau][iEndLZ] = M28Utilities.GetTravelDistanceBetweenPositions(tStartLZData[subrefLZMidpoint], tAllPlateaus[iPlateau][subrefPlateauLandZones][iEndLZ][subrefLZMidpoint], refPathingTypeLand)
    end
    return tStartLZData[subrefLZTravelDistToOtherLandZones][iPlateau][iEndLZ]
end


function GetPositionAtOrNearTargetInPathingGroup(tStartPos, tTargetPos, iDistanceFromTargetToStart, iAngleAdjust, oPathingUnit, bMoveCloserBeforeFurtherIfBlocked, bCheckIfExistingTargetIsBetter, iMinDistanceFromExistingCommandTarget)
    --Intended as a rewriting of GetPositionNearTargetInSamePathingGroup due to some inconsistencies arising with the below, to make use of new logic that allows any angle; introduced from v15
    local bDebugMessages = false if M28Profiler.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetPositionAtOrNearTargetInPathingGroup'
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerStart)

    --Get angle from target to start
    local iAngleFromTargetToStart = M28Utilities.GetAngleFromAToB(tTargetPos, tStartPos) + (iAngleAdjust or 0)
    --Get initial desired position
    local tPossibleTarget = M28Utilities.MoveInDirection(tTargetPos, iAngleFromTargetToStart, iDistanceFromTargetToStart)
    local sPathing = M28UnitInfo.GetUnitPathingType(oPathingUnit)
    local iPathingGroupWanted = NavUtils.GetLabel(sPathing, tTargetPos)
    local iPathingGroupOfPossibleTarget = NavUtils.GetLabel(sPathing, tPossibleTarget)
    local bCanPathToTarget = false

    if bDebugMessages == true then LOG(sFunctionRef..': Start of code; oPathingUnit='..oPathingUnit.UnitId..M28UnitInfo.GetUnitLifetimeCount(oPathingUnit)..'; tTargetPos='..repru(tTargetPos)..'; iAngleAdjust ='..iAngleAdjust..'; iDistanceFromTargetToStart='..iDistanceFromTargetToStart..'; tStartPos='..repru(tStartPos)..'; iPathingGroupOfPossibleTarget='..iPathingGroupOfPossibleTarget..'; iPathingGroupWanted='..iPathingGroupWanted..'; Angle from start to target='..M28Utilities.GetAngleFromAToB(tStartPos, tTargetPos)..'; iAngleFromTargetToStart='..iAngleFromTargetToStart..'; Amphibious group of target position='..NavUtils.GetLabel(refPathingTypeAmphibious, tTargetPos)..'; Amphib group of our base='..NavUtils.GetLabel(refPathingTypeAmphibious, PlayerStartPoints[oPathingUnit:GetAIBrain():GetArmyIndex()])..'; tPossibleTarget before adjust='..repru(tPossibleTarget)..'; Distance between possible target and tTargetPos='..M28Utilities.GetDistanceBetweenPositions(tPossibleTarget, tTargetPos)) end
    --Find a target we can path to
    if iPathingGroupOfPossibleTarget == iPathingGroupWanted then
        bCanPathToTarget = true
    else
        --Dif pathing group, need to try alternatives; first try the target itself
        if not(bMoveCloserBeforeFurtherIfBlocked == false) then
            tPossibleTarget = {tTargetPos[1], tTargetPos[2], tTargetPos[3]}
            iPathingGroupOfPossibleTarget = NavUtils.GetLabel(sPathing, tPossibleTarget)
            if bDebugMessages == true then LOG(sFunctionRef..': Pathing group if just try target position='..iPathingGroupOfPossibleTarget) end
            if iPathingGroupOfPossibleTarget == iPathingGroupWanted then
                bCanPathToTarget = true
            end
        end

        if bCanPathToTarget == false then
            if bDebugMessages == true then LOG(sFunctionRef..': Cant path to the initial expected point so will try nearby points') end
            local tDistanceFactors
            if bMoveCloserBeforeFurtherIfBlocked then
                tDistanceFactors = {0.5, 1.5, 3}
            else tDistanceFactors = {1.25, 3}
            end
            local tAngleVariations = {-45, 0, 45}
            --Make sure we have at least some distance we're moving away from
            if iDistanceFromTargetToStart == 0 then iDistanceFromTargetToStart = 1 end

            if math.abs(iDistanceFromTargetToStart) < 4 then
                local iFactorIncrease = 4 / iDistanceFromTargetToStart
                for iDistanceFactor = 1, table.getn(tDistanceFactors) do
                    tDistanceFactors[iDistanceFactor] = tDistanceFactors[iDistanceFactor] * iFactorIncrease
                end
            end
            for iDistanceFactor = 1, table.getn(tDistanceFactors) do
                for iAngleAlternative = 1, table.getn(tAngleVariations) do
                    tPossibleTarget = M28Utilities..MoveInDirection(tTargetPos, iAngleFromTargetToStart + tAngleVariations[iAngleAlternative], iDistanceFromTargetToStart * tDistanceFactors[iDistanceFactor])
                    if NavUtils.GetLabel(sPathing, tPossibleTarget) == iPathingGroupWanted then
                        bCanPathToTarget = true
                        break
                    end
                end
                if bCanPathToTarget then break end
                if bDebugMessages == true then LOG(sFunctionRef..': iDistanceFactor='..iDistanceFactor..'; tPossibleTarget based on the last of the angle variations='..repru(tPossibleTarget)..'; still cant path to the target so will keep looking') end
            end
        end

    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished checking if can path to target, bCanPathToTarget='..tostring(bCanPathToTarget)..'; tPossibleTarget='..repru(tPossibleTarget)) end

    if bCanPathToTarget then
        --Consider if the target meets any other values specified (e.g. if must be certain distance away from current target or unit)
        if bCheckIfExistingTargetIsBetter == true or iMinDistanceFromExistingCommandTarget then
            if bDebugMessages == true then LOG(sFunctionRef..': Checking against existing target to see if thats better') end
            if oPathingUnit.GetNavigator then
                local oNavigator = oPathingUnit:GetNavigator()
                if oNavigator.GetCurrentTargetPos then
                    local tExistingTargetPos = oNavigator:GetCurrentTargetPos()
                    if M28Utilities.IsTableEmpty(tExistingTargetPos) == false then
                        if bDebugMessages == true then LOG(sFunctionRef..': tExistingTargetPos='..repru(tExistingTargetPos)..'; Distance to possible target='..M28Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tPossibleTarget)..'; iMinDistanceFromExistingCommandTarget='..(iMinDistanceFromExistingCommandTarget or 'nil')..'; Pathing group of this='..NavUtils.GetLabel(sPathing, tExistingTargetPos)..'; Pathing group wanted='..iPathingGroupWanted..'; sPathing='..sPathing..'; Distance of existing position toa ctual target='..M28Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tTargetPos)) end
                        if NavUtils.GetLabel(sPathing, tExistingTargetPos) == iPathingGroupWanted then

                            --Do we have a minimum distance away from current target required?
                            if iMinDistanceFromExistingCommandTarget and M28Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tPossibleTarget) < iMinDistanceFromExistingCommandTarget then
                                if bDebugMessages == true then LOG(sFunctionRef..': Distance between existing target position and possible target position is less than the min distance; tExistingTargetPos='..repru(tExistingTargetPos)..'; tPossibleTarget='..repru(tPossibleTarget)) end
                                tPossibleTarget = tExistingTargetPos
                            else
                                --Is the existing target position closer to the distance required than the new position, factoring in if we want a negative position or not?
                                local iDistanceFromQueuedMoveLocationToTarget = M28Utilities.GetDistanceBetweenPositions(tExistingTargetPos, tTargetPos)
                                local iDistanceFromPossibleTargetToTarget = M28Utilities.GetDistanceBetweenPositions(tPossibleTarget, tTargetPos)
                                --Are these further away from the start position than the actual target?
                                if math.abs(iDistanceFromQueuedMoveLocationToTarget - iDistanceFromTargetToStart) < math.abs(iDistanceFromPossibleTargetToTarget - iDistanceFromTargetToStart) then
                                    --Have we said we want to move closer if the initial point is blocked?
                                    if not(bMoveCloserBeforeFurtherIfBlocked) or iDistanceFromQueuedMoveLocationToTarget <= iDistanceFromTargetToStart then
                                        --Factor in we might be infront of the target and actually want to be behind
                                        local iDistanceFromStartToTarget = M28Utilities.GetDistanceBetweenPositions(tStartPos, tTargetPos)
                                        local iDistanceFromQueuedToStart = M28Utilities.GetDistanceBetweenPositions(tStartPos, tExistingTargetPos)
                                        if bDebugMessages == true then LOG(sFunctionRef..': iDistanceFromQueuedMoveLocationToTarget='..iDistanceFromQueuedMoveLocationToTarget..'; iDistanceFromPossibleTargetToTarget='..iDistanceFromPossibleTargetToTarget..'; iDistanceFromQueuedToStart='..iDistanceFromQueuedToStart..'; iDistanceFromStartToTarget='..iDistanceFromStartToTarget..'; iDistanceFromTargetToStart='..iDistanceFromTargetToStart) end
                                        if iDistanceFromQueuedToStart > 1 and ((iDistanceFromQueuedToStart < iDistanceFromStartToTarget and iDistanceFromTargetToStart > 0) or (iDistanceFromQueuedToStart > iDistanceFromStartToTarget and iDistanceFromTargetToStart < 0)) then
                                            if bDebugMessages == true then LOG(sFunctionRef..': Existing location is closer than the new possible location so go with this') end
                                            --Existing location is closer than the new location so go with this
                                            tPossibleTarget = tExistingTargetPos
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    else
        --This could be due to a pathfinding error, will just use the potential target
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code; tPossibleTarget='..repru(tPossibleTarget or {'nil'})..'; bCanPathToTarget='..tostring(bCanPathToTarget)) end
    M28Profiler.FunctionProfiler(sFunctionRef, M28Profiler.refProfilerEnd)
    return tPossibleTarget
end