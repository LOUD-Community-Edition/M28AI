---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by maudlin27.
--- DateTime: 16/11/2022 07:22
---

local M28Profiling = import('/mods/M28AI/lua/AI/M28Profiling.lua')
local M28Utilities = import('/mods/M28AI/lua/AI/M28Utilities.lua')
local NavUtils = import("/lua/sim/navutils.lua")
local FAFColour = import("/lua/shared/color.lua")

--Pathing types
--NavLayers 'Land' | 'Water' | 'Amphibious' | 'Hover' | 'Air'
refPathingTypeAmphibious = 'Amphibious'
refPathingTypeNavy = 'Water'
refPathingTypeAir = 'Air'
refPathingTypeLand = 'Land'
refPathingTypeNone = 'None'
refPathingTypeAll = {refPathingTypeAmphibious, refPathingTypeNavy, refPathingTypeAir, refPathingTypeLand}

--Map size
rMapPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2} - Set at start of the game, use instead of the scenarioinfo method
iMaxLandSegmentX = 1
iMaxLandSegmentZ = 1

iMapWaterHeight = 0 --Surface height of water on the map

--Resource information
tMassPoints = {} --[x] is an integer count, returns the location of a mass point; stores all mexes on the map
tHydroPoints = {} --[x] is an integer count, returns the location of a hydro point; stores all hydro points on the map
tMexByPathingAndGrouping = {} --Stores position of each mex based on the pathing group that it's part of; [a][b][c]: [a] = pathing type ('Land' etc.); [b] = Segment grouping; [c] = Mex position
tHydroByPathingAndGrouping = {} --as above but for hydros


--Plateaus - core
tAllPlateaus = {} --[x] = AmphibiousPathingGroup, [y]: subrefs, e.g. subrefPlateauMexes;
--aibrain variables for plateaus:
reftPlateausOfInterest = 'M27PlateausOfInterest' --[x] = Amphibious pathing group; will record a table of the pathing groups we're interested in expanding to, returns the location of then earest mex
refiLastPlateausUpdate = 'M27LastTimeUpdatedPlateau' --gametime that we last updated the plateaus
reftOurPlateauInformation = 'M27OurPlateauInformation' --[x] = AmphibiousPathingGroup; [y] = subref, e.g. subrefPlateauLandFactories; Used to store details such as factories on the plateau
refiOurBasePlateauGroup = 'M27PlateausOurBaseGroup' --Segment group of our base (so can easily check somewhere is in a dif plateau)

--subrefs for tables
--tAllPlateaus subrefs
subrefPlateauMexes = 'M27PlateauMex' --[x] = mex count, returns mex position
subrefPlateauMinXZ = 'M27PlateauMinXZ' --{x,z} min values
subrefPlateauMaxXZ = 'M27PlateauMaxXZ' --{x,z} max values - i.e. can create a rectangle covering entire plateau using min and max xz values
subrefPlateauTotalMexCount = 'M27PlateauMexCount' --Number of mexes on the plateau
subrefPlateauReclaimSegments = 'M27PlateauReclaimSegments' --[x] = reclaim segment x, [z] = reclaim segment z, returns true if part of plateau
subrefPlateauMidpoint = 'M27PlateauMidpoint' --Location of the midpoint of the plateau
subrefPlateauMaxRadius = 'M27PlateauMaxRadius' --Radius to use to ensure the circle coveres the square of the plateau
subrefPlateauContainsActiveStart = 'M27PlateauContainsActiveStart' --True if the plateau is pathable amphibiously to a start position that was active at the start of the game

--reftOurPlateauInformation subrefs (NOTE: If adding more info here need to update in several places, including ReRecordUnitsAndPlatoonsInPlateaus)
subrefPlateauLandFactories = 'M27PlateauLandFactories'

subrefPlateauLandCombatPlatoons = 'M27PlateauLandCombatPlatoons'
subrefPlateauIndirectPlatoons = 'M27PlateauIndirectPlatoons'
subrefPlateauMAAPlatoons = 'M27PlateauMAAPlatoons'
subrefPlateauScoutPlatoons = 'M27PlateauScoutPlatoons'

subrefPlateauEngineers = 'M27PlateauEngineers' --[x] is engineer unique ref (per m27engineeroverseer), returns engineer object

--Plateaus - Land zone variables
subrefPlateauLandZones = 'M27PlateauLandZones' --against the main plateau table, stores info on land zones for that plateau
subrefLandZoneCount = 'M27PlateauZoneCount' --against the main plateau table, records how many land zones there are (alternative to table.getn on the land zones)
iLandZoneSegmentSize = 5 --Gets updated by the SetupLandZones - the size of one side of the square that is the lowest resolution land zones go to; each segment that is land pathable gets assigned to a land zone
tLandZonesByPlateau = {} --[x] is the plateau group number, returns a table where [y] is the land zone number, which then returns details on the land zone; use tLandZoneBySegment to get a zone reference from land segments
subrefLZMexCount = 'MexCount' --against tLandZonesByPlateau[iPlateau][iLZ], returns number of mexes in the LZ
subrefLZMexLocations = 'MexLoc' --against tLandZonesByPlateau[iPlateau][iLZ], returns table of mex locations in the LZ
subrefLZReclaimMass = 'ReclaimMass' --against tLandZonesByPlateau[iPlateau][iLZ], returns total mass reclaim in the LZ

--Land pathing segment data
tLandZoneBySegment = {} --[x][z] should be the x and z segments baed on iLandZoneSegmentSize, and should return the land zone number, or nil if there is none
tTempZoneTravelDistanceBySegment = {} --[x][z] should be the x and z segments, used to temporarily store the distance values for segments at start of the game when setting up land zones

---@param tPosition table
---@return number, number
function GetPathingSegmentFromPosition(tPosition)
    --The map is divided into equal sized square segments with each segment allocated to a land zone; this can be used to get the segment X and Z references
    --tPosition shoudl be {x,y,z} format, although y value is ignored)
    return math.floor( (tPosition[1] - rMapPlayableArea[1]) / iLandZoneSegmentSize) + 1, math.floor((tPosition[3] - rMapPlayableArea[2]) / iLandZoneSegmentSize) + 1
end

---@param iSegmentX number
---@param iSegmentZ number
---@return table
function GetPositionFromPathingSegments(iSegmentX, iSegmentZ)
    --Returns the position/location of land segment X and Z references iSegmentX and iSegmentZ (i.e. the map is divided into equal sized square segments, with each segment allocated to a land zone)
    local x = iSegmentX * iLandZoneSegmentSize - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[1]
    local z = iSegmentZ * iLandZoneSegmentSize - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[2] --If changing this, then also update AssignRemainingSegmentsToLandZone which manually does this for performance
    return {x, GetTerrainHeight(x, z), z}
end

---@param tPosition table
---@param bOptionalShouldBePathable boolean
---@return number, number
function GetPlateauAndLandZoneReferenceFromPosition(tPosition, bOptionalShouldBePathable)
    --Returns the plateau reference of tPosition (where tPosition is {x,y,z}), and the Land zone reference for that position
    --returns nil if cant find valid plateau or land zone
    --bOptionalShouldBePathable - if e.g. have a unit at tPosition, then set this to true as it means somehow a unit could path in this area, and the code will then try backup options and give error messages

    --Get the plateau reference and the land segment X and Z references:
    local iPlateauGroup = NavUtils.GetLabel(refPathingTypeAmphibious, tPosition)
    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tPosition)
    --Check if the plateau reference is valid:
    local bUsingSegmentPlateauRef = false
    if not(tAllPlateaus[iPlateauGroup]) then
        --Potential error - get the plateau if the midpoint instead if should be pathable
        if bOptionalShouldBePathable then
            iPlateauGroup = NavUtils.GetLabel(refPathingTypeAmphibious, GetPositionFromPathingSegments(iSegmentX, iSegmentZ))
            bUsingSegmentPlateauRef = true
            if not(tAllPlateaus[iPlateauGroup]) then
                M28Utilities.ErrorHandler('No plateau group for tPosition '..repru(tPosition)..' or segment midpoint '..repru(GetPositionFromPathingSegments(iSegmentX, iSegmentZ))..'; Plateau group of segment midpoint='..(NavUtils.GetLabel(refPathingTypeAmphibious, GetPositionFromPathingSegments(iSegmentX, iSegmentZ)) or 'nil')..'; Plateau Group of tPosition='..(NavUtils.GetLabel(refPathingTypeAmphibious, tPosition) or 'nil'))
                return nil
            end
        else
            return nil
        end
    end
    --Get the land zone reference:
    local iLandZone = tLandZoneBySegment[iSegmentX][iSegmentZ]
    --Check if the land zone reference is valid for this plateau group:
    if not(tAllPlateaus[iPlateauGroup][subrefPlateauLandZones][iLandZone]) then
        if bOptionalShouldBePathable then
            if not(bUsingSegmentPlateauRef) then
                iPlateauGroup = NavUtils.GetLabel(refPathingTypeAmphibious, GetPositionFromPathingSegments(iSegmentX, iSegmentZ))
            end
            if not(tAllPlateaus[iPlateauGroup][subrefPlateauLandZones][iLandZone]) then
                M28Utilities.ErrorHandler('The plateau group '..(iPlateauGroup or 'nil')..' for the segment '..iSegmentX..'-'..iSegmentZ..' midpoint of '..repru(GetPositionFromPathingSegments(iSegmentX, iSegmentZ))..' doesnt have a plateau setup with the land zone reference '..(iLandZone or 'nil')..'; tPosition='..repru(tPosition)..'; NavUtils.GetLabel(refPathingTypeAmphibious, tPosition)='..(NavUtils.GetLabel(refPathingTypeAmphibious, tPosition) or 'nil'))
                return nil
            end
        else
            return nil
        end
    end

    --Have a valid plateau and land zone reference so return these:
    return iPlateauGroup, iLandZone
end

---@param tLocation table
---@return number, number
function GetReclaimSegmentsFromLocation(tLocation)
    --Returns the reclaim segment X and Z values for a given location on the map (i.e. map is divided into reclaim segment squares which are a different size to land zone segments)
    --tLocation should be in the {x,y,z} format, although y value is ignored
    return math.ceil(tLocation[1] / iReclaimSegmentSizeX), math.ceil(tLocation[3] / iReclaimSegmentSizeZ)
end

---@param iReclaimSegmentX number
---@param iReclaimSegmentZ number
---@return table
function GetReclaimLocationFromSegment(iReclaimSegmentX, iReclaimSegmentZ)
    --If given the reclaim segment X and Z values, then will convert this into an {x,y,z} position
    --e.g. segment (1,1) will be 0 to ReclaimSegmentSizeX and 0 to ReclaimSegmentSizeZ in size
    --This will return the midpoint of the reclaim segment
    local iX = math.max(rMapPlayableArea[1], math.min(rMapPlayableArea[3], (iReclaimSegmentX - 0.5) * iReclaimSegmentSizeX))
    local iZ = math.max(rMapPlayableArea[2], math.min(rMapPlayableArea[4], (iReclaimSegmentZ - 0.5) * iReclaimSegmentSizeZ))
    return {iX, GetSurfaceHeight(iX, iZ), iZ}
end

local function SetupPlayableAreaAndSegmentSizes()
    --Sets up key values needed to divide the map up into segments (small squares) for both land zone segments and reclaim segments - should be called as one of the first pieces of code
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DetermineReclaimAndLandSegmentSizes'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)
    if ScenarioInfo.MapData.PlayableRect then
        rMapPlayableArea = ScenarioInfo.MapData.PlayableRect
    else
        rMapPlayableArea = {0, 0, ScenarioInfo.size[1], ScenarioInfo.size[2]}
    end


    --Decide on land zone segment sizes
    local iHighestSize = math.max(rMapPlayableArea[3] - rMapPlayableArea[1], rMapPlayableArea[4] - rMapPlayableArea[2])
    local iTableSizeCap = 25000 --tried with 50k but on a 10km map it took too long to do the initial setup

    --50000 = SegmentCount^2; SegmentCount = iTotalSize / SegmentSize; (TotalSize/SegmentSize)^2 = 50k; SemgentSize = TotalSize/Sqrt(50k)
    iLandZoneSegmentSize = math.ceil(iHighestSize / math.sqrt(iTableSizeCap))

    --Record the max values
    iMaxLandSegmentX, iMaxLandSegmentZ = GetPathingSegmentFromPosition({rMapPlayableArea[3], 0, rMapPlayableArea[4]})

    if bDebugMessages == true then LOG(sFunctionRef..': iHighestSize='..iHighestSize..'; iTableSizeCap='..iTableSizeCap..'; iLandZoneSegmentSize='..iLandZoneSegmentSize..'; Max Segment X-Z='..iMaxLandSegmentX..'-'..iMaxLandSegmentZ) end


    local iMinReclaimSegmentSize = 8.5 --Engineer build range is 6; means that a square of about 4.2 will fit inside this circle; If have 2 separate engineers assigned to adjacent reclaim segments, and want their build range to cover the two areas, then would want a gap twice this, so 8.4; will therefore go with min size of 8
    local iMapSizeX = rMapPlayableArea[3] - rMapPlayableArea[1]
    local iMapSizeZ = rMapPlayableArea[4] - rMapPlayableArea[2]
    iReclaimSegmentSizeX = math.max(iMinReclaimSegmentSize, iMapSizeX / iLandZoneSegmentSize)
    iReclaimSegmentSizeZ = math.max(iMinReclaimSegmentSize, iMapSizeZ / iLandZoneSegmentSize)
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

---@param sResourceType string
---@param x number
---@param y number
---@param z number
function RecordResourcePoint(sResourceType,x,y,z,size)
    --called by hook into simInit, more reliable method of figuring out if have adaptive map than using markers, as not all mass markers may have mexes generated on an adaptive map
    --Whenever a resource location is created in the map, this is called, and will record the resource location into a table of mex points (tMassPoints) and hydro points (tHydroPoints) for referencing in later code
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordResourcePoint'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': sResourceType='..sResourceType..'; x='..x..'; y='..y..'; z='..z..'; size='..repru(size)..'; Mass count pre update='..table.getn(tMassPoints)..'; Hydro points pre update='..table.getn(tHydroPoints)) end

    if sResourceType == 'Mass' then
        table.insert(tMassPoints, {x,y,z})
    elseif sResourceType == 'Hydrocarbon' then
        table.insert(tHydroPoints, {x,y,z})
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of hook; Mass points post update='..table.getn(tMassPoints)..'; Hydro poitns post update='..table.getn(tHydroPoints)) end
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

---@param sPathing string
---@param tLocation table
---@return number
function GetSegmentGroupOfLocation(sPathing, tLocation)
    --Included for backwards compatibility with M27 logic; better to use the below line directly
    --Returns a reference number based on sPathing that groups areas based on whether they can path to each other (so if two locations have the same reference, they can path to each other)
    --sPathing should be one of the refPathingType variables defined at the top of this file; tLocation is {x,y,z} format
    return NavUtils.GetLabel(sPathing, tLocation)
end

local function RecordMexForPathingGroup()
    --Cycles through every mex on the map, and includes it in a table of mexes that is grouped by pathing type, so in future we can easily cycle through mexes for a particular pathing type
    --e.g. after running this, can use tMexByPathingAndGrouping[sPathing][iPathingGroup] where sPathing is the refPathingType variable, and ipathingGroup is the NavUtils.GetLabel(sPathing, tLocation) reference
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordMexForPathingGroup'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': About to record mexes for each pathing group. MassPoints='..repru(tMassPoints)) end
    local tsPathingTypes = {refPathingTypeAmphibious, refPathingTypeNavy, refPathingTypeLand}
    local iCurResourceGroup
    local iValidCount = 0
    tMexByPathingAndGrouping = {}
    if bDebugMessages == true then
        LOG(sFunctionRef..': NavUtils test - will cycle through each mex and get land label')
        for iMex, tMex in tMassPoints do
            LOG(sFunctionRef..': tMex='..repru(tMex)..'; Label='..(NavUtils.GetLabel('Land', tMex) or 'nil'))
            if not(NavUtils.GetLabel('Land', tMex)) then
                LOG(sFunctionRef..': WARNING - dont have a land label for mex '..repru(tMex))
            else
                LOG(sFunctionRef..': Have a land label for mex '..repru(tMex)..' so will stop with warning messages as pathing apepars generated')
                break
            end
        end
    end
    for iPathingType, sPathing in tsPathingTypes do
        tMexByPathingAndGrouping[sPathing] = {}
        iValidCount = 0

        if bDebugMessages == true then
            LOG(sFunctionRef..': About to record all mexes for pathing type sPathing='..sPathing)
        end

        for iCurMex, tMexLocation in tMassPoints do
            iValidCount = iValidCount + 1
            iCurResourceGroup = NavUtils.GetLabel(sPathing, tMexLocation)
            if not(iCurResourceGroup) then
                if bDebugMessages == true then LOG('Dont have a resource group for mex location '..repru(tMexLocation)..'; This is expected if mexes are located outside the playable area or are testing water pathing for land mexes and vice versa') end
            else
                if bDebugMessages == true then
                    LOG(sFunctionRef..': iCurMex='..iCurMex..'; About to get segment group for pathing='..sPathing..'; location='..repru((tMexLocation or {'nil'}))..'; iCurResourceGroup='..(iCurResourceGroup or 'nil'))
                    local iSegmentX, iSegmentZ = GetPathingSegmentFromPosition(tMexLocation)
                    LOG(sFunctionRef..': Pathing segments='..(iSegmentX or 'nil')..'; iSegmentZ='..(iSegmentZ or 'nil')..'; rMapPlayableArea='..repru(rMapPlayableArea)..'; iLandZoneSegmentSize='..(iLandZoneSegmentSize or 'nil'))
                end
                if tMexByPathingAndGrouping[sPathing][iCurResourceGroup] == nil then
                    tMexByPathingAndGrouping[sPathing][iCurResourceGroup] = {}
                    iValidCount = 1
                else iValidCount = table.getn(tMexByPathingAndGrouping[sPathing][iCurResourceGroup]) + 1
                end
                tMexByPathingAndGrouping[sPathing][iCurResourceGroup][iValidCount] = tMexLocation
                if bDebugMessages == true then LOG(sFunctionRef..': iValidCount='..iValidCount..'; sPathing='..sPathing..'; iCurResourceGroup='..iCurResourceGroup..'; just added tMexLocation='..repru(tMexLocation)..' to this group') end
            end
        end
        if sPathing == refPathingTypeLand and iValidCount == 0 then M28Utilities.ErrorHandler('Dont have any mexes recording for land pathing type') end
    end
    if bDebugMessages == true then LOG(sFunctionRef..'; tMexByPathingAndGrouping='..repru(tMexByPathingAndGrouping)) end
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

local function RecordAllPlateaus()
    --Records any plateaus that contain mexes, along with info on the plateau
    --tAllPlateaus[iSegmentGroup] can be used to then reference subtables with further information on the plateau, where iSegmentGroup is the result of NavUtils.GetLabel(refPathingTypeAmphibious, {x,y,z})

    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordAllPlateaus'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)


    --tMexByPathingAndGrouping --[a][b][c]: [a] = pathing type ('Land' etc.); [b] = Segment grouping; [c] = Mex position
    --tAllPlateaus = {} --v41 - decided to take this out to see if it helps with issue where plateau number changes and all existing platoons become invalid


    local iCurPlateauMex
    local iMinSegmentX, iMinSegmentZ, iMaxSegmentX, iMaxSegmentZ, iCurSegmentGroup

    if bDebugMessages == true then LOG(sFunctionRef..': About to get max map segment X and Z based on rMapPlayableArea='..repru(rMapPlayableArea)) end
    local iMapMaxSegmentX, iMapMaxSegmentZ = GetPathingSegmentFromPosition({rMapPlayableArea[3], 0, rMapPlayableArea[4]})
    local iStartSegmentX, iStartSegmentZ
    local bSearchingForBoundary
    local iCurCount
    local tSegmentPosition
    local iReclaimSegmentStartX, iReclaimSegmentStartZ, iReclaimSegmentEndX, iReclaimSegmentEndZ
    local sPathing = refPathingTypeAmphibious


    --Cycle through every amphibious pathing group that has mexes in it:
    for iSegmentGroup, tSubtable in tMexByPathingAndGrouping[sPathing] do
        --If we dont already have a plateau setup then create one:
        if not(tAllPlateaus[iSegmentGroup]) then
            --Have a plateau with mexes that havent already recorded
            tAllPlateaus[iSegmentGroup] = {}
            tAllPlateaus[iSegmentGroup][subrefPlateauMexes] = {}
            iCurPlateauMex = 0
            --Record every mex against the PlateausWithMexes table:
            for iMex, tMex in tMexByPathingAndGrouping[sPathing][iSegmentGroup] do
                iCurPlateauMex = iCurPlateauMex + 1
                tAllPlateaus[iSegmentGroup][subrefPlateauMexes][iCurPlateauMex] = tMex
            end
            tAllPlateaus[iSegmentGroup][subrefPlateauTotalMexCount] = iCurPlateauMex
            --Record additional information if the plateau has mexes:
            if iCurPlateauMex > 0 then
                --Record information on the size of the plateau:
                    --Start from mex, and move up on map to determine top point; then move left to determine left point, and right to determine right point etc.
                    --i.e. dont want to go through every segment on map since could take ages if lots of plateaus and may only be dealing with small area
                iStartSegmentX, iStartSegmentZ = GetPathingSegmentFromPosition(tAllPlateaus[iSegmentGroup][subrefPlateauMexes][1])

                --First find the smallest z (so go up)
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount > iStartSegmentZ then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments(iStartSegmentX, iStartSegmentZ - iCurCount))  --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX][iStartSegmentZ - iCurCount]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartX = 1, iMapMaxSegmentX do
                            iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments(iAltStartX, iStartSegmentZ - iCurCount)) --tPathingSegmentGroupBySegment[sPathing][iAltStartX][iStartSegmentZ - iCurCount]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentX = iAltStartX
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                --Will have the min Z value now
                iMinSegmentZ = iStartSegmentZ - iCurCount + 1


                --Now check for the min X value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount > iStartSegmentX then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments((iStartSegmentX - iCurCount), iStartSegmentZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX - iCurCount][iStartSegmentZ]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same X value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartZ = iMinSegmentZ, iMapMaxSegmentZ do
                            iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments((iStartSegmentX - iCurCount), iAltStartZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX - iCurCount][iAltStartZ]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentZ = iAltStartZ
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end

                --Will now have the min X value
                iMinSegmentX = iStartSegmentX - iCurCount + 1

                --Now get max Z value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount + iStartSegmentZ > iMapMaxSegmentZ then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments(iStartSegmentX, (iStartSegmentZ + iCurCount))) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX][iStartSegmentZ + iCurCount]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartX = iMinSegmentX, iMapMaxSegmentX do
                            iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments(iAltStartX, (iStartSegmentZ + iCurCount))) --tPathingSegmentGroupBySegment[sPathing][iAltStartX][iStartSegmentZ + iCurCount]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentX = iAltStartX
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                iMaxSegmentZ = iStartSegmentZ + iCurCount - 1

                --Now get the max X value
                bSearchingForBoundary = true
                iCurCount = 0
                while bSearchingForBoundary do
                    iCurCount = iCurCount + 1
                    if iCurCount > 10000 then
                        M28Utilities.ErrorHandler('Infinite loop')
                        break
                    end
                    --Stop if we will exceed map bounds
                    if iCurCount + iStartSegmentX > iMapMaxSegmentX then break end
                    --Are we still in the same pathing group?
                    iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments((iStartSegmentX + iCurCount), iStartSegmentZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX + iCurCount][iStartSegmentZ]
                    if not(iCurSegmentGroup == iSegmentGroup) then
                        --Can we find anywhere else with the same Z value in the pathing group?
                        bSearchingForBoundary = false
                        for iAltStartZ = iMinSegmentZ, iMaxSegmentZ do
                            iCurSegmentGroup = NavUtils.GetLabel(sPathing, GetPositionFromPathingSegments((iStartSegmentX + iCurCount), iAltStartZ)) --tPathingSegmentGroupBySegment[sPathing][iStartSegmentX + iCurCount][iAltStartZ]
                            if iCurSegmentGroup == iSegmentGroup then
                                iStartSegmentZ = iAltStartZ
                                bSearchingForBoundary = true
                                break
                            end
                        end
                    end
                end
                iMaxSegmentX = iStartSegmentX + iCurCount - 1

                --Have now got the min and max land segment X and Z values for the plateau
                tSegmentPosition = GetPositionFromPathingSegments(iMinSegmentX, iMinSegmentZ)
                tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ] = {tSegmentPosition[1], tSegmentPosition[3]}
                iReclaimSegmentStartX, iReclaimSegmentStartZ = GetReclaimSegmentsFromLocation(tSegmentPosition)

                tSegmentPosition = GetPositionFromPathingSegments(iMaxSegmentX, iMaxSegmentZ)
                tAllPlateaus[iSegmentGroup][subrefPlateauMaxXZ] = {tSegmentPosition[1], tSegmentPosition[3]}
                iReclaimSegmentEndX, iReclaimSegmentEndZ = GetReclaimSegmentsFromLocation(tSegmentPosition)


                --Record all reclaim segments that are part of the plateau
                tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments] = {}
                for iCurReclaimSegmentX = iReclaimSegmentStartX, iReclaimSegmentEndX do
                    tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX] = {}
                    for iCurReclaimSegmentZ = iReclaimSegmentStartZ, iReclaimSegmentEndZ do
                        if iSegmentGroup == GetSegmentGroupOfLocation(sPathing, GetReclaimLocationFromSegment(iCurReclaimSegmentX, iCurReclaimSegmentZ)) then
                            tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX][iCurReclaimSegmentZ] = true
                        end
                    end
                end
                --Clear any empty values
                for iCurReclaimSegmentX = iReclaimSegmentStartX, iReclaimSegmentEndX do
                    if tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX] and M28Utilities.IsTableEmpty(tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX]) then tAllPlateaus[iSegmentGroup][subrefPlateauReclaimSegments][iCurReclaimSegmentX] = nil end
                end

                --Record midpoint of the plateau
                local iXRadius = (tAllPlateaus[iSegmentGroup][subrefPlateauMaxXZ][1] - tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ][1])*0.5
                local iZRadius = (tAllPlateaus[iSegmentGroup][subrefPlateauMaxXZ][2] - tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ][2])*0.5
                tAllPlateaus[iSegmentGroup][subrefPlateauMidpoint] = {tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ][1] + iXRadius, 0, tAllPlateaus[iSegmentGroup][subrefPlateauMinXZ][2] + iZRadius}
                tAllPlateaus[iSegmentGroup][subrefPlateauMidpoint][2] = GetTerrainHeight(tAllPlateaus[iSegmentGroup][subrefPlateauMidpoint][1], tAllPlateaus[iSegmentGroup][subrefPlateauMidpoint][3])
                --CIrcle radius will be the square/rectangle diagonal, so (square radius^2*2)^0.5 for a square, or (x^2+z^2)^0.5

                tAllPlateaus[iSegmentGroup][subrefPlateauMaxRadius] = (iXRadius^2+iZRadius^2)^0.5
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, listing tAllPlateaus='..repru(tAllPlateaus)) end
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

---@param iPlateauGroup number
local function AddNewLandZoneReferenceToPlateau(iPlateauGroup)
    --Adds a new land zone reference number to iPlateauGroup, assumes that information about the zone will be added later
    --Intended to be called as part of wider code for recording a land zone, e.g. from CreateNewLandZoneAtSegment and similar functions
        --iPlateauGroup is the result of NavUtils.GetLabel(refPathingTypeAmphibious, tLocation)
    --To get the land zone created by this immediately after it is created, use iLandZone = tAllPlateaus[iPlateauGroup][subrefLandZoneCount]
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddNewLandZoneReferenceToPlateau'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)


    if not(tAllPlateaus[iPlateauGroup]) then
        --Presumably we have a plateau with no mexes so add this plateau to the table of plateaus
        tAllPlateaus[iPlateauGroup] = {}
        tAllPlateaus[iPlateauGroup][subrefPlateauTotalMexCount] = 0
    end
    if not(tAllPlateaus[iPlateauGroup][subrefLandZoneCount]) then
        tAllPlateaus[iPlateauGroup][subrefLandZoneCount] = 0
        tAllPlateaus[iPlateauGroup][subrefPlateauLandZones] = {}
    end
    tAllPlateaus[iPlateauGroup][subrefLandZoneCount] = (tAllPlateaus[iPlateauGroup][subrefLandZoneCount] or 0) + 1
    local iLandZone = tAllPlateaus[iPlateauGroup][subrefLandZoneCount]
    tAllPlateaus[iPlateauGroup][subrefPlateauLandZones][iLandZone] = {}
    tAllPlateaus[iPlateauGroup][subrefPlateauLandZones][iLandZone][subrefLZMexCount] = 0
    tAllPlateaus[iPlateauGroup][subrefPlateauLandZones][iLandZone][subrefLZMexLocations] = {}
    tAllPlateaus[iPlateauGroup][subrefPlateauLandZones][iLandZone][subrefLZReclaimMass] = 0

    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end


---@param iBaseSegmentX number
---@param iBaseSegmentZ number
local function CreateNewLandZoneAtSegment(iBaseSegmentX, iBaseSegmentZ)
    --Creates a new land zone reference at the land segment given by iBaseSegmentX-iBaseSegmentZ (includes adding new land zone reference to the plateau group that these segments are part of)
    --iBaseSegmentX and Z are the land segment X and Z references
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'CreateNewLandZoneAtSegment'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)

    --First check we dont have a zone assigned already (redundancy)
    if not(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]) then
        --PlateauGroup ref will be the amphibious pathing ref from navutils.getlabel (since that's what is used to define mexes by amphibious pathing group, and plateau recognition then uses the same reference)
        local tMidpoint = GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
        local iPlateauGroup = NavUtils.GetLabel(refPathingTypeAmphibious, tMidpoint)
        AddNewLandZoneReferenceToPlateau(iPlateauGroup)
        local iLandZone = tAllPlateaus[iPlateauGroup][subrefLandZoneCount]
        if not(tLandZoneBySegment[iBaseSegmentX]) then tLandZoneBySegment[iBaseSegmentX] = {} end
        tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ] = iLandZone
    end
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

---@param iPlateauGroup number
---@param iOptionalLandZone number
---@param iPlateauMexRef number
---@param tTempLandZoneByMexRef table
local function AddMexToLandZone(iPlateauGroup, iOptionalLandZone, iPlateauMexRef, tTempLandZoneByMexRef)
    --Determine the land zone if it isnt specified
        --iPlateauGroup is the result of NavUtils.GetLabel(refPathingTypeAmphibious, tLocation)
        --iOptionalLandZone - if not specified, then this will create a new land zone for iPlateauGroup and use htis reference
        --iPlateauMexRef - the reference key in the table tAllPlateaus[iPlateauGroup][subrefPlateauMexes], which should return the location of the mex
        --tTempLandZoneByMexRef - temporary table used to store information for purposes of creating the land zones

    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AddMexToLandZone'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)

    --Get the land zone that we are using (/create a new land zone if we haven't had one specified to be used):
    local iLandZone
    if iOptionalLandZone then iLandZone = iOptionalLandZone
    else
        AddNewLandZoneReferenceToPlateau(iPlateauGroup)
        iLandZone = tAllPlateaus[iPlateauGroup][subrefLandZoneCount]
    end

    --Add the mex to this land zone
    tAllPlateaus[iPlateauGroup][subrefPlateauLandZones][iLandZone][subrefLZMexCount] = tAllPlateaus[iPlateauGroup][subrefPlateauLandZones][iLandZone][subrefLZMexCount] + 1
    table.insert(tAllPlateaus[iPlateauGroup][subrefPlateauLandZones][iLandZone][subrefLZMexLocations], tAllPlateaus[iPlateauGroup][subrefPlateauMexes][iPlateauMexRef])
    tTempLandZoneByMexRef[iPlateauMexRef] = iLandZone
    local iCurSegmentX, iCurSegmentZ = GetPathingSegmentFromPosition(tAllPlateaus[iPlateauGroup][subrefPlateauMexes][iPlateauMexRef])
    if not(tLandZoneBySegment[iCurSegmentX]) then tLandZoneBySegment[iCurSegmentX] = {} end
    tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] = iLandZone

    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

local function AssignTempSegmentsWithDistance()
    --Used to go through the temporary table tTempZoneTravelDistanceBySegment and assign any segments within here to the nearest land zone
    --i.e. Assumes tTempZoneTravelDistanceBySegment has been setup and is a table that has [SegmentX][SegmentZ] values that returns a table with [zone] as the key, which in turn returns the pathing distance from SegmentX-SegmentZ for each zone
    --Goes through all the distance values in tTempZoneTravelDistanceBySegment and picks the lowest distance, and then assigns the X+Z segment to land zone that corresponds to that distance, then clears the table tTempZoneTravelDistanceBySegment


    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignTempSegmentsWithDistance'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)


    local iLowestDistance
    local iLowestZone
    --Cycle through every entry
    if M28Utilities.IsTableEmpty(tTempZoneTravelDistanceBySegment) == false then
        for iCurSegmentX, tSubtable in tTempZoneTravelDistanceBySegment do
            if not(tLandZoneBySegment[iCurSegmentX]) then tLandZoneBySegment[iCurSegmentX] = {} end
            for iCurSegmentZ, tDistanceByZone in tSubtable do
                --Have we not recorded a zone for this segment?
                if not(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]) then
                    iLowestDistance = 10000
                    iLowestZone = nil
                    --Cycle through every distance that has been recorded for this segment, and record the lowest distance and the zone that corresponds to this distance
                    if M28Utilities.IsTableEmpty(tDistanceByZone) == false then
                        for iZone, iDistance in tDistanceByZone do
                            if iDistance < iLowestDistance then
                                iLowestDistance = iDistance
                                iLowestZone = iZone
                            end
                        end
                        tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] = iLowestZone
                    end
                end
                tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ] = nil --Clear the value so when we cycle through in the future we dont reconsider this
            end
        end
    end

    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

local function AssignSegmentsNearMexesToLandZones()
    --Assigns every land pathable segment near a mex to that mex's land zone (where mexes from multiple zones are nearby then it picks the closest one)

    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignSegmentsNearMexesToLandZones'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)


    local iMaxSegmentSearchDistance = math.max(4, math.ceil(50 / iLandZoneSegmentSize)) --NOTE: If changing this consider if also want to change the value for AssignRemainingSegmentsToLandZones
    local iDistanceCap = math.max(50, iMaxSegmentSearchDistance * iLandZoneSegmentSize)
    local iBaseSegmentX, iBaseSegmentZ
    local iPathingGroupWanted
    local tCurPosition
    local iCurZone
    local iCurTravelDist
    tTempZoneTravelDistanceBySegment = {} --[x][z] are the segment x and z values, returns a table with a key which is the zone ID, which returns the travel distance for that zone
    local iCurSegmentX, iCurSegmentZ
    local iMaxAdjustedX,iMaxAdjustedZ, iMinAdjustedX, iMinAdjustedZ

    --Cycle through every plateau, and then every mex within every plateau
    for iPlateauGroup, tPlateauSubtable in tAllPlateaus do
        for iMex, tMex in tPlateauSubtable[subrefPlateauMexes] do
            iBaseSegmentX, iBaseSegmentZ = GetPathingSegmentFromPosition(tMex)
            iPathingGroupWanted = NavUtils.GetLabel(refPathingTypeLand, tMex)
            iCurZone = tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]
            iMaxAdjustedX = math.min(iMaxSegmentSearchDistance + iBaseSegmentX, iMaxLandSegmentX)
            iMaxAdjustedZ = math.min(iMaxSegmentSearchDistance + iBaseSegmentZ, iMaxLandSegmentZ)
            iMinAdjustedX = math.max(1, iBaseSegmentX-iMaxSegmentSearchDistance)
            iMinAdjustedZ = math.max(1, iBaseSegmentZ-iMaxSegmentSearchDistance)

            --Cycle through the segments around this mex:
            for iCurSegmentX = iMinAdjustedX, iMaxAdjustedX, 1 do
                --iCurSegmentX = iBaseSegmentX + iSegmentXAdjust
                if not(tLandZoneBySegment[iCurSegmentX]) then
                    tLandZoneBySegment[iCurSegmentX] = {}
                    tTempZoneTravelDistanceBySegment[iCurSegmentX] = {}
                end
                for iCurSegmentZ = iMinAdjustedZ, iMaxAdjustedZ, 1 do

                    --Check we can path to this segment from the mex with land units:
                    tCurPosition = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                    if NavUtils.GetLabel(refPathingTypeLand, tCurPosition) == iPathingGroupWanted then
                        if not(tTempZoneTravelDistanceBySegment[iCurSegmentX]) then tTempZoneTravelDistanceBySegment[iCurSegmentX] = {} end
                        if not(tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ]) then
                            tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ] = {}
                        end
                        --Record how long it will take to travel from this position to the mex in a temporary table (that we will then consider later after recording all such values, so we can pick the closest mex zone)
                        iCurTravelDist = M28Utilities.GetTravelDistanceBetweenPositions(tMex, tCurPosition)
                        if (iCurTravelDist or 100000) < iDistanceCap then
                            tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ][iCurZone] = math.min(iCurTravelDist, (tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ][iCurZone] or 100000))
                        end
                    end
                end
            end

        end
    end
    --Now go through each segment in tTempZoneTravelDistanceBySegment and pick the lowest value
    AssignTempSegmentsWithDistance()

    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

---@param iBaseSegmentX number
---@param iBaseSegmentZ number
---@param iLandPathingGroupWanted number
---@param tBasePosition table
---@param iMaxSegmentSearchDistance number
---@param iDistanceCap number
---@param bUseRoughPathingDistance boolean
local function RecordTemporaryTravelDistanceForBaseSegment(iBaseSegmentX, iBaseSegmentZ, iLandPathingGroupWanted, tBasePosition, iMaxSegmentSearchDistance, iDistanceCap, bUseRoughPathingDistance)
    --Cycle through segments adjacent to the base segment to see if they have a land zone assigned; if they do, check how far it takes to path to the base segment, and record in the tTempZoneTravelDistanceBySegment any zones that are within the distance cap
    --iMaxSegmentSearchDistance - number of segments to search (will do +/- this)
    --iDistanceCap - will ignore any segment zones further away than this
    --bUseRoughPathingDistance - will rely on the default FAF pathfinding distance rather than manually recalculating all the distance values (runs quicker, but less accurate)
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'RecordTemporaryTravelDistanceForBaseSegment'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)

    local tCurPosition
    local iCurZone, iCurTravelDist
    local bAbort = false --if we find a really close location then will stop looking for better ones

    if bDebugMessages == true then LOG(sFunctionRef..': About to look for segments near base segment '..iBaseSegmentX..'-'..iBaseSegmentZ..'; iMaxSegmentSearchDistance='..iMaxSegmentSearchDistance..'; iDistanceCap='..iDistanceCap..'; iLandPathingGroupWanted='..(iLandPathingGroupWanted or 'nil')) end

    local iAbortThreshold --This is used so we can stop looking through nearby segments if we find one that is likely to be the closest we will find

    --Below sub-function will consider the segment iCurSegmentX-iCurSegmentZ, if it has a land zone assigned then will check how far it is to the base segment and if it satisfies the requirements then will record in the temporary table of distances
    function CheckAndRecordTemporaryDistanceForCurSegment(iCurSegmentX, iCurSegmentZ)
        --Does the segment have a land zone assigned, and we haven't just assigned it in this loop?
        if bDebugMessages == true then
            LOG(sFunctionRef..': Considering curSegmentX-z='..iCurSegmentX..'-'..iCurSegmentZ..'; Will note if we have a landzone for this')
            if tLandZoneBySegment[iCurSegmentX] then LOG('tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]='..repru(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]))
            else
                LOG('Dont have any land zone for anything with semgnet X='..iCurSegmentX)
            end
        end
        if tLandZoneBySegment[iCurSegmentX] and tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] then --and (not(tTempZoneTravelDistanceBySegment[iCurSegmentX]) or not(tTempZoneTravelDistanceBySegment[iCurSegmentX][iCurSegmentZ])) then
            tCurPosition = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
            if bDebugMessages == true then LOG(sFunctionRef..': Have a land zone for CurSegmentX-Z'..iCurSegmentX..'-'..iCurSegmentZ..'; Pathing label of this segment='..NavUtils.GetLabel(refPathingTypeLand, tCurPosition)..'; iLandPathingGroupWanted='..iLandPathingGroupWanted) end
            if NavUtils.GetLabel(refPathingTypeLand, tCurPosition) == iLandPathingGroupWanted then

                if bUseRoughPathingDistance then
                    iCurTravelDist = M28Utilities.GetApproxTravelDistanceBetweenPositions(tBasePosition, tCurPosition)
                else
                    iCurTravelDist = M28Utilities.GetTravelDistanceBetweenPositions(tBasePosition, tCurPosition)
                end
                if bDebugMessages == true then LOG(sFunctionRef..': iCurTravelDist='..iCurTravelDist) end
                if (iCurTravelDist or 100000) < iDistanceCap then

                    --Update the distance between the bsae segment and a segment in iCurZone to the lower of the current distance and any previously recorded distance
                    iCurZone = tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]
                    if bDebugMessages == true then LOG(sFunctionRef..': We have a segment nearby with a land zone, iCurZone='..iCurZone..'; will record iCurTravelDist of '..iCurTravelDist..'; against the base segment') end
                    tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ][iCurZone] = math.min(iCurTravelDist, (tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ][iCurZone] or 100000))
                    if iCurTravelDist <= iAbortThreshold then
                        if bDebugMessages == true then LOG(sFunctionRef..': Found a really close segment so will stop looking for more') end
                        bAbort = true
                    end
                end
            end
        end
    end

    local iMaxAdjustedX, iMaxAdjustedZ, iMinAdjustedX, iMinAdjustedZ, iZInterval

    --Cycle through each segment, starting with those closest to the base position
    for iAdjustmentSize = 1, iMaxSegmentSearchDistance do
        iAbortThreshold = iLandZoneSegmentSize * (iAdjustmentSize + 0.5)
        iMaxAdjustedX = math.min(iAdjustmentSize + iBaseSegmentX, iMaxLandSegmentX)
        iMaxAdjustedZ = math.min(iAdjustmentSize + iBaseSegmentZ, iMaxLandSegmentZ)
        iMinAdjustedX = math.max(1, iBaseSegmentX-iAdjustmentSize)
        iMinAdjustedZ = math.max(1, iBaseSegmentZ-iAdjustmentSize)
        iZInterval = math.max(1, iMaxAdjustedZ - iMinAdjustedZ)



        for iCurSegmentX = iMinAdjustedX, iMaxAdjustedX, 1 do
            --Since we are starting from the closest segments and moving out, we effectively want to cycle through a hollow square of segments with each change in iAdjustmentSize:
            if iCurSegmentX == iMinAdjustedX or iCurSegmentX == iMaxAdjustedX then
                for iCurSegmentZ = iMinAdjustedZ, iMaxAdjustedZ, 1 do
                    CheckAndRecordTemporaryDistanceForCurSegment(iCurSegmentX, iCurSegmentZ)
                    if bAbort then break end
                end
            else
                for iCurSegmentZ = iMinAdjustedZ, iMaxAdjustedZ, iZInterval do
                    CheckAndRecordTemporaryDistanceForCurSegment(iCurSegmentX, iCurSegmentZ)
                    if bAbort then break end
                end
            end
            if bAbort then break end
        end
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Finsihed recording if we have any nearby zones that can path here, tTempZoneTravelDistanceBySegment for base segment '..iBaseSegmentX..'-'..iBaseSegmentZ..'='..repru(tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ])..'; bAbort='..tostring(bAbort)) end

    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

---@param iBaseSegmentX number
---@param iBaseSegmentZ number
---@param iLandZone number
---@param iSegmentSearchRange number
---@param iDistanceCap number
local function AssignNearbySegmentsToSameLandZone(iBaseSegmentX, iBaseSegmentZ, iLandZone, iSegmentSearchRange, iDistanceCap)
    --Cycles through every segment within iSegmentSearchRange of the base segment X-Z value, and if the pathing distance is within the distance cap iDistanceCap then will assign it to iLandZone
    local iCurTravelDist
    for iCurSegmentX = math.max(1, iBaseSegmentX - iSegmentSearchRange), math.min(iBaseSegmentX + iSegmentSearchRange, iMaxLandSegmentX), 1 do
        for iCurSegmentZ = math.max(1, iBaseSegmentZ - iSegmentSearchRange), math.min(iBaseSegmentZ + iSegmentSearchRange, iMaxLandSegmentZ), 1 do
            if not(tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]) then
                iCurTravelDist = M28Utilities.GetTravelDistanceBetweenPositions(GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ), GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ))
                if (iCurTravelDist or 100000) <= iDistanceCap then
                    if not(tLandZoneBySegment[iCurSegmentX]) then tLandZoneBySegment[iCurSegmentX] = {} end
                    tLandZoneBySegment[iCurSegmentX][iCurSegmentZ] = iLandZone
                end
            end
        end
    end
end


local function AssignRemainingSegmentsToLandZones()
    --Cycles through key points on the map and if they ahve no nearby land zone then creates a new land zone
    --then cycles through every segment on the map and if it has no land zone assigns it to the nearest existing land zone
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignRemainingSegmentsToLandZones'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)

    --rMapPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2}
    local iLandPathingGroupWanted

    local iMaxSegmentSearchDistance = math.max(3, math.ceil(40 / iLandZoneSegmentSize)) --NOTE: If changing this consider if also want to change the value for AssignSegmentsNearMexesToLandZones; for first draft have this as slightly lower
    local iDistanceCap = math.max(40, iMaxSegmentSearchDistance * iLandZoneSegmentSize)

    local tBasePosition

    --Create a new zone for any locations with no nearby pathable zones
    local iNewZoneCount = 0
    local iBasePositionX = - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[1]
    local iBasePositionZ
    local iNearbyAssignmentSegmentRange = math.min(iMaxSegmentSearchDistance, math.ceil(iMaxSegmentSearchDistance * 0.5) + 1)

    --Subfunction that checks nearby segments that we can path to with a land zone already assigned, and if there are none then creates a new land zone for the base position and assigns segments near it to the same land zone
    function CheckForNearbyZonesAndCreateNewZoneIfNeeded(iBaseSegmentX, iBaseSegmentZ, iBasePositionX, iBasePositionZ, bUseRoughPathingDistance)
        if not(tLandZoneBySegment[iBaseSegmentX] and tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]) then
            tBasePosition = {iBasePositionX, 0, iBasePositionZ} --GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
            iLandPathingGroupWanted = NavUtils.GetLabel(refPathingTypeLand, tBasePosition)
            if (iLandPathingGroupWanted or 0) > 0 then
                --Dont create a new zone if we have a nearby zone
                if not(tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ]) then
                    if not(tTempZoneTravelDistanceBySegment[iBaseSegmentX]) then tTempZoneTravelDistanceBySegment[iBaseSegmentX] = {} end
                    tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ] = {}
                end

                --Cycle through adjacent segments to see if they have a zone, and if so check how far away the segment is from the base segment
                RecordTemporaryTravelDistanceForBaseSegment(iBaseSegmentX, iBaseSegmentZ, iLandPathingGroupWanted, tBasePosition, iMaxSegmentSearchDistance, iDistanceCap, bUseRoughPathingDistance)

                --Create a new zone if no segments nearby that already have a land zone that we can path to
                if M28Utilities.IsTableEmpty(tTempZoneTravelDistanceBySegment[iBaseSegmentX][iBaseSegmentZ]) then
                    if bDebugMessages == true then
                        LOG(sFunctionRef..': Have no temp travel distance recorded so have created a new land zone for segmentX-Z='..iBaseSegmentX..'-'..iBaseSegmentZ..'; Position from segments='..repru(GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ))..'; tBasePosition (should be the same)='..repru(tBasePosition)..'; will draw midpoint in red.  iNewZoneCount before increasing by 1='..iNewZoneCount..'; Plateau group of the segment midpoint='..(NavUtils.GetLabel(refPathingTypeLand, GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)) or 'nil'))
                        M28Utilities.DrawLocation(GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ))
                    end
                    CreateNewLandZoneAtSegment(iBaseSegmentX, iBaseSegmentZ)
                    iNewZoneCount = iNewZoneCount + 1

                    --Assign very nearby segments to this
                    AssignNearbySegmentsToSameLandZone(iBaseSegmentX, iBaseSegmentZ, iNewZoneCount, iNearbyAssignmentSegmentRange, iDistanceCap)
                end
            end
        end
    end

    --Cycle through every segment on the map, but only consider every iMaxSegmentSearchDistance 'th segment (for performance reasons), and check if it has nearby land zones, and if not then create a new land zone at this position
    for iBaseSegmentX = iMaxSegmentSearchDistance, iMaxLandSegmentX, iMaxSegmentSearchDistance do
        iBasePositionX = iBasePositionX + iLandZoneSegmentSize * iMaxSegmentSearchDistance --Manually done instead of GetPositionFromPathingSegments for performance
        iBasePositionZ = - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[2]

        if not(tLandZoneBySegment[iBaseSegmentX]) then tLandZoneBySegment[iBaseSegmentX] = {} end
        if not(tTempZoneTravelDistanceBySegment[iBaseSegmentX]) then
            tTempZoneTravelDistanceBySegment[iBaseSegmentX] = {}
        end
        for iBaseSegmentZ = iMaxSegmentSearchDistance, iMaxLandSegmentZ, iMaxSegmentSearchDistance do
            iBasePositionZ = iBasePositionZ + iLandZoneSegmentSize * iMaxSegmentSearchDistance
            --Check we dont already have a zone assigned
            CheckForNearbyZonesAndCreateNewZoneIfNeeded(iBaseSegmentX, iBaseSegmentZ, iBasePositionX, iBasePositionZ)
        end
        --WaitTicks(1)
        if bDebugMessages == true then LOG(sFunctionRef..': Finished all iBaseSegmentX='..iBaseSegmentX..'; moving to next X segments, systemtime='..GetSystemTimeSecondsOnlyForProfileUse()) end
    end
    --Now go through each segment considered and pick the lowest value distance as the assigned land zone
    AssignTempSegmentsWithDistance()
    if bDebugMessages == true then LOG(sFunctionRef..': Finished assigning land zones for locations with no nearby zones, systemtime='..GetSystemTimeSecondsOnlyForProfileUse()) end

    --Now cycle through every segment on the map, and assign to a land zone (or create a new land zone if none nearby, but hopefully after the above code this will be rare)
    iBasePositionX = - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[1] --Calculate the position manually (instead of using the function GetPositionFromPathingSegments) for performance
    for iBaseSegmentX = 1, iMaxLandSegmentX do
        iBasePositionX = iBasePositionX + iLandZoneSegmentSize --(i.e. as per GetPositionFromPathingSegments)
        iBasePositionZ = - iLandZoneSegmentSize * 0.5 + rMapPlayableArea[2]
        for iBaseSegmentZ = 1, iMaxLandSegmentZ do
            iBasePositionZ = iBasePositionZ + iLandZoneSegmentSize
            CheckForNearbyZonesAndCreateNewZoneIfNeeded(iBaseSegmentX, iBaseSegmentZ, iBasePositionX, iBasePositionZ, true)
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finsihed creating land zones for any remaining locations with no nearby land zone, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    --The above will have updated the temporary table with details of how long to path to each zone; now go through and assign each segment to the closest zone to it
    AssignTempSegmentsWithDistance()
    if bDebugMessages == true then LOG(sFunctionRef..': Finsihed assigning zones for any temporary distances for the zones created in the previous step, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end


    --Redundancy - cycle through any zones that dont have a segment and create new zones for them - hopefully this shouldnt be possible provided we have setup the segment search ranges correctly above
    for iBaseSegmentX = 1, iMaxLandSegmentX do
        for iBaseSegmentZ = 1, iMaxLandSegmentZ do
            if not(tLandZoneBySegment[iBaseSegmentX][iBaseSegmentZ]) then
                tBasePosition = GetPositionFromPathingSegments(iBaseSegmentX, iBaseSegmentZ)
                iLandPathingGroupWanted = NavUtils.GetLabel(refPathingTypeLand, tBasePosition)
                if (iLandPathingGroupWanted or 0) > 1 then
                    M28Utilities.ErrorHandler('Have an unassigned land zone='..iBaseSegmentX..'-'..iBaseSegmentZ)
                    CreateNewLandZoneAtSegment(iBaseSegmentX, iBaseSegmentZ)
                    RecordTemporaryTravelDistanceForBaseSegment(iBaseSegmentX, iBaseSegmentZ, iLandPathingGroupWanted, tBasePosition, iMaxSegmentSearchDistance, iDistanceCap)
                    AssignTempSegmentsWithDistance()
                end
            end
        end
    end
    if bDebugMessages == true then LOG(sFunctionRef..': Finished redundancy of checking every segment has a land zone if it is land pathable, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

local function AssignMexesALandZone()
    --Cycles through every mex and assigns it to a new land zone, unless it is near another mex in which case they should both use the same land zone

    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'AssignMexesALandZone'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)

    --Key config values
    local iNearbyMexRange = 40 --Initially mexes will be grouped together based on this, i.e. will assign mexes within this distance of each other to the same land zone

    if bDebugMessages == true then LOG('About to setup land zones') end

    local tiLandZoneByMexRef

    --Subfunction - if we have a mex to assign to a land zone then this subfunction should be called to check for any nearby mexes without a zone and assign these to the same zone
    function AddNearbyMexesToLandZone(iPlateauGroup, iCurLandZone, tMex)
        local iLandGroupWanted = NavUtils.GetLabel(refPathingTypeLand, tMex)
        for iAltMex, tAltMex in tAllPlateaus[iPlateauGroup][subrefPlateauMexes] do
            if not(tiLandZoneByMexRef[iAltMex]) then
                if NavUtils.GetLabel(refPathingTypeLand, tAltMex) == iLandGroupWanted and not(IsUnderwater(tAltMex, false, 0.1)) then
                    if bDebugMessages == true then LOG(sFunctionRef..': Considering iAltMex='..iAltMex..'; Distance straight line='..M28Utilities.GetDistanceBetweenPositions(tAltMex, tMex)..'; Travel distance='..M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex)) end
                    if M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex) <= iNearbyMexRange then
                        AddMexToLandZone(iPlateauGroup, iCurLandZone, iAltMex, tiLandZoneByMexRef)
                        if bDebugMessages == true then LOG(sFunctionRef..': Added mex '..iAltMex..' with position '..repru(tAltMex)..' to land zone, tiLandZoneByMexRef='..(tiLandZoneByMexRef[iAltMex] or 'nil')..'; Distance in straight line='..M28Utilities.GetDistanceBetweenPositions(tAltMex, tMex)..'; Travel distance='..M28Utilities.GetTravelDistanceBetweenPositions(tAltMex, tMex)) end
                        AddNearbyMexesToLandZone(iPlateauGroup, iCurLandZone, tAltMex) --Needs to be recursive or else can end up with 2 mees that are really close to each other not being in the same group depending on the order in which the original mexes are called
                    end
                end
            end
        end
    end
    --First assign zones to mex locations - group mexes that are near each other in the same zone
    local iCurLandZone
    for iPlateauGroup, tPlateauSubtable in tAllPlateaus do
        tiLandZoneByMexRef = {} --[x] is the mex ref from tPlateauSubtable[subrefPlateauMexes]
        tAllPlateaus[iPlateauGroup][subrefPlateauLandZones] = {}
        for iMex, tMex in tPlateauSubtable[subrefPlateauMexes] do
            if not(IsUnderwater(tMex, false, 0.1)) then
                if bDebugMessages == true then LOG(sFunctionRef..': Plateau='..iPlateauGroup..': Considering mex with plateau mex ref='..iMex..'; position='..repru(tMex)..'; tiLandZoneByMexRef for this ref='..(tiLandZoneByMexRef[iMex] or 'nil')) end
                if not(tiLandZoneByMexRef[iMex]) then
                    AddMexToLandZone(iPlateauGroup, nil, iMex, tiLandZoneByMexRef)
                    iCurLandZone = tiLandZoneByMexRef[iMex]
                    if bDebugMessages == true then LOG(sFunctionRef..': Added mex '..iMex..' with position '..repru(tMex)..' to land zone, tiLandZoneByMexRef='..(tiLandZoneByMexRef[iMex] or 'nil')) end

                    --Cycle through each other mex in the plateau and if it is within iNearbyMexRange then assign it to the same group if it hasnt had a group assigned already
                    AddNearbyMexesToLandZone(iPlateauGroup, iCurLandZone, tMex)
                end
            end
        end
        if bDebugMessages == true then LOG(sFunctionRef..': Finished recording land zone mexes for iPlateauGroup='..iPlateauGroup..'; Size of land zones table='..table.getn(tAllPlateaus[iPlateauGroup][subrefPlateauLandZones])) end
    end
    --Debug - draw the groupings of mexes with rectangles around them to show how they've been grouped, with a different colour for each plateau group:
    if bDebugMessages == true then
        local iColour = 0
        for iPlateauGroup, tPlateauSubtable in tAllPlateaus do
            LOG(sFunctionRef..': About to draw results of land zones for iPlateauGroup='..iPlateauGroup..'; tiLandZoneByMexRef='..repru(tiLandZoneByMexRef)..'; tAllPlateaus[iPlateauGroup][subrefPlateauLandZones]='..repru(tAllPlateaus[iPlateauGroup][subrefPlateauLandZones]))
            iColour = iColour + 1
            if iColour > 7 then iColour = 1 end
            --Draw the mex groupings
            for iZone, tZone in tAllPlateaus[iPlateauGroup][subrefPlateauLandZones] do
                local iMinX = 100000
                local iMaxX = 0
                local iMinZ = 100000
                local iMaxZ = 0

                for iMex, tMex in tZone[subrefLZMexLocations] do
                    iMinX = math.min(tMex[1], iMinX)
                    iMaxX = math.max(tMex[1], iMaxX)
                    iMinZ = math.min(tMex[3], iMinZ)
                    iMaxZ = math.max(tMex[3], iMaxZ)
                end
                M28Utilities.DrawRectangle(Rect(iMinX, iMinZ, iMaxX, iMaxZ), iColour, 1000, 10)
            end
        end
    end

    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

local function DrawLandZones()
    --For debug use - will draw each land zone in a plateau in a different colour to allow a visual check of how land zones have been created.  Can be called part-way through the process (e.g. to show land zones after the initial mex creation and nearby areas)
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'DrawLandZones'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)

    --Create fixed colours per ref
    local iUniqueColourCount = 30
    local tColourTable = M28Utilities.GenerateUniqueColourTable(iUniqueColourCount)

    --Subfunction which assigns a unique colour to each land zone
    function GetColourFromLandZoneNumber(iLandZoneRef)
        local iColour = iLandZoneRef
        while iColour >= iUniqueColourCount do
            iColour = iColour - iUniqueColourCount
        end

        return tColourTable[iColour]
    end

    if bDebugMessages == true then LOG(sFunctionRef..': Will now draw every land zone in every plateau, cycling the colour used') end
    local tLocation, iLandZoneRef
    --Cycle through every segment on the map and draw a colour for it based on the land zone that it's part of
    for iCurSegmentX = 1, iMaxLandSegmentX do
        for iCurSegmentZ = 1, iMaxLandSegmentZ do
            iLandZoneRef = tLandZoneBySegment[iCurSegmentX][iCurSegmentZ]
            if (iLandZoneRef or 0) > 0 then
                tLocation = GetPositionFromPathingSegments(iCurSegmentX, iCurSegmentZ)
                --M28Utilities.DrawLocation(tLocation, GetColourFromLandZoneNumber(iLandZoneRef), nil, iLandZoneSegmentSize - 0.1)
                M28Utilities.DrawLocation(tLocation, GetColourFromLandZoneNumber(iLandZoneRef), nil, iLandZoneSegmentSize - 0.1)
            end
        end
    end

    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

local function SetupLandZones()
    --Divides the map into 'land zones' based on mex placement and plateau groups, which is to form the basis for managing land units.  Land zones are areas that can be pathed by land units and are intended to group the map based on how long it takes to travel
    --Intended to be called at start of game when AI is created (so after siminit and recordresourcepoints has run), and after plateaus have been generated
    --Broadly, will group nearby mexes together in the same land zone, along with the nearby area; then will look for any places on the map with no nearby land zone and create a zone for these, and then go through the whole map and ensure every land pathable area has an assigned land zone
    --To avoid too much of a CPU load, the map is first divided into small 'segment' squares, the size of which varies based on the size of a map (1x1 for a 5km map, 2x2 for a 10km map, etc.), with it assumed that any location within a segment square has the same pathing as the midpoint of that segment
    --i.e. there will inevitably be cases where units go near a cliff where the land pathing zone is inconsistent with where the unit can path to

    --Using land zones:
    --To return both the plateau reference, and the land zone reference, of a position tPosiiton, use the function GetPlateauAndLandZoneReferenceFromPosition(tPosition) (which will return nil if it doesnt have a value)


    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupLandZones'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)
    if bDebugMessages == true then LOG(sFunctionRef..': Start of land zone generation, system time='..GetSystemTimeSecondsOnlyForProfileUse()) end

    --First go through every mex on the map, and assign it a land zone (grouping mexes near each other together):
    AssignMexesALandZone()
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
    WaitTicks(1)
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)

    --Now add any areas that can easily be pathed to each mex to the same land zone as that mex:
    AssignSegmentsNearMexesToLandZones()
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
    WaitTicks(1)
    if bDebugMessages == true then
        DrawLandZones()
        WaitSeconds(5)
    end
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)

    --Now look for empty spots on the map without land zones and assign them a land zone, creating new ones (that have no mexes in them) where they are far from any existing land zone:
    AssignRemainingSegmentsToLandZones()

    --Clear variables that we no longer need:
    tTempZoneTravelDistanceBySegment =  nil


    --If debug is enabled, draw land zones (different colour for each land zone on a plateau)
    if bDebugMessages == true then
        LOG(sFunctionRef..': Finished generating all land zones, will now draw them. System time='..GetSystemTimeSecondsOnlyForProfileUse())
        DrawLandZones()
    end

    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

---@param tPosition table
---@param bReturnSufaceHeightInstead boolean
---@param iOptionalAmountToBeUnderwatner number
---@return boolean
function IsUnderwater(tPosition, bReturnSurfaceHeightInstead, iOptionalAmountToBeUnderwater)
    --Returns true if tPosition underwater, otherwise returns false
    --bReturnSurfaceHeightInstead:: Return the actual height at which underwater, instead of true/false
    if bReturnSurfaceHeightInstead then return iMapWaterHeight
    else
        if M28Utilities.IsTableEmpty(tPosition) == true then
            M28Utilities.ErrorHandler('tPosition is empty')
        else
            if iMapWaterHeight > tPosition[2] + (iOptionalAmountToBeUnderwater or 0) then
                --Check we're not just under an arch but are actually underwater
                if not(GetTerrainHeight(tPosition[1], tPosition[3]) == iMapWaterHeight) then
                    return true
                end
            end
        end
        return false
    end
end

local function GetMapWaterHeight()
    --Updates iMapWaterHeight to the water height on the map (if the map has water)
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'GetMapWaterHeight'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)
    --rMapPlayableArea = {0,0, 256, 256} --{x1,z1, x2,z2} - Set at start of the game, use instead of the scenarioinfo method
    local iWaterCount = 0
    local iWaterLevel = 10000
    local iCurTerrainHeight = 10000
    local iInterval = 1

    --Cycle through the map in iInterval sizes, until we come to a point where the surface height exceeds the terrain height, which suggests it is water:
    for iX = rMapPlayableArea[1] + iInterval, rMapPlayableArea[3], iInterval do
        for iZ = rMapPlayableArea[2] + iInterval, rMapPlayableArea[4], iInterval do
            iCurTerrainHeight =  GetTerrainHeight(iX, iZ)
            if GetSurfaceHeight(iX, iZ) > GetTerrainHeight(iX, iZ) then
                iWaterCount = iWaterCount + 1
                iWaterLevel = math.min(iWaterLevel, GetSurfaceHeight(iX, iZ))
                if bDebugMessages == true then LOG(sFunctionRef..': Found water at position X-Z='..iX..'-'..iZ..'; Surface height='..GetSurfaceHeight(iX, iZ)..'; Terrain height='..GetTerrainHeight(iX, iZ)) end
                if iWaterCount >= 3 then
                    break
                end
            else
                --Backup for maps like theta passage arch - have commented out as running on theta passage with interval of 1 it never triggers a water count in the first place, but could remove comments if do come across this issue
                --if bDebugMessages == true and iWaterCount > 0 and GetTerrainHeight(iX, iZ) < iWaterLevel and iWaterLevel < 10000 then LOG(sFunctionRef..': Have suspected arch previously so will adjust water level to terrain height='..GetTerrainHeight(iX, iZ)..'; for iX-Z='..iX..'-'..iZ..'; prev iWaterLevel='..iWaterLevel) end
                --iWaterLevel = math.min(iWaterLevel, GetTerrainHeight(iX, iZ))
            end
        end
        if iWaterCount >= 3 then break end
    end
    if iWaterCount == 0 then iMapWaterHeight = 0
    else
        iMapWaterHeight = iWaterLevel
    end
    if bDebugMessages == true then LOG(sFunctionRef..': End of code, iWaterCount='..iWaterCount..'; iMapWaterHeight='..iMapWaterHeight) end
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end

function SetupMap()
    --Sets up non-brain specific info on the map
    local bDebugMessages = false if M28Profiling.bGlobalDebugOverride == true then   bDebugMessages = true end
    local sFunctionRef = 'SetupMap'
    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerStart)

    --Decide how accurate map related functions are to be based on the map size:
    SetupPlayableAreaAndSegmentSizes()

    --Generate pathing
    if not(NavUtils.IsGenerated()) then
        local NavGen = import("/lua/sim/navgenerator.lua")
        NavGen.Generate()
    end

    GetMapWaterHeight()

    --Create table that stores details for each pathing group (e.g. land, amphibious) each mex in that group for easy reference later
    RecordMexForPathingGroup()

    --Create table with details on all plateaus (initially just those with mexes, although the land zone logic may add to this)
    RecordAllPlateaus() --Needed first since will organise land zones by plateau

    --Setup land zones
    SetupLandZones()

    M28Profiling.FunctionProfiler(sFunctionRef, M28Profiling.refProfilerEnd)
end
